// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]


#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientsettings.proto`

// @@protoc_insertion_point(message:CMsgHotkey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHotkey {
    // message fields
    // @@protoc_insertion_point(field:CMsgHotkey.key_code)
    pub key_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHotkey.alt_key)
    pub alt_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.shift_key)
    pub shift_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.ctrl_key)
    pub ctrl_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.meta_key)
    pub meta_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHotkey.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHotkey {
    fn default() -> &'a CMsgHotkey {
        <CMsgHotkey as crate::Message>::default_instance()
    }
}

impl CMsgHotkey {
    pub fn new() -> CMsgHotkey {
        ::std::default::Default::default()
    }

    // optional uint32 key_code = 1;

    pub fn key_code(&self) -> u32 {
        self.key_code.unwrap_or(0)
    }

    pub fn clear_key_code(&mut self) {
        self.key_code = ::std::option::Option::None;
    }

    pub fn has_key_code(&self) -> bool {
        self.key_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: u32) {
        self.key_code = ::std::option::Option::Some(v);
    }

    // optional bool alt_key = 2;

    pub fn alt_key(&self) -> bool {
        self.alt_key.unwrap_or(false)
    }

    pub fn clear_alt_key(&mut self) {
        self.alt_key = ::std::option::Option::None;
    }

    pub fn has_alt_key(&self) -> bool {
        self.alt_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alt_key(&mut self, v: bool) {
        self.alt_key = ::std::option::Option::Some(v);
    }

    // optional bool shift_key = 3;

    pub fn shift_key(&self) -> bool {
        self.shift_key.unwrap_or(false)
    }

    pub fn clear_shift_key(&mut self) {
        self.shift_key = ::std::option::Option::None;
    }

    pub fn has_shift_key(&self) -> bool {
        self.shift_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_key(&mut self, v: bool) {
        self.shift_key = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_key = 4;

    pub fn ctrl_key(&self) -> bool {
        self.ctrl_key.unwrap_or(false)
    }

    pub fn clear_ctrl_key(&mut self) {
        self.ctrl_key = ::std::option::Option::None;
    }

    pub fn has_ctrl_key(&self) -> bool {
        self.ctrl_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_key(&mut self, v: bool) {
        self.ctrl_key = ::std::option::Option::Some(v);
    }

    // optional bool meta_key = 5;

    pub fn meta_key(&self) -> bool {
        self.meta_key.unwrap_or(false)
    }

    pub fn clear_meta_key(&mut self) {
        self.meta_key = ::std::option::Option::None;
    }

    pub fn has_meta_key(&self) -> bool {
        self.meta_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_key(&mut self, v: bool) {
        self.meta_key = ::std::option::Option::Some(v);
    }

    // optional string display_name = 6;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_code",
            |m: &CMsgHotkey| { &m.key_code },
            |m: &mut CMsgHotkey| { &mut m.key_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "alt_key",
            |m: &CMsgHotkey| { &m.alt_key },
            |m: &mut CMsgHotkey| { &mut m.alt_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shift_key",
            |m: &CMsgHotkey| { &m.shift_key },
            |m: &mut CMsgHotkey| { &mut m.shift_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctrl_key",
            |m: &CMsgHotkey| { &m.ctrl_key },
            |m: &mut CMsgHotkey| { &mut m.ctrl_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "meta_key",
            |m: &CMsgHotkey| { &m.meta_key },
            |m: &mut CMsgHotkey| { &mut m.meta_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &CMsgHotkey| { &m.display_name },
            |m: &mut CMsgHotkey| { &mut m.display_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHotkey>(
            "CMsgHotkey",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHotkey {
    const NAME: &'static str = "CMsgHotkey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.key_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.alt_key = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.shift_key = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ctrl_key = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.meta_key = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_code {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.alt_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.shift_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ctrl_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.meta_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.key_code {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.alt_key {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.shift_key {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ctrl_key {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.meta_key {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHotkey {
        CMsgHotkey::new()
    }

    fn clear(&mut self) {
        self.key_code = ::std::option::Option::None;
        self.alt_key = ::std::option::Option::None;
        self.shift_key = ::std::option::Option::None;
        self.ctrl_key = ::std::option::Option::None;
        self.meta_key = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHotkey {
        static instance: CMsgHotkey = CMsgHotkey {
            key_code: ::std::option::Option::None,
            alt_key: ::std::option::Option::None,
            shift_key: ::std::option::Option::None,
            ctrl_key: ::std::option::Option::None,
            meta_key: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHotkey {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHotkey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHotkey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHotkey {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSettings.no_save_personal_info)
    pub no_save_personal_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.oobe_test_mode_enabled)
    pub oobe_test_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.in_client_beta)
    pub in_client_beta: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.is_steam_sideloaded)
    pub is_steam_sideloaded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.preferred_monitor)
    pub preferred_monitor: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_cef_gpu_blocklist_disabled)
    pub steam_cef_gpu_blocklist_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.bigpicture_windowed)
    pub bigpicture_windowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.is_external_display)
    pub is_external_display: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_os_underscan_level)
    pub steam_os_underscan_level: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_os_underscan_enabled)
    pub steam_os_underscan_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.min_scale_factor)
    pub min_scale_factor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.max_scale_factor)
    pub max_scale_factor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.auto_scale_factor)
    pub auto_scale_factor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.small_mode)
    pub small_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.skip_steamvr_install_dialog)
    pub skip_steamvr_install_dialog: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.always_show_user_chooser)
    pub always_show_user_chooser: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_family_sharing_notifications)
    pub show_family_sharing_notifications: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_fps_counter_corner)
    pub overlay_fps_counter_corner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_fps_counter_high_contrast)
    pub overlay_fps_counter_high_contrast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_key)
    pub overlay_key: crate::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.screenshot_key)
    pub screenshot_key: crate::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_overlay)
    pub enable_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_screenshot_notification)
    pub enable_screenshot_notification: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_screenshot_sound)
    pub enable_screenshot_sound: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.save_uncompressed_screenshots)
    pub save_uncompressed_screenshots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.screenshots_path)
    pub screenshots_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.default_ping_rate)
    pub default_ping_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.server_ping_rate)
    pub server_ping_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_networking_share_ip)
    pub steam_networking_share_ip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.web_browser_home)
    pub web_browser_home: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_mic_device_name)
    pub voice_mic_device_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_mic_input_gain)
    pub voice_mic_input_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_speaker_output_gain)
    pub voice_speaker_output_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_push_to_talk_setting)
    pub voice_push_to_talk_setting: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_push_to_talk_key)
    pub voice_push_to_talk_key: crate::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_toolbar_list_view)
    pub overlay_toolbar_list_view: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.always_use_gamepadui_overlay)
    pub always_use_gamepadui_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_tabs)
    pub overlay_tabs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_scale_interface)
    pub overlay_scale_interface: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_restore_browser_tabs)
    pub overlay_restore_browser_tabs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.smooth_scroll_webviews)
    pub smooth_scroll_webviews: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_gpu_accelerated_webviews)
    pub enable_gpu_accelerated_webviews: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_hardware_video_decoding)
    pub enable_hardware_video_decoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.run_at_startup)
    pub run_at_startup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_dpi_scaling)
    pub enable_dpi_scaling: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_marketing_messages)
    pub enable_marketing_messages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.start_in_big_picture_mode)
    pub start_in_big_picture_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.jumplist_flags)
    pub jumplist_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_ui_sounds)
    pub enable_ui_sounds: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.disable_all_toasts)
    pub disable_all_toasts: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.disable_toasts_in_game)
    pub disable_toasts_in_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.play_sound_on_toast)
    pub play_sound_on_toast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_display_size)
    pub library_display_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_whats_new_show_only_product_updates)
    pub library_whats_new_show_only_product_updates: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_store_content_on_home)
    pub show_store_content_on_home: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.start_page)
    pub start_page: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_low_bandwidth_mode)
    pub library_low_bandwidth_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_low_perf_mode)
    pub library_low_perf_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_disable_community_content)
    pub library_disable_community_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_display_icon_in_game_list)
    pub library_display_icon_in_game_list: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.ready_to_play_includes_streaming)
    pub ready_to_play_includes_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_steam_deck_info)
    pub show_steam_deck_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_shader_precache)
    pub enable_shader_precache: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_shader_background_processing)
    pub enable_shader_background_processing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.shader_precached_size)
    pub shader_precached_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientSettings.needs_steam_service_repair)
    pub needs_steam_service_repair: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_peer_content)
    pub download_peer_content: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_rate_bits_per_s)
    pub download_rate_bits_per_s: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.restrict_auto_updates)
    pub restrict_auto_updates: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.restrict_auto_updates_start)
    pub restrict_auto_updates_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.restrict_auto_updates_end)
    pub restrict_auto_updates_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_region)
    pub download_region: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_while_app_running)
    pub download_while_app_running: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_throttle_while_streaming)
    pub download_throttle_while_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_throttle_rate)
    pub download_throttle_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.cloud_enabled)
    pub cloud_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_screenshot_manager)
    pub show_screenshot_manager: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_volume)
    pub music_volume: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_pause_on_app_start)
    pub music_pause_on_app_start: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_pause_on_voice_chat)
    pub music_pause_on_voice_chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_download_high_quality)
    pub music_download_high_quality: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_playlist_notification)
    pub music_playlist_notification: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_permissions)
    pub broadcast_permissions: ::std::option::Option<crate::EnumOrUnknown<super::enums::EBroadcastPermission>>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_output_width)
    pub broadcast_output_width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_output_height)
    pub broadcast_output_height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_bitrate)
    pub broadcast_bitrate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_encoding_option)
    pub broadcast_encoding_option: ::std::option::Option<crate::EnumOrUnknown<super::enums::EBroadcastEncoderSetting>>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_record_all_video)
    pub broadcast_record_all_video: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_record_all_audio)
    pub broadcast_record_all_audio: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_record_microphone)
    pub broadcast_record_microphone: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_show_upload_stats)
    pub broadcast_show_upload_stats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_show_live_reminder)
    pub broadcast_show_live_reminder: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_chat_corner)
    pub broadcast_chat_corner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_input_configurator_error_msg_enable)
    pub steam_input_configurator_error_msg_enable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_guide_button_focus_steam)
    pub controller_guide_button_focus_steam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_ps_support)
    pub controller_ps_support: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_xbox_support)
    pub controller_xbox_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_xbox_driver)
    pub controller_xbox_driver: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_switch_support)
    pub controller_switch_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_generic_support)
    pub controller_generic_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_power_off_timeout)
    pub controller_power_off_timeout: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.turn_off_controller_on_exit)
    pub turn_off_controller_on_exit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_combine_nintendo_joycons)
    pub controller_combine_nintendo_joycons: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_id)
    pub startup_movie_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_local_path)
    pub startup_movie_local_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_shuffle)
    pub startup_movie_shuffle: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_used_for_resume)
    pub startup_movie_used_for_resume: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.game_notes_enable_spellcheck)
    pub game_notes_enable_spellcheck: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.screenshot_items_per_row)
    pub screenshot_items_per_row: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_enabled)
    pub g_background_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_path)
    pub g_background_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_max_keep)
    pub g_background_max_keep: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_time_resolution)
    pub g_background_time_resolution: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_devmode)
    pub g_background_devmode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_mk)
    pub g_background_mk: crate::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_tg)
    pub g_background_tg: crate::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_timestamps_in_console)
    pub show_timestamps_in_console: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.force_oobe)
    pub force_oobe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.override_browser_composer_mode)
    pub override_browser_composer_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.cef_remote_debugging_enabled)
    pub cef_remote_debugging_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.force_deck_perf_tab)
    pub force_deck_perf_tab: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.force_fake_mandatory_update)
    pub force_fake_mandatory_update: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.gamescope_hdr_visualization)
    pub gamescope_hdr_visualization: ::std::option::Option<crate::EnumOrUnknown<super::enums::EHDRVisualization>>,
    // @@protoc_insertion_point(field:CMsgClientSettings.gamescope_app_target_framerate)
    pub gamescope_app_target_framerate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.gamescope_enable_app_target_framerate)
    pub gamescope_enable_app_target_framerate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.gamescope_disable_framelimit)
    pub gamescope_disable_framelimit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.gamescope_display_refresh_rate)
    pub gamescope_display_refresh_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.gamescope_use_game_refresh_rate_in_steam)
    pub gamescope_use_game_refresh_rate_in_steam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steamos_status_led_brightness)
    pub steamos_status_led_brightness: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSettings.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSettings {
    fn default() -> &'a CMsgClientSettings {
        <CMsgClientSettings as crate::Message>::default_instance()
    }
}

impl CMsgClientSettings {
    pub fn new() -> CMsgClientSettings {
        ::std::default::Default::default()
    }

    // optional bool no_save_personal_info = 1;

    pub fn no_save_personal_info(&self) -> bool {
        self.no_save_personal_info.unwrap_or(false)
    }

    pub fn clear_no_save_personal_info(&mut self) {
        self.no_save_personal_info = ::std::option::Option::None;
    }

    pub fn has_no_save_personal_info(&self) -> bool {
        self.no_save_personal_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_save_personal_info(&mut self, v: bool) {
        self.no_save_personal_info = ::std::option::Option::Some(v);
    }

    // optional bool oobe_test_mode_enabled = 2;

    pub fn oobe_test_mode_enabled(&self) -> bool {
        self.oobe_test_mode_enabled.unwrap_or(false)
    }

    pub fn clear_oobe_test_mode_enabled(&mut self) {
        self.oobe_test_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_oobe_test_mode_enabled(&self) -> bool {
        self.oobe_test_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oobe_test_mode_enabled(&mut self, v: bool) {
        self.oobe_test_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional bool in_client_beta = 3;

    pub fn in_client_beta(&self) -> bool {
        self.in_client_beta.unwrap_or(false)
    }

    pub fn clear_in_client_beta(&mut self) {
        self.in_client_beta = ::std::option::Option::None;
    }

    pub fn has_in_client_beta(&self) -> bool {
        self.in_client_beta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_client_beta(&mut self, v: bool) {
        self.in_client_beta = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_sideloaded = 4;

    pub fn is_steam_sideloaded(&self) -> bool {
        self.is_steam_sideloaded.unwrap_or(false)
    }

    pub fn clear_is_steam_sideloaded(&mut self) {
        self.is_steam_sideloaded = ::std::option::Option::None;
    }

    pub fn has_is_steam_sideloaded(&self) -> bool {
        self.is_steam_sideloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_sideloaded(&mut self, v: bool) {
        self.is_steam_sideloaded = ::std::option::Option::Some(v);
    }

    // optional string preferred_monitor = 5;

    pub fn preferred_monitor(&self) -> &str {
        match self.preferred_monitor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_monitor(&mut self) {
        self.preferred_monitor = ::std::option::Option::None;
    }

    pub fn has_preferred_monitor(&self) -> bool {
        self.preferred_monitor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_monitor(&mut self, v: ::std::string::String) {
        self.preferred_monitor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_monitor(&mut self) -> &mut ::std::string::String {
        if self.preferred_monitor.is_none() {
            self.preferred_monitor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_monitor.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_monitor(&mut self) -> ::std::string::String {
        self.preferred_monitor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool steam_cef_gpu_blocklist_disabled = 6;

    pub fn steam_cef_gpu_blocklist_disabled(&self) -> bool {
        self.steam_cef_gpu_blocklist_disabled.unwrap_or(false)
    }

    pub fn clear_steam_cef_gpu_blocklist_disabled(&mut self) {
        self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::None;
    }

    pub fn has_steam_cef_gpu_blocklist_disabled(&self) -> bool {
        self.steam_cef_gpu_blocklist_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_cef_gpu_blocklist_disabled(&mut self, v: bool) {
        self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::Some(v);
    }

    // optional bool bigpicture_windowed = 7;

    pub fn bigpicture_windowed(&self) -> bool {
        self.bigpicture_windowed.unwrap_or(false)
    }

    pub fn clear_bigpicture_windowed(&mut self) {
        self.bigpicture_windowed = ::std::option::Option::None;
    }

    pub fn has_bigpicture_windowed(&self) -> bool {
        self.bigpicture_windowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bigpicture_windowed(&mut self, v: bool) {
        self.bigpicture_windowed = ::std::option::Option::Some(v);
    }

    // optional string display_name = 8;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_external_display = 9;

    pub fn is_external_display(&self) -> bool {
        self.is_external_display.unwrap_or(false)
    }

    pub fn clear_is_external_display(&mut self) {
        self.is_external_display = ::std::option::Option::None;
    }

    pub fn has_is_external_display(&self) -> bool {
        self.is_external_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_external_display(&mut self, v: bool) {
        self.is_external_display = ::std::option::Option::Some(v);
    }

    // optional float steam_os_underscan_level = 10;

    pub fn steam_os_underscan_level(&self) -> f32 {
        self.steam_os_underscan_level.unwrap_or(0.)
    }

    pub fn clear_steam_os_underscan_level(&mut self) {
        self.steam_os_underscan_level = ::std::option::Option::None;
    }

    pub fn has_steam_os_underscan_level(&self) -> bool {
        self.steam_os_underscan_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_os_underscan_level(&mut self, v: f32) {
        self.steam_os_underscan_level = ::std::option::Option::Some(v);
    }

    // optional bool steam_os_underscan_enabled = 11;

    pub fn steam_os_underscan_enabled(&self) -> bool {
        self.steam_os_underscan_enabled.unwrap_or(false)
    }

    pub fn clear_steam_os_underscan_enabled(&mut self) {
        self.steam_os_underscan_enabled = ::std::option::Option::None;
    }

    pub fn has_steam_os_underscan_enabled(&self) -> bool {
        self.steam_os_underscan_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_os_underscan_enabled(&mut self, v: bool) {
        self.steam_os_underscan_enabled = ::std::option::Option::Some(v);
    }

    // optional float min_scale_factor = 12;

    pub fn min_scale_factor(&self) -> f32 {
        self.min_scale_factor.unwrap_or(0.)
    }

    pub fn clear_min_scale_factor(&mut self) {
        self.min_scale_factor = ::std::option::Option::None;
    }

    pub fn has_min_scale_factor(&self) -> bool {
        self.min_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_scale_factor(&mut self, v: f32) {
        self.min_scale_factor = ::std::option::Option::Some(v);
    }

    // optional float max_scale_factor = 13;

    pub fn max_scale_factor(&self) -> f32 {
        self.max_scale_factor.unwrap_or(0.)
    }

    pub fn clear_max_scale_factor(&mut self) {
        self.max_scale_factor = ::std::option::Option::None;
    }

    pub fn has_max_scale_factor(&self) -> bool {
        self.max_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_scale_factor(&mut self, v: f32) {
        self.max_scale_factor = ::std::option::Option::Some(v);
    }

    // optional float auto_scale_factor = 14;

    pub fn auto_scale_factor(&self) -> f32 {
        self.auto_scale_factor.unwrap_or(0.)
    }

    pub fn clear_auto_scale_factor(&mut self) {
        self.auto_scale_factor = ::std::option::Option::None;
    }

    pub fn has_auto_scale_factor(&self) -> bool {
        self.auto_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_scale_factor(&mut self, v: f32) {
        self.auto_scale_factor = ::std::option::Option::Some(v);
    }

    // optional bool small_mode = 16;

    pub fn small_mode(&self) -> bool {
        self.small_mode.unwrap_or(false)
    }

    pub fn clear_small_mode(&mut self) {
        self.small_mode = ::std::option::Option::None;
    }

    pub fn has_small_mode(&self) -> bool {
        self.small_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small_mode(&mut self, v: bool) {
        self.small_mode = ::std::option::Option::Some(v);
    }

    // optional bool skip_steamvr_install_dialog = 19;

    pub fn skip_steamvr_install_dialog(&self) -> bool {
        self.skip_steamvr_install_dialog.unwrap_or(false)
    }

    pub fn clear_skip_steamvr_install_dialog(&mut self) {
        self.skip_steamvr_install_dialog = ::std::option::Option::None;
    }

    pub fn has_skip_steamvr_install_dialog(&self) -> bool {
        self.skip_steamvr_install_dialog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_steamvr_install_dialog(&mut self, v: bool) {
        self.skip_steamvr_install_dialog = ::std::option::Option::Some(v);
    }

    // optional bool always_show_user_chooser = 20;

    pub fn always_show_user_chooser(&self) -> bool {
        self.always_show_user_chooser.unwrap_or(false)
    }

    pub fn clear_always_show_user_chooser(&mut self) {
        self.always_show_user_chooser = ::std::option::Option::None;
    }

    pub fn has_always_show_user_chooser(&self) -> bool {
        self.always_show_user_chooser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_show_user_chooser(&mut self, v: bool) {
        self.always_show_user_chooser = ::std::option::Option::Some(v);
    }

    // optional bool show_family_sharing_notifications = 3000;

    pub fn show_family_sharing_notifications(&self) -> bool {
        self.show_family_sharing_notifications.unwrap_or(false)
    }

    pub fn clear_show_family_sharing_notifications(&mut self) {
        self.show_family_sharing_notifications = ::std::option::Option::None;
    }

    pub fn has_show_family_sharing_notifications(&self) -> bool {
        self.show_family_sharing_notifications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_family_sharing_notifications(&mut self, v: bool) {
        self.show_family_sharing_notifications = ::std::option::Option::Some(v);
    }

    // optional int32 overlay_fps_counter_corner = 4000;

    pub fn overlay_fps_counter_corner(&self) -> i32 {
        self.overlay_fps_counter_corner.unwrap_or(0)
    }

    pub fn clear_overlay_fps_counter_corner(&mut self) {
        self.overlay_fps_counter_corner = ::std::option::Option::None;
    }

    pub fn has_overlay_fps_counter_corner(&self) -> bool {
        self.overlay_fps_counter_corner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_fps_counter_corner(&mut self, v: i32) {
        self.overlay_fps_counter_corner = ::std::option::Option::Some(v);
    }

    // optional bool overlay_fps_counter_high_contrast = 4001;

    pub fn overlay_fps_counter_high_contrast(&self) -> bool {
        self.overlay_fps_counter_high_contrast.unwrap_or(false)
    }

    pub fn clear_overlay_fps_counter_high_contrast(&mut self) {
        self.overlay_fps_counter_high_contrast = ::std::option::Option::None;
    }

    pub fn has_overlay_fps_counter_high_contrast(&self) -> bool {
        self.overlay_fps_counter_high_contrast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_fps_counter_high_contrast(&mut self, v: bool) {
        self.overlay_fps_counter_high_contrast = ::std::option::Option::Some(v);
    }

    // optional .CMsgHotkey overlay_key = 4002;

    pub fn overlay_key(&self) -> &CMsgHotkey {
        self.overlay_key.as_ref().unwrap_or_else(|| <CMsgHotkey as crate::Message>::default_instance())
    }

    pub fn clear_overlay_key(&mut self) {
        self.overlay_key.clear();
    }

    pub fn has_overlay_key(&self) -> bool {
        self.overlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_key(&mut self, v: CMsgHotkey) {
        self.overlay_key = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overlay_key(&mut self) -> &mut CMsgHotkey {
        self.overlay_key.mut_or_insert_default()
    }

    // Take field
    pub fn take_overlay_key(&mut self) -> CMsgHotkey {
        self.overlay_key.take().unwrap_or_else(|| CMsgHotkey::new())
    }

    // optional .CMsgHotkey screenshot_key = 4003;

    pub fn screenshot_key(&self) -> &CMsgHotkey {
        self.screenshot_key.as_ref().unwrap_or_else(|| <CMsgHotkey as crate::Message>::default_instance())
    }

    pub fn clear_screenshot_key(&mut self) {
        self.screenshot_key.clear();
    }

    pub fn has_screenshot_key(&self) -> bool {
        self.screenshot_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot_key(&mut self, v: CMsgHotkey) {
        self.screenshot_key = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot_key(&mut self) -> &mut CMsgHotkey {
        self.screenshot_key.mut_or_insert_default()
    }

    // Take field
    pub fn take_screenshot_key(&mut self) -> CMsgHotkey {
        self.screenshot_key.take().unwrap_or_else(|| CMsgHotkey::new())
    }

    // optional bool enable_overlay = 4004;

    pub fn enable_overlay(&self) -> bool {
        self.enable_overlay.unwrap_or(false)
    }

    pub fn clear_enable_overlay(&mut self) {
        self.enable_overlay = ::std::option::Option::None;
    }

    pub fn has_enable_overlay(&self) -> bool {
        self.enable_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_overlay(&mut self, v: bool) {
        self.enable_overlay = ::std::option::Option::Some(v);
    }

    // optional bool enable_screenshot_notification = 4006;

    pub fn enable_screenshot_notification(&self) -> bool {
        self.enable_screenshot_notification.unwrap_or(false)
    }

    pub fn clear_enable_screenshot_notification(&mut self) {
        self.enable_screenshot_notification = ::std::option::Option::None;
    }

    pub fn has_enable_screenshot_notification(&self) -> bool {
        self.enable_screenshot_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_screenshot_notification(&mut self, v: bool) {
        self.enable_screenshot_notification = ::std::option::Option::Some(v);
    }

    // optional bool enable_screenshot_sound = 4007;

    pub fn enable_screenshot_sound(&self) -> bool {
        self.enable_screenshot_sound.unwrap_or(false)
    }

    pub fn clear_enable_screenshot_sound(&mut self) {
        self.enable_screenshot_sound = ::std::option::Option::None;
    }

    pub fn has_enable_screenshot_sound(&self) -> bool {
        self.enable_screenshot_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_screenshot_sound(&mut self, v: bool) {
        self.enable_screenshot_sound = ::std::option::Option::Some(v);
    }

    // optional bool save_uncompressed_screenshots = 4008;

    pub fn save_uncompressed_screenshots(&self) -> bool {
        self.save_uncompressed_screenshots.unwrap_or(false)
    }

    pub fn clear_save_uncompressed_screenshots(&mut self) {
        self.save_uncompressed_screenshots = ::std::option::Option::None;
    }

    pub fn has_save_uncompressed_screenshots(&self) -> bool {
        self.save_uncompressed_screenshots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_uncompressed_screenshots(&mut self, v: bool) {
        self.save_uncompressed_screenshots = ::std::option::Option::Some(v);
    }

    // optional string screenshots_path = 4009;

    pub fn screenshots_path(&self) -> &str {
        match self.screenshots_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_screenshots_path(&mut self) {
        self.screenshots_path = ::std::option::Option::None;
    }

    pub fn has_screenshots_path(&self) -> bool {
        self.screenshots_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshots_path(&mut self, v: ::std::string::String) {
        self.screenshots_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshots_path(&mut self) -> &mut ::std::string::String {
        if self.screenshots_path.is_none() {
            self.screenshots_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.screenshots_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshots_path(&mut self) -> ::std::string::String {
        self.screenshots_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 default_ping_rate = 4010;

    pub fn default_ping_rate(&self) -> i32 {
        self.default_ping_rate.unwrap_or(0)
    }

    pub fn clear_default_ping_rate(&mut self) {
        self.default_ping_rate = ::std::option::Option::None;
    }

    pub fn has_default_ping_rate(&self) -> bool {
        self.default_ping_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_ping_rate(&mut self, v: i32) {
        self.default_ping_rate = ::std::option::Option::Some(v);
    }

    // optional int32 server_ping_rate = 4011;

    pub fn server_ping_rate(&self) -> i32 {
        self.server_ping_rate.unwrap_or(0)
    }

    pub fn clear_server_ping_rate(&mut self) {
        self.server_ping_rate = ::std::option::Option::None;
    }

    pub fn has_server_ping_rate(&self) -> bool {
        self.server_ping_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ping_rate(&mut self, v: i32) {
        self.server_ping_rate = ::std::option::Option::Some(v);
    }

    // optional int32 steam_networking_share_ip = 4012;

    pub fn steam_networking_share_ip(&self) -> i32 {
        self.steam_networking_share_ip.unwrap_or(0)
    }

    pub fn clear_steam_networking_share_ip(&mut self) {
        self.steam_networking_share_ip = ::std::option::Option::None;
    }

    pub fn has_steam_networking_share_ip(&self) -> bool {
        self.steam_networking_share_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_networking_share_ip(&mut self, v: i32) {
        self.steam_networking_share_ip = ::std::option::Option::Some(v);
    }

    // optional string web_browser_home = 4013;

    pub fn web_browser_home(&self) -> &str {
        match self.web_browser_home.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_web_browser_home(&mut self) {
        self.web_browser_home = ::std::option::Option::None;
    }

    pub fn has_web_browser_home(&self) -> bool {
        self.web_browser_home.is_some()
    }

    // Param is passed by value, moved
    pub fn set_web_browser_home(&mut self, v: ::std::string::String) {
        self.web_browser_home = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_web_browser_home(&mut self) -> &mut ::std::string::String {
        if self.web_browser_home.is_none() {
            self.web_browser_home = ::std::option::Option::Some(::std::string::String::new());
        }
        self.web_browser_home.as_mut().unwrap()
    }

    // Take field
    pub fn take_web_browser_home(&mut self) -> ::std::string::String {
        self.web_browser_home.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string voice_mic_device_name = 4014;

    pub fn voice_mic_device_name(&self) -> &str {
        match self.voice_mic_device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_voice_mic_device_name(&mut self) {
        self.voice_mic_device_name = ::std::option::Option::None;
    }

    pub fn has_voice_mic_device_name(&self) -> bool {
        self.voice_mic_device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_mic_device_name(&mut self, v: ::std::string::String) {
        self.voice_mic_device_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_mic_device_name(&mut self) -> &mut ::std::string::String {
        if self.voice_mic_device_name.is_none() {
            self.voice_mic_device_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.voice_mic_device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_mic_device_name(&mut self) -> ::std::string::String {
        self.voice_mic_device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float voice_mic_input_gain = 4015;

    pub fn voice_mic_input_gain(&self) -> f32 {
        self.voice_mic_input_gain.unwrap_or(0.)
    }

    pub fn clear_voice_mic_input_gain(&mut self) {
        self.voice_mic_input_gain = ::std::option::Option::None;
    }

    pub fn has_voice_mic_input_gain(&self) -> bool {
        self.voice_mic_input_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_mic_input_gain(&mut self, v: f32) {
        self.voice_mic_input_gain = ::std::option::Option::Some(v);
    }

    // optional float voice_speaker_output_gain = 4016;

    pub fn voice_speaker_output_gain(&self) -> f32 {
        self.voice_speaker_output_gain.unwrap_or(0.)
    }

    pub fn clear_voice_speaker_output_gain(&mut self) {
        self.voice_speaker_output_gain = ::std::option::Option::None;
    }

    pub fn has_voice_speaker_output_gain(&self) -> bool {
        self.voice_speaker_output_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_speaker_output_gain(&mut self, v: f32) {
        self.voice_speaker_output_gain = ::std::option::Option::Some(v);
    }

    // optional int32 voice_push_to_talk_setting = 4017;

    pub fn voice_push_to_talk_setting(&self) -> i32 {
        self.voice_push_to_talk_setting.unwrap_or(0)
    }

    pub fn clear_voice_push_to_talk_setting(&mut self) {
        self.voice_push_to_talk_setting = ::std::option::Option::None;
    }

    pub fn has_voice_push_to_talk_setting(&self) -> bool {
        self.voice_push_to_talk_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_push_to_talk_setting(&mut self, v: i32) {
        self.voice_push_to_talk_setting = ::std::option::Option::Some(v);
    }

    // optional .CMsgHotkey voice_push_to_talk_key = 4018;

    pub fn voice_push_to_talk_key(&self) -> &CMsgHotkey {
        self.voice_push_to_talk_key.as_ref().unwrap_or_else(|| <CMsgHotkey as crate::Message>::default_instance())
    }

    pub fn clear_voice_push_to_talk_key(&mut self) {
        self.voice_push_to_talk_key.clear();
    }

    pub fn has_voice_push_to_talk_key(&self) -> bool {
        self.voice_push_to_talk_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_push_to_talk_key(&mut self, v: CMsgHotkey) {
        self.voice_push_to_talk_key = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_push_to_talk_key(&mut self) -> &mut CMsgHotkey {
        self.voice_push_to_talk_key.mut_or_insert_default()
    }

    // Take field
    pub fn take_voice_push_to_talk_key(&mut self) -> CMsgHotkey {
        self.voice_push_to_talk_key.take().unwrap_or_else(|| CMsgHotkey::new())
    }

    // optional bool overlay_toolbar_list_view = 4019;

    pub fn overlay_toolbar_list_view(&self) -> bool {
        self.overlay_toolbar_list_view.unwrap_or(false)
    }

    pub fn clear_overlay_toolbar_list_view(&mut self) {
        self.overlay_toolbar_list_view = ::std::option::Option::None;
    }

    pub fn has_overlay_toolbar_list_view(&self) -> bool {
        self.overlay_toolbar_list_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_toolbar_list_view(&mut self, v: bool) {
        self.overlay_toolbar_list_view = ::std::option::Option::Some(v);
    }

    // optional bool always_use_gamepadui_overlay = 4020;

    pub fn always_use_gamepadui_overlay(&self) -> bool {
        self.always_use_gamepadui_overlay.unwrap_or(false)
    }

    pub fn clear_always_use_gamepadui_overlay(&mut self) {
        self.always_use_gamepadui_overlay = ::std::option::Option::None;
    }

    pub fn has_always_use_gamepadui_overlay(&self) -> bool {
        self.always_use_gamepadui_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_use_gamepadui_overlay(&mut self, v: bool) {
        self.always_use_gamepadui_overlay = ::std::option::Option::Some(v);
    }

    // optional string overlay_tabs = 4021;

    pub fn overlay_tabs(&self) -> &str {
        match self.overlay_tabs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_overlay_tabs(&mut self) {
        self.overlay_tabs = ::std::option::Option::None;
    }

    pub fn has_overlay_tabs(&self) -> bool {
        self.overlay_tabs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_tabs(&mut self, v: ::std::string::String) {
        self.overlay_tabs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overlay_tabs(&mut self) -> &mut ::std::string::String {
        if self.overlay_tabs.is_none() {
            self.overlay_tabs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.overlay_tabs.as_mut().unwrap()
    }

    // Take field
    pub fn take_overlay_tabs(&mut self) -> ::std::string::String {
        self.overlay_tabs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool overlay_scale_interface = 4022;

    pub fn overlay_scale_interface(&self) -> bool {
        self.overlay_scale_interface.unwrap_or(false)
    }

    pub fn clear_overlay_scale_interface(&mut self) {
        self.overlay_scale_interface = ::std::option::Option::None;
    }

    pub fn has_overlay_scale_interface(&self) -> bool {
        self.overlay_scale_interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_scale_interface(&mut self, v: bool) {
        self.overlay_scale_interface = ::std::option::Option::Some(v);
    }

    // optional bool overlay_restore_browser_tabs = 4023;

    pub fn overlay_restore_browser_tabs(&self) -> bool {
        self.overlay_restore_browser_tabs.unwrap_or(false)
    }

    pub fn clear_overlay_restore_browser_tabs(&mut self) {
        self.overlay_restore_browser_tabs = ::std::option::Option::None;
    }

    pub fn has_overlay_restore_browser_tabs(&self) -> bool {
        self.overlay_restore_browser_tabs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_restore_browser_tabs(&mut self, v: bool) {
        self.overlay_restore_browser_tabs = ::std::option::Option::Some(v);
    }

    // optional bool smooth_scroll_webviews = 5000;

    pub fn smooth_scroll_webviews(&self) -> bool {
        self.smooth_scroll_webviews.unwrap_or(false)
    }

    pub fn clear_smooth_scroll_webviews(&mut self) {
        self.smooth_scroll_webviews = ::std::option::Option::None;
    }

    pub fn has_smooth_scroll_webviews(&self) -> bool {
        self.smooth_scroll_webviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smooth_scroll_webviews(&mut self, v: bool) {
        self.smooth_scroll_webviews = ::std::option::Option::Some(v);
    }

    // optional bool enable_gpu_accelerated_webviews = 5001;

    pub fn enable_gpu_accelerated_webviews(&self) -> bool {
        self.enable_gpu_accelerated_webviews.unwrap_or(false)
    }

    pub fn clear_enable_gpu_accelerated_webviews(&mut self) {
        self.enable_gpu_accelerated_webviews = ::std::option::Option::None;
    }

    pub fn has_enable_gpu_accelerated_webviews(&self) -> bool {
        self.enable_gpu_accelerated_webviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_gpu_accelerated_webviews(&mut self, v: bool) {
        self.enable_gpu_accelerated_webviews = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_video_decoding = 5003;

    pub fn enable_hardware_video_decoding(&self) -> bool {
        self.enable_hardware_video_decoding.unwrap_or(false)
    }

    pub fn clear_enable_hardware_video_decoding(&mut self) {
        self.enable_hardware_video_decoding = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_video_decoding(&self) -> bool {
        self.enable_hardware_video_decoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_video_decoding(&mut self, v: bool) {
        self.enable_hardware_video_decoding = ::std::option::Option::Some(v);
    }

    // optional bool run_at_startup = 5004;

    pub fn run_at_startup(&self) -> bool {
        self.run_at_startup.unwrap_or(false)
    }

    pub fn clear_run_at_startup(&mut self) {
        self.run_at_startup = ::std::option::Option::None;
    }

    pub fn has_run_at_startup(&self) -> bool {
        self.run_at_startup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_at_startup(&mut self, v: bool) {
        self.run_at_startup = ::std::option::Option::Some(v);
    }

    // optional bool enable_dpi_scaling = 5005;

    pub fn enable_dpi_scaling(&self) -> bool {
        self.enable_dpi_scaling.unwrap_or(false)
    }

    pub fn clear_enable_dpi_scaling(&mut self) {
        self.enable_dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_enable_dpi_scaling(&self) -> bool {
        self.enable_dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_dpi_scaling(&mut self, v: bool) {
        self.enable_dpi_scaling = ::std::option::Option::Some(v);
    }

    // optional bool enable_marketing_messages = 5006;

    pub fn enable_marketing_messages(&self) -> bool {
        self.enable_marketing_messages.unwrap_or(false)
    }

    pub fn clear_enable_marketing_messages(&mut self) {
        self.enable_marketing_messages = ::std::option::Option::None;
    }

    pub fn has_enable_marketing_messages(&self) -> bool {
        self.enable_marketing_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_marketing_messages(&mut self, v: bool) {
        self.enable_marketing_messages = ::std::option::Option::Some(v);
    }

    // optional bool start_in_big_picture_mode = 5007;

    pub fn start_in_big_picture_mode(&self) -> bool {
        self.start_in_big_picture_mode.unwrap_or(false)
    }

    pub fn clear_start_in_big_picture_mode(&mut self) {
        self.start_in_big_picture_mode = ::std::option::Option::None;
    }

    pub fn has_start_in_big_picture_mode(&self) -> bool {
        self.start_in_big_picture_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_in_big_picture_mode(&mut self, v: bool) {
        self.start_in_big_picture_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 jumplist_flags = 5008;

    pub fn jumplist_flags(&self) -> u32 {
        self.jumplist_flags.unwrap_or(0)
    }

    pub fn clear_jumplist_flags(&mut self) {
        self.jumplist_flags = ::std::option::Option::None;
    }

    pub fn has_jumplist_flags(&self) -> bool {
        self.jumplist_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jumplist_flags(&mut self, v: u32) {
        self.jumplist_flags = ::std::option::Option::Some(v);
    }

    // optional bool enable_ui_sounds = 5009;

    pub fn enable_ui_sounds(&self) -> bool {
        self.enable_ui_sounds.unwrap_or(false)
    }

    pub fn clear_enable_ui_sounds(&mut self) {
        self.enable_ui_sounds = ::std::option::Option::None;
    }

    pub fn has_enable_ui_sounds(&self) -> bool {
        self.enable_ui_sounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_ui_sounds(&mut self, v: bool) {
        self.enable_ui_sounds = ::std::option::Option::Some(v);
    }

    // optional bool disable_all_toasts = 6000;

    pub fn disable_all_toasts(&self) -> bool {
        self.disable_all_toasts.unwrap_or(false)
    }

    pub fn clear_disable_all_toasts(&mut self) {
        self.disable_all_toasts = ::std::option::Option::None;
    }

    pub fn has_disable_all_toasts(&self) -> bool {
        self.disable_all_toasts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_all_toasts(&mut self, v: bool) {
        self.disable_all_toasts = ::std::option::Option::Some(v);
    }

    // optional bool disable_toasts_in_game = 6001;

    pub fn disable_toasts_in_game(&self) -> bool {
        self.disable_toasts_in_game.unwrap_or(false)
    }

    pub fn clear_disable_toasts_in_game(&mut self) {
        self.disable_toasts_in_game = ::std::option::Option::None;
    }

    pub fn has_disable_toasts_in_game(&self) -> bool {
        self.disable_toasts_in_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_toasts_in_game(&mut self, v: bool) {
        self.disable_toasts_in_game = ::std::option::Option::Some(v);
    }

    // optional bool play_sound_on_toast = 6002;

    pub fn play_sound_on_toast(&self) -> bool {
        self.play_sound_on_toast.unwrap_or(false)
    }

    pub fn clear_play_sound_on_toast(&mut self) {
        self.play_sound_on_toast = ::std::option::Option::None;
    }

    pub fn has_play_sound_on_toast(&self) -> bool {
        self.play_sound_on_toast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_sound_on_toast(&mut self, v: bool) {
        self.play_sound_on_toast = ::std::option::Option::Some(v);
    }

    // optional int32 library_display_size = 7000;

    pub fn library_display_size(&self) -> i32 {
        self.library_display_size.unwrap_or(0)
    }

    pub fn clear_library_display_size(&mut self) {
        self.library_display_size = ::std::option::Option::None;
    }

    pub fn has_library_display_size(&self) -> bool {
        self.library_display_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_display_size(&mut self, v: i32) {
        self.library_display_size = ::std::option::Option::Some(v);
    }

    // optional bool library_whats_new_show_only_product_updates = 7001;

    pub fn library_whats_new_show_only_product_updates(&self) -> bool {
        self.library_whats_new_show_only_product_updates.unwrap_or(false)
    }

    pub fn clear_library_whats_new_show_only_product_updates(&mut self) {
        self.library_whats_new_show_only_product_updates = ::std::option::Option::None;
    }

    pub fn has_library_whats_new_show_only_product_updates(&self) -> bool {
        self.library_whats_new_show_only_product_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_whats_new_show_only_product_updates(&mut self, v: bool) {
        self.library_whats_new_show_only_product_updates = ::std::option::Option::Some(v);
    }

    // optional bool show_store_content_on_home = 7002;

    pub fn show_store_content_on_home(&self) -> bool {
        self.show_store_content_on_home.unwrap_or(false)
    }

    pub fn clear_show_store_content_on_home(&mut self) {
        self.show_store_content_on_home = ::std::option::Option::None;
    }

    pub fn has_show_store_content_on_home(&self) -> bool {
        self.show_store_content_on_home.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_store_content_on_home(&mut self, v: bool) {
        self.show_store_content_on_home = ::std::option::Option::Some(v);
    }

    // optional string start_page = 7003;

    pub fn start_page(&self) -> &str {
        match self.start_page.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_page(&mut self) {
        self.start_page = ::std::option::Option::None;
    }

    pub fn has_start_page(&self) -> bool {
        self.start_page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_page(&mut self, v: ::std::string::String) {
        self.start_page = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_page(&mut self) -> &mut ::std::string::String {
        if self.start_page.is_none() {
            self.start_page = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_page.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_page(&mut self) -> ::std::string::String {
        self.start_page.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool library_low_bandwidth_mode = 7004;

    pub fn library_low_bandwidth_mode(&self) -> bool {
        self.library_low_bandwidth_mode.unwrap_or(false)
    }

    pub fn clear_library_low_bandwidth_mode(&mut self) {
        self.library_low_bandwidth_mode = ::std::option::Option::None;
    }

    pub fn has_library_low_bandwidth_mode(&self) -> bool {
        self.library_low_bandwidth_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_bandwidth_mode(&mut self, v: bool) {
        self.library_low_bandwidth_mode = ::std::option::Option::Some(v);
    }

    // optional bool library_low_perf_mode = 7005;

    pub fn library_low_perf_mode(&self) -> bool {
        self.library_low_perf_mode.unwrap_or(false)
    }

    pub fn clear_library_low_perf_mode(&mut self) {
        self.library_low_perf_mode = ::std::option::Option::None;
    }

    pub fn has_library_low_perf_mode(&self) -> bool {
        self.library_low_perf_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_perf_mode(&mut self, v: bool) {
        self.library_low_perf_mode = ::std::option::Option::Some(v);
    }

    // optional bool library_disable_community_content = 7006;

    pub fn library_disable_community_content(&self) -> bool {
        self.library_disable_community_content.unwrap_or(false)
    }

    pub fn clear_library_disable_community_content(&mut self) {
        self.library_disable_community_content = ::std::option::Option::None;
    }

    pub fn has_library_disable_community_content(&self) -> bool {
        self.library_disable_community_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_disable_community_content(&mut self, v: bool) {
        self.library_disable_community_content = ::std::option::Option::Some(v);
    }

    // optional bool library_display_icon_in_game_list = 7007;

    pub fn library_display_icon_in_game_list(&self) -> bool {
        self.library_display_icon_in_game_list.unwrap_or(false)
    }

    pub fn clear_library_display_icon_in_game_list(&mut self) {
        self.library_display_icon_in_game_list = ::std::option::Option::None;
    }

    pub fn has_library_display_icon_in_game_list(&self) -> bool {
        self.library_display_icon_in_game_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_display_icon_in_game_list(&mut self, v: bool) {
        self.library_display_icon_in_game_list = ::std::option::Option::Some(v);
    }

    // optional bool ready_to_play_includes_streaming = 7008;

    pub fn ready_to_play_includes_streaming(&self) -> bool {
        self.ready_to_play_includes_streaming.unwrap_or(false)
    }

    pub fn clear_ready_to_play_includes_streaming(&mut self) {
        self.ready_to_play_includes_streaming = ::std::option::Option::None;
    }

    pub fn has_ready_to_play_includes_streaming(&self) -> bool {
        self.ready_to_play_includes_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ready_to_play_includes_streaming(&mut self, v: bool) {
        self.ready_to_play_includes_streaming = ::std::option::Option::Some(v);
    }

    // optional bool show_steam_deck_info = 7009;

    pub fn show_steam_deck_info(&self) -> bool {
        self.show_steam_deck_info.unwrap_or(false)
    }

    pub fn clear_show_steam_deck_info(&mut self) {
        self.show_steam_deck_info = ::std::option::Option::None;
    }

    pub fn has_show_steam_deck_info(&self) -> bool {
        self.show_steam_deck_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_steam_deck_info(&mut self, v: bool) {
        self.show_steam_deck_info = ::std::option::Option::Some(v);
    }

    // optional bool enable_shader_precache = 8000;

    pub fn enable_shader_precache(&self) -> bool {
        self.enable_shader_precache.unwrap_or(false)
    }

    pub fn clear_enable_shader_precache(&mut self) {
        self.enable_shader_precache = ::std::option::Option::None;
    }

    pub fn has_enable_shader_precache(&self) -> bool {
        self.enable_shader_precache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_shader_precache(&mut self, v: bool) {
        self.enable_shader_precache = ::std::option::Option::Some(v);
    }

    // optional bool enable_shader_background_processing = 8001;

    pub fn enable_shader_background_processing(&self) -> bool {
        self.enable_shader_background_processing.unwrap_or(false)
    }

    pub fn clear_enable_shader_background_processing(&mut self) {
        self.enable_shader_background_processing = ::std::option::Option::None;
    }

    pub fn has_enable_shader_background_processing(&self) -> bool {
        self.enable_shader_background_processing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_shader_background_processing(&mut self, v: bool) {
        self.enable_shader_background_processing = ::std::option::Option::Some(v);
    }

    // optional uint64 shader_precached_size = 8002;

    pub fn shader_precached_size(&self) -> u64 {
        self.shader_precached_size.unwrap_or(0)
    }

    pub fn clear_shader_precached_size(&mut self) {
        self.shader_precached_size = ::std::option::Option::None;
    }

    pub fn has_shader_precached_size(&self) -> bool {
        self.shader_precached_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shader_precached_size(&mut self, v: u64) {
        self.shader_precached_size = ::std::option::Option::Some(v);
    }

    // optional bool needs_steam_service_repair = 8003;

    pub fn needs_steam_service_repair(&self) -> bool {
        self.needs_steam_service_repair.unwrap_or(false)
    }

    pub fn clear_needs_steam_service_repair(&mut self) {
        self.needs_steam_service_repair = ::std::option::Option::None;
    }

    pub fn has_needs_steam_service_repair(&self) -> bool {
        self.needs_steam_service_repair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_steam_service_repair(&mut self, v: bool) {
        self.needs_steam_service_repair = ::std::option::Option::Some(v);
    }

    // optional int32 download_peer_content = 8004;

    pub fn download_peer_content(&self) -> i32 {
        self.download_peer_content.unwrap_or(0)
    }

    pub fn clear_download_peer_content(&mut self) {
        self.download_peer_content = ::std::option::Option::None;
    }

    pub fn has_download_peer_content(&self) -> bool {
        self.download_peer_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_peer_content(&mut self, v: i32) {
        self.download_peer_content = ::std::option::Option::Some(v);
    }

    // optional bool download_rate_bits_per_s = 8005;

    pub fn download_rate_bits_per_s(&self) -> bool {
        self.download_rate_bits_per_s.unwrap_or(false)
    }

    pub fn clear_download_rate_bits_per_s(&mut self) {
        self.download_rate_bits_per_s = ::std::option::Option::None;
    }

    pub fn has_download_rate_bits_per_s(&self) -> bool {
        self.download_rate_bits_per_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_rate_bits_per_s(&mut self, v: bool) {
        self.download_rate_bits_per_s = ::std::option::Option::Some(v);
    }

    // optional bool restrict_auto_updates = 8006;

    pub fn restrict_auto_updates(&self) -> bool {
        self.restrict_auto_updates.unwrap_or(false)
    }

    pub fn clear_restrict_auto_updates(&mut self) {
        self.restrict_auto_updates = ::std::option::Option::None;
    }

    pub fn has_restrict_auto_updates(&self) -> bool {
        self.restrict_auto_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restrict_auto_updates(&mut self, v: bool) {
        self.restrict_auto_updates = ::std::option::Option::Some(v);
    }

    // optional int32 restrict_auto_updates_start = 8007;

    pub fn restrict_auto_updates_start(&self) -> i32 {
        self.restrict_auto_updates_start.unwrap_or(0)
    }

    pub fn clear_restrict_auto_updates_start(&mut self) {
        self.restrict_auto_updates_start = ::std::option::Option::None;
    }

    pub fn has_restrict_auto_updates_start(&self) -> bool {
        self.restrict_auto_updates_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restrict_auto_updates_start(&mut self, v: i32) {
        self.restrict_auto_updates_start = ::std::option::Option::Some(v);
    }

    // optional int32 restrict_auto_updates_end = 8008;

    pub fn restrict_auto_updates_end(&self) -> i32 {
        self.restrict_auto_updates_end.unwrap_or(0)
    }

    pub fn clear_restrict_auto_updates_end(&mut self) {
        self.restrict_auto_updates_end = ::std::option::Option::None;
    }

    pub fn has_restrict_auto_updates_end(&self) -> bool {
        self.restrict_auto_updates_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restrict_auto_updates_end(&mut self, v: i32) {
        self.restrict_auto_updates_end = ::std::option::Option::Some(v);
    }

    // optional int32 download_region = 8009;

    pub fn download_region(&self) -> i32 {
        self.download_region.unwrap_or(0)
    }

    pub fn clear_download_region(&mut self) {
        self.download_region = ::std::option::Option::None;
    }

    pub fn has_download_region(&self) -> bool {
        self.download_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_region(&mut self, v: i32) {
        self.download_region = ::std::option::Option::Some(v);
    }

    // optional bool download_while_app_running = 8010;

    pub fn download_while_app_running(&self) -> bool {
        self.download_while_app_running.unwrap_or(false)
    }

    pub fn clear_download_while_app_running(&mut self) {
        self.download_while_app_running = ::std::option::Option::None;
    }

    pub fn has_download_while_app_running(&self) -> bool {
        self.download_while_app_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_while_app_running(&mut self, v: bool) {
        self.download_while_app_running = ::std::option::Option::Some(v);
    }

    // optional bool download_throttle_while_streaming = 8011;

    pub fn download_throttle_while_streaming(&self) -> bool {
        self.download_throttle_while_streaming.unwrap_or(false)
    }

    pub fn clear_download_throttle_while_streaming(&mut self) {
        self.download_throttle_while_streaming = ::std::option::Option::None;
    }

    pub fn has_download_throttle_while_streaming(&self) -> bool {
        self.download_throttle_while_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_throttle_while_streaming(&mut self, v: bool) {
        self.download_throttle_while_streaming = ::std::option::Option::Some(v);
    }

    // optional int32 download_throttle_rate = 8012;

    pub fn download_throttle_rate(&self) -> i32 {
        self.download_throttle_rate.unwrap_or(0)
    }

    pub fn clear_download_throttle_rate(&mut self) {
        self.download_throttle_rate = ::std::option::Option::None;
    }

    pub fn has_download_throttle_rate(&self) -> bool {
        self.download_throttle_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_throttle_rate(&mut self, v: i32) {
        self.download_throttle_rate = ::std::option::Option::Some(v);
    }

    // optional bool cloud_enabled = 10000;

    pub fn cloud_enabled(&self) -> bool {
        self.cloud_enabled.unwrap_or(false)
    }

    pub fn clear_cloud_enabled(&mut self) {
        self.cloud_enabled = ::std::option::Option::None;
    }

    pub fn has_cloud_enabled(&self) -> bool {
        self.cloud_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_enabled(&mut self, v: bool) {
        self.cloud_enabled = ::std::option::Option::Some(v);
    }

    // optional bool show_screenshot_manager = 10001;

    pub fn show_screenshot_manager(&self) -> bool {
        self.show_screenshot_manager.unwrap_or(false)
    }

    pub fn clear_show_screenshot_manager(&mut self) {
        self.show_screenshot_manager = ::std::option::Option::None;
    }

    pub fn has_show_screenshot_manager(&self) -> bool {
        self.show_screenshot_manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_screenshot_manager(&mut self, v: bool) {
        self.show_screenshot_manager = ::std::option::Option::Some(v);
    }

    // optional int32 music_volume = 11000;

    pub fn music_volume(&self) -> i32 {
        self.music_volume.unwrap_or(0)
    }

    pub fn clear_music_volume(&mut self) {
        self.music_volume = ::std::option::Option::None;
    }

    pub fn has_music_volume(&self) -> bool {
        self.music_volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_volume(&mut self, v: i32) {
        self.music_volume = ::std::option::Option::Some(v);
    }

    // optional bool music_pause_on_app_start = 11001;

    pub fn music_pause_on_app_start(&self) -> bool {
        self.music_pause_on_app_start.unwrap_or(false)
    }

    pub fn clear_music_pause_on_app_start(&mut self) {
        self.music_pause_on_app_start = ::std::option::Option::None;
    }

    pub fn has_music_pause_on_app_start(&self) -> bool {
        self.music_pause_on_app_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_pause_on_app_start(&mut self, v: bool) {
        self.music_pause_on_app_start = ::std::option::Option::Some(v);
    }

    // optional bool music_pause_on_voice_chat = 11002;

    pub fn music_pause_on_voice_chat(&self) -> bool {
        self.music_pause_on_voice_chat.unwrap_or(false)
    }

    pub fn clear_music_pause_on_voice_chat(&mut self) {
        self.music_pause_on_voice_chat = ::std::option::Option::None;
    }

    pub fn has_music_pause_on_voice_chat(&self) -> bool {
        self.music_pause_on_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_pause_on_voice_chat(&mut self, v: bool) {
        self.music_pause_on_voice_chat = ::std::option::Option::Some(v);
    }

    // optional bool music_download_high_quality = 11003;

    pub fn music_download_high_quality(&self) -> bool {
        self.music_download_high_quality.unwrap_or(false)
    }

    pub fn clear_music_download_high_quality(&mut self) {
        self.music_download_high_quality = ::std::option::Option::None;
    }

    pub fn has_music_download_high_quality(&self) -> bool {
        self.music_download_high_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_download_high_quality(&mut self, v: bool) {
        self.music_download_high_quality = ::std::option::Option::Some(v);
    }

    // optional bool music_playlist_notification = 11004;

    pub fn music_playlist_notification(&self) -> bool {
        self.music_playlist_notification.unwrap_or(false)
    }

    pub fn clear_music_playlist_notification(&mut self) {
        self.music_playlist_notification = ::std::option::Option::None;
    }

    pub fn has_music_playlist_notification(&self) -> bool {
        self.music_playlist_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_playlist_notification(&mut self, v: bool) {
        self.music_playlist_notification = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastPermission broadcast_permissions = 12000;

    pub fn broadcast_permissions(&self) -> super::enums::EBroadcastPermission {
        match self.broadcast_permissions {
            Some(e) => e.enum_value_or(super::enums::EBroadcastPermission::k_EBroadcastPermissionDisabled),
            None => super::enums::EBroadcastPermission::k_EBroadcastPermissionDisabled,
        }
    }

    pub fn clear_broadcast_permissions(&mut self) {
        self.broadcast_permissions = ::std::option::Option::None;
    }

    pub fn has_broadcast_permissions(&self) -> bool {
        self.broadcast_permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permissions(&mut self, v: super::enums::EBroadcastPermission) {
        self.broadcast_permissions = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 broadcast_output_width = 12001;

    pub fn broadcast_output_width(&self) -> i32 {
        self.broadcast_output_width.unwrap_or(0)
    }

    pub fn clear_broadcast_output_width(&mut self) {
        self.broadcast_output_width = ::std::option::Option::None;
    }

    pub fn has_broadcast_output_width(&self) -> bool {
        self.broadcast_output_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_output_width(&mut self, v: i32) {
        self.broadcast_output_width = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_output_height = 12002;

    pub fn broadcast_output_height(&self) -> i32 {
        self.broadcast_output_height.unwrap_or(0)
    }

    pub fn clear_broadcast_output_height(&mut self) {
        self.broadcast_output_height = ::std::option::Option::None;
    }

    pub fn has_broadcast_output_height(&self) -> bool {
        self.broadcast_output_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_output_height(&mut self, v: i32) {
        self.broadcast_output_height = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_bitrate = 12003;

    pub fn broadcast_bitrate(&self) -> i32 {
        self.broadcast_bitrate.unwrap_or(0)
    }

    pub fn clear_broadcast_bitrate(&mut self) {
        self.broadcast_bitrate = ::std::option::Option::None;
    }

    pub fn has_broadcast_bitrate(&self) -> bool {
        self.broadcast_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_bitrate(&mut self, v: i32) {
        self.broadcast_bitrate = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastEncoderSetting broadcast_encoding_option = 12004;

    pub fn broadcast_encoding_option(&self) -> super::enums::EBroadcastEncoderSetting {
        match self.broadcast_encoding_option {
            Some(e) => e.enum_value_or(super::enums::EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality),
            None => super::enums::EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality,
        }
    }

    pub fn clear_broadcast_encoding_option(&mut self) {
        self.broadcast_encoding_option = ::std::option::Option::None;
    }

    pub fn has_broadcast_encoding_option(&self) -> bool {
        self.broadcast_encoding_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_encoding_option(&mut self, v: super::enums::EBroadcastEncoderSetting) {
        self.broadcast_encoding_option = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool broadcast_record_all_video = 12005;

    pub fn broadcast_record_all_video(&self) -> bool {
        self.broadcast_record_all_video.unwrap_or(false)
    }

    pub fn clear_broadcast_record_all_video(&mut self) {
        self.broadcast_record_all_video = ::std::option::Option::None;
    }

    pub fn has_broadcast_record_all_video(&self) -> bool {
        self.broadcast_record_all_video.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_record_all_video(&mut self, v: bool) {
        self.broadcast_record_all_video = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_record_all_audio = 12006;

    pub fn broadcast_record_all_audio(&self) -> bool {
        self.broadcast_record_all_audio.unwrap_or(false)
    }

    pub fn clear_broadcast_record_all_audio(&mut self) {
        self.broadcast_record_all_audio = ::std::option::Option::None;
    }

    pub fn has_broadcast_record_all_audio(&self) -> bool {
        self.broadcast_record_all_audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_record_all_audio(&mut self, v: bool) {
        self.broadcast_record_all_audio = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_record_microphone = 12007;

    pub fn broadcast_record_microphone(&self) -> bool {
        self.broadcast_record_microphone.unwrap_or(false)
    }

    pub fn clear_broadcast_record_microphone(&mut self) {
        self.broadcast_record_microphone = ::std::option::Option::None;
    }

    pub fn has_broadcast_record_microphone(&self) -> bool {
        self.broadcast_record_microphone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_record_microphone(&mut self, v: bool) {
        self.broadcast_record_microphone = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_show_upload_stats = 12008;

    pub fn broadcast_show_upload_stats(&self) -> bool {
        self.broadcast_show_upload_stats.unwrap_or(false)
    }

    pub fn clear_broadcast_show_upload_stats(&mut self) {
        self.broadcast_show_upload_stats = ::std::option::Option::None;
    }

    pub fn has_broadcast_show_upload_stats(&self) -> bool {
        self.broadcast_show_upload_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_show_upload_stats(&mut self, v: bool) {
        self.broadcast_show_upload_stats = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_show_live_reminder = 12009;

    pub fn broadcast_show_live_reminder(&self) -> bool {
        self.broadcast_show_live_reminder.unwrap_or(false)
    }

    pub fn clear_broadcast_show_live_reminder(&mut self) {
        self.broadcast_show_live_reminder = ::std::option::Option::None;
    }

    pub fn has_broadcast_show_live_reminder(&self) -> bool {
        self.broadcast_show_live_reminder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_show_live_reminder(&mut self, v: bool) {
        self.broadcast_show_live_reminder = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_chat_corner = 12010;

    pub fn broadcast_chat_corner(&self) -> i32 {
        self.broadcast_chat_corner.unwrap_or(0)
    }

    pub fn clear_broadcast_chat_corner(&mut self) {
        self.broadcast_chat_corner = ::std::option::Option::None;
    }

    pub fn has_broadcast_chat_corner(&self) -> bool {
        self.broadcast_chat_corner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_chat_corner(&mut self, v: i32) {
        self.broadcast_chat_corner = ::std::option::Option::Some(v);
    }

    // optional bool steam_input_configurator_error_msg_enable = 14001;

    pub fn steam_input_configurator_error_msg_enable(&self) -> bool {
        self.steam_input_configurator_error_msg_enable.unwrap_or(false)
    }

    pub fn clear_steam_input_configurator_error_msg_enable(&mut self) {
        self.steam_input_configurator_error_msg_enable = ::std::option::Option::None;
    }

    pub fn has_steam_input_configurator_error_msg_enable(&self) -> bool {
        self.steam_input_configurator_error_msg_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_input_configurator_error_msg_enable(&mut self, v: bool) {
        self.steam_input_configurator_error_msg_enable = ::std::option::Option::Some(v);
    }

    // optional bool controller_guide_button_focus_steam = 14002;

    pub fn controller_guide_button_focus_steam(&self) -> bool {
        self.controller_guide_button_focus_steam.unwrap_or(false)
    }

    pub fn clear_controller_guide_button_focus_steam(&mut self) {
        self.controller_guide_button_focus_steam = ::std::option::Option::None;
    }

    pub fn has_controller_guide_button_focus_steam(&self) -> bool {
        self.controller_guide_button_focus_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_guide_button_focus_steam(&mut self, v: bool) {
        self.controller_guide_button_focus_steam = ::std::option::Option::Some(v);
    }

    // optional int32 controller_ps_support = 14003;

    pub fn controller_ps_support(&self) -> i32 {
        self.controller_ps_support.unwrap_or(0)
    }

    pub fn clear_controller_ps_support(&mut self) {
        self.controller_ps_support = ::std::option::Option::None;
    }

    pub fn has_controller_ps_support(&self) -> bool {
        self.controller_ps_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_ps_support(&mut self, v: i32) {
        self.controller_ps_support = ::std::option::Option::Some(v);
    }

    // optional bool controller_xbox_support = 14004;

    pub fn controller_xbox_support(&self) -> bool {
        self.controller_xbox_support.unwrap_or(false)
    }

    pub fn clear_controller_xbox_support(&mut self) {
        self.controller_xbox_support = ::std::option::Option::None;
    }

    pub fn has_controller_xbox_support(&self) -> bool {
        self.controller_xbox_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_xbox_support(&mut self, v: bool) {
        self.controller_xbox_support = ::std::option::Option::Some(v);
    }

    // optional bool controller_xbox_driver = 14005;

    pub fn controller_xbox_driver(&self) -> bool {
        self.controller_xbox_driver.unwrap_or(false)
    }

    pub fn clear_controller_xbox_driver(&mut self) {
        self.controller_xbox_driver = ::std::option::Option::None;
    }

    pub fn has_controller_xbox_driver(&self) -> bool {
        self.controller_xbox_driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_xbox_driver(&mut self, v: bool) {
        self.controller_xbox_driver = ::std::option::Option::Some(v);
    }

    // optional bool controller_switch_support = 14006;

    pub fn controller_switch_support(&self) -> bool {
        self.controller_switch_support.unwrap_or(false)
    }

    pub fn clear_controller_switch_support(&mut self) {
        self.controller_switch_support = ::std::option::Option::None;
    }

    pub fn has_controller_switch_support(&self) -> bool {
        self.controller_switch_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_switch_support(&mut self, v: bool) {
        self.controller_switch_support = ::std::option::Option::Some(v);
    }

    // optional bool controller_generic_support = 14007;

    pub fn controller_generic_support(&self) -> bool {
        self.controller_generic_support.unwrap_or(false)
    }

    pub fn clear_controller_generic_support(&mut self) {
        self.controller_generic_support = ::std::option::Option::None;
    }

    pub fn has_controller_generic_support(&self) -> bool {
        self.controller_generic_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_generic_support(&mut self, v: bool) {
        self.controller_generic_support = ::std::option::Option::Some(v);
    }

    // optional int32 controller_power_off_timeout = 14008;

    pub fn controller_power_off_timeout(&self) -> i32 {
        self.controller_power_off_timeout.unwrap_or(0)
    }

    pub fn clear_controller_power_off_timeout(&mut self) {
        self.controller_power_off_timeout = ::std::option::Option::None;
    }

    pub fn has_controller_power_off_timeout(&self) -> bool {
        self.controller_power_off_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_power_off_timeout(&mut self, v: i32) {
        self.controller_power_off_timeout = ::std::option::Option::Some(v);
    }

    // optional bool turn_off_controller_on_exit = 14009;

    pub fn turn_off_controller_on_exit(&self) -> bool {
        self.turn_off_controller_on_exit.unwrap_or(false)
    }

    pub fn clear_turn_off_controller_on_exit(&mut self) {
        self.turn_off_controller_on_exit = ::std::option::Option::None;
    }

    pub fn has_turn_off_controller_on_exit(&self) -> bool {
        self.turn_off_controller_on_exit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_off_controller_on_exit(&mut self, v: bool) {
        self.turn_off_controller_on_exit = ::std::option::Option::Some(v);
    }

    // optional bool controller_combine_nintendo_joycons = 14010;

    pub fn controller_combine_nintendo_joycons(&self) -> bool {
        self.controller_combine_nintendo_joycons.unwrap_or(false)
    }

    pub fn clear_controller_combine_nintendo_joycons(&mut self) {
        self.controller_combine_nintendo_joycons = ::std::option::Option::None;
    }

    pub fn has_controller_combine_nintendo_joycons(&self) -> bool {
        self.controller_combine_nintendo_joycons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_combine_nintendo_joycons(&mut self, v: bool) {
        self.controller_combine_nintendo_joycons = ::std::option::Option::Some(v);
    }

    // optional uint64 startup_movie_id = 16000;

    pub fn startup_movie_id(&self) -> u64 {
        self.startup_movie_id.unwrap_or(0)
    }

    pub fn clear_startup_movie_id(&mut self) {
        self.startup_movie_id = ::std::option::Option::None;
    }

    pub fn has_startup_movie_id(&self) -> bool {
        self.startup_movie_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_id(&mut self, v: u64) {
        self.startup_movie_id = ::std::option::Option::Some(v);
    }

    // optional string startup_movie_local_path = 16001;

    pub fn startup_movie_local_path(&self) -> &str {
        match self.startup_movie_local_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_startup_movie_local_path(&mut self) {
        self.startup_movie_local_path = ::std::option::Option::None;
    }

    pub fn has_startup_movie_local_path(&self) -> bool {
        self.startup_movie_local_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_local_path(&mut self, v: ::std::string::String) {
        self.startup_movie_local_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startup_movie_local_path(&mut self) -> &mut ::std::string::String {
        if self.startup_movie_local_path.is_none() {
            self.startup_movie_local_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.startup_movie_local_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_startup_movie_local_path(&mut self) -> ::std::string::String {
        self.startup_movie_local_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool startup_movie_shuffle = 16002;

    pub fn startup_movie_shuffle(&self) -> bool {
        self.startup_movie_shuffle.unwrap_or(false)
    }

    pub fn clear_startup_movie_shuffle(&mut self) {
        self.startup_movie_shuffle = ::std::option::Option::None;
    }

    pub fn has_startup_movie_shuffle(&self) -> bool {
        self.startup_movie_shuffle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_shuffle(&mut self, v: bool) {
        self.startup_movie_shuffle = ::std::option::Option::Some(v);
    }

    // optional bool startup_movie_used_for_resume = 16003;

    pub fn startup_movie_used_for_resume(&self) -> bool {
        self.startup_movie_used_for_resume.unwrap_or(false)
    }

    pub fn clear_startup_movie_used_for_resume(&mut self) {
        self.startup_movie_used_for_resume = ::std::option::Option::None;
    }

    pub fn has_startup_movie_used_for_resume(&self) -> bool {
        self.startup_movie_used_for_resume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_used_for_resume(&mut self, v: bool) {
        self.startup_movie_used_for_resume = ::std::option::Option::Some(v);
    }

    // optional bool game_notes_enable_spellcheck = 17001;

    pub fn game_notes_enable_spellcheck(&self) -> bool {
        self.game_notes_enable_spellcheck.unwrap_or(false)
    }

    pub fn clear_game_notes_enable_spellcheck(&mut self) {
        self.game_notes_enable_spellcheck = ::std::option::Option::None;
    }

    pub fn has_game_notes_enable_spellcheck(&self) -> bool {
        self.game_notes_enable_spellcheck.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_notes_enable_spellcheck(&mut self, v: bool) {
        self.game_notes_enable_spellcheck = ::std::option::Option::Some(v);
    }

    // optional int32 screenshot_items_per_row = 18000;

    pub fn screenshot_items_per_row(&self) -> i32 {
        self.screenshot_items_per_row.unwrap_or(0)
    }

    pub fn clear_screenshot_items_per_row(&mut self) {
        self.screenshot_items_per_row = ::std::option::Option::None;
    }

    pub fn has_screenshot_items_per_row(&self) -> bool {
        self.screenshot_items_per_row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot_items_per_row(&mut self, v: i32) {
        self.screenshot_items_per_row = ::std::option::Option::Some(v);
    }

    // optional bool g_background_enabled = 18200;

    pub fn g_background_enabled(&self) -> bool {
        self.g_background_enabled.unwrap_or(false)
    }

    pub fn clear_g_background_enabled(&mut self) {
        self.g_background_enabled = ::std::option::Option::None;
    }

    pub fn has_g_background_enabled(&self) -> bool {
        self.g_background_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_enabled(&mut self, v: bool) {
        self.g_background_enabled = ::std::option::Option::Some(v);
    }

    // optional string g_background_path = 18201;

    pub fn g_background_path(&self) -> &str {
        match self.g_background_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_g_background_path(&mut self) {
        self.g_background_path = ::std::option::Option::None;
    }

    pub fn has_g_background_path(&self) -> bool {
        self.g_background_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_path(&mut self, v: ::std::string::String) {
        self.g_background_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g_background_path(&mut self) -> &mut ::std::string::String {
        if self.g_background_path.is_none() {
            self.g_background_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.g_background_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_g_background_path(&mut self) -> ::std::string::String {
        self.g_background_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string g_background_max_keep = 18202;

    pub fn g_background_max_keep(&self) -> &str {
        match self.g_background_max_keep.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_g_background_max_keep(&mut self) {
        self.g_background_max_keep = ::std::option::Option::None;
    }

    pub fn has_g_background_max_keep(&self) -> bool {
        self.g_background_max_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_max_keep(&mut self, v: ::std::string::String) {
        self.g_background_max_keep = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g_background_max_keep(&mut self) -> &mut ::std::string::String {
        if self.g_background_max_keep.is_none() {
            self.g_background_max_keep = ::std::option::Option::Some(::std::string::String::new());
        }
        self.g_background_max_keep.as_mut().unwrap()
    }

    // Take field
    pub fn take_g_background_max_keep(&mut self) -> ::std::string::String {
        self.g_background_max_keep.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 g_background_time_resolution = 18203;

    pub fn g_background_time_resolution(&self) -> i32 {
        self.g_background_time_resolution.unwrap_or(0)
    }

    pub fn clear_g_background_time_resolution(&mut self) {
        self.g_background_time_resolution = ::std::option::Option::None;
    }

    pub fn has_g_background_time_resolution(&self) -> bool {
        self.g_background_time_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_time_resolution(&mut self, v: i32) {
        self.g_background_time_resolution = ::std::option::Option::Some(v);
    }

    // optional bool g_background_devmode = 18206;

    pub fn g_background_devmode(&self) -> bool {
        self.g_background_devmode.unwrap_or(false)
    }

    pub fn clear_g_background_devmode(&mut self) {
        self.g_background_devmode = ::std::option::Option::None;
    }

    pub fn has_g_background_devmode(&self) -> bool {
        self.g_background_devmode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_devmode(&mut self, v: bool) {
        self.g_background_devmode = ::std::option::Option::Some(v);
    }

    // optional .CMsgHotkey g_background_mk = 18207;

    pub fn g_background_mk(&self) -> &CMsgHotkey {
        self.g_background_mk.as_ref().unwrap_or_else(|| <CMsgHotkey as crate::Message>::default_instance())
    }

    pub fn clear_g_background_mk(&mut self) {
        self.g_background_mk.clear();
    }

    pub fn has_g_background_mk(&self) -> bool {
        self.g_background_mk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_mk(&mut self, v: CMsgHotkey) {
        self.g_background_mk = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g_background_mk(&mut self) -> &mut CMsgHotkey {
        self.g_background_mk.mut_or_insert_default()
    }

    // Take field
    pub fn take_g_background_mk(&mut self) -> CMsgHotkey {
        self.g_background_mk.take().unwrap_or_else(|| CMsgHotkey::new())
    }

    // optional .CMsgHotkey g_background_tg = 18208;

    pub fn g_background_tg(&self) -> &CMsgHotkey {
        self.g_background_tg.as_ref().unwrap_or_else(|| <CMsgHotkey as crate::Message>::default_instance())
    }

    pub fn clear_g_background_tg(&mut self) {
        self.g_background_tg.clear();
    }

    pub fn has_g_background_tg(&self) -> bool {
        self.g_background_tg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_tg(&mut self, v: CMsgHotkey) {
        self.g_background_tg = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g_background_tg(&mut self) -> &mut CMsgHotkey {
        self.g_background_tg.mut_or_insert_default()
    }

    // Take field
    pub fn take_g_background_tg(&mut self) -> CMsgHotkey {
        self.g_background_tg.take().unwrap_or_else(|| CMsgHotkey::new())
    }

    // optional bool show_timestamps_in_console = 20000;

    pub fn show_timestamps_in_console(&self) -> bool {
        self.show_timestamps_in_console.unwrap_or(false)
    }

    pub fn clear_show_timestamps_in_console(&mut self) {
        self.show_timestamps_in_console = ::std::option::Option::None;
    }

    pub fn has_show_timestamps_in_console(&self) -> bool {
        self.show_timestamps_in_console.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_timestamps_in_console(&mut self, v: bool) {
        self.show_timestamps_in_console = ::std::option::Option::Some(v);
    }

    // optional bool force_oobe = 20001;

    pub fn force_oobe(&self) -> bool {
        self.force_oobe.unwrap_or(false)
    }

    pub fn clear_force_oobe(&mut self) {
        self.force_oobe = ::std::option::Option::None;
    }

    pub fn has_force_oobe(&self) -> bool {
        self.force_oobe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_oobe(&mut self, v: bool) {
        self.force_oobe = ::std::option::Option::Some(v);
    }

    // optional int32 override_browser_composer_mode = 20002;

    pub fn override_browser_composer_mode(&self) -> i32 {
        self.override_browser_composer_mode.unwrap_or(0)
    }

    pub fn clear_override_browser_composer_mode(&mut self) {
        self.override_browser_composer_mode = ::std::option::Option::None;
    }

    pub fn has_override_browser_composer_mode(&self) -> bool {
        self.override_browser_composer_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_browser_composer_mode(&mut self, v: i32) {
        self.override_browser_composer_mode = ::std::option::Option::Some(v);
    }

    // optional bool cef_remote_debugging_enabled = 20003;

    pub fn cef_remote_debugging_enabled(&self) -> bool {
        self.cef_remote_debugging_enabled.unwrap_or(false)
    }

    pub fn clear_cef_remote_debugging_enabled(&mut self) {
        self.cef_remote_debugging_enabled = ::std::option::Option::None;
    }

    pub fn has_cef_remote_debugging_enabled(&self) -> bool {
        self.cef_remote_debugging_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cef_remote_debugging_enabled(&mut self, v: bool) {
        self.cef_remote_debugging_enabled = ::std::option::Option::Some(v);
    }

    // optional bool force_deck_perf_tab = 20004;

    pub fn force_deck_perf_tab(&self) -> bool {
        self.force_deck_perf_tab.unwrap_or(false)
    }

    pub fn clear_force_deck_perf_tab(&mut self) {
        self.force_deck_perf_tab = ::std::option::Option::None;
    }

    pub fn has_force_deck_perf_tab(&self) -> bool {
        self.force_deck_perf_tab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_deck_perf_tab(&mut self, v: bool) {
        self.force_deck_perf_tab = ::std::option::Option::Some(v);
    }

    // optional bool force_fake_mandatory_update = 20005;

    pub fn force_fake_mandatory_update(&self) -> bool {
        self.force_fake_mandatory_update.unwrap_or(false)
    }

    pub fn clear_force_fake_mandatory_update(&mut self) {
        self.force_fake_mandatory_update = ::std::option::Option::None;
    }

    pub fn has_force_fake_mandatory_update(&self) -> bool {
        self.force_fake_mandatory_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_fake_mandatory_update(&mut self, v: bool) {
        self.force_fake_mandatory_update = ::std::option::Option::Some(v);
    }

    // optional .EHDRVisualization gamescope_hdr_visualization = 21001;

    pub fn gamescope_hdr_visualization(&self) -> super::enums::EHDRVisualization {
        match self.gamescope_hdr_visualization {
            Some(e) => e.enum_value_or(super::enums::EHDRVisualization::k_EHDRVisualization_None),
            None => super::enums::EHDRVisualization::k_EHDRVisualization_None,
        }
    }

    pub fn clear_gamescope_hdr_visualization(&mut self) {
        self.gamescope_hdr_visualization = ::std::option::Option::None;
    }

    pub fn has_gamescope_hdr_visualization(&self) -> bool {
        self.gamescope_hdr_visualization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamescope_hdr_visualization(&mut self, v: super::enums::EHDRVisualization) {
        self.gamescope_hdr_visualization = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 gamescope_app_target_framerate = 21002;

    pub fn gamescope_app_target_framerate(&self) -> i32 {
        self.gamescope_app_target_framerate.unwrap_or(0)
    }

    pub fn clear_gamescope_app_target_framerate(&mut self) {
        self.gamescope_app_target_framerate = ::std::option::Option::None;
    }

    pub fn has_gamescope_app_target_framerate(&self) -> bool {
        self.gamescope_app_target_framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamescope_app_target_framerate(&mut self, v: i32) {
        self.gamescope_app_target_framerate = ::std::option::Option::Some(v);
    }

    // optional bool gamescope_enable_app_target_framerate = 21003;

    pub fn gamescope_enable_app_target_framerate(&self) -> bool {
        self.gamescope_enable_app_target_framerate.unwrap_or(false)
    }

    pub fn clear_gamescope_enable_app_target_framerate(&mut self) {
        self.gamescope_enable_app_target_framerate = ::std::option::Option::None;
    }

    pub fn has_gamescope_enable_app_target_framerate(&self) -> bool {
        self.gamescope_enable_app_target_framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamescope_enable_app_target_framerate(&mut self, v: bool) {
        self.gamescope_enable_app_target_framerate = ::std::option::Option::Some(v);
    }

    // optional bool gamescope_disable_framelimit = 21004;

    pub fn gamescope_disable_framelimit(&self) -> bool {
        self.gamescope_disable_framelimit.unwrap_or(false)
    }

    pub fn clear_gamescope_disable_framelimit(&mut self) {
        self.gamescope_disable_framelimit = ::std::option::Option::None;
    }

    pub fn has_gamescope_disable_framelimit(&self) -> bool {
        self.gamescope_disable_framelimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamescope_disable_framelimit(&mut self, v: bool) {
        self.gamescope_disable_framelimit = ::std::option::Option::Some(v);
    }

    // optional int32 gamescope_display_refresh_rate = 21005;

    pub fn gamescope_display_refresh_rate(&self) -> i32 {
        self.gamescope_display_refresh_rate.unwrap_or(0)
    }

    pub fn clear_gamescope_display_refresh_rate(&mut self) {
        self.gamescope_display_refresh_rate = ::std::option::Option::None;
    }

    pub fn has_gamescope_display_refresh_rate(&self) -> bool {
        self.gamescope_display_refresh_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamescope_display_refresh_rate(&mut self, v: i32) {
        self.gamescope_display_refresh_rate = ::std::option::Option::Some(v);
    }

    // optional bool gamescope_use_game_refresh_rate_in_steam = 21006;

    pub fn gamescope_use_game_refresh_rate_in_steam(&self) -> bool {
        self.gamescope_use_game_refresh_rate_in_steam.unwrap_or(false)
    }

    pub fn clear_gamescope_use_game_refresh_rate_in_steam(&mut self) {
        self.gamescope_use_game_refresh_rate_in_steam = ::std::option::Option::None;
    }

    pub fn has_gamescope_use_game_refresh_rate_in_steam(&self) -> bool {
        self.gamescope_use_game_refresh_rate_in_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamescope_use_game_refresh_rate_in_steam(&mut self, v: bool) {
        self.gamescope_use_game_refresh_rate_in_steam = ::std::option::Option::Some(v);
    }

    // optional int32 steamos_status_led_brightness = 22000;

    pub fn steamos_status_led_brightness(&self) -> i32 {
        self.steamos_status_led_brightness.unwrap_or(0)
    }

    pub fn clear_steamos_status_led_brightness(&mut self) {
        self.steamos_status_led_brightness = ::std::option::Option::None;
    }

    pub fn has_steamos_status_led_brightness(&self) -> bool {
        self.steamos_status_led_brightness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamos_status_led_brightness(&mut self, v: i32) {
        self.steamos_status_led_brightness = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(130);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_save_personal_info",
            |m: &CMsgClientSettings| { &m.no_save_personal_info },
            |m: &mut CMsgClientSettings| { &mut m.no_save_personal_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "oobe_test_mode_enabled",
            |m: &CMsgClientSettings| { &m.oobe_test_mode_enabled },
            |m: &mut CMsgClientSettings| { &mut m.oobe_test_mode_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_client_beta",
            |m: &CMsgClientSettings| { &m.in_client_beta },
            |m: &mut CMsgClientSettings| { &mut m.in_client_beta },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_steam_sideloaded",
            |m: &CMsgClientSettings| { &m.is_steam_sideloaded },
            |m: &mut CMsgClientSettings| { &mut m.is_steam_sideloaded },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "preferred_monitor",
            |m: &CMsgClientSettings| { &m.preferred_monitor },
            |m: &mut CMsgClientSettings| { &mut m.preferred_monitor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_cef_gpu_blocklist_disabled",
            |m: &CMsgClientSettings| { &m.steam_cef_gpu_blocklist_disabled },
            |m: &mut CMsgClientSettings| { &mut m.steam_cef_gpu_blocklist_disabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bigpicture_windowed",
            |m: &CMsgClientSettings| { &m.bigpicture_windowed },
            |m: &mut CMsgClientSettings| { &mut m.bigpicture_windowed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &CMsgClientSettings| { &m.display_name },
            |m: &mut CMsgClientSettings| { &mut m.display_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_external_display",
            |m: &CMsgClientSettings| { &m.is_external_display },
            |m: &mut CMsgClientSettings| { &mut m.is_external_display },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_os_underscan_level",
            |m: &CMsgClientSettings| { &m.steam_os_underscan_level },
            |m: &mut CMsgClientSettings| { &mut m.steam_os_underscan_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_os_underscan_enabled",
            |m: &CMsgClientSettings| { &m.steam_os_underscan_enabled },
            |m: &mut CMsgClientSettings| { &mut m.steam_os_underscan_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_scale_factor",
            |m: &CMsgClientSettings| { &m.min_scale_factor },
            |m: &mut CMsgClientSettings| { &mut m.min_scale_factor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_scale_factor",
            |m: &CMsgClientSettings| { &m.max_scale_factor },
            |m: &mut CMsgClientSettings| { &mut m.max_scale_factor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "auto_scale_factor",
            |m: &CMsgClientSettings| { &m.auto_scale_factor },
            |m: &mut CMsgClientSettings| { &mut m.auto_scale_factor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "small_mode",
            |m: &CMsgClientSettings| { &m.small_mode },
            |m: &mut CMsgClientSettings| { &mut m.small_mode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_steamvr_install_dialog",
            |m: &CMsgClientSettings| { &m.skip_steamvr_install_dialog },
            |m: &mut CMsgClientSettings| { &mut m.skip_steamvr_install_dialog },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "always_show_user_chooser",
            |m: &CMsgClientSettings| { &m.always_show_user_chooser },
            |m: &mut CMsgClientSettings| { &mut m.always_show_user_chooser },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_family_sharing_notifications",
            |m: &CMsgClientSettings| { &m.show_family_sharing_notifications },
            |m: &mut CMsgClientSettings| { &mut m.show_family_sharing_notifications },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_fps_counter_corner",
            |m: &CMsgClientSettings| { &m.overlay_fps_counter_corner },
            |m: &mut CMsgClientSettings| { &mut m.overlay_fps_counter_corner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_fps_counter_high_contrast",
            |m: &CMsgClientSettings| { &m.overlay_fps_counter_high_contrast },
            |m: &mut CMsgClientSettings| { &mut m.overlay_fps_counter_high_contrast },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgHotkey>(
            "overlay_key",
            |m: &CMsgClientSettings| { &m.overlay_key },
            |m: &mut CMsgClientSettings| { &mut m.overlay_key },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgHotkey>(
            "screenshot_key",
            |m: &CMsgClientSettings| { &m.screenshot_key },
            |m: &mut CMsgClientSettings| { &mut m.screenshot_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_overlay",
            |m: &CMsgClientSettings| { &m.enable_overlay },
            |m: &mut CMsgClientSettings| { &mut m.enable_overlay },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_screenshot_notification",
            |m: &CMsgClientSettings| { &m.enable_screenshot_notification },
            |m: &mut CMsgClientSettings| { &mut m.enable_screenshot_notification },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_screenshot_sound",
            |m: &CMsgClientSettings| { &m.enable_screenshot_sound },
            |m: &mut CMsgClientSettings| { &mut m.enable_screenshot_sound },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_uncompressed_screenshots",
            |m: &CMsgClientSettings| { &m.save_uncompressed_screenshots },
            |m: &mut CMsgClientSettings| { &mut m.save_uncompressed_screenshots },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshots_path",
            |m: &CMsgClientSettings| { &m.screenshots_path },
            |m: &mut CMsgClientSettings| { &mut m.screenshots_path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_ping_rate",
            |m: &CMsgClientSettings| { &m.default_ping_rate },
            |m: &mut CMsgClientSettings| { &mut m.default_ping_rate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ping_rate",
            |m: &CMsgClientSettings| { &m.server_ping_rate },
            |m: &mut CMsgClientSettings| { &mut m.server_ping_rate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_networking_share_ip",
            |m: &CMsgClientSettings| { &m.steam_networking_share_ip },
            |m: &mut CMsgClientSettings| { &mut m.steam_networking_share_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "web_browser_home",
            |m: &CMsgClientSettings| { &m.web_browser_home },
            |m: &mut CMsgClientSettings| { &mut m.web_browser_home },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_mic_device_name",
            |m: &CMsgClientSettings| { &m.voice_mic_device_name },
            |m: &mut CMsgClientSettings| { &mut m.voice_mic_device_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_mic_input_gain",
            |m: &CMsgClientSettings| { &m.voice_mic_input_gain },
            |m: &mut CMsgClientSettings| { &mut m.voice_mic_input_gain },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_speaker_output_gain",
            |m: &CMsgClientSettings| { &m.voice_speaker_output_gain },
            |m: &mut CMsgClientSettings| { &mut m.voice_speaker_output_gain },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_push_to_talk_setting",
            |m: &CMsgClientSettings| { &m.voice_push_to_talk_setting },
            |m: &mut CMsgClientSettings| { &mut m.voice_push_to_talk_setting },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgHotkey>(
            "voice_push_to_talk_key",
            |m: &CMsgClientSettings| { &m.voice_push_to_talk_key },
            |m: &mut CMsgClientSettings| { &mut m.voice_push_to_talk_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_toolbar_list_view",
            |m: &CMsgClientSettings| { &m.overlay_toolbar_list_view },
            |m: &mut CMsgClientSettings| { &mut m.overlay_toolbar_list_view },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "always_use_gamepadui_overlay",
            |m: &CMsgClientSettings| { &m.always_use_gamepadui_overlay },
            |m: &mut CMsgClientSettings| { &mut m.always_use_gamepadui_overlay },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_tabs",
            |m: &CMsgClientSettings| { &m.overlay_tabs },
            |m: &mut CMsgClientSettings| { &mut m.overlay_tabs },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_scale_interface",
            |m: &CMsgClientSettings| { &m.overlay_scale_interface },
            |m: &mut CMsgClientSettings| { &mut m.overlay_scale_interface },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_restore_browser_tabs",
            |m: &CMsgClientSettings| { &m.overlay_restore_browser_tabs },
            |m: &mut CMsgClientSettings| { &mut m.overlay_restore_browser_tabs },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "smooth_scroll_webviews",
            |m: &CMsgClientSettings| { &m.smooth_scroll_webviews },
            |m: &mut CMsgClientSettings| { &mut m.smooth_scroll_webviews },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_gpu_accelerated_webviews",
            |m: &CMsgClientSettings| { &m.enable_gpu_accelerated_webviews },
            |m: &mut CMsgClientSettings| { &mut m.enable_gpu_accelerated_webviews },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_hardware_video_decoding",
            |m: &CMsgClientSettings| { &m.enable_hardware_video_decoding },
            |m: &mut CMsgClientSettings| { &mut m.enable_hardware_video_decoding },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "run_at_startup",
            |m: &CMsgClientSettings| { &m.run_at_startup },
            |m: &mut CMsgClientSettings| { &mut m.run_at_startup },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_dpi_scaling",
            |m: &CMsgClientSettings| { &m.enable_dpi_scaling },
            |m: &mut CMsgClientSettings| { &mut m.enable_dpi_scaling },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_marketing_messages",
            |m: &CMsgClientSettings| { &m.enable_marketing_messages },
            |m: &mut CMsgClientSettings| { &mut m.enable_marketing_messages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_in_big_picture_mode",
            |m: &CMsgClientSettings| { &m.start_in_big_picture_mode },
            |m: &mut CMsgClientSettings| { &mut m.start_in_big_picture_mode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "jumplist_flags",
            |m: &CMsgClientSettings| { &m.jumplist_flags },
            |m: &mut CMsgClientSettings| { &mut m.jumplist_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_ui_sounds",
            |m: &CMsgClientSettings| { &m.enable_ui_sounds },
            |m: &mut CMsgClientSettings| { &mut m.enable_ui_sounds },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_all_toasts",
            |m: &CMsgClientSettings| { &m.disable_all_toasts },
            |m: &mut CMsgClientSettings| { &mut m.disable_all_toasts },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_toasts_in_game",
            |m: &CMsgClientSettings| { &m.disable_toasts_in_game },
            |m: &mut CMsgClientSettings| { &mut m.disable_toasts_in_game },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "play_sound_on_toast",
            |m: &CMsgClientSettings| { &m.play_sound_on_toast },
            |m: &mut CMsgClientSettings| { &mut m.play_sound_on_toast },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_display_size",
            |m: &CMsgClientSettings| { &m.library_display_size },
            |m: &mut CMsgClientSettings| { &mut m.library_display_size },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_whats_new_show_only_product_updates",
            |m: &CMsgClientSettings| { &m.library_whats_new_show_only_product_updates },
            |m: &mut CMsgClientSettings| { &mut m.library_whats_new_show_only_product_updates },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_store_content_on_home",
            |m: &CMsgClientSettings| { &m.show_store_content_on_home },
            |m: &mut CMsgClientSettings| { &mut m.show_store_content_on_home },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_page",
            |m: &CMsgClientSettings| { &m.start_page },
            |m: &mut CMsgClientSettings| { &mut m.start_page },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_low_bandwidth_mode",
            |m: &CMsgClientSettings| { &m.library_low_bandwidth_mode },
            |m: &mut CMsgClientSettings| { &mut m.library_low_bandwidth_mode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_low_perf_mode",
            |m: &CMsgClientSettings| { &m.library_low_perf_mode },
            |m: &mut CMsgClientSettings| { &mut m.library_low_perf_mode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_disable_community_content",
            |m: &CMsgClientSettings| { &m.library_disable_community_content },
            |m: &mut CMsgClientSettings| { &mut m.library_disable_community_content },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_display_icon_in_game_list",
            |m: &CMsgClientSettings| { &m.library_display_icon_in_game_list },
            |m: &mut CMsgClientSettings| { &mut m.library_display_icon_in_game_list },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ready_to_play_includes_streaming",
            |m: &CMsgClientSettings| { &m.ready_to_play_includes_streaming },
            |m: &mut CMsgClientSettings| { &mut m.ready_to_play_includes_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_steam_deck_info",
            |m: &CMsgClientSettings| { &m.show_steam_deck_info },
            |m: &mut CMsgClientSettings| { &mut m.show_steam_deck_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_shader_precache",
            |m: &CMsgClientSettings| { &m.enable_shader_precache },
            |m: &mut CMsgClientSettings| { &mut m.enable_shader_precache },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_shader_background_processing",
            |m: &CMsgClientSettings| { &m.enable_shader_background_processing },
            |m: &mut CMsgClientSettings| { &mut m.enable_shader_background_processing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shader_precached_size",
            |m: &CMsgClientSettings| { &m.shader_precached_size },
            |m: &mut CMsgClientSettings| { &mut m.shader_precached_size },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_steam_service_repair",
            |m: &CMsgClientSettings| { &m.needs_steam_service_repair },
            |m: &mut CMsgClientSettings| { &mut m.needs_steam_service_repair },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_peer_content",
            |m: &CMsgClientSettings| { &m.download_peer_content },
            |m: &mut CMsgClientSettings| { &mut m.download_peer_content },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_rate_bits_per_s",
            |m: &CMsgClientSettings| { &m.download_rate_bits_per_s },
            |m: &mut CMsgClientSettings| { &mut m.download_rate_bits_per_s },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "restrict_auto_updates",
            |m: &CMsgClientSettings| { &m.restrict_auto_updates },
            |m: &mut CMsgClientSettings| { &mut m.restrict_auto_updates },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "restrict_auto_updates_start",
            |m: &CMsgClientSettings| { &m.restrict_auto_updates_start },
            |m: &mut CMsgClientSettings| { &mut m.restrict_auto_updates_start },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "restrict_auto_updates_end",
            |m: &CMsgClientSettings| { &m.restrict_auto_updates_end },
            |m: &mut CMsgClientSettings| { &mut m.restrict_auto_updates_end },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_region",
            |m: &CMsgClientSettings| { &m.download_region },
            |m: &mut CMsgClientSettings| { &mut m.download_region },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_while_app_running",
            |m: &CMsgClientSettings| { &m.download_while_app_running },
            |m: &mut CMsgClientSettings| { &mut m.download_while_app_running },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_throttle_while_streaming",
            |m: &CMsgClientSettings| { &m.download_throttle_while_streaming },
            |m: &mut CMsgClientSettings| { &mut m.download_throttle_while_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_throttle_rate",
            |m: &CMsgClientSettings| { &m.download_throttle_rate },
            |m: &mut CMsgClientSettings| { &mut m.download_throttle_rate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cloud_enabled",
            |m: &CMsgClientSettings| { &m.cloud_enabled },
            |m: &mut CMsgClientSettings| { &mut m.cloud_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_screenshot_manager",
            |m: &CMsgClientSettings| { &m.show_screenshot_manager },
            |m: &mut CMsgClientSettings| { &mut m.show_screenshot_manager },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_volume",
            |m: &CMsgClientSettings| { &m.music_volume },
            |m: &mut CMsgClientSettings| { &mut m.music_volume },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_pause_on_app_start",
            |m: &CMsgClientSettings| { &m.music_pause_on_app_start },
            |m: &mut CMsgClientSettings| { &mut m.music_pause_on_app_start },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_pause_on_voice_chat",
            |m: &CMsgClientSettings| { &m.music_pause_on_voice_chat },
            |m: &mut CMsgClientSettings| { &mut m.music_pause_on_voice_chat },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_download_high_quality",
            |m: &CMsgClientSettings| { &m.music_download_high_quality },
            |m: &mut CMsgClientSettings| { &mut m.music_download_high_quality },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_playlist_notification",
            |m: &CMsgClientSettings| { &m.music_playlist_notification },
            |m: &mut CMsgClientSettings| { &mut m.music_playlist_notification },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_permissions",
            |m: &CMsgClientSettings| { &m.broadcast_permissions },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_permissions },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_output_width",
            |m: &CMsgClientSettings| { &m.broadcast_output_width },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_output_width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_output_height",
            |m: &CMsgClientSettings| { &m.broadcast_output_height },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_output_height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_bitrate",
            |m: &CMsgClientSettings| { &m.broadcast_bitrate },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_bitrate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_encoding_option",
            |m: &CMsgClientSettings| { &m.broadcast_encoding_option },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_encoding_option },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_record_all_video",
            |m: &CMsgClientSettings| { &m.broadcast_record_all_video },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_record_all_video },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_record_all_audio",
            |m: &CMsgClientSettings| { &m.broadcast_record_all_audio },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_record_all_audio },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_record_microphone",
            |m: &CMsgClientSettings| { &m.broadcast_record_microphone },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_record_microphone },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_show_upload_stats",
            |m: &CMsgClientSettings| { &m.broadcast_show_upload_stats },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_show_upload_stats },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_show_live_reminder",
            |m: &CMsgClientSettings| { &m.broadcast_show_live_reminder },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_show_live_reminder },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_chat_corner",
            |m: &CMsgClientSettings| { &m.broadcast_chat_corner },
            |m: &mut CMsgClientSettings| { &mut m.broadcast_chat_corner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_input_configurator_error_msg_enable",
            |m: &CMsgClientSettings| { &m.steam_input_configurator_error_msg_enable },
            |m: &mut CMsgClientSettings| { &mut m.steam_input_configurator_error_msg_enable },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_guide_button_focus_steam",
            |m: &CMsgClientSettings| { &m.controller_guide_button_focus_steam },
            |m: &mut CMsgClientSettings| { &mut m.controller_guide_button_focus_steam },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_ps_support",
            |m: &CMsgClientSettings| { &m.controller_ps_support },
            |m: &mut CMsgClientSettings| { &mut m.controller_ps_support },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_xbox_support",
            |m: &CMsgClientSettings| { &m.controller_xbox_support },
            |m: &mut CMsgClientSettings| { &mut m.controller_xbox_support },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_xbox_driver",
            |m: &CMsgClientSettings| { &m.controller_xbox_driver },
            |m: &mut CMsgClientSettings| { &mut m.controller_xbox_driver },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_switch_support",
            |m: &CMsgClientSettings| { &m.controller_switch_support },
            |m: &mut CMsgClientSettings| { &mut m.controller_switch_support },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_generic_support",
            |m: &CMsgClientSettings| { &m.controller_generic_support },
            |m: &mut CMsgClientSettings| { &mut m.controller_generic_support },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_power_off_timeout",
            |m: &CMsgClientSettings| { &m.controller_power_off_timeout },
            |m: &mut CMsgClientSettings| { &mut m.controller_power_off_timeout },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "turn_off_controller_on_exit",
            |m: &CMsgClientSettings| { &m.turn_off_controller_on_exit },
            |m: &mut CMsgClientSettings| { &mut m.turn_off_controller_on_exit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_combine_nintendo_joycons",
            |m: &CMsgClientSettings| { &m.controller_combine_nintendo_joycons },
            |m: &mut CMsgClientSettings| { &mut m.controller_combine_nintendo_joycons },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "startup_movie_id",
            |m: &CMsgClientSettings| { &m.startup_movie_id },
            |m: &mut CMsgClientSettings| { &mut m.startup_movie_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "startup_movie_local_path",
            |m: &CMsgClientSettings| { &m.startup_movie_local_path },
            |m: &mut CMsgClientSettings| { &mut m.startup_movie_local_path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "startup_movie_shuffle",
            |m: &CMsgClientSettings| { &m.startup_movie_shuffle },
            |m: &mut CMsgClientSettings| { &mut m.startup_movie_shuffle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "startup_movie_used_for_resume",
            |m: &CMsgClientSettings| { &m.startup_movie_used_for_resume },
            |m: &mut CMsgClientSettings| { &mut m.startup_movie_used_for_resume },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_notes_enable_spellcheck",
            |m: &CMsgClientSettings| { &m.game_notes_enable_spellcheck },
            |m: &mut CMsgClientSettings| { &mut m.game_notes_enable_spellcheck },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshot_items_per_row",
            |m: &CMsgClientSettings| { &m.screenshot_items_per_row },
            |m: &mut CMsgClientSettings| { &mut m.screenshot_items_per_row },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "g_background_enabled",
            |m: &CMsgClientSettings| { &m.g_background_enabled },
            |m: &mut CMsgClientSettings| { &mut m.g_background_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "g_background_path",
            |m: &CMsgClientSettings| { &m.g_background_path },
            |m: &mut CMsgClientSettings| { &mut m.g_background_path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "g_background_max_keep",
            |m: &CMsgClientSettings| { &m.g_background_max_keep },
            |m: &mut CMsgClientSettings| { &mut m.g_background_max_keep },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "g_background_time_resolution",
            |m: &CMsgClientSettings| { &m.g_background_time_resolution },
            |m: &mut CMsgClientSettings| { &mut m.g_background_time_resolution },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "g_background_devmode",
            |m: &CMsgClientSettings| { &m.g_background_devmode },
            |m: &mut CMsgClientSettings| { &mut m.g_background_devmode },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgHotkey>(
            "g_background_mk",
            |m: &CMsgClientSettings| { &m.g_background_mk },
            |m: &mut CMsgClientSettings| { &mut m.g_background_mk },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgHotkey>(
            "g_background_tg",
            |m: &CMsgClientSettings| { &m.g_background_tg },
            |m: &mut CMsgClientSettings| { &mut m.g_background_tg },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_timestamps_in_console",
            |m: &CMsgClientSettings| { &m.show_timestamps_in_console },
            |m: &mut CMsgClientSettings| { &mut m.show_timestamps_in_console },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_oobe",
            |m: &CMsgClientSettings| { &m.force_oobe },
            |m: &mut CMsgClientSettings| { &mut m.force_oobe },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_browser_composer_mode",
            |m: &CMsgClientSettings| { &m.override_browser_composer_mode },
            |m: &mut CMsgClientSettings| { &mut m.override_browser_composer_mode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cef_remote_debugging_enabled",
            |m: &CMsgClientSettings| { &m.cef_remote_debugging_enabled },
            |m: &mut CMsgClientSettings| { &mut m.cef_remote_debugging_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_deck_perf_tab",
            |m: &CMsgClientSettings| { &m.force_deck_perf_tab },
            |m: &mut CMsgClientSettings| { &mut m.force_deck_perf_tab },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_fake_mandatory_update",
            |m: &CMsgClientSettings| { &m.force_fake_mandatory_update },
            |m: &mut CMsgClientSettings| { &mut m.force_fake_mandatory_update },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamescope_hdr_visualization",
            |m: &CMsgClientSettings| { &m.gamescope_hdr_visualization },
            |m: &mut CMsgClientSettings| { &mut m.gamescope_hdr_visualization },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamescope_app_target_framerate",
            |m: &CMsgClientSettings| { &m.gamescope_app_target_framerate },
            |m: &mut CMsgClientSettings| { &mut m.gamescope_app_target_framerate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamescope_enable_app_target_framerate",
            |m: &CMsgClientSettings| { &m.gamescope_enable_app_target_framerate },
            |m: &mut CMsgClientSettings| { &mut m.gamescope_enable_app_target_framerate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamescope_disable_framelimit",
            |m: &CMsgClientSettings| { &m.gamescope_disable_framelimit },
            |m: &mut CMsgClientSettings| { &mut m.gamescope_disable_framelimit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamescope_display_refresh_rate",
            |m: &CMsgClientSettings| { &m.gamescope_display_refresh_rate },
            |m: &mut CMsgClientSettings| { &mut m.gamescope_display_refresh_rate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamescope_use_game_refresh_rate_in_steam",
            |m: &CMsgClientSettings| { &m.gamescope_use_game_refresh_rate_in_steam },
            |m: &mut CMsgClientSettings| { &mut m.gamescope_use_game_refresh_rate_in_steam },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamos_status_led_brightness",
            |m: &CMsgClientSettings| { &m.steamos_status_led_brightness },
            |m: &mut CMsgClientSettings| { &mut m.steamos_status_led_brightness },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSettings>(
            "CMsgClientSettings",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSettings {
    const NAME: &'static str = "CMsgClientSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.no_save_personal_info = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.oobe_test_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.in_client_beta = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_steam_sideloaded = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.preferred_monitor = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.bigpicture_windowed = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.is_external_display = ::std::option::Option::Some(is.read_bool()?);
                },
                85 => {
                    self.steam_os_underscan_level = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.steam_os_underscan_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                101 => {
                    self.min_scale_factor = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.max_scale_factor = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.auto_scale_factor = ::std::option::Option::Some(is.read_float()?);
                },
                128 => {
                    self.small_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.skip_steamvr_install_dialog = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.always_show_user_chooser = ::std::option::Option::Some(is.read_bool()?);
                },
                24000 => {
                    self.show_family_sharing_notifications = ::std::option::Option::Some(is.read_bool()?);
                },
                32000 => {
                    self.overlay_fps_counter_corner = ::std::option::Option::Some(is.read_int32()?);
                },
                32008 => {
                    self.overlay_fps_counter_high_contrast = ::std::option::Option::Some(is.read_bool()?);
                },
                32018 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.overlay_key)?;
                },
                32026 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.screenshot_key)?;
                },
                32032 => {
                    self.enable_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                32048 => {
                    self.enable_screenshot_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                32056 => {
                    self.enable_screenshot_sound = ::std::option::Option::Some(is.read_bool()?);
                },
                32064 => {
                    self.save_uncompressed_screenshots = ::std::option::Option::Some(is.read_bool()?);
                },
                32074 => {
                    self.screenshots_path = ::std::option::Option::Some(is.read_string()?);
                },
                32080 => {
                    self.default_ping_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                32088 => {
                    self.server_ping_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                32096 => {
                    self.steam_networking_share_ip = ::std::option::Option::Some(is.read_int32()?);
                },
                32106 => {
                    self.web_browser_home = ::std::option::Option::Some(is.read_string()?);
                },
                32114 => {
                    self.voice_mic_device_name = ::std::option::Option::Some(is.read_string()?);
                },
                32125 => {
                    self.voice_mic_input_gain = ::std::option::Option::Some(is.read_float()?);
                },
                32133 => {
                    self.voice_speaker_output_gain = ::std::option::Option::Some(is.read_float()?);
                },
                32136 => {
                    self.voice_push_to_talk_setting = ::std::option::Option::Some(is.read_int32()?);
                },
                32146 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.voice_push_to_talk_key)?;
                },
                32152 => {
                    self.overlay_toolbar_list_view = ::std::option::Option::Some(is.read_bool()?);
                },
                32160 => {
                    self.always_use_gamepadui_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                32170 => {
                    self.overlay_tabs = ::std::option::Option::Some(is.read_string()?);
                },
                32176 => {
                    self.overlay_scale_interface = ::std::option::Option::Some(is.read_bool()?);
                },
                32184 => {
                    self.overlay_restore_browser_tabs = ::std::option::Option::Some(is.read_bool()?);
                },
                40000 => {
                    self.smooth_scroll_webviews = ::std::option::Option::Some(is.read_bool()?);
                },
                40008 => {
                    self.enable_gpu_accelerated_webviews = ::std::option::Option::Some(is.read_bool()?);
                },
                40024 => {
                    self.enable_hardware_video_decoding = ::std::option::Option::Some(is.read_bool()?);
                },
                40032 => {
                    self.run_at_startup = ::std::option::Option::Some(is.read_bool()?);
                },
                40040 => {
                    self.enable_dpi_scaling = ::std::option::Option::Some(is.read_bool()?);
                },
                40048 => {
                    self.enable_marketing_messages = ::std::option::Option::Some(is.read_bool()?);
                },
                40056 => {
                    self.start_in_big_picture_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                40064 => {
                    self.jumplist_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                40072 => {
                    self.enable_ui_sounds = ::std::option::Option::Some(is.read_bool()?);
                },
                48000 => {
                    self.disable_all_toasts = ::std::option::Option::Some(is.read_bool()?);
                },
                48008 => {
                    self.disable_toasts_in_game = ::std::option::Option::Some(is.read_bool()?);
                },
                48016 => {
                    self.play_sound_on_toast = ::std::option::Option::Some(is.read_bool()?);
                },
                56000 => {
                    self.library_display_size = ::std::option::Option::Some(is.read_int32()?);
                },
                56008 => {
                    self.library_whats_new_show_only_product_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                56016 => {
                    self.show_store_content_on_home = ::std::option::Option::Some(is.read_bool()?);
                },
                56026 => {
                    self.start_page = ::std::option::Option::Some(is.read_string()?);
                },
                56032 => {
                    self.library_low_bandwidth_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                56040 => {
                    self.library_low_perf_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                56048 => {
                    self.library_disable_community_content = ::std::option::Option::Some(is.read_bool()?);
                },
                56056 => {
                    self.library_display_icon_in_game_list = ::std::option::Option::Some(is.read_bool()?);
                },
                56064 => {
                    self.ready_to_play_includes_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                56072 => {
                    self.show_steam_deck_info = ::std::option::Option::Some(is.read_bool()?);
                },
                64000 => {
                    self.enable_shader_precache = ::std::option::Option::Some(is.read_bool()?);
                },
                64008 => {
                    self.enable_shader_background_processing = ::std::option::Option::Some(is.read_bool()?);
                },
                64016 => {
                    self.shader_precached_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                64024 => {
                    self.needs_steam_service_repair = ::std::option::Option::Some(is.read_bool()?);
                },
                64032 => {
                    self.download_peer_content = ::std::option::Option::Some(is.read_int32()?);
                },
                64040 => {
                    self.download_rate_bits_per_s = ::std::option::Option::Some(is.read_bool()?);
                },
                64048 => {
                    self.restrict_auto_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                64056 => {
                    self.restrict_auto_updates_start = ::std::option::Option::Some(is.read_int32()?);
                },
                64064 => {
                    self.restrict_auto_updates_end = ::std::option::Option::Some(is.read_int32()?);
                },
                64072 => {
                    self.download_region = ::std::option::Option::Some(is.read_int32()?);
                },
                64080 => {
                    self.download_while_app_running = ::std::option::Option::Some(is.read_bool()?);
                },
                64088 => {
                    self.download_throttle_while_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                64096 => {
                    self.download_throttle_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                80000 => {
                    self.cloud_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                80008 => {
                    self.show_screenshot_manager = ::std::option::Option::Some(is.read_bool()?);
                },
                88000 => {
                    self.music_volume = ::std::option::Option::Some(is.read_int32()?);
                },
                88008 => {
                    self.music_pause_on_app_start = ::std::option::Option::Some(is.read_bool()?);
                },
                88016 => {
                    self.music_pause_on_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                88024 => {
                    self.music_download_high_quality = ::std::option::Option::Some(is.read_bool()?);
                },
                88032 => {
                    self.music_playlist_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                96000 => {
                    self.broadcast_permissions = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96008 => {
                    self.broadcast_output_width = ::std::option::Option::Some(is.read_int32()?);
                },
                96016 => {
                    self.broadcast_output_height = ::std::option::Option::Some(is.read_int32()?);
                },
                96024 => {
                    self.broadcast_bitrate = ::std::option::Option::Some(is.read_int32()?);
                },
                96032 => {
                    self.broadcast_encoding_option = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96040 => {
                    self.broadcast_record_all_video = ::std::option::Option::Some(is.read_bool()?);
                },
                96048 => {
                    self.broadcast_record_all_audio = ::std::option::Option::Some(is.read_bool()?);
                },
                96056 => {
                    self.broadcast_record_microphone = ::std::option::Option::Some(is.read_bool()?);
                },
                96064 => {
                    self.broadcast_show_upload_stats = ::std::option::Option::Some(is.read_bool()?);
                },
                96072 => {
                    self.broadcast_show_live_reminder = ::std::option::Option::Some(is.read_bool()?);
                },
                96080 => {
                    self.broadcast_chat_corner = ::std::option::Option::Some(is.read_int32()?);
                },
                112008 => {
                    self.steam_input_configurator_error_msg_enable = ::std::option::Option::Some(is.read_bool()?);
                },
                112016 => {
                    self.controller_guide_button_focus_steam = ::std::option::Option::Some(is.read_bool()?);
                },
                112024 => {
                    self.controller_ps_support = ::std::option::Option::Some(is.read_int32()?);
                },
                112032 => {
                    self.controller_xbox_support = ::std::option::Option::Some(is.read_bool()?);
                },
                112040 => {
                    self.controller_xbox_driver = ::std::option::Option::Some(is.read_bool()?);
                },
                112048 => {
                    self.controller_switch_support = ::std::option::Option::Some(is.read_bool()?);
                },
                112056 => {
                    self.controller_generic_support = ::std::option::Option::Some(is.read_bool()?);
                },
                112064 => {
                    self.controller_power_off_timeout = ::std::option::Option::Some(is.read_int32()?);
                },
                112072 => {
                    self.turn_off_controller_on_exit = ::std::option::Option::Some(is.read_bool()?);
                },
                112080 => {
                    self.controller_combine_nintendo_joycons = ::std::option::Option::Some(is.read_bool()?);
                },
                128000 => {
                    self.startup_movie_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                128010 => {
                    self.startup_movie_local_path = ::std::option::Option::Some(is.read_string()?);
                },
                128016 => {
                    self.startup_movie_shuffle = ::std::option::Option::Some(is.read_bool()?);
                },
                128024 => {
                    self.startup_movie_used_for_resume = ::std::option::Option::Some(is.read_bool()?);
                },
                136008 => {
                    self.game_notes_enable_spellcheck = ::std::option::Option::Some(is.read_bool()?);
                },
                144000 => {
                    self.screenshot_items_per_row = ::std::option::Option::Some(is.read_int32()?);
                },
                145600 => {
                    self.g_background_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                145610 => {
                    self.g_background_path = ::std::option::Option::Some(is.read_string()?);
                },
                145618 => {
                    self.g_background_max_keep = ::std::option::Option::Some(is.read_string()?);
                },
                145624 => {
                    self.g_background_time_resolution = ::std::option::Option::Some(is.read_int32()?);
                },
                145648 => {
                    self.g_background_devmode = ::std::option::Option::Some(is.read_bool()?);
                },
                145658 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.g_background_mk)?;
                },
                145666 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.g_background_tg)?;
                },
                160000 => {
                    self.show_timestamps_in_console = ::std::option::Option::Some(is.read_bool()?);
                },
                160008 => {
                    self.force_oobe = ::std::option::Option::Some(is.read_bool()?);
                },
                160016 => {
                    self.override_browser_composer_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                160024 => {
                    self.cef_remote_debugging_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                160032 => {
                    self.force_deck_perf_tab = ::std::option::Option::Some(is.read_bool()?);
                },
                160040 => {
                    self.force_fake_mandatory_update = ::std::option::Option::Some(is.read_bool()?);
                },
                168008 => {
                    self.gamescope_hdr_visualization = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                168016 => {
                    self.gamescope_app_target_framerate = ::std::option::Option::Some(is.read_int32()?);
                },
                168024 => {
                    self.gamescope_enable_app_target_framerate = ::std::option::Option::Some(is.read_bool()?);
                },
                168032 => {
                    self.gamescope_disable_framelimit = ::std::option::Option::Some(is.read_bool()?);
                },
                168040 => {
                    self.gamescope_display_refresh_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                168048 => {
                    self.gamescope_use_game_refresh_rate_in_steam = ::std::option::Option::Some(is.read_bool()?);
                },
                176000 => {
                    self.steamos_status_led_brightness = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.no_save_personal_info {
            my_size += 1 + 1;
        }
        if let Some(v) = self.oobe_test_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.in_client_beta {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_steam_sideloaded {
            my_size += 1 + 1;
        }
        if let Some(v) = self.preferred_monitor.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.steam_cef_gpu_blocklist_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bigpicture_windowed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.is_external_display {
            my_size += 1 + 1;
        }
        if let Some(v) = self.steam_os_underscan_level {
            my_size += 1 + 4;
        }
        if let Some(v) = self.steam_os_underscan_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.min_scale_factor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_scale_factor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.auto_scale_factor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.small_mode {
            my_size += 2 + 1;
        }
        if let Some(v) = self.skip_steamvr_install_dialog {
            my_size += 2 + 1;
        }
        if let Some(v) = self.always_show_user_chooser {
            my_size += 2 + 1;
        }
        if let Some(v) = self.show_family_sharing_notifications {
            my_size += 3 + 1;
        }
        if let Some(v) = self.overlay_fps_counter_corner {
            my_size += crate::rt::int32_size(4000, v);
        }
        if let Some(v) = self.overlay_fps_counter_high_contrast {
            my_size += 3 + 1;
        }
        if let Some(v) = self.overlay_key.as_ref() {
            let len = v.compute_size();
            my_size += 3 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.screenshot_key.as_ref() {
            let len = v.compute_size();
            my_size += 3 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.enable_overlay {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_screenshot_notification {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_screenshot_sound {
            my_size += 3 + 1;
        }
        if let Some(v) = self.save_uncompressed_screenshots {
            my_size += 3 + 1;
        }
        if let Some(v) = self.screenshots_path.as_ref() {
            my_size += crate::rt::string_size(4009, &v);
        }
        if let Some(v) = self.default_ping_rate {
            my_size += crate::rt::int32_size(4010, v);
        }
        if let Some(v) = self.server_ping_rate {
            my_size += crate::rt::int32_size(4011, v);
        }
        if let Some(v) = self.steam_networking_share_ip {
            my_size += crate::rt::int32_size(4012, v);
        }
        if let Some(v) = self.web_browser_home.as_ref() {
            my_size += crate::rt::string_size(4013, &v);
        }
        if let Some(v) = self.voice_mic_device_name.as_ref() {
            my_size += crate::rt::string_size(4014, &v);
        }
        if let Some(v) = self.voice_mic_input_gain {
            my_size += 3 + 4;
        }
        if let Some(v) = self.voice_speaker_output_gain {
            my_size += 3 + 4;
        }
        if let Some(v) = self.voice_push_to_talk_setting {
            my_size += crate::rt::int32_size(4017, v);
        }
        if let Some(v) = self.voice_push_to_talk_key.as_ref() {
            let len = v.compute_size();
            my_size += 3 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.overlay_toolbar_list_view {
            my_size += 3 + 1;
        }
        if let Some(v) = self.always_use_gamepadui_overlay {
            my_size += 3 + 1;
        }
        if let Some(v) = self.overlay_tabs.as_ref() {
            my_size += crate::rt::string_size(4021, &v);
        }
        if let Some(v) = self.overlay_scale_interface {
            my_size += 3 + 1;
        }
        if let Some(v) = self.overlay_restore_browser_tabs {
            my_size += 3 + 1;
        }
        if let Some(v) = self.smooth_scroll_webviews {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_gpu_accelerated_webviews {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_hardware_video_decoding {
            my_size += 3 + 1;
        }
        if let Some(v) = self.run_at_startup {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_dpi_scaling {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_marketing_messages {
            my_size += 3 + 1;
        }
        if let Some(v) = self.start_in_big_picture_mode {
            my_size += 3 + 1;
        }
        if let Some(v) = self.jumplist_flags {
            my_size += crate::rt::uint32_size(5008, v);
        }
        if let Some(v) = self.enable_ui_sounds {
            my_size += 3 + 1;
        }
        if let Some(v) = self.disable_all_toasts {
            my_size += 3 + 1;
        }
        if let Some(v) = self.disable_toasts_in_game {
            my_size += 3 + 1;
        }
        if let Some(v) = self.play_sound_on_toast {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_display_size {
            my_size += crate::rt::int32_size(7000, v);
        }
        if let Some(v) = self.library_whats_new_show_only_product_updates {
            my_size += 3 + 1;
        }
        if let Some(v) = self.show_store_content_on_home {
            my_size += 3 + 1;
        }
        if let Some(v) = self.start_page.as_ref() {
            my_size += crate::rt::string_size(7003, &v);
        }
        if let Some(v) = self.library_low_bandwidth_mode {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_low_perf_mode {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_disable_community_content {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_display_icon_in_game_list {
            my_size += 3 + 1;
        }
        if let Some(v) = self.ready_to_play_includes_streaming {
            my_size += 3 + 1;
        }
        if let Some(v) = self.show_steam_deck_info {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_shader_precache {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_shader_background_processing {
            my_size += 3 + 1;
        }
        if let Some(v) = self.shader_precached_size {
            my_size += crate::rt::uint64_size(8002, v);
        }
        if let Some(v) = self.needs_steam_service_repair {
            my_size += 3 + 1;
        }
        if let Some(v) = self.download_peer_content {
            my_size += crate::rt::int32_size(8004, v);
        }
        if let Some(v) = self.download_rate_bits_per_s {
            my_size += 3 + 1;
        }
        if let Some(v) = self.restrict_auto_updates {
            my_size += 3 + 1;
        }
        if let Some(v) = self.restrict_auto_updates_start {
            my_size += crate::rt::int32_size(8007, v);
        }
        if let Some(v) = self.restrict_auto_updates_end {
            my_size += crate::rt::int32_size(8008, v);
        }
        if let Some(v) = self.download_region {
            my_size += crate::rt::int32_size(8009, v);
        }
        if let Some(v) = self.download_while_app_running {
            my_size += 3 + 1;
        }
        if let Some(v) = self.download_throttle_while_streaming {
            my_size += 3 + 1;
        }
        if let Some(v) = self.download_throttle_rate {
            my_size += crate::rt::int32_size(8012, v);
        }
        if let Some(v) = self.cloud_enabled {
            my_size += 3 + 1;
        }
        if let Some(v) = self.show_screenshot_manager {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_volume {
            my_size += crate::rt::int32_size(11000, v);
        }
        if let Some(v) = self.music_pause_on_app_start {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_pause_on_voice_chat {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_download_high_quality {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_playlist_notification {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_permissions {
            my_size += crate::rt::int32_size(12000, v.value());
        }
        if let Some(v) = self.broadcast_output_width {
            my_size += crate::rt::int32_size(12001, v);
        }
        if let Some(v) = self.broadcast_output_height {
            my_size += crate::rt::int32_size(12002, v);
        }
        if let Some(v) = self.broadcast_bitrate {
            my_size += crate::rt::int32_size(12003, v);
        }
        if let Some(v) = self.broadcast_encoding_option {
            my_size += crate::rt::int32_size(12004, v.value());
        }
        if let Some(v) = self.broadcast_record_all_video {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_record_all_audio {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_record_microphone {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_show_upload_stats {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_show_live_reminder {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_chat_corner {
            my_size += crate::rt::int32_size(12010, v);
        }
        if let Some(v) = self.steam_input_configurator_error_msg_enable {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_guide_button_focus_steam {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_ps_support {
            my_size += crate::rt::int32_size(14003, v);
        }
        if let Some(v) = self.controller_xbox_support {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_xbox_driver {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_switch_support {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_generic_support {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_power_off_timeout {
            my_size += crate::rt::int32_size(14008, v);
        }
        if let Some(v) = self.turn_off_controller_on_exit {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_combine_nintendo_joycons {
            my_size += 3 + 1;
        }
        if let Some(v) = self.startup_movie_id {
            my_size += crate::rt::uint64_size(16000, v);
        }
        if let Some(v) = self.startup_movie_local_path.as_ref() {
            my_size += crate::rt::string_size(16001, &v);
        }
        if let Some(v) = self.startup_movie_shuffle {
            my_size += 3 + 1;
        }
        if let Some(v) = self.startup_movie_used_for_resume {
            my_size += 3 + 1;
        }
        if let Some(v) = self.game_notes_enable_spellcheck {
            my_size += 3 + 1;
        }
        if let Some(v) = self.screenshot_items_per_row {
            my_size += crate::rt::int32_size(18000, v);
        }
        if let Some(v) = self.g_background_enabled {
            my_size += 3 + 1;
        }
        if let Some(v) = self.g_background_path.as_ref() {
            my_size += crate::rt::string_size(18201, &v);
        }
        if let Some(v) = self.g_background_max_keep.as_ref() {
            my_size += crate::rt::string_size(18202, &v);
        }
        if let Some(v) = self.g_background_time_resolution {
            my_size += crate::rt::int32_size(18203, v);
        }
        if let Some(v) = self.g_background_devmode {
            my_size += 3 + 1;
        }
        if let Some(v) = self.g_background_mk.as_ref() {
            let len = v.compute_size();
            my_size += 3 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.g_background_tg.as_ref() {
            let len = v.compute_size();
            my_size += 3 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.show_timestamps_in_console {
            my_size += 3 + 1;
        }
        if let Some(v) = self.force_oobe {
            my_size += 3 + 1;
        }
        if let Some(v) = self.override_browser_composer_mode {
            my_size += crate::rt::int32_size(20002, v);
        }
        if let Some(v) = self.cef_remote_debugging_enabled {
            my_size += 3 + 1;
        }
        if let Some(v) = self.force_deck_perf_tab {
            my_size += 3 + 1;
        }
        if let Some(v) = self.force_fake_mandatory_update {
            my_size += 3 + 1;
        }
        if let Some(v) = self.gamescope_hdr_visualization {
            my_size += crate::rt::int32_size(21001, v.value());
        }
        if let Some(v) = self.gamescope_app_target_framerate {
            my_size += crate::rt::int32_size(21002, v);
        }
        if let Some(v) = self.gamescope_enable_app_target_framerate {
            my_size += 3 + 1;
        }
        if let Some(v) = self.gamescope_disable_framelimit {
            my_size += 3 + 1;
        }
        if let Some(v) = self.gamescope_display_refresh_rate {
            my_size += crate::rt::int32_size(21005, v);
        }
        if let Some(v) = self.gamescope_use_game_refresh_rate_in_steam {
            my_size += 3 + 1;
        }
        if let Some(v) = self.steamos_status_led_brightness {
            my_size += crate::rt::int32_size(22000, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.no_save_personal_info {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.oobe_test_mode_enabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.in_client_beta {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_steam_sideloaded {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.preferred_monitor.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.steam_cef_gpu_blocklist_disabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.bigpicture_windowed {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.is_external_display {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.steam_os_underscan_level {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.steam_os_underscan_enabled {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.min_scale_factor {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.max_scale_factor {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.auto_scale_factor {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.small_mode {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.skip_steamvr_install_dialog {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.always_show_user_chooser {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.show_family_sharing_notifications {
            os.write_bool(3000, v)?;
        }
        if let Some(v) = self.overlay_fps_counter_corner {
            os.write_int32(4000, v)?;
        }
        if let Some(v) = self.overlay_fps_counter_high_contrast {
            os.write_bool(4001, v)?;
        }
        if let Some(v) = self.overlay_key.as_ref() {
            crate::rt::write_message_field_with_cached_size(4002, v, os)?;
        }
        if let Some(v) = self.screenshot_key.as_ref() {
            crate::rt::write_message_field_with_cached_size(4003, v, os)?;
        }
        if let Some(v) = self.enable_overlay {
            os.write_bool(4004, v)?;
        }
        if let Some(v) = self.enable_screenshot_notification {
            os.write_bool(4006, v)?;
        }
        if let Some(v) = self.enable_screenshot_sound {
            os.write_bool(4007, v)?;
        }
        if let Some(v) = self.save_uncompressed_screenshots {
            os.write_bool(4008, v)?;
        }
        if let Some(v) = self.screenshots_path.as_ref() {
            os.write_string(4009, v)?;
        }
        if let Some(v) = self.default_ping_rate {
            os.write_int32(4010, v)?;
        }
        if let Some(v) = self.server_ping_rate {
            os.write_int32(4011, v)?;
        }
        if let Some(v) = self.steam_networking_share_ip {
            os.write_int32(4012, v)?;
        }
        if let Some(v) = self.web_browser_home.as_ref() {
            os.write_string(4013, v)?;
        }
        if let Some(v) = self.voice_mic_device_name.as_ref() {
            os.write_string(4014, v)?;
        }
        if let Some(v) = self.voice_mic_input_gain {
            os.write_float(4015, v)?;
        }
        if let Some(v) = self.voice_speaker_output_gain {
            os.write_float(4016, v)?;
        }
        if let Some(v) = self.voice_push_to_talk_setting {
            os.write_int32(4017, v)?;
        }
        if let Some(v) = self.voice_push_to_talk_key.as_ref() {
            crate::rt::write_message_field_with_cached_size(4018, v, os)?;
        }
        if let Some(v) = self.overlay_toolbar_list_view {
            os.write_bool(4019, v)?;
        }
        if let Some(v) = self.always_use_gamepadui_overlay {
            os.write_bool(4020, v)?;
        }
        if let Some(v) = self.overlay_tabs.as_ref() {
            os.write_string(4021, v)?;
        }
        if let Some(v) = self.overlay_scale_interface {
            os.write_bool(4022, v)?;
        }
        if let Some(v) = self.overlay_restore_browser_tabs {
            os.write_bool(4023, v)?;
        }
        if let Some(v) = self.smooth_scroll_webviews {
            os.write_bool(5000, v)?;
        }
        if let Some(v) = self.enable_gpu_accelerated_webviews {
            os.write_bool(5001, v)?;
        }
        if let Some(v) = self.enable_hardware_video_decoding {
            os.write_bool(5003, v)?;
        }
        if let Some(v) = self.run_at_startup {
            os.write_bool(5004, v)?;
        }
        if let Some(v) = self.enable_dpi_scaling {
            os.write_bool(5005, v)?;
        }
        if let Some(v) = self.enable_marketing_messages {
            os.write_bool(5006, v)?;
        }
        if let Some(v) = self.start_in_big_picture_mode {
            os.write_bool(5007, v)?;
        }
        if let Some(v) = self.jumplist_flags {
            os.write_uint32(5008, v)?;
        }
        if let Some(v) = self.enable_ui_sounds {
            os.write_bool(5009, v)?;
        }
        if let Some(v) = self.disable_all_toasts {
            os.write_bool(6000, v)?;
        }
        if let Some(v) = self.disable_toasts_in_game {
            os.write_bool(6001, v)?;
        }
        if let Some(v) = self.play_sound_on_toast {
            os.write_bool(6002, v)?;
        }
        if let Some(v) = self.library_display_size {
            os.write_int32(7000, v)?;
        }
        if let Some(v) = self.library_whats_new_show_only_product_updates {
            os.write_bool(7001, v)?;
        }
        if let Some(v) = self.show_store_content_on_home {
            os.write_bool(7002, v)?;
        }
        if let Some(v) = self.start_page.as_ref() {
            os.write_string(7003, v)?;
        }
        if let Some(v) = self.library_low_bandwidth_mode {
            os.write_bool(7004, v)?;
        }
        if let Some(v) = self.library_low_perf_mode {
            os.write_bool(7005, v)?;
        }
        if let Some(v) = self.library_disable_community_content {
            os.write_bool(7006, v)?;
        }
        if let Some(v) = self.library_display_icon_in_game_list {
            os.write_bool(7007, v)?;
        }
        if let Some(v) = self.ready_to_play_includes_streaming {
            os.write_bool(7008, v)?;
        }
        if let Some(v) = self.show_steam_deck_info {
            os.write_bool(7009, v)?;
        }
        if let Some(v) = self.enable_shader_precache {
            os.write_bool(8000, v)?;
        }
        if let Some(v) = self.enable_shader_background_processing {
            os.write_bool(8001, v)?;
        }
        if let Some(v) = self.shader_precached_size {
            os.write_uint64(8002, v)?;
        }
        if let Some(v) = self.needs_steam_service_repair {
            os.write_bool(8003, v)?;
        }
        if let Some(v) = self.download_peer_content {
            os.write_int32(8004, v)?;
        }
        if let Some(v) = self.download_rate_bits_per_s {
            os.write_bool(8005, v)?;
        }
        if let Some(v) = self.restrict_auto_updates {
            os.write_bool(8006, v)?;
        }
        if let Some(v) = self.restrict_auto_updates_start {
            os.write_int32(8007, v)?;
        }
        if let Some(v) = self.restrict_auto_updates_end {
            os.write_int32(8008, v)?;
        }
        if let Some(v) = self.download_region {
            os.write_int32(8009, v)?;
        }
        if let Some(v) = self.download_while_app_running {
            os.write_bool(8010, v)?;
        }
        if let Some(v) = self.download_throttle_while_streaming {
            os.write_bool(8011, v)?;
        }
        if let Some(v) = self.download_throttle_rate {
            os.write_int32(8012, v)?;
        }
        if let Some(v) = self.cloud_enabled {
            os.write_bool(10000, v)?;
        }
        if let Some(v) = self.show_screenshot_manager {
            os.write_bool(10001, v)?;
        }
        if let Some(v) = self.music_volume {
            os.write_int32(11000, v)?;
        }
        if let Some(v) = self.music_pause_on_app_start {
            os.write_bool(11001, v)?;
        }
        if let Some(v) = self.music_pause_on_voice_chat {
            os.write_bool(11002, v)?;
        }
        if let Some(v) = self.music_download_high_quality {
            os.write_bool(11003, v)?;
        }
        if let Some(v) = self.music_playlist_notification {
            os.write_bool(11004, v)?;
        }
        if let Some(v) = self.broadcast_permissions {
            os.write_enum(12000, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.broadcast_output_width {
            os.write_int32(12001, v)?;
        }
        if let Some(v) = self.broadcast_output_height {
            os.write_int32(12002, v)?;
        }
        if let Some(v) = self.broadcast_bitrate {
            os.write_int32(12003, v)?;
        }
        if let Some(v) = self.broadcast_encoding_option {
            os.write_enum(12004, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.broadcast_record_all_video {
            os.write_bool(12005, v)?;
        }
        if let Some(v) = self.broadcast_record_all_audio {
            os.write_bool(12006, v)?;
        }
        if let Some(v) = self.broadcast_record_microphone {
            os.write_bool(12007, v)?;
        }
        if let Some(v) = self.broadcast_show_upload_stats {
            os.write_bool(12008, v)?;
        }
        if let Some(v) = self.broadcast_show_live_reminder {
            os.write_bool(12009, v)?;
        }
        if let Some(v) = self.broadcast_chat_corner {
            os.write_int32(12010, v)?;
        }
        if let Some(v) = self.steam_input_configurator_error_msg_enable {
            os.write_bool(14001, v)?;
        }
        if let Some(v) = self.controller_guide_button_focus_steam {
            os.write_bool(14002, v)?;
        }
        if let Some(v) = self.controller_ps_support {
            os.write_int32(14003, v)?;
        }
        if let Some(v) = self.controller_xbox_support {
            os.write_bool(14004, v)?;
        }
        if let Some(v) = self.controller_xbox_driver {
            os.write_bool(14005, v)?;
        }
        if let Some(v) = self.controller_switch_support {
            os.write_bool(14006, v)?;
        }
        if let Some(v) = self.controller_generic_support {
            os.write_bool(14007, v)?;
        }
        if let Some(v) = self.controller_power_off_timeout {
            os.write_int32(14008, v)?;
        }
        if let Some(v) = self.turn_off_controller_on_exit {
            os.write_bool(14009, v)?;
        }
        if let Some(v) = self.controller_combine_nintendo_joycons {
            os.write_bool(14010, v)?;
        }
        if let Some(v) = self.startup_movie_id {
            os.write_uint64(16000, v)?;
        }
        if let Some(v) = self.startup_movie_local_path.as_ref() {
            os.write_string(16001, v)?;
        }
        if let Some(v) = self.startup_movie_shuffle {
            os.write_bool(16002, v)?;
        }
        if let Some(v) = self.startup_movie_used_for_resume {
            os.write_bool(16003, v)?;
        }
        if let Some(v) = self.game_notes_enable_spellcheck {
            os.write_bool(17001, v)?;
        }
        if let Some(v) = self.screenshot_items_per_row {
            os.write_int32(18000, v)?;
        }
        if let Some(v) = self.g_background_enabled {
            os.write_bool(18200, v)?;
        }
        if let Some(v) = self.g_background_path.as_ref() {
            os.write_string(18201, v)?;
        }
        if let Some(v) = self.g_background_max_keep.as_ref() {
            os.write_string(18202, v)?;
        }
        if let Some(v) = self.g_background_time_resolution {
            os.write_int32(18203, v)?;
        }
        if let Some(v) = self.g_background_devmode {
            os.write_bool(18206, v)?;
        }
        if let Some(v) = self.g_background_mk.as_ref() {
            crate::rt::write_message_field_with_cached_size(18207, v, os)?;
        }
        if let Some(v) = self.g_background_tg.as_ref() {
            crate::rt::write_message_field_with_cached_size(18208, v, os)?;
        }
        if let Some(v) = self.show_timestamps_in_console {
            os.write_bool(20000, v)?;
        }
        if let Some(v) = self.force_oobe {
            os.write_bool(20001, v)?;
        }
        if let Some(v) = self.override_browser_composer_mode {
            os.write_int32(20002, v)?;
        }
        if let Some(v) = self.cef_remote_debugging_enabled {
            os.write_bool(20003, v)?;
        }
        if let Some(v) = self.force_deck_perf_tab {
            os.write_bool(20004, v)?;
        }
        if let Some(v) = self.force_fake_mandatory_update {
            os.write_bool(20005, v)?;
        }
        if let Some(v) = self.gamescope_hdr_visualization {
            os.write_enum(21001, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gamescope_app_target_framerate {
            os.write_int32(21002, v)?;
        }
        if let Some(v) = self.gamescope_enable_app_target_framerate {
            os.write_bool(21003, v)?;
        }
        if let Some(v) = self.gamescope_disable_framelimit {
            os.write_bool(21004, v)?;
        }
        if let Some(v) = self.gamescope_display_refresh_rate {
            os.write_int32(21005, v)?;
        }
        if let Some(v) = self.gamescope_use_game_refresh_rate_in_steam {
            os.write_bool(21006, v)?;
        }
        if let Some(v) = self.steamos_status_led_brightness {
            os.write_int32(22000, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSettings {
        CMsgClientSettings::new()
    }

    fn clear(&mut self) {
        self.no_save_personal_info = ::std::option::Option::None;
        self.oobe_test_mode_enabled = ::std::option::Option::None;
        self.in_client_beta = ::std::option::Option::None;
        self.is_steam_sideloaded = ::std::option::Option::None;
        self.preferred_monitor = ::std::option::Option::None;
        self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::None;
        self.bigpicture_windowed = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.is_external_display = ::std::option::Option::None;
        self.steam_os_underscan_level = ::std::option::Option::None;
        self.steam_os_underscan_enabled = ::std::option::Option::None;
        self.min_scale_factor = ::std::option::Option::None;
        self.max_scale_factor = ::std::option::Option::None;
        self.auto_scale_factor = ::std::option::Option::None;
        self.small_mode = ::std::option::Option::None;
        self.skip_steamvr_install_dialog = ::std::option::Option::None;
        self.always_show_user_chooser = ::std::option::Option::None;
        self.show_family_sharing_notifications = ::std::option::Option::None;
        self.overlay_fps_counter_corner = ::std::option::Option::None;
        self.overlay_fps_counter_high_contrast = ::std::option::Option::None;
        self.overlay_key.clear();
        self.screenshot_key.clear();
        self.enable_overlay = ::std::option::Option::None;
        self.enable_screenshot_notification = ::std::option::Option::None;
        self.enable_screenshot_sound = ::std::option::Option::None;
        self.save_uncompressed_screenshots = ::std::option::Option::None;
        self.screenshots_path = ::std::option::Option::None;
        self.default_ping_rate = ::std::option::Option::None;
        self.server_ping_rate = ::std::option::Option::None;
        self.steam_networking_share_ip = ::std::option::Option::None;
        self.web_browser_home = ::std::option::Option::None;
        self.voice_mic_device_name = ::std::option::Option::None;
        self.voice_mic_input_gain = ::std::option::Option::None;
        self.voice_speaker_output_gain = ::std::option::Option::None;
        self.voice_push_to_talk_setting = ::std::option::Option::None;
        self.voice_push_to_talk_key.clear();
        self.overlay_toolbar_list_view = ::std::option::Option::None;
        self.always_use_gamepadui_overlay = ::std::option::Option::None;
        self.overlay_tabs = ::std::option::Option::None;
        self.overlay_scale_interface = ::std::option::Option::None;
        self.overlay_restore_browser_tabs = ::std::option::Option::None;
        self.smooth_scroll_webviews = ::std::option::Option::None;
        self.enable_gpu_accelerated_webviews = ::std::option::Option::None;
        self.enable_hardware_video_decoding = ::std::option::Option::None;
        self.run_at_startup = ::std::option::Option::None;
        self.enable_dpi_scaling = ::std::option::Option::None;
        self.enable_marketing_messages = ::std::option::Option::None;
        self.start_in_big_picture_mode = ::std::option::Option::None;
        self.jumplist_flags = ::std::option::Option::None;
        self.enable_ui_sounds = ::std::option::Option::None;
        self.disable_all_toasts = ::std::option::Option::None;
        self.disable_toasts_in_game = ::std::option::Option::None;
        self.play_sound_on_toast = ::std::option::Option::None;
        self.library_display_size = ::std::option::Option::None;
        self.library_whats_new_show_only_product_updates = ::std::option::Option::None;
        self.show_store_content_on_home = ::std::option::Option::None;
        self.start_page = ::std::option::Option::None;
        self.library_low_bandwidth_mode = ::std::option::Option::None;
        self.library_low_perf_mode = ::std::option::Option::None;
        self.library_disable_community_content = ::std::option::Option::None;
        self.library_display_icon_in_game_list = ::std::option::Option::None;
        self.ready_to_play_includes_streaming = ::std::option::Option::None;
        self.show_steam_deck_info = ::std::option::Option::None;
        self.enable_shader_precache = ::std::option::Option::None;
        self.enable_shader_background_processing = ::std::option::Option::None;
        self.shader_precached_size = ::std::option::Option::None;
        self.needs_steam_service_repair = ::std::option::Option::None;
        self.download_peer_content = ::std::option::Option::None;
        self.download_rate_bits_per_s = ::std::option::Option::None;
        self.restrict_auto_updates = ::std::option::Option::None;
        self.restrict_auto_updates_start = ::std::option::Option::None;
        self.restrict_auto_updates_end = ::std::option::Option::None;
        self.download_region = ::std::option::Option::None;
        self.download_while_app_running = ::std::option::Option::None;
        self.download_throttle_while_streaming = ::std::option::Option::None;
        self.download_throttle_rate = ::std::option::Option::None;
        self.cloud_enabled = ::std::option::Option::None;
        self.show_screenshot_manager = ::std::option::Option::None;
        self.music_volume = ::std::option::Option::None;
        self.music_pause_on_app_start = ::std::option::Option::None;
        self.music_pause_on_voice_chat = ::std::option::Option::None;
        self.music_download_high_quality = ::std::option::Option::None;
        self.music_playlist_notification = ::std::option::Option::None;
        self.broadcast_permissions = ::std::option::Option::None;
        self.broadcast_output_width = ::std::option::Option::None;
        self.broadcast_output_height = ::std::option::Option::None;
        self.broadcast_bitrate = ::std::option::Option::None;
        self.broadcast_encoding_option = ::std::option::Option::None;
        self.broadcast_record_all_video = ::std::option::Option::None;
        self.broadcast_record_all_audio = ::std::option::Option::None;
        self.broadcast_record_microphone = ::std::option::Option::None;
        self.broadcast_show_upload_stats = ::std::option::Option::None;
        self.broadcast_show_live_reminder = ::std::option::Option::None;
        self.broadcast_chat_corner = ::std::option::Option::None;
        self.steam_input_configurator_error_msg_enable = ::std::option::Option::None;
        self.controller_guide_button_focus_steam = ::std::option::Option::None;
        self.controller_ps_support = ::std::option::Option::None;
        self.controller_xbox_support = ::std::option::Option::None;
        self.controller_xbox_driver = ::std::option::Option::None;
        self.controller_switch_support = ::std::option::Option::None;
        self.controller_generic_support = ::std::option::Option::None;
        self.controller_power_off_timeout = ::std::option::Option::None;
        self.turn_off_controller_on_exit = ::std::option::Option::None;
        self.controller_combine_nintendo_joycons = ::std::option::Option::None;
        self.startup_movie_id = ::std::option::Option::None;
        self.startup_movie_local_path = ::std::option::Option::None;
        self.startup_movie_shuffle = ::std::option::Option::None;
        self.startup_movie_used_for_resume = ::std::option::Option::None;
        self.game_notes_enable_spellcheck = ::std::option::Option::None;
        self.screenshot_items_per_row = ::std::option::Option::None;
        self.g_background_enabled = ::std::option::Option::None;
        self.g_background_path = ::std::option::Option::None;
        self.g_background_max_keep = ::std::option::Option::None;
        self.g_background_time_resolution = ::std::option::Option::None;
        self.g_background_devmode = ::std::option::Option::None;
        self.g_background_mk.clear();
        self.g_background_tg.clear();
        self.show_timestamps_in_console = ::std::option::Option::None;
        self.force_oobe = ::std::option::Option::None;
        self.override_browser_composer_mode = ::std::option::Option::None;
        self.cef_remote_debugging_enabled = ::std::option::Option::None;
        self.force_deck_perf_tab = ::std::option::Option::None;
        self.force_fake_mandatory_update = ::std::option::Option::None;
        self.gamescope_hdr_visualization = ::std::option::Option::None;
        self.gamescope_app_target_framerate = ::std::option::Option::None;
        self.gamescope_enable_app_target_framerate = ::std::option::Option::None;
        self.gamescope_disable_framelimit = ::std::option::Option::None;
        self.gamescope_display_refresh_rate = ::std::option::Option::None;
        self.gamescope_use_game_refresh_rate_in_steam = ::std::option::Option::None;
        self.steamos_status_led_brightness = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSettings {
        static instance: CMsgClientSettings = CMsgClientSettings {
            no_save_personal_info: ::std::option::Option::None,
            oobe_test_mode_enabled: ::std::option::Option::None,
            in_client_beta: ::std::option::Option::None,
            is_steam_sideloaded: ::std::option::Option::None,
            preferred_monitor: ::std::option::Option::None,
            steam_cef_gpu_blocklist_disabled: ::std::option::Option::None,
            bigpicture_windowed: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            is_external_display: ::std::option::Option::None,
            steam_os_underscan_level: ::std::option::Option::None,
            steam_os_underscan_enabled: ::std::option::Option::None,
            min_scale_factor: ::std::option::Option::None,
            max_scale_factor: ::std::option::Option::None,
            auto_scale_factor: ::std::option::Option::None,
            small_mode: ::std::option::Option::None,
            skip_steamvr_install_dialog: ::std::option::Option::None,
            always_show_user_chooser: ::std::option::Option::None,
            show_family_sharing_notifications: ::std::option::Option::None,
            overlay_fps_counter_corner: ::std::option::Option::None,
            overlay_fps_counter_high_contrast: ::std::option::Option::None,
            overlay_key: crate::MessageField::none(),
            screenshot_key: crate::MessageField::none(),
            enable_overlay: ::std::option::Option::None,
            enable_screenshot_notification: ::std::option::Option::None,
            enable_screenshot_sound: ::std::option::Option::None,
            save_uncompressed_screenshots: ::std::option::Option::None,
            screenshots_path: ::std::option::Option::None,
            default_ping_rate: ::std::option::Option::None,
            server_ping_rate: ::std::option::Option::None,
            steam_networking_share_ip: ::std::option::Option::None,
            web_browser_home: ::std::option::Option::None,
            voice_mic_device_name: ::std::option::Option::None,
            voice_mic_input_gain: ::std::option::Option::None,
            voice_speaker_output_gain: ::std::option::Option::None,
            voice_push_to_talk_setting: ::std::option::Option::None,
            voice_push_to_talk_key: crate::MessageField::none(),
            overlay_toolbar_list_view: ::std::option::Option::None,
            always_use_gamepadui_overlay: ::std::option::Option::None,
            overlay_tabs: ::std::option::Option::None,
            overlay_scale_interface: ::std::option::Option::None,
            overlay_restore_browser_tabs: ::std::option::Option::None,
            smooth_scroll_webviews: ::std::option::Option::None,
            enable_gpu_accelerated_webviews: ::std::option::Option::None,
            enable_hardware_video_decoding: ::std::option::Option::None,
            run_at_startup: ::std::option::Option::None,
            enable_dpi_scaling: ::std::option::Option::None,
            enable_marketing_messages: ::std::option::Option::None,
            start_in_big_picture_mode: ::std::option::Option::None,
            jumplist_flags: ::std::option::Option::None,
            enable_ui_sounds: ::std::option::Option::None,
            disable_all_toasts: ::std::option::Option::None,
            disable_toasts_in_game: ::std::option::Option::None,
            play_sound_on_toast: ::std::option::Option::None,
            library_display_size: ::std::option::Option::None,
            library_whats_new_show_only_product_updates: ::std::option::Option::None,
            show_store_content_on_home: ::std::option::Option::None,
            start_page: ::std::option::Option::None,
            library_low_bandwidth_mode: ::std::option::Option::None,
            library_low_perf_mode: ::std::option::Option::None,
            library_disable_community_content: ::std::option::Option::None,
            library_display_icon_in_game_list: ::std::option::Option::None,
            ready_to_play_includes_streaming: ::std::option::Option::None,
            show_steam_deck_info: ::std::option::Option::None,
            enable_shader_precache: ::std::option::Option::None,
            enable_shader_background_processing: ::std::option::Option::None,
            shader_precached_size: ::std::option::Option::None,
            needs_steam_service_repair: ::std::option::Option::None,
            download_peer_content: ::std::option::Option::None,
            download_rate_bits_per_s: ::std::option::Option::None,
            restrict_auto_updates: ::std::option::Option::None,
            restrict_auto_updates_start: ::std::option::Option::None,
            restrict_auto_updates_end: ::std::option::Option::None,
            download_region: ::std::option::Option::None,
            download_while_app_running: ::std::option::Option::None,
            download_throttle_while_streaming: ::std::option::Option::None,
            download_throttle_rate: ::std::option::Option::None,
            cloud_enabled: ::std::option::Option::None,
            show_screenshot_manager: ::std::option::Option::None,
            music_volume: ::std::option::Option::None,
            music_pause_on_app_start: ::std::option::Option::None,
            music_pause_on_voice_chat: ::std::option::Option::None,
            music_download_high_quality: ::std::option::Option::None,
            music_playlist_notification: ::std::option::Option::None,
            broadcast_permissions: ::std::option::Option::None,
            broadcast_output_width: ::std::option::Option::None,
            broadcast_output_height: ::std::option::Option::None,
            broadcast_bitrate: ::std::option::Option::None,
            broadcast_encoding_option: ::std::option::Option::None,
            broadcast_record_all_video: ::std::option::Option::None,
            broadcast_record_all_audio: ::std::option::Option::None,
            broadcast_record_microphone: ::std::option::Option::None,
            broadcast_show_upload_stats: ::std::option::Option::None,
            broadcast_show_live_reminder: ::std::option::Option::None,
            broadcast_chat_corner: ::std::option::Option::None,
            steam_input_configurator_error_msg_enable: ::std::option::Option::None,
            controller_guide_button_focus_steam: ::std::option::Option::None,
            controller_ps_support: ::std::option::Option::None,
            controller_xbox_support: ::std::option::Option::None,
            controller_xbox_driver: ::std::option::Option::None,
            controller_switch_support: ::std::option::Option::None,
            controller_generic_support: ::std::option::Option::None,
            controller_power_off_timeout: ::std::option::Option::None,
            turn_off_controller_on_exit: ::std::option::Option::None,
            controller_combine_nintendo_joycons: ::std::option::Option::None,
            startup_movie_id: ::std::option::Option::None,
            startup_movie_local_path: ::std::option::Option::None,
            startup_movie_shuffle: ::std::option::Option::None,
            startup_movie_used_for_resume: ::std::option::Option::None,
            game_notes_enable_spellcheck: ::std::option::Option::None,
            screenshot_items_per_row: ::std::option::Option::None,
            g_background_enabled: ::std::option::Option::None,
            g_background_path: ::std::option::Option::None,
            g_background_max_keep: ::std::option::Option::None,
            g_background_time_resolution: ::std::option::Option::None,
            g_background_devmode: ::std::option::Option::None,
            g_background_mk: crate::MessageField::none(),
            g_background_tg: crate::MessageField::none(),
            show_timestamps_in_console: ::std::option::Option::None,
            force_oobe: ::std::option::Option::None,
            override_browser_composer_mode: ::std::option::Option::None,
            cef_remote_debugging_enabled: ::std::option::Option::None,
            force_deck_perf_tab: ::std::option::Option::None,
            force_fake_mandatory_update: ::std::option::Option::None,
            gamescope_hdr_visualization: ::std::option::Option::None,
            gamescope_app_target_framerate: ::std::option::Option::None,
            gamescope_enable_app_target_framerate: ::std::option::Option::None,
            gamescope_disable_framelimit: ::std::option::Option::None,
            gamescope_display_refresh_rate: ::std::option::Option::None,
            gamescope_use_game_refresh_rate_in_steam: ::std::option::Option::None,
            steamos_status_led_brightness: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSettings {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSettings {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EClientSettingStore)
pub enum EClientSettingStore {
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_Invalid)
    k_EClientSettingStore_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_ConfigStore_Install)
    k_EClientSettingStore_ConfigStore_Install = 1,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_ConfigStore_UserRoaming)
    k_EClientSettingStore_ConfigStore_UserRoaming = 2,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_ConfigStore_UserLocal)
    k_EClientSettingStore_ConfigStore_UserLocal = 3,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_Registry)
    k_EClientSettingStore_Registry = 4,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_CustomFunc)
    k_EClientSettingStore_CustomFunc = 5,
}

impl crate::Enum for EClientSettingStore {
    const NAME: &'static str = "EClientSettingStore";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EClientSettingStore> {
        match value {
            0 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Invalid),
            1 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_Install),
            2 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserRoaming),
            3 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserLocal),
            4 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Registry),
            5 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_CustomFunc),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EClientSettingStore> {
        match str {
            "k_EClientSettingStore_Invalid" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Invalid),
            "k_EClientSettingStore_ConfigStore_Install" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_Install),
            "k_EClientSettingStore_ConfigStore_UserRoaming" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserRoaming),
            "k_EClientSettingStore_ConfigStore_UserLocal" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserLocal),
            "k_EClientSettingStore_Registry" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Registry),
            "k_EClientSettingStore_CustomFunc" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_CustomFunc),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EClientSettingStore] = &[
        EClientSettingStore::k_EClientSettingStore_Invalid,
        EClientSettingStore::k_EClientSettingStore_ConfigStore_Install,
        EClientSettingStore::k_EClientSettingStore_ConfigStore_UserRoaming,
        EClientSettingStore::k_EClientSettingStore_ConfigStore_UserLocal,
        EClientSettingStore::k_EClientSettingStore_Registry,
        EClientSettingStore::k_EClientSettingStore_CustomFunc,
    ];
}

impl crate::EnumFull for EClientSettingStore {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EClientSettingStore").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EClientSettingStore {
    fn default() -> Self {
        EClientSettingStore::k_EClientSettingStore_Invalid
    }
}

impl EClientSettingStore {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EClientSettingStore>("EClientSettingStore")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOverlayToggleBarLocation)
pub enum EOverlayToggleBarLocation {
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Bottom)
    k_EOverlayToggleBarLocation_Bottom = 0,
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Left)
    k_EOverlayToggleBarLocation_Left = 1,
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Right)
    k_EOverlayToggleBarLocation_Right = 2,
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Top)
    k_EOverlayToggleBarLocation_Top = 3,
}

impl crate::Enum for EOverlayToggleBarLocation {
    const NAME: &'static str = "EOverlayToggleBarLocation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverlayToggleBarLocation> {
        match value {
            0 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom),
            1 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Left),
            2 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Right),
            3 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Top),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverlayToggleBarLocation> {
        match str {
            "k_EOverlayToggleBarLocation_Bottom" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom),
            "k_EOverlayToggleBarLocation_Left" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Left),
            "k_EOverlayToggleBarLocation_Right" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Right),
            "k_EOverlayToggleBarLocation_Top" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Top),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverlayToggleBarLocation] = &[
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom,
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Left,
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Right,
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Top,
    ];
}

impl crate::EnumFull for EOverlayToggleBarLocation {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EOverlayToggleBarLocation").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EOverlayToggleBarLocation {
    fn default() -> Self {
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom
    }
}

impl EOverlayToggleBarLocation {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EOverlayToggleBarLocation>("EOverlayToggleBarLocation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESettingProfileMode)
pub enum ESettingProfileMode {
    // @@protoc_insertion_point(enum_value:ESettingProfileMode.k_ESettingProfileMode_None)
    k_ESettingProfileMode_None = 0,
    // @@protoc_insertion_point(enum_value:ESettingProfileMode.k_ESettingProfileMode_PerGame)
    k_ESettingProfileMode_PerGame = 1,
    // @@protoc_insertion_point(enum_value:ESettingProfileMode.k_ESettingProfileMode_PerGamePerDisplay)
    k_ESettingProfileMode_PerGamePerDisplay = 2,
}

impl crate::Enum for ESettingProfileMode {
    const NAME: &'static str = "ESettingProfileMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESettingProfileMode> {
        match value {
            0 => ::std::option::Option::Some(ESettingProfileMode::k_ESettingProfileMode_None),
            1 => ::std::option::Option::Some(ESettingProfileMode::k_ESettingProfileMode_PerGame),
            2 => ::std::option::Option::Some(ESettingProfileMode::k_ESettingProfileMode_PerGamePerDisplay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESettingProfileMode> {
        match str {
            "k_ESettingProfileMode_None" => ::std::option::Option::Some(ESettingProfileMode::k_ESettingProfileMode_None),
            "k_ESettingProfileMode_PerGame" => ::std::option::Option::Some(ESettingProfileMode::k_ESettingProfileMode_PerGame),
            "k_ESettingProfileMode_PerGamePerDisplay" => ::std::option::Option::Some(ESettingProfileMode::k_ESettingProfileMode_PerGamePerDisplay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESettingProfileMode] = &[
        ESettingProfileMode::k_ESettingProfileMode_None,
        ESettingProfileMode::k_ESettingProfileMode_PerGame,
        ESettingProfileMode::k_ESettingProfileMode_PerGamePerDisplay,
    ];
}

impl crate::EnumFull for ESettingProfileMode {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESettingProfileMode").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESettingProfileMode {
    fn default() -> Self {
        ESettingProfileMode::k_ESettingProfileMode_None
    }
}

impl ESettingProfileMode {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESettingProfileMode>("ESettingProfileMode")
    }
}

/// Extension fields
pub mod exts {

    pub const setting_store: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, crate::EnumOrUnknown<super::EClientSettingStore>> = crate::ext::ExtFieldOptional::new(60000, crate::descriptor::field_descriptor_proto::Type::TYPE_ENUM);

    pub const setting_name: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, ::std::string::String> = crate::ext::ExtFieldOptional::new(60001, crate::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const setting_pre_login: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(60002, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const setting_default_bool: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(60003, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const setting_default_int: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, i32> = crate::ext::ExtFieldOptional::new(60004, crate::descriptor::field_descriptor_proto::Type::TYPE_INT32);

    pub const setting_default_uint: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, u32> = crate::ext::ExtFieldOptional::new(60005, crate::descriptor::field_descriptor_proto::Type::TYPE_UINT32);

    pub const setting_default_float: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, f32> = crate::ext::ExtFieldOptional::new(60006, crate::descriptor::field_descriptor_proto::Type::TYPE_FLOAT);

    pub const setting_default_string: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, ::std::string::String> = crate::ext::ExtFieldOptional::new(60007, crate::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const setting_readonly: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(60008, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const setting_description: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, ::std::string::String> = crate::ext::ExtFieldOptional::new(60009, crate::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const setting_profile_mode: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, crate::EnumOrUnknown<super::ESettingProfileMode>> = crate::ext::ExtFieldOptional::new(60010, crate::descriptor::field_descriptor_proto::Type::TYPE_ENUM);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"steammessages_clientsettings.proto\x1a\x20google/protobuf/descriptor\
    .proto\x1a\x0benums.proto\"\xb6\x01\n\nCMsgHotkey\x12\x19\n\x08key_code\
    \x18\x01\x20\x01(\rR\x07keyCode\x12\x17\n\x07alt_key\x18\x02\x20\x01(\
    \x08R\x06altKey\x12\x1b\n\tshift_key\x18\x03\x20\x01(\x08R\x08shiftKey\
    \x12\x19\n\x08ctrl_key\x18\x04\x20\x01(\x08R\x07ctrlKey\x12\x19\n\x08met\
    a_key\x18\x05\x20\x01(\x08R\x07metaKey\x12!\n\x0cdisplay_name\x18\x06\
    \x20\x01(\tR\x0bdisplayName\"\x9d[\n\x12CMsgClientSettings\x12b\n\x15no_\
    save_personal_info\x18\x01\x20\x01(\x08R\x12noSavePersonalInfoB/\x80\xa6\
    \x1d\x01\x8a\xa6\x1d'Software\\Valve\\Steam\\NoSavePersonalInfo\x12e\n\
    \x16oobe_test_mode_enabled\x18\x02\x20\x01(\x08R\x13oobeTestModeEnabledB\
    0\x80\xa6\x1d\x01\x8a\xa6\x1d(Software\\Valve\\Steam\\OOBETestModeEnable\
    d\x12.\n\x0ein_client_beta\x18\x03\x20\x01(\x08R\x0cinClientBetaB\x08\
    \x90\xa6\x1d\x01\x80\xa6\x1d\x05\x128\n\x13is_steam_sideloaded\x18\x04\
    \x20\x01(\x08R\x11isSteamSideloadedB\x08\x90\xa6\x1d\x01\x80\xa6\x1d\x05\
    \x12G\n\x11preferred_monitor\x18\x05\x20\x01(\tR\x10preferredMonitorB\
    \x1a\x80\xa6\x1d\x01\x8a\xa6\x1d\x12BigPicture/Monitor\x12\x8e\x01\n\x20\
    steam_cef_gpu_blocklist_disabled\x18\x06\x20\x01(\x08R\x1csteamCefGpuBlo\
    cklistDisabledBF\x80\xa6\x1d\x04\x8a\xa6\x1d>HKEY_CURRENT_USER\\Software\
    \\Valve\\Steam\\CEFGPUBlocklistDisabled\x12P\n\x13bigpicture_windowed\
    \x18\x07\x20\x01(\x08R\x12bigpictureWindowedB\x1f\x90\xa6\x1d\x01\x80\
    \xa6\x1d\x01\x8a\xa6\x1d\x13BigPicture/Windowed\x12B\n\x0cdisplay_name\
    \x18\x08\x20\x01(\tR\x0bdisplayNameB\x1f\x80\xa6\x1d\x01\x8a\xa6\x1d\x17\
    UI/Display/Current/Name\x12\\\n\x13is_external_display\x18\t\x20\x01(\
    \x08R\x11isExternalDisplayB,\x80\xa6\x1d\x01\x8a\xa6\x1d$UI/Display/Curr\
    ent/IsExternalDisplay\x12\\\n\x18steam_os_underscan_level\x18\n\x20\x01(\
    \x02R\x15steamOsUnderscanLevelB#\x80\xa6\x1d\x01\x8a\xa6\x1d\x1bSteamOSS\
    creenUnderscanLevel\x12b\n\x1asteam_os_underscan_enabled\x18\x0b\x20\x01\
    (\x08R\x17steamOsUnderscanEnabledB%\x80\xa6\x1d\x01\x8a\xa6\x1d\x1dSteam\
    OSScreenUnderscanEnabled\x12S\n\x10min_scale_factor\x18\x0c\x20\x01(\x02\
    R\x0eminScaleFactorB)\x80\xa6\x1d\x01\x8a\xa6\x1d!UI/Display/Current/Min\
    ScaleFactor\x12S\n\x10max_scale_factor\x18\r\x20\x01(\x02R\x0emaxScaleFa\
    ctorB)\x80\xa6\x1d\x01\x8a\xa6\x1d!UI/Display/Current/MaxScaleFactor\x12\
    V\n\x11auto_scale_factor\x18\x0e\x20\x01(\x02R\x0fautoScaleFactorB*\x80\
    \xa6\x1d\x01\x8a\xa6\x1d\"UI/Display/Current/AutoScaleFactor\x12E\n\nsma\
    ll_mode\x18\x10\x20\x01(\x08R\tsmallModeB&\x80\xa6\x1d\x03\x8a\xa6\x1d\
    \x1eSoftware\\Valve\\Steam\\SmallMode\x12c\n\x1bskip_steamvr_install_dia\
    log\x18\x13\x20\x01(\x08R\x18skipSteamvrInstallDialogB$\x80\xa6\x1d\x03\
    \x8a\xa6\x1d\x1csystem\\SteamVRHMDVGUIWarning\x12f\n\x18always_show_user\
    _chooser\x18\x14\x20\x01(\x08R\x15alwaysShowUserChooserB-\x80\xa6\x1d\
    \x01\x8a\xa6\x1d%WebStorage\\Auth\\AlwaysShowUserChooser\x12P\n!show_fam\
    ily_sharing_notifications\x18\xb8\x17\x20\x01(\x08R\x1eshowFamilySharing\
    NotificationsB\x04\x80\xa6\x1d\x05\x12g\n\x1aoverlay_fps_counter_corner\
    \x18\xa0\x1f\x20\x01(\x05R\x17overlayFpsCounterCornerB)\x80\xa6\x1d\x03\
    \x8a\xa6\x1d!system\\InGameOverlayShowFPSCorner\x12v\n!overlay_fps_count\
    er_high_contrast\x18\xa1\x1f\x20\x01(\x08R\x1doverlayFpsCounterHighContr\
    astB+\x80\xa6\x1d\x03\x8a\xa6\x1d#system\\InGameOverlayShowFPSContrast\
    \x12g\n\x0boverlay_key\x18\xa2\x1f\x20\x01(\x0b2\x0b.CMsgHotkeyR\noverla\
    yKeyB8\x80\xa6\x1d\x03\x8a\xa6\x1d\x1fsystem\\InGameOverlayShortcutKey\
    \xba\xa6\x1d\rShift\tKEY_TAB\x12l\n\x0escreenshot_key\x18\xa3\x1f\x20\
    \x01(\x0b2\x0b.CMsgHotkeyR\rscreenshotKeyB7\x80\xa6\x1d\x03\x8a\xa6\x1d$\
    system\\InGameOverlayScreenshotHotKey\xba\xa6\x1d\x07KEY_F12\x12H\n\x0ee\
    nable_overlay\x18\xa4\x1f\x20\x01(\x08R\renableOverlayB\x20\x80\xa6\x1d\
    \x03\x8a\xa6\x1d\x18system\\EnableGameOverlay\x12}\n\x1eenable_screensho\
    t_notification\x18\xa6\x1f\x20\x01(\x08R\x1cenableScreenshotNotification\
    B6\x80\xa6\x1d\x03\x8a\xa6\x1d*system\\InGameOverlayScreenshotNotificati\
    on\x98\xa6\x1d\x01\x12l\n\x17enable_screenshot_sound\x18\xa7\x1f\x20\x01\
    (\x08R\x15enableScreenshotSoundB3\x80\xa6\x1d\x03\x8a\xa6\x1d'system\\In\
    GameOverlayScreenshotPlaySound\x98\xa6\x1d\x01\x12{\n\x1dsave_uncompress\
    ed_screenshots\x18\xa8\x1f\x20\x01(\x08R\x1bsaveUncompressedScreenshotsB\
    6\x80\xa6\x1d\x03\x8a\xa6\x1d.system\\InGameOverlayScreenshotSaveUncompr\
    essed\x120\n\x10screenshots_path\x18\xa9\x1f\x20\x01(\tR\x0fscreenshotsP\
    athB\x04\x80\xa6\x1d\x05\x12}\n\x11default_ping_rate\x18\xaa\x1f\x20\x01\
    (\x05R\x0fdefaultPingRateBP\xc0\xa6\x1d\x01\x80\xa6\x1d\x05\xca\xa6\x1dD\
    Computed\x20default\x20(automatic)\x20server\x20ping\x20rate\x20based\
    \x20on\x20network\x20speed\x12/\n\x10server_ping_rate\x18\xab\x1f\x20\
    \x01(\x05R\x0eserverPingRateB\x04\x80\xa6\x1d\x05\x12@\n\x19steam_networ\
    king_share_ip\x18\xac\x1f\x20\x01(\x05R\x16steamNetworkingShareIpB\x04\
    \x80\xa6\x1d\x05\x12/\n\x10web_browser_home\x18\xad\x1f\x20\x01(\tR\x0ew\
    ebBrowserHomeB\x04\x80\xa6\x1d\x05\x128\n\x15voice_mic_device_name\x18\
    \xae\x1f\x20\x01(\tR\x12voiceMicDeviceNameB\x04\x80\xa6\x1d\x05\x126\n\
    \x14voice_mic_input_gain\x18\xaf\x1f\x20\x01(\x02R\x11voiceMicInputGainB\
    \x04\x80\xa6\x1d\x05\x12@\n\x19voice_speaker_output_gain\x18\xb0\x1f\x20\
    \x01(\x02R\x16voiceSpeakerOutputGainB\x04\x80\xa6\x1d\x05\x12A\n\x1avoic\
    e_push_to_talk_setting\x18\xb1\x1f\x20\x01(\x05R\x16voicePushToTalkSetti\
    ngB\x04\x80\xa6\x1d\x05\x12F\n\x16voice_push_to_talk_key\x18\xb2\x1f\x20\
    \x01(\x0b2\x0b.CMsgHotkeyR\x12voicePushToTalkKeyB\x04\x80\xa6\x1d\x05\
    \x12Z\n\x19overlay_toolbar_list_view\x18\xb3\x1f\x20\x01(\x08R\x16overla\
    yToolbarListViewB\x1e\x80\xa6\x1d\x03\x8a\xa6\x1d\x16OverlayToolBarListV\
    iew\x12o\n\x1calways_use_gamepadui_overlay\x18\xb4\x1f\x20\x01(\x08R\x19\
    alwaysUseGamepaduiOverlayB-\x80\xa6\x1d\x03\x8a\xa6\x1d%system\\EnableSC\
    TenFootOverlayCheckNew\x127\n\x0coverlay_tabs\x18\xb5\x1f\x20\x01(\tR\
    \x0boverlayTabsB\x13\x80\xa6\x1d\x02\x8a\xa6\x1d\x0bOverlayTabs\x12\x81\
    \x01\n\x17overlay_scale_interface\x18\xb6\x1f\x20\x01(\x08R\x15overlaySc\
    aleInterfaceBH\x80\xa6\x1d\x04\x8a\xa6\x1d<HKEY_CURRENT_USER\\Software\\\
    Valve\\Steam\\OverlayScaleInterface\x98\xa6\x1d\x01\x12t\n\x1coverlay_re\
    store_browser_tabs\x18\xb7\x1f\x20\x01(\x08R\x19overlayRestoreBrowserTab\
    sB2\x80\xa6\x1d\x03\x8a\xa6\x1d&system\\InGameOverlayRestoreBrowserTabs\
    \x98\xa6\x1d\x01\x12~\n\x16smooth_scroll_webviews\x18\x88'\x20\x01(\x08R\
    \x14smoothScrollWebviewsBG\x80\xa6\x1d\x04\x8a\xa6\x1d;HKEY_CURRENT_USER\
    \\Software\\Valve\\Steam\\SmoothScrollWebViews\x98\xa6\x1d\x01\x12L\n\
    \x1fenable_gpu_accelerated_webviews\x18\x89'\x20\x01(\x08R\x1cenableGpuA\
    cceleratedWebviewsB\x04\x80\xa6\x1d\x05\x12J\n\x1eenable_hardware_video_\
    decoding\x18\x8b'\x20\x01(\x08R\x1benableHardwareVideoDecodingB\x04\x80\
    \xa6\x1d\x05\x12+\n\x0erun_at_startup\x18\x8c'\x20\x01(\x08R\x0crunAtSta\
    rtupB\x04\x80\xa6\x1d\x05\x123\n\x12enable_dpi_scaling\x18\x8d'\x20\x01(\
    \x08R\x10enableDpiScalingB\x04\x80\xa6\x1d\x05\x12b\n\x19enable_marketin\
    g_messages\x18\x8e'\x20\x01(\x08R\x17enableMarketingMessagesB%\x80\xa6\
    \x1d\x03\x8a\xa6\x1d\x19news\\NotifyAvailableGames\x98\xa6\x1d\x01\x12?\
    \n\x19start_in_big_picture_mode\x18\x8f'\x20\x01(\x08R\x15startInBigPict\
    ureModeB\x04\x80\xa6\x1d\x05\x12M\n\x0ejumplist_flags\x18\x90'\x20\x01(\
    \rR\rjumplistFlagsB%\x80\xa6\x1d\x03\x8a\xa6\x1d\x17system\\JumplistSett\
    ings\xa8\xa6\x1d\xf0\xde\x04\x12L\n\x10enable_ui_sounds\x18\x91'\x20\x01\
    (\x08R\x0eenableUiSoundsB!\x80\xa6\x1d\x03\x8a\xa6\x1d\x15system\\Enable\
    UISounds\x98\xa6\x1d\x01\x12G\n\x12disable_all_toasts\x18\xf0.\x20\x01(\
    \x08R\x10disableAllToastsB\x18\x80\xa6\x1d\x02\x8a\xa6\x1d\x10DisableAll\
    Toasts\x12Q\n\x16disable_toasts_in_game\x18\xf1.\x20\x01(\x08R\x13disabl\
    eToastsInGameB\x1b\x80\xa6\x1d\x02\x8a\xa6\x1d\x13DisableToastsInGame\
    \x12L\n\x13play_sound_on_toast\x18\xf2.\x20\x01(\x08R\x10playSoundOnToas\
    tB\x1c\x80\xa6\x1d\x02\x8a\xa6\x1d\x10PlaySoundOnToast\x98\xa6\x1d\x01\
    \x12M\n\x14library_display_size\x18\xd86\x20\x01(\x05R\x12libraryDisplay\
    SizeB\x1a\x80\xa6\x1d\x03\x8a\xa6\x1d\x12LibraryDisplaySize\x12\x8a\x01\
    \n+library_whats_new_show_only_product_updates\x18\xd96\x20\x01(\x08R%li\
    braryWhatsNewShowOnlyProductUpdatesB-\x80\xa6\x1d\x02\x8a\xa6\x1d%Librar\
    yWhatsNewShowOnlyProductUpdates\x12_\n\x1ashow_store_content_on_home\x18\
    \xda6\x20\x01(\x08R\x16showStoreContentOnHomeB\"\x80\xa6\x1d\x02\x8a\xa6\
    \x1d\x16ShowStoreContentOnHome\x98\xa6\x1d\x01\x12$\n\nstart_page\x18\
    \xdb6\x20\x01(\tR\tstartPageB\x04\x80\xa6\x1d\x05\x12]\n\x1alibrary_low_\
    bandwidth_mode\x18\xdc6\x20\x01(\x08R\x17libraryLowBandwidthModeB\x1f\
    \x80\xa6\x1d\x03\x8a\xa6\x1d\x17LibraryLowBandwidthMode\x12N\n\x15librar\
    y_low_perf_mode\x18\xdd6\x20\x01(\x08R\x12libraryLowPerfModeB\x1a\x80\
    \xa6\x1d\x03\x8a\xa6\x1d\x12LibraryLowPerfMode\x12r\n!library_disable_co\
    mmunity_content\x18\xde6\x20\x01(\x08R\x1elibraryDisableCommunityContent\
    B&\x80\xa6\x1d\x03\x8a\xa6\x1d\x1eLibraryDisableCommunityContent\x12r\n!\
    library_display_icon_in_game_list\x18\xdf6\x20\x01(\x08R\x1clibraryDispl\
    ayIconInGameListB(\x80\xa6\x1d\x03\x8a\xa6\x1d\x1cLibraryDisplayIconInGa\
    meList\x98\xa6\x1d\x01\x12m\n\x20ready_to_play_includes_streaming\x18\
    \xe06\x20\x01(\x08R\x1creadyToPlayIncludesStreamingB$\x80\xa6\x1d\x05\
    \x8a\xa6\x1d\x1cReadyToPlayIncludesStreaming\x12T\n\x14show_steam_deck_i\
    nfo\x18\xe16\x20\x01(\x08R\x11showSteamDeckInfoB\"\x80\xa6\x1d\x03\x8a\
    \xa6\x1d\x1aShowSteamDeckInfoInLibrary\x12;\n\x16enable_shader_precache\
    \x18\xc0>\x20\x01(\x08R\x14enableShaderPrecacheB\x04\x80\xa6\x1d\x05\x12\
    T\n#enable_shader_background_processing\x18\xc1>\x20\x01(\x08R\x20enable\
    ShaderBackgroundProcessingB\x04\x80\xa6\x1d\x05\x12=\n\x15shader_precach\
    ed_size\x18\xc2>\x20\x01(\x04R\x13shaderPrecachedSizeB\x08\xc0\xa6\x1d\
    \x01\x80\xa6\x1d\x05\x12F\n\x1aneeds_steam_service_repair\x18\xc3>\x20\
    \x01(\x08R\x17needsSteamServiceRepairB\x08\xc0\xa6\x1d\x01\x80\xa6\x1d\
    \x05\x129\n\x15download_peer_content\x18\xc4>\x20\x01(\x05R\x13downloadP\
    eerContentB\x04\x80\xa6\x1d\x05\x12=\n\x18download_rate_bits_per_s\x18\
    \xc5>\x20\x01(\x08R\x14downloadRateBitsPerSB\x04\x80\xa6\x1d\x05\x129\n\
    \x15restrict_auto_updates\x18\xc6>\x20\x01(\x08R\x13restrictAutoUpdatesB\
    \x04\x80\xa6\x1d\x05\x12D\n\x1brestrict_auto_updates_start\x18\xc7>\x20\
    \x01(\x05R\x18restrictAutoUpdatesStartB\x04\x80\xa6\x1d\x05\x12@\n\x19re\
    strict_auto_updates_end\x18\xc8>\x20\x01(\x05R\x16restrictAutoUpdatesEnd\
    B\x04\x80\xa6\x1d\x05\x12.\n\x0fdownload_region\x18\xc9>\x20\x01(\x05R\
    \x0edownloadRegionB\x04\x80\xa6\x1d\x05\x12B\n\x1adownload_while_app_run\
    ning\x18\xca>\x20\x01(\x08R\x17downloadWhileAppRunningB\x04\x80\xa6\x1d\
    \x05\x12P\n!download_throttle_while_streaming\x18\xcb>\x20\x01(\x08R\x1e\
    downloadThrottleWhileStreamingB\x04\x80\xa6\x1d\x05\x12;\n\x16download_t\
    hrottle_rate\x18\xcc>\x20\x01(\x05R\x14downloadThrottleRateB\x04\x80\xa6\
    \x1d\x05\x12*\n\rcloud_enabled\x18\x90N\x20\x01(\x08R\x0ccloudEnabledB\
    \x04\x80\xa6\x1d\x05\x12k\n\x17show_screenshot_manager\x18\x91N\x20\x01(\
    \x08R\x15showScreenshotManagerB2\x80\xa6\x1d\x02\x8a\xa6\x1d*Software\\V\
    alve\\Steam\\ShowScreenshotManager\x12(\n\x0cmusic_volume\x18\xf8U\x20\
    \x01(\x05R\x0bmusicVolumeB\x04\x80\xa6\x1d\x05\x12_\n\x18music_pause_on_\
    app_start\x18\xf9U\x20\x01(\x08R\x14musicPauseOnAppStartB&\x80\xa6\x1d\
    \x01\x8a\xa6\x1d\x1eMusic\\PauseOnAppStartedProcess\x12Y\n\x19music_paus\
    e_on_voice_chat\x18\xfaU\x20\x01(\x08R\x15musicPauseOnVoiceChatB\x1e\x80\
    \xa6\x1d\x01\x8a\xa6\x1d\x16Music\\PauseOnVoiceChat\x12q\n\x1bmusic_down\
    load_high_quality\x18\xfbU\x20\x01(\x08R\x18musicDownloadHighQualityB1\
    \x80\xa6\x1d\x01\x8a\xa6\x1d)Music\\DownloadHighQualityAudioSoundtracks\
    \x12m\n\x1bmusic_playlist_notification\x18\xfcU\x20\x01(\x08R\x19musicPl\
    aylistNotificationB,\x80\xa6\x1d\x01\x8a\xa6\x1d$Music\\PlaylistNowPlayi\
    ngNotification\x12\x8e\x01\n\x15broadcast_permissions\x18\xe0]\x20\x01(\
    \x0e2\x15.EBroadcastPermission:\x1ek_EBroadcastPermissionDisabledR\x14br\
    oadcastPermissionsB!\xa0\xa6\x1d\x01\x80\xa6\x1d\x03\x8a\xa6\x1d\x15Broa\
    dcast\\Permissions\x12T\n\x16broadcast_output_width\x18\xe1]\x20\x01(\
    \x05R\x14broadcastOutputWidthB\x1d\x80\xa6\x1d\x03\x8a\xa6\x1d\x15Broadc\
    ast\\OutputWidth\x12W\n\x17broadcast_output_height\x18\xe2]\x20\x01(\x05\
    R\x15broadcastOutputHeightB\x1e\x80\xa6\x1d\x03\x8a\xa6\x1d\x16Broadcast\
    \\OutputHeight\x12G\n\x11broadcast_bitrate\x18\xe3]\x20\x01(\x05R\x10bro\
    adcastBitrateB\x19\x80\xa6\x1d\x03\x8a\xa6\x1d\x11Broadcast\\MaxKbps\x12\
    \x98\x01\n\x19broadcast_encoding_option\x18\xe4]\x20\x01(\x0e2\x19.EBroa\
    dcastEncoderSetting:\x1ek_EBroadcastEncoderBestQualityR\x17broadcastEnco\
    dingOptionB\x20\x80\xa6\x1d\x03\x8a\xa6\x1d\x18Broadcast\\EncoderSetting\
    \x12^\n\x1abroadcast_record_all_video\x18\xe5]\x20\x01(\x08R\x17broadcas\
    tRecordAllVideoB\x20\x80\xa6\x1d\x03\x8a\xa6\x1d\x18Broadcast\\IncludeDe\
    sktop\x12a\n\x1abroadcast_record_all_audio\x18\xe6]\x20\x01(\x08R\x17bro\
    adcastRecordAllAudioB#\x80\xa6\x1d\x03\x8a\xa6\x1d\x1bBroadcast\\RecordS\
    ystemAudio\x12\\\n\x1bbroadcast_record_microphone\x18\xe7]\x20\x01(\x08R\
    \x19broadcastRecordMicrophoneB\x1b\x80\xa6\x1d\x03\x8a\xa6\x1d\x13Broadc\
    ast\\RecordMic\x12_\n\x1bbroadcast_show_upload_stats\x18\xe8]\x20\x01(\
    \x08R\x18broadcastShowUploadStatsB\x1f\x80\xa6\x1d\x03\x8a\xa6\x1d\x17Br\
    oadcast\\ShowDebugInfo\x12d\n\x1cbroadcast_show_live_reminder\x18\xe9]\
    \x20\x01(\x08R\x19broadcastShowLiveReminderB\"\x80\xa6\x1d\x03\x8a\xa6\
    \x1d\x16Broadcast\\ShowReminder\x98\xa6\x1d\x01\x12S\n\x15broadcast_chat\
    _corner\x18\xea]\x20\x01(\x05R\x13broadcastChatCornerB\x1e\xa0\xa6\x1d\
    \x01\x80\xa6\x1d\x03\x8a\xa6\x1d\x12Broadcast\\ShowChat\x12\x89\x01\n)st\
    eam_input_configurator_error_msg_enable\x18\xb1m\x20\x01(\x08R$steamInpu\
    tConfiguratorErrorMsgEnableB/\x80\xa6\x1d\x01\x8a\xa6\x1d'SteamInput/Con\
    figurator/ErrorMsgEnabled\x12r\n#controller_guide_button_focus_steam\x18\
    \xb2m\x20\x01(\x08R\x1fcontrollerGuideButtonFocusSteamB#\x80\xa6\x1d\x03\
    \x8a\xa6\x1d\x1bController_CheckGuideButton\x12Z\n\x15controller_ps_supp\
    ort\x18\xb3m\x20\x01(\x05R\x13controllerPsSupportB%\xa0\xa6\x1d\x01\x80\
    \xa6\x1d\x03\x8a\xa6\x1d\x19SteamController_PSSupport\x12\\\n\x17control\
    ler_xbox_support\x18\xb4m\x20\x01(\x08R\x15controllerXboxSupportB#\x80\
    \xa6\x1d\x03\x8a\xa6\x1d\x1bSteamController_XBoxSupport\x12Y\n\x16contro\
    ller_xbox_driver\x18\xb5m\x20\x01(\x08R\x14controllerXboxDriverB\"\x80\
    \xa6\x1d\x03\x8a\xa6\x1d\x1aSteamController_XBoxDriver\x12b\n\x19control\
    ler_switch_support\x18\xb6m\x20\x01(\x08R\x17controllerSwitchSupportB%\
    \x80\xa6\x1d\x03\x8a\xa6\x1d\x1dSteamController_SwitchSupport\x12l\n\x1a\
    controller_generic_support\x18\xb7m\x20\x01(\x08R\x18controllerGenericSu\
    pportB-\x80\xa6\x1d\x03\x8a\xa6\x1d%SteamController_GenericGamepadSuppor\
    t\x12r\n\x1ccontroller_power_off_timeout\x18\xb8m\x20\x01(\x05R\x19contr\
    ollerPowerOffTimeoutB0\xa0\xa6\x1d\x0f\x80\xa6\x1d\x03\x8a\xa6\x1d$CSett\
    ingsPanelGameController.Timeout\x12k\n\x1bturn_off_controller_on_exit\
    \x18\xb9m\x20\x01(\x08R\x17turnOffControllerOnExitB,\x80\xa6\x1d\x03\x8a\
    \xa6\x1d$CSettingsPanelGameController.TurnOff\x12T\n#controller_combine_\
    nintendo_joycons\x18\xbam\x20\x01(\x08R\x20controllerCombineNintendoJoyc\
    onsB\x04\x80\xa6\x1d\x05\x12Y\n\x10startup_movie_id\x18\x80}\x20\x01(\
    \x04R\x0estartupMovieIdB.\x90\xa6\x1d\x01\x80\xa6\x1d\x01\x8a\xa6\x1d\"C\
    ustomization/StartupMovie/MovieID\x12j\n\x18startup_movie_local_path\x18\
    \x81}\x20\x01(\tR\x15startupMovieLocalPathB0\x90\xa6\x1d\x01\x80\xa6\x1d\
    \x01\x8a\xa6\x1d$Customization/StartupMovie/LocalPath\x12c\n\x15startup_\
    movie_shuffle\x18\x82}\x20\x01(\x08R\x13startupMovieShuffleB.\x90\xa6\
    \x1d\x01\x80\xa6\x1d\x01\x8a\xa6\x1d\"Customization/StartupMovie/Shuffle\
    \x12s\n\x1dstartup_movie_used_for_resume\x18\x83}\x20\x01(\x08R\x19start\
    upMovieUsedForResumeB0\x80\xa6\x1d\x03\x8a\xa6\x1d(Customization/Startup\
    Movie/UsedForResume\x12h\n\x1cgame_notes_enable_spellcheck\x18\xe9\x84\
    \x01\x20\x01(\x08R\x19gameNotesEnableSpellcheckB%\x80\xa6\x1d\x02\x8a\
    \xa6\x1d\x19GameNotesEnableSpellcheck\x98\xa6\x1d\x01\x12`\n\x18screensh\
    ot_items_per_row\x18\xd0\x8c\x01\x20\x01(\x05R\x15screenshotItemsPerRowB\
    %\xa0\xa6\x1d\x01\x80\xa6\x1d\x02\x8a\xa6\x1d\x19ScreenshotViewItemsPerR\
    ow\x128\n\x14g_background_enabled\x18\x98\x8e\x01\x20\x01(\x08R\x12gBack\
    groundEnabledB\x04\x80\xa6\x1d\x05\x122\n\x11g_background_path\x18\x99\
    \x8e\x01\x20\x01(\tR\x0fgBackgroundPathB\x04\x80\xa6\x1d\x05\x129\n\x15g\
    _background_max_keep\x18\x9a\x8e\x01\x20\x01(\tR\x12gBackgroundMaxKeepB\
    \x04\x80\xa6\x1d\x05\x12G\n\x1cg_background_time_resolution\x18\x9b\x8e\
    \x01\x20\x01(\x05R\x19gBackgroundTimeResolutionB\x04\x80\xa6\x1d\x05\x12\
    8\n\x14g_background_devmode\x18\x9e\x8e\x01\x20\x01(\x08R\x12gBackground\
    DevmodeB\x04\x80\xa6\x1d\x05\x12;\n\x0fg_background_mk\x18\x9f\x8e\x01\
    \x20\x01(\x0b2\x0b.CMsgHotkeyR\rgBackgroundMkB\x04\x80\xa6\x1d\x05\x12;\
    \n\x0fg_background_tg\x18\xa0\x8e\x01\x20\x01(\x0b2\x0b.CMsgHotkeyR\rgBa\
    ckgroundTgB\x04\x80\xa6\x1d\x05\x12h\n\x1ashow_timestamps_in_console\x18\
    \xa0\x9c\x01\x20\x01(\x08R\x17showTimestampsInConsoleB)\x80\xa6\x1d\x03\
    \x8a\xa6\x1d!Developer\\ShowTimestampsInConsole\x12Y\n\nforce_oobe\x18\
    \xa1\x9c\x01\x20\x01(\x08R\tforceOobeB8\x80\xa6\x1d\x04\x8a\xa6\x1d0HKEY\
    _CURRENT_USER\\Software\\Valve\\Steam\\ForceOOBE\x12K\n\x1eoverride_brow\
    ser_composer_mode\x18\xa2\x9c\x01\x20\x01(\x05R\x1boverrideBrowserCompos\
    erModeB\x04\x80\xa6\x1d\x05\x12G\n\x1ccef_remote_debugging_enabled\x18\
    \xa3\x9c\x01\x20\x01(\x08R\x19cefRemoteDebuggingEnabledB\x04\x80\xa6\x1d\
    \x05\x12S\n\x13force_deck_perf_tab\x18\xa4\x9c\x01\x20\x01(\x08R\x10forc\
    eDeckPerfTabB\"\x80\xa6\x1d\x01\x8a\xa6\x1d\x1aDeveloper/ForceDeckPerfTa\
    b\x12f\n\x1bforce_fake_mandatory_update\x18\xa5\x9c\x01\x20\x01(\x08R\
    \x18forceFakeMandatoryUpdateB%\x80\xa6\x1d\x01\x8a\xa6\x1d\x1dDeveloper/\
    FakeMandatoryUpdate\x12\x93\x01\n\x1bgamescope_hdr_visualization\x18\x89\
    \xa4\x01\x20\x01(\x0e2\x12.EHDRVisualization:\x18k_EHDRVisualization_Non\
    eR\x19gamescopeHdrVisualizationB#\x80\xa6\x1d\x03\x8a\xa6\x1d\x1bGamesco\
    pe/HDRVisualization2\x12s\n\x1egamescope_app_target_framerate\x18\x8a\
    \xa4\x01\x20\x01(\x05R\x1bgamescopeAppTargetFramerateB,\xd0\xa6\x1d\x02\
    \xa0\xa6\x1d\0\x80\xa6\x1d\x03\x8a\xa6\x1d\x1cGamescope/AppTargetFrameRa\
    te\x12\xab\x01\n%gamescope_enable_app_target_framerate\x18\x8b\xa4\x01\
    \x20\x01(\x08R!gamescopeEnableAppTargetFramerateBW\x80\xa6\x1d\x04\x8a\
    \xa6\x1dKHKEY_CURRENT_USER\\Software\\Valve\\Steam\\GamescopeEnableAppTa\
    rgetRefreshRate2\x98\xa6\x1d\x01\x12o\n\x1cgamescope_disable_framelimit\
    \x18\x8c\xa4\x01\x20\x01(\x08R\x1agamescopeDisableFramelimitB+\xd0\xa6\
    \x1d\x02\x98\xa6\x1d\0\x80\xa6\x1d\x03\x8a\xa6\x1d\x1bGamescope/DisableF\
    rameLimit\x12l\n\x1egamescope_display_refresh_rate\x18\x8d\xa4\x01\x20\
    \x01(\x05R\x1bgamescopeDisplayRefreshRateB%\xd0\xa6\x1d\x02\xa0\xa6\x1d\
    \0\x80\xa6\x1d\x03\x8a\xa6\x1d\x15Gamescope/RefreshRate\x12\x87\x01\n(ga\
    mescope_use_game_refresh_rate_in_steam\x18\x8e\xa4\x01\x20\x01(\x08R\"ga\
    mescopeUseGameRefreshRateInSteamB/\x80\xa6\x1d\x03\x8a\xa6\x1d#Developer\
    /DynamicRefreshRateInSteam\x98\xa6\x1d\x01\x12l\n\x1dsteamos_status_led_\
    brightness\x18\xf0\xab\x01\x20\x01(\x05R\x1asteamosStatusLedBrightnessB'\
    \xa0\xa6\x1dd\x80\xa6\x1d\x03\x8a\xa6\x1d\x1bSteamOS/StatusLEDBrightness\
    *\x95\x02\n\x13EClientSettingStore\x12!\n\x1dk_EClientSettingStore_Inval\
    id\x10\0\x12-\n)k_EClientSettingStore_ConfigStore_Install\x10\x01\x121\n\
    -k_EClientSettingStore_ConfigStore_UserRoaming\x10\x02\x12/\n+k_EClientS\
    ettingStore_ConfigStore_UserLocal\x10\x03\x12\"\n\x1ek_EClientSettingSto\
    re_Registry\x10\x04\x12$\n\x20k_EClientSettingStore_CustomFunc\x10\x05*\
    \xb5\x01\n\x19EOverlayToggleBarLocation\x12&\n\"k_EOverlayToggleBarLocat\
    ion_Bottom\x10\0\x12$\n\x20k_EOverlayToggleBarLocation_Left\x10\x01\x12%\
    \n!k_EOverlayToggleBarLocation_Right\x10\x02\x12#\n\x1fk_EOverlayToggleB\
    arLocation_Top\x10\x03*\x85\x01\n\x13ESettingProfileMode\x12\x1e\n\x1ak_\
    ESettingProfileMode_None\x10\0\x12!\n\x1dk_ESettingProfileMode_PerGame\
    \x10\x01\x12+\n'k_ESettingProfileMode_PerGamePerDisplay\x10\x02:y\n\rset\
    ting_store\x18\xe0\xd4\x03\x20\x01(\x0e2\x14.EClientSettingStore\x12\x1d\
    .google.protobuf.FieldOptions:\x1dk_EClientSettingStore_InvalidR\x0csett\
    ingStore:B\n\x0csetting_name\x18\xe1\xd4\x03\x20\x01(\t\x12\x1d.google.p\
    rotobuf.FieldOptionsR\x0bsettingName:K\n\x11setting_pre_login\x18\xe2\
    \xd4\x03\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptionsR\x0fsettingPr\
    eLogin:Q\n\x14setting_default_bool\x18\xe3\xd4\x03\x20\x01(\x08\x12\x1d.\
    google.protobuf.FieldOptionsR\x12settingDefaultBool:O\n\x13setting_defau\
    lt_int\x18\xe4\xd4\x03\x20\x01(\x05\x12\x1d.google.protobuf.FieldOptions\
    R\x11settingDefaultInt:Q\n\x14setting_default_uint\x18\xe5\xd4\x03\x20\
    \x01(\r\x12\x1d.google.protobuf.FieldOptionsR\x12settingDefaultUint:S\n\
    \x15setting_default_float\x18\xe6\xd4\x03\x20\x01(\x02\x12\x1d.google.pr\
    otobuf.FieldOptionsR\x13settingDefaultFloat:U\n\x16setting_default_strin\
    g\x18\xe7\xd4\x03\x20\x01(\t\x12\x1d.google.protobuf.FieldOptionsR\x14se\
    ttingDefaultString:J\n\x10setting_readonly\x18\xe8\xd4\x03\x20\x01(\x08\
    \x12\x1d.google.protobuf.FieldOptionsR\x0fsettingReadonly:P\n\x13setting\
    _description\x18\xe9\xd4\x03\x20\x01(\t\x12\x1d.google.protobuf.FieldOpt\
    ionsR\x12settingDescription:\x83\x01\n\x14setting_profile_mode\x18\xea\
    \xd4\x03\x20\x01(\x0e2\x14.ESettingProfileMode\x12\x1d.google.protobuf.F\
    ieldOptions:\x1ak_ESettingProfileMode_NoneR\x12settingProfileModeB\x05H\
    \x01\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(crate::descriptor::file_descriptor().clone());
            deps.push(super::enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(2);
            messages.push(CMsgHotkey::generated_message_descriptor_data());
            messages.push(CMsgClientSettings::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(EClientSettingStore::generated_enum_descriptor_data());
            enums.push(EOverlayToggleBarLocation::generated_enum_descriptor_data());
            enums.push(ESettingProfileMode::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
