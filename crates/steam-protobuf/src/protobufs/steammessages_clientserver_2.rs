// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]


#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_2.proto`

// @@protoc_insertion_point(message:CMsgClientUpdateUserGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateUserGameInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.steamid_idgs)
    pub steamid_idgs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.game_ip)
    pub game_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateUserGameInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateUserGameInfo {
    fn default() -> &'a CMsgClientUpdateUserGameInfo {
        <CMsgClientUpdateUserGameInfo as crate::Message>::default_instance()
    }
}

impl CMsgClientUpdateUserGameInfo {
    pub fn new() -> CMsgClientUpdateUserGameInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_idgs = 1;

    pub fn steamid_idgs(&self) -> u64 {
        self.steamid_idgs.unwrap_or(0)
    }

    pub fn clear_steamid_idgs(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
    }

    pub fn has_steamid_idgs(&self) -> bool {
        self.steamid_idgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_idgs(&mut self, v: u64) {
        self.steamid_idgs = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 2;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_ip = 3;

    pub fn game_ip(&self) -> u32 {
        self.game_ip.unwrap_or(0)
    }

    pub fn clear_game_ip(&mut self) {
        self.game_ip = ::std::option::Option::None;
    }

    pub fn has_game_ip(&self) -> bool {
        self.game_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip(&mut self, v: u32) {
        self.game_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional bytes token = 5;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_idgs",
            |m: &CMsgClientUpdateUserGameInfo| { &m.steamid_idgs },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.steamid_idgs },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgClientUpdateUserGameInfo| { &m.gameid },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.gameid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_ip",
            |m: &CMsgClientUpdateUserGameInfo| { &m.game_ip },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port",
            |m: &CMsgClientUpdateUserGameInfo| { &m.game_port },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientUpdateUserGameInfo| { &m.token },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUpdateUserGameInfo>(
            "CMsgClientUpdateUserGameInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUpdateUserGameInfo {
    const NAME: &'static str = "CMsgClientUpdateUserGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_idgs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.game_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_idgs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_ip {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += crate::rt::bytes_size(5, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_idgs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateUserGameInfo {
        CMsgClientUpdateUserGameInfo::new()
    }

    fn clear(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.game_ip = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateUserGameInfo {
        static instance: CMsgClientUpdateUserGameInfo = CMsgClientUpdateUserGameInfo {
            steamid_idgs: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            game_ip: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUpdateUserGameInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUpdateUserGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUpdateUserGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUpdateUserGameInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceUpload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceUpload {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceUpload.rich_presence_kv)
    pub rich_presence_kv: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientRichPresenceUpload.steamid_broadcast)
    pub steamid_broadcast: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceUpload.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceUpload {
    fn default() -> &'a CMsgClientRichPresenceUpload {
        <CMsgClientRichPresenceUpload as crate::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceUpload {
    pub fn new() -> CMsgClientRichPresenceUpload {
        ::std::default::Default::default()
    }

    // optional bytes rich_presence_kv = 1;

    pub fn rich_presence_kv(&self) -> &[u8] {
        match self.rich_presence_kv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rich_presence_kv(&mut self) {
        self.rich_presence_kv = ::std::option::Option::None;
    }

    pub fn has_rich_presence_kv(&self) -> bool {
        self.rich_presence_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rich_presence_kv(&mut self, v: ::bytes::Bytes) {
        self.rich_presence_kv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rich_presence_kv(&mut self) -> &mut ::bytes::Bytes {
        if self.rich_presence_kv.is_none() {
            self.rich_presence_kv = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.rich_presence_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rich_presence_kv(&mut self) -> ::bytes::Bytes {
        self.rich_presence_kv.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // repeated fixed64 steamid_broadcast = 2;

    pub fn steamid_broadcast(&self) -> &[u64] {
        &self.steamid_broadcast
    }

    pub fn clear_steamid_broadcast(&mut self) {
        self.steamid_broadcast.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_broadcast(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_broadcast = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_broadcast(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_broadcast
    }

    // Take field
    pub fn take_steamid_broadcast(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_broadcast, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rich_presence_kv",
            |m: &CMsgClientRichPresenceUpload| { &m.rich_presence_kv },
            |m: &mut CMsgClientRichPresenceUpload| { &mut m.rich_presence_kv },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_broadcast",
            |m: &CMsgClientRichPresenceUpload| { &m.steamid_broadcast },
            |m: &mut CMsgClientRichPresenceUpload| { &mut m.steamid_broadcast },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRichPresenceUpload>(
            "CMsgClientRichPresenceUpload",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRichPresenceUpload {
    const NAME: &'static str = "CMsgClientRichPresenceUpload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rich_presence_kv = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_broadcast)?;
                },
                17 => {
                    self.steamid_broadcast.push(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rich_presence_kv.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        my_size += 9 * self.steamid_broadcast.len() as u64;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.rich_presence_kv.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.steamid_broadcast {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceUpload {
        CMsgClientRichPresenceUpload::new()
    }

    fn clear(&mut self) {
        self.rich_presence_kv = ::std::option::Option::None;
        self.steamid_broadcast.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceUpload {
        static instance: CMsgClientRichPresenceUpload = CMsgClientRichPresenceUpload {
            rich_presence_kv: ::std::option::Option::None,
            steamid_broadcast: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRichPresenceUpload {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceUpload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRichPresenceUpload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRichPresenceUpload {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceRequest.steamid_request)
    pub steamid_request: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceRequest {
    fn default() -> &'a CMsgClientRichPresenceRequest {
        <CMsgClientRichPresenceRequest as crate::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceRequest {
    pub fn new() -> CMsgClientRichPresenceRequest {
        ::std::default::Default::default()
    }

    // repeated fixed64 steamid_request = 1;

    pub fn steamid_request(&self) -> &[u64] {
        &self.steamid_request
    }

    pub fn clear_steamid_request(&mut self) {
        self.steamid_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_request(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_request = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_request(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_request
    }

    // Take field
    pub fn take_steamid_request(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_request, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_request",
            |m: &CMsgClientRichPresenceRequest| { &m.steamid_request },
            |m: &mut CMsgClientRichPresenceRequest| { &mut m.steamid_request },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRichPresenceRequest>(
            "CMsgClientRichPresenceRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRichPresenceRequest {
    const NAME: &'static str = "CMsgClientRichPresenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_request)?;
                },
                9 => {
                    self.steamid_request.push(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.steamid_request.len() as u64;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.steamid_request {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceRequest {
        CMsgClientRichPresenceRequest::new()
    }

    fn clear(&mut self) {
        self.steamid_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceRequest {
        static instance: CMsgClientRichPresenceRequest = CMsgClientRichPresenceRequest {
            steamid_request: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRichPresenceRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRichPresenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRichPresenceRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.rich_presence)
    pub rich_presence: ::std::vec::Vec<cmsg_client_rich_presence_info::RichPresence>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceInfo {
    fn default() -> &'a CMsgClientRichPresenceInfo {
        <CMsgClientRichPresenceInfo as crate::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceInfo {
    pub fn new() -> CMsgClientRichPresenceInfo {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientRichPresenceInfo.RichPresence rich_presence = 1;

    pub fn rich_presence(&self) -> &[cmsg_client_rich_presence_info::RichPresence] {
        &self.rich_presence
    }

    pub fn clear_rich_presence(&mut self) {
        self.rich_presence.clear();
    }

    // Param is passed by value, moved
    pub fn set_rich_presence(&mut self, v: ::std::vec::Vec<cmsg_client_rich_presence_info::RichPresence>) {
        self.rich_presence = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rich_presence(&mut self) -> &mut ::std::vec::Vec<cmsg_client_rich_presence_info::RichPresence> {
        &mut self.rich_presence
    }

    // Take field
    pub fn take_rich_presence(&mut self) -> ::std::vec::Vec<cmsg_client_rich_presence_info::RichPresence> {
        ::std::mem::replace(&mut self.rich_presence, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rich_presence",
            |m: &CMsgClientRichPresenceInfo| { &m.rich_presence },
            |m: &mut CMsgClientRichPresenceInfo| { &mut m.rich_presence },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRichPresenceInfo>(
            "CMsgClientRichPresenceInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRichPresenceInfo {
    const NAME: &'static str = "CMsgClientRichPresenceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rich_presence.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rich_presence {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.rich_presence {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceInfo {
        CMsgClientRichPresenceInfo::new()
    }

    fn clear(&mut self) {
        self.rich_presence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceInfo {
        static instance: CMsgClientRichPresenceInfo = CMsgClientRichPresenceInfo {
            rich_presence: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRichPresenceInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRichPresenceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRichPresenceInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientRichPresenceInfo`
pub mod cmsg_client_rich_presence_info {
    // @@protoc_insertion_point(message:CMsgClientRichPresenceInfo.RichPresence)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RichPresence {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.RichPresence.steamid_user)
        pub steamid_user: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.RichPresence.rich_presence_kv)
        pub rich_presence_kv: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientRichPresenceInfo.RichPresence.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RichPresence {
        fn default() -> &'a RichPresence {
            <RichPresence as crate::Message>::default_instance()
        }
    }

    impl RichPresence {
        pub fn new() -> RichPresence {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid_user = 1;

        pub fn steamid_user(&self) -> u64 {
            self.steamid_user.unwrap_or(0)
        }

        pub fn clear_steamid_user(&mut self) {
            self.steamid_user = ::std::option::Option::None;
        }

        pub fn has_steamid_user(&self) -> bool {
            self.steamid_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_user(&mut self, v: u64) {
            self.steamid_user = ::std::option::Option::Some(v);
        }

        // optional bytes rich_presence_kv = 2;

        pub fn rich_presence_kv(&self) -> &[u8] {
            match self.rich_presence_kv.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_rich_presence_kv(&mut self) {
            self.rich_presence_kv = ::std::option::Option::None;
        }

        pub fn has_rich_presence_kv(&self) -> bool {
            self.rich_presence_kv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rich_presence_kv(&mut self, v: ::bytes::Bytes) {
            self.rich_presence_kv = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rich_presence_kv(&mut self) -> &mut ::bytes::Bytes {
            if self.rich_presence_kv.is_none() {
                self.rich_presence_kv = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.rich_presence_kv.as_mut().unwrap()
        }

        // Take field
        pub fn take_rich_presence_kv(&mut self) -> ::bytes::Bytes {
            self.rich_presence_kv.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid_user",
                |m: &RichPresence| { &m.steamid_user },
                |m: &mut RichPresence| { &mut m.steamid_user },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rich_presence_kv",
                |m: &RichPresence| { &m.rich_presence_kv },
                |m: &mut RichPresence| { &mut m.rich_presence_kv },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<RichPresence>(
                "CMsgClientRichPresenceInfo.RichPresence",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for RichPresence {
        const NAME: &'static str = "RichPresence";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid_user = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.rich_presence_kv = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid_user {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                my_size += crate::rt::bytes_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steamid_user {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RichPresence {
            RichPresence::new()
        }

        fn clear(&mut self) {
            self.steamid_user = ::std::option::Option::None;
            self.rich_presence_kv = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RichPresence {
            static instance: RichPresence = RichPresence {
                steamid_user: ::std::option::Option::None,
                rich_presence_kv: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for RichPresence {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceInfo.RichPresence").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RichPresence {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for RichPresence {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientCheckFileSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckFileSignature {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignature.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckFileSignature.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignature {
    fn default() -> &'a CMsgClientCheckFileSignature {
        <CMsgClientCheckFileSignature as crate::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignature {
    pub fn new() -> CMsgClientCheckFileSignature {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientCheckFileSignature| { &m.app_id },
            |m: &mut CMsgClientCheckFileSignature| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckFileSignature>(
            "CMsgClientCheckFileSignature",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCheckFileSignature {
    const NAME: &'static str = "CMsgClientCheckFileSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckFileSignature {
        CMsgClientCheckFileSignature::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignature {
        static instance: CMsgClientCheckFileSignature = CMsgClientCheckFileSignature {
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCheckFileSignature {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckFileSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckFileSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCheckFileSignature {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCheckFileSignatureResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckFileSignatureResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.pid)
    pub pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.esignatureresult)
    pub esignatureresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.sha_file)
    pub sha_file: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.signatureheader)
    pub signatureheader: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.evalvesignaturecheckdetail)
    pub evalvesignaturecheckdetail: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckFileSignatureResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignatureResponse {
    fn default() -> &'a CMsgClientCheckFileSignatureResponse {
        <CMsgClientCheckFileSignatureResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignatureResponse {
    pub fn new() -> CMsgClientCheckFileSignatureResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 pid = 2;

    pub fn pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 3;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 esignatureresult = 5;

    pub fn esignatureresult(&self) -> u32 {
        self.esignatureresult.unwrap_or(0)
    }

    pub fn clear_esignatureresult(&mut self) {
        self.esignatureresult = ::std::option::Option::None;
    }

    pub fn has_esignatureresult(&self) -> bool {
        self.esignatureresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esignatureresult(&mut self, v: u32) {
        self.esignatureresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 6;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::bytes::Bytes) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::bytes::Bytes {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::bytes::Bytes {
        self.sha_file.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes signatureheader = 7;

    pub fn signatureheader(&self) -> &[u8] {
        match self.signatureheader.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signatureheader(&mut self) {
        self.signatureheader = ::std::option::Option::None;
    }

    pub fn has_signatureheader(&self) -> bool {
        self.signatureheader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatureheader(&mut self, v: ::bytes::Bytes) {
        self.signatureheader = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signatureheader(&mut self) -> &mut ::bytes::Bytes {
        if self.signatureheader.is_none() {
            self.signatureheader = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.signatureheader.as_mut().unwrap()
    }

    // Take field
    pub fn take_signatureheader(&mut self) -> ::bytes::Bytes {
        self.signatureheader.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 filesize = 8;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional uint32 getlasterror = 9;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 evalvesignaturecheckdetail = 10;

    pub fn evalvesignaturecheckdetail(&self) -> u32 {
        self.evalvesignaturecheckdetail.unwrap_or(0)
    }

    pub fn clear_evalvesignaturecheckdetail(&mut self) {
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
    }

    pub fn has_evalvesignaturecheckdetail(&self) -> bool {
        self.evalvesignaturecheckdetail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evalvesignaturecheckdetail(&mut self, v: u32) {
        self.evalvesignaturecheckdetail = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.app_id },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pid",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.pid },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.pid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.eresult },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.filename },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "esignatureresult",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.esignatureresult },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.esignatureresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.sha_file },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.sha_file },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "signatureheader",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.signatureheader },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.signatureheader },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.filesize },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filesize },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "getlasterror",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.getlasterror },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.getlasterror },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "evalvesignaturecheckdetail",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.evalvesignaturecheckdetail },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.evalvesignaturecheckdetail },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckFileSignatureResponse>(
            "CMsgClientCheckFileSignatureResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCheckFileSignatureResponse {
    const NAME: &'static str = "CMsgClientCheckFileSignatureResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.esignatureresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.sha_file = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                58 => {
                    self.signatureheader = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                64 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.evalvesignaturecheckdetail = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.pid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.esignatureresult {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += crate::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.signatureheader.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.filesize {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.getlasterror {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            my_size += crate::rt::uint32_size(10, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.esignatureresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.signatureheader.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckFileSignatureResponse {
        CMsgClientCheckFileSignatureResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.pid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.esignatureresult = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.signatureheader = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignatureResponse {
        static instance: CMsgClientCheckFileSignatureResponse = CMsgClientCheckFileSignatureResponse {
            app_id: ::std::option::Option::None,
            pid: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            esignatureresult: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            signatureheader: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            evalvesignaturecheckdetail: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCheckFileSignatureResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckFileSignatureResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckFileSignatureResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCheckFileSignatureResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientReadMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReadMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.cubtoread)
    pub cubtoread: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReadMachineAuth.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuth {
    fn default() -> &'a CMsgClientReadMachineAuth {
        <CMsgClientReadMachineAuth as crate::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuth {
    pub fn new() -> CMsgClientReadMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtoread = 3;

    pub fn cubtoread(&self) -> u32 {
        self.cubtoread.unwrap_or(0)
    }

    pub fn clear_cubtoread(&mut self) {
        self.cubtoread = ::std::option::Option::None;
    }

    pub fn has_cubtoread(&self) -> bool {
        self.cubtoread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtoread(&mut self, v: u32) {
        self.cubtoread = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientReadMachineAuth| { &m.filename },
            |m: &mut CMsgClientReadMachineAuth| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientReadMachineAuth| { &m.offset },
            |m: &mut CMsgClientReadMachineAuth| { &mut m.offset },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubtoread",
            |m: &CMsgClientReadMachineAuth| { &m.cubtoread },
            |m: &mut CMsgClientReadMachineAuth| { &mut m.cubtoread },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientReadMachineAuth>(
            "CMsgClientReadMachineAuth",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientReadMachineAuth {
    const NAME: &'static str = "CMsgClientReadMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cubtoread = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubtoread {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtoread {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReadMachineAuth {
        CMsgClientReadMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubtoread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuth {
        static instance: CMsgClientReadMachineAuth = CMsgClientReadMachineAuth {
            filename: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubtoread: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientReadMachineAuth {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientReadMachineAuth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientReadMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientReadMachineAuth {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientReadMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReadMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.sha_file)
    pub sha_file: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.cubread)
    pub cubread: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.bytes_read)
    pub bytes_read: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filename_sentry)
    pub filename_sentry: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReadMachineAuthResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuthResponse {
    fn default() -> &'a CMsgClientReadMachineAuthResponse {
        <CMsgClientReadMachineAuthResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuthResponse {
    pub fn new() -> CMsgClientReadMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::bytes::Bytes) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::bytes::Bytes {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::bytes::Bytes {
        self.sha_file.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubread = 7;

    pub fn cubread(&self) -> u32 {
        self.cubread.unwrap_or(0)
    }

    pub fn clear_cubread(&mut self) {
        self.cubread = ::std::option::Option::None;
    }

    pub fn has_cubread(&self) -> bool {
        self.cubread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubread(&mut self, v: u32) {
        self.cubread = ::std::option::Option::Some(v);
    }

    // optional bytes bytes_read = 8;

    pub fn bytes_read(&self) -> &[u8] {
        match self.bytes_read.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_read(&mut self) {
        self.bytes_read = ::std::option::Option::None;
    }

    pub fn has_bytes_read(&self) -> bool {
        self.bytes_read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_read(&mut self, v: ::bytes::Bytes) {
        self.bytes_read = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_read(&mut self) -> &mut ::bytes::Bytes {
        if self.bytes_read.is_none() {
            self.bytes_read = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.bytes_read.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_read(&mut self) -> ::bytes::Bytes {
        self.bytes_read.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional string filename_sentry = 9;

    pub fn filename_sentry(&self) -> &str {
        match self.filename_sentry.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename_sentry(&mut self) {
        self.filename_sentry = ::std::option::Option::None;
    }

    pub fn has_filename_sentry(&self) -> bool {
        self.filename_sentry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename_sentry(&mut self, v: ::std::string::String) {
        self.filename_sentry = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename_sentry(&mut self) -> &mut ::std::string::String {
        if self.filename_sentry.is_none() {
            self.filename_sentry = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename_sentry.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename_sentry(&mut self) -> ::std::string::String {
        self.filename_sentry.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientReadMachineAuthResponse| { &m.filename },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientReadMachineAuthResponse| { &m.eresult },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientReadMachineAuthResponse| { &m.filesize },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filesize },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientReadMachineAuthResponse| { &m.sha_file },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.sha_file },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "getlasterror",
            |m: &CMsgClientReadMachineAuthResponse| { &m.getlasterror },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.getlasterror },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientReadMachineAuthResponse| { &m.offset },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.offset },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubread",
            |m: &CMsgClientReadMachineAuthResponse| { &m.cubread },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.cubread },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_read",
            |m: &CMsgClientReadMachineAuthResponse| { &m.bytes_read },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.bytes_read },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename_sentry",
            |m: &CMsgClientReadMachineAuthResponse| { &m.filename_sentry },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename_sentry },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientReadMachineAuthResponse>(
            "CMsgClientReadMachineAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientReadMachineAuthResponse {
    const NAME: &'static str = "CMsgClientReadMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cubread = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.bytes_read = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                74 => {
                    self.filename_sentry = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.offset {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cubread {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bytes_read.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubread {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_read.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReadMachineAuthResponse {
        CMsgClientReadMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubread = ::std::option::Option::None;
        self.bytes_read = ::std::option::Option::None;
        self.filename_sentry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuthResponse {
        static instance: CMsgClientReadMachineAuthResponse = CMsgClientReadMachineAuthResponse {
            filename: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubread: ::std::option::Option::None,
            bytes_read: ::std::option::Option::None,
            filename_sentry: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientReadMachineAuthResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientReadMachineAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientReadMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientReadMachineAuthResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUpdateMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.cubtowrite)
    pub cubtowrite: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.bytes)
    pub bytes: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_type)
    pub otp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_sharedsecret)
    pub otp_sharedsecret: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_timedrift)
    pub otp_timedrift: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateMachineAuth.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuth {
    fn default() -> &'a CMsgClientUpdateMachineAuth {
        <CMsgClientUpdateMachineAuth as crate::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuth {
    pub fn new() -> CMsgClientUpdateMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtowrite = 3;

    pub fn cubtowrite(&self) -> u32 {
        self.cubtowrite.unwrap_or(0)
    }

    pub fn clear_cubtowrite(&mut self) {
        self.cubtowrite = ::std::option::Option::None;
    }

    pub fn has_cubtowrite(&self) -> bool {
        self.cubtowrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtowrite(&mut self, v: u32) {
        self.cubtowrite = ::std::option::Option::Some(v);
    }

    // optional bytes bytes = 4;

    pub fn bytes(&self) -> &[u8] {
        match self.bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::bytes::Bytes) {
        self.bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::bytes::Bytes {
        if self.bytes.is_none() {
            self.bytes = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::bytes::Bytes {
        self.bytes.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 otp_type = 5;

    pub fn otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 6;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 7;

    pub fn otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret = ::std::option::Option::None;
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::bytes::Bytes) {
        self.otp_sharedsecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::bytes::Bytes {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::bytes::Bytes {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 otp_timedrift = 8;

    pub fn otp_timedrift(&self) -> u32 {
        self.otp_timedrift.unwrap_or(0)
    }

    pub fn clear_otp_timedrift(&mut self) {
        self.otp_timedrift = ::std::option::Option::None;
    }

    pub fn has_otp_timedrift(&self) -> bool {
        self.otp_timedrift.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_timedrift(&mut self, v: u32) {
        self.otp_timedrift = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientUpdateMachineAuth| { &m.filename },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientUpdateMachineAuth| { &m.offset },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.offset },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubtowrite",
            |m: &CMsgClientUpdateMachineAuth| { &m.cubtowrite },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.cubtowrite },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes",
            |m: &CMsgClientUpdateMachineAuth| { &m.bytes },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.bytes },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_type",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_type },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_identifier",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_identifier },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_identifier },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_sharedsecret",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_sharedsecret },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_sharedsecret },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_timedrift",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_timedrift },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_timedrift },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUpdateMachineAuth>(
            "CMsgClientUpdateMachineAuth",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUpdateMachineAuth {
    const NAME: &'static str = "CMsgClientUpdateMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cubtowrite = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.bytes = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.otp_sharedsecret = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                64 => {
                    self.otp_timedrift = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubtowrite {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.bytes.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.otp_type {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.otp_timedrift {
            my_size += crate::rt::uint32_size(8, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtowrite {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.bytes.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.otp_timedrift {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateMachineAuth {
        CMsgClientUpdateMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubtowrite = ::std::option::Option::None;
        self.bytes = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.otp_sharedsecret = ::std::option::Option::None;
        self.otp_timedrift = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuth {
        static instance: CMsgClientUpdateMachineAuth = CMsgClientUpdateMachineAuth {
            filename: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubtowrite: ::std::option::Option::None,
            bytes: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            otp_sharedsecret: ::std::option::Option::None,
            otp_timedrift: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUpdateMachineAuth {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUpdateMachineAuth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUpdateMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUpdateMachineAuth {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUpdateMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.sha_file)
    pub sha_file: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.cubwrote)
    pub cubwrote: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_type)
    pub otp_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_value)
    pub otp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateMachineAuthResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuthResponse {
    fn default() -> &'a CMsgClientUpdateMachineAuthResponse {
        <CMsgClientUpdateMachineAuthResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuthResponse {
    pub fn new() -> CMsgClientUpdateMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::bytes::Bytes) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::bytes::Bytes {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::bytes::Bytes {
        self.sha_file.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubwrote = 7;

    pub fn cubwrote(&self) -> u32 {
        self.cubwrote.unwrap_or(0)
    }

    pub fn clear_cubwrote(&mut self) {
        self.cubwrote = ::std::option::Option::None;
    }

    pub fn has_cubwrote(&self) -> bool {
        self.cubwrote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubwrote(&mut self, v: u32) {
        self.cubwrote = ::std::option::Option::Some(v);
    }

    // optional int32 otp_type = 8;

    pub fn otp_type(&self) -> i32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: i32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_value = 9;

    pub fn otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 10;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.filename },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.eresult },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.filesize },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filesize },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.sha_file },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.sha_file },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "getlasterror",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.getlasterror },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.getlasterror },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.offset },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.offset },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubwrote",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.cubwrote },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.cubwrote },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_type",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_type },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_value",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_value },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_identifier",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_identifier },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_identifier },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUpdateMachineAuthResponse>(
            "CMsgClientUpdateMachineAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUpdateMachineAuthResponse {
    const NAME: &'static str = "CMsgClientUpdateMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cubwrote = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.otp_type = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.offset {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cubwrote {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.otp_type {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.otp_value {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubwrote {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateMachineAuthResponse {
        CMsgClientUpdateMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubwrote = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuthResponse {
        static instance: CMsgClientUpdateMachineAuthResponse = CMsgClientUpdateMachineAuthResponse {
            filename: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubwrote: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_value: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUpdateMachineAuthResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUpdateMachineAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUpdateMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUpdateMachineAuthResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.eresult_sentryfile)
    pub eresult_sentryfile: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.sha_sentryfile)
    pub sha_sentryfile: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.lock_account_action)
    pub lock_account_action: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_type)
    pub otp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_sharedsecret)
    pub otp_sharedsecret: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_value)
    pub otp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.machine_name_userchosen)
    pub machine_name_userchosen: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestMachineAuth.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuth {
    fn default() -> &'a CMsgClientRequestMachineAuth {
        <CMsgClientRequestMachineAuth as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuth {
    pub fn new() -> CMsgClientRequestMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult_sentryfile = 2;

    pub fn eresult_sentryfile(&self) -> u32 {
        self.eresult_sentryfile.unwrap_or(0)
    }

    pub fn clear_eresult_sentryfile(&mut self) {
        self.eresult_sentryfile = ::std::option::Option::None;
    }

    pub fn has_eresult_sentryfile(&self) -> bool {
        self.eresult_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult_sentryfile(&mut self, v: u32) {
        self.eresult_sentryfile = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_sentryfile = 4;

    pub fn sha_sentryfile(&self) -> &[u8] {
        match self.sha_sentryfile.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_sentryfile(&mut self) {
        self.sha_sentryfile = ::std::option::Option::None;
    }

    pub fn has_sha_sentryfile(&self) -> bool {
        self.sha_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_sentryfile(&mut self, v: ::bytes::Bytes) {
        self.sha_sentryfile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_sentryfile(&mut self) -> &mut ::bytes::Bytes {
        if self.sha_sentryfile.is_none() {
            self.sha_sentryfile = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sha_sentryfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_sentryfile(&mut self) -> ::bytes::Bytes {
        self.sha_sentryfile.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 lock_account_action = 6;

    pub fn lock_account_action(&self) -> i32 {
        self.lock_account_action.unwrap_or(0)
    }

    pub fn clear_lock_account_action(&mut self) {
        self.lock_account_action = ::std::option::Option::None;
    }

    pub fn has_lock_account_action(&self) -> bool {
        self.lock_account_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_account_action(&mut self, v: i32) {
        self.lock_account_action = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_type = 7;

    pub fn otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 8;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 9;

    pub fn otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret = ::std::option::Option::None;
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::bytes::Bytes) {
        self.otp_sharedsecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::bytes::Bytes {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::bytes::Bytes {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 otp_value = 10;

    pub fn otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 11;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name_userchosen = 12;

    pub fn machine_name_userchosen(&self) -> &str {
        match self.machine_name_userchosen.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name_userchosen(&mut self) {
        self.machine_name_userchosen = ::std::option::Option::None;
    }

    pub fn has_machine_name_userchosen(&self) -> bool {
        self.machine_name_userchosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name_userchosen(&mut self, v: ::std::string::String) {
        self.machine_name_userchosen = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name_userchosen(&mut self) -> &mut ::std::string::String {
        if self.machine_name_userchosen.is_none() {
            self.machine_name_userchosen = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name_userchosen.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name_userchosen(&mut self) -> ::std::string::String {
        self.machine_name_userchosen.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientRequestMachineAuth| { &m.filename },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult_sentryfile",
            |m: &CMsgClientRequestMachineAuth| { &m.eresult_sentryfile },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.eresult_sentryfile },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientRequestMachineAuth| { &m.filesize },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.filesize },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_sentryfile",
            |m: &CMsgClientRequestMachineAuth| { &m.sha_sentryfile },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.sha_sentryfile },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lock_account_action",
            |m: &CMsgClientRequestMachineAuth| { &m.lock_account_action },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.lock_account_action },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_type",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_type },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_identifier",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_identifier },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_identifier },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_sharedsecret",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_sharedsecret },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_sharedsecret },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_value",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_value },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name",
            |m: &CMsgClientRequestMachineAuth| { &m.machine_name },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name_userchosen",
            |m: &CMsgClientRequestMachineAuth| { &m.machine_name_userchosen },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name_userchosen },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestMachineAuth>(
            "CMsgClientRequestMachineAuth",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestMachineAuth {
    const NAME: &'static str = "CMsgClientRequestMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult_sentryfile = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_sentryfile = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                48 => {
                    self.lock_account_action = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.otp_sharedsecret = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                80 => {
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.machine_name_userchosen = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult_sentryfile {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.lock_account_action {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.otp_type {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += crate::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.otp_value {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult_sentryfile {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.lock_account_action {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestMachineAuth {
        CMsgClientRequestMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult_sentryfile = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_sentryfile = ::std::option::Option::None;
        self.lock_account_action = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.otp_sharedsecret = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.machine_name_userchosen = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuth {
        static instance: CMsgClientRequestMachineAuth = CMsgClientRequestMachineAuth {
            filename: ::std::option::Option::None,
            eresult_sentryfile: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_sentryfile: ::std::option::Option::None,
            lock_account_action: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            otp_sharedsecret: ::std::option::Option::None,
            otp_value: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            machine_name_userchosen: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestMachineAuth {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestMachineAuth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestMachineAuth {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestMachineAuthResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuthResponse {
    fn default() -> &'a CMsgClientRequestMachineAuthResponse {
        <CMsgClientRequestMachineAuthResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuthResponse {
    pub fn new() -> CMsgClientRequestMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestMachineAuthResponse| { &m.eresult },
            |m: &mut CMsgClientRequestMachineAuthResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestMachineAuthResponse>(
            "CMsgClientRequestMachineAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestMachineAuthResponse {
    const NAME: &'static str = "CMsgClientRequestMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestMachineAuthResponse {
        CMsgClientRequestMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuthResponse {
        static instance: CMsgClientRequestMachineAuthResponse = CMsgClientRequestMachineAuthResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestMachineAuthResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestMachineAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestMachineAuthResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRegisterKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterKey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterKey.key)
    pub key: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterKey.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterKey {
    fn default() -> &'a CMsgClientRegisterKey {
        <CMsgClientRegisterKey as crate::Message>::default_instance()
    }
}

impl CMsgClientRegisterKey {
    pub fn new() -> CMsgClientRegisterKey {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CMsgClientRegisterKey| { &m.key },
            |m: &mut CMsgClientRegisterKey| { &mut m.key },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterKey>(
            "CMsgClientRegisterKey",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRegisterKey {
    const NAME: &'static str = "CMsgClientRegisterKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterKey {
        CMsgClientRegisterKey::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterKey {
        static instance: CMsgClientRegisterKey = CMsgClientRegisterKey {
            key: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRegisterKey {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRegisterKey {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPurchaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.purchase_result_details)
    pub purchase_result_details: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.purchase_receipt_info)
    pub purchase_receipt_info: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPurchaseResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseResponse {
    fn default() -> &'a CMsgClientPurchaseResponse {
        <CMsgClientPurchaseResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientPurchaseResponse {
    pub fn new() -> CMsgClientPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 purchase_result_details = 2;

    pub fn purchase_result_details(&self) -> i32 {
        self.purchase_result_details.unwrap_or(0)
    }

    pub fn clear_purchase_result_details(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
    }

    pub fn has_purchase_result_details(&self) -> bool {
        self.purchase_result_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_result_details(&mut self, v: i32) {
        self.purchase_result_details = ::std::option::Option::Some(v);
    }

    // optional bytes purchase_receipt_info = 3;

    pub fn purchase_receipt_info(&self) -> &[u8] {
        match self.purchase_receipt_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_purchase_receipt_info(&mut self) {
        self.purchase_receipt_info = ::std::option::Option::None;
    }

    pub fn has_purchase_receipt_info(&self) -> bool {
        self.purchase_receipt_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_receipt_info(&mut self, v: ::bytes::Bytes) {
        self.purchase_receipt_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_receipt_info(&mut self) -> &mut ::bytes::Bytes {
        if self.purchase_receipt_info.is_none() {
            self.purchase_receipt_info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.purchase_receipt_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_purchase_receipt_info(&mut self) -> ::bytes::Bytes {
        self.purchase_receipt_info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientPurchaseResponse| { &m.eresult },
            |m: &mut CMsgClientPurchaseResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_result_details",
            |m: &CMsgClientPurchaseResponse| { &m.purchase_result_details },
            |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_result_details },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_receipt_info",
            |m: &CMsgClientPurchaseResponse| { &m.purchase_receipt_info },
            |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_receipt_info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPurchaseResponse>(
            "CMsgClientPurchaseResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientPurchaseResponse {
    const NAME: &'static str = "CMsgClientPurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.purchase_result_details = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.purchase_receipt_info = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.purchase_result_details {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchase_result_details {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPurchaseResponse {
        CMsgClientPurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.purchase_result_details = ::std::option::Option::None;
        self.purchase_receipt_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPurchaseResponse {
        static instance: CMsgClientPurchaseResponse = CMsgClientPurchaseResponse {
            eresult: ::std::option::Option::None,
            purchase_result_details: ::std::option::Option::None,
            purchase_receipt_info: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientPurchaseResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPurchaseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientPurchaseResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientActivateOEMLicense)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientActivateOEMLicense {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.bios_manufacturer)
    pub bios_manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.bios_serialnumber)
    pub bios_serialnumber: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.license_file)
    pub license_file: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_manufacturer)
    pub mainboard_manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_product)
    pub mainboard_product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_serialnumber)
    pub mainboard_serialnumber: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientActivateOEMLicense.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientActivateOEMLicense {
    fn default() -> &'a CMsgClientActivateOEMLicense {
        <CMsgClientActivateOEMLicense as crate::Message>::default_instance()
    }
}

impl CMsgClientActivateOEMLicense {
    pub fn new() -> CMsgClientActivateOEMLicense {
        ::std::default::Default::default()
    }

    // optional string bios_manufacturer = 1;

    pub fn bios_manufacturer(&self) -> &str {
        match self.bios_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_manufacturer(&mut self) {
        self.bios_manufacturer = ::std::option::Option::None;
    }

    pub fn has_bios_manufacturer(&self) -> bool {
        self.bios_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_manufacturer(&mut self, v: ::std::string::String) {
        self.bios_manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.bios_manufacturer.is_none() {
            self.bios_manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bios_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_manufacturer(&mut self) -> ::std::string::String {
        self.bios_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bios_serialnumber = 2;

    pub fn bios_serialnumber(&self) -> &str {
        match self.bios_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_serialnumber(&mut self) {
        self.bios_serialnumber = ::std::option::Option::None;
    }

    pub fn has_bios_serialnumber(&self) -> bool {
        self.bios_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_serialnumber(&mut self, v: ::std::string::String) {
        self.bios_serialnumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.bios_serialnumber.is_none() {
            self.bios_serialnumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bios_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_serialnumber(&mut self) -> ::std::string::String {
        self.bios_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes license_file = 3;

    pub fn license_file(&self) -> &[u8] {
        match self.license_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_license_file(&mut self) {
        self.license_file = ::std::option::Option::None;
    }

    pub fn has_license_file(&self) -> bool {
        self.license_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_file(&mut self, v: ::bytes::Bytes) {
        self.license_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license_file(&mut self) -> &mut ::bytes::Bytes {
        if self.license_file.is_none() {
            self.license_file = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.license_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_license_file(&mut self) -> ::bytes::Bytes {
        self.license_file.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional string mainboard_manufacturer = 4;

    pub fn mainboard_manufacturer(&self) -> &str {
        match self.mainboard_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_manufacturer(&mut self) {
        self.mainboard_manufacturer = ::std::option::Option::None;
    }

    pub fn has_mainboard_manufacturer(&self) -> bool {
        self.mainboard_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_manufacturer(&mut self, v: ::std::string::String) {
        self.mainboard_manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.mainboard_manufacturer.is_none() {
            self.mainboard_manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_manufacturer(&mut self) -> ::std::string::String {
        self.mainboard_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_product = 5;

    pub fn mainboard_product(&self) -> &str {
        match self.mainboard_product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_product(&mut self) {
        self.mainboard_product = ::std::option::Option::None;
    }

    pub fn has_mainboard_product(&self) -> bool {
        self.mainboard_product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_product(&mut self, v: ::std::string::String) {
        self.mainboard_product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_product(&mut self) -> &mut ::std::string::String {
        if self.mainboard_product.is_none() {
            self.mainboard_product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_product.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_product(&mut self) -> ::std::string::String {
        self.mainboard_product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_serialnumber = 6;

    pub fn mainboard_serialnumber(&self) -> &str {
        match self.mainboard_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_serialnumber(&mut self) {
        self.mainboard_serialnumber = ::std::option::Option::None;
    }

    pub fn has_mainboard_serialnumber(&self) -> bool {
        self.mainboard_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_serialnumber(&mut self, v: ::std::string::String) {
        self.mainboard_serialnumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.mainboard_serialnumber.is_none() {
            self.mainboard_serialnumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_serialnumber(&mut self) -> ::std::string::String {
        self.mainboard_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bios_manufacturer",
            |m: &CMsgClientActivateOEMLicense| { &m.bios_manufacturer },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_manufacturer },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bios_serialnumber",
            |m: &CMsgClientActivateOEMLicense| { &m.bios_serialnumber },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_serialnumber },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "license_file",
            |m: &CMsgClientActivateOEMLicense| { &m.license_file },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.license_file },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mainboard_manufacturer",
            |m: &CMsgClientActivateOEMLicense| { &m.mainboard_manufacturer },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_manufacturer },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mainboard_product",
            |m: &CMsgClientActivateOEMLicense| { &m.mainboard_product },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_product },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mainboard_serialnumber",
            |m: &CMsgClientActivateOEMLicense| { &m.mainboard_serialnumber },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_serialnumber },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientActivateOEMLicense>(
            "CMsgClientActivateOEMLicense",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientActivateOEMLicense {
    const NAME: &'static str = "CMsgClientActivateOEMLicense";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bios_manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.bios_serialnumber = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.license_file = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                34 => {
                    self.mainboard_manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.mainboard_product = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.mainboard_serialnumber = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bios_manufacturer.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.license_file.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.bios_manufacturer.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.license_file.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientActivateOEMLicense {
        CMsgClientActivateOEMLicense::new()
    }

    fn clear(&mut self) {
        self.bios_manufacturer = ::std::option::Option::None;
        self.bios_serialnumber = ::std::option::Option::None;
        self.license_file = ::std::option::Option::None;
        self.mainboard_manufacturer = ::std::option::Option::None;
        self.mainboard_product = ::std::option::Option::None;
        self.mainboard_serialnumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientActivateOEMLicense {
        static instance: CMsgClientActivateOEMLicense = CMsgClientActivateOEMLicense {
            bios_manufacturer: ::std::option::Option::None,
            bios_serialnumber: ::std::option::Option::None,
            license_file: ::std::option::Option::None,
            mainboard_manufacturer: ::std::option::Option::None,
            mainboard_product: ::std::option::Option::None,
            mainboard_serialnumber: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientActivateOEMLicense {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientActivateOEMLicense").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientActivateOEMLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientActivateOEMLicense {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRegisterOEMMachine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterOEMMachine {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterOEMMachine.oem_register_file)
    pub oem_register_file: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterOEMMachine.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachine {
    fn default() -> &'a CMsgClientRegisterOEMMachine {
        <CMsgClientRegisterOEMMachine as crate::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachine {
    pub fn new() -> CMsgClientRegisterOEMMachine {
        ::std::default::Default::default()
    }

    // optional bytes oem_register_file = 1;

    pub fn oem_register_file(&self) -> &[u8] {
        match self.oem_register_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_oem_register_file(&mut self) {
        self.oem_register_file = ::std::option::Option::None;
    }

    pub fn has_oem_register_file(&self) -> bool {
        self.oem_register_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oem_register_file(&mut self, v: ::bytes::Bytes) {
        self.oem_register_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oem_register_file(&mut self) -> &mut ::bytes::Bytes {
        if self.oem_register_file.is_none() {
            self.oem_register_file = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.oem_register_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_oem_register_file(&mut self) -> ::bytes::Bytes {
        self.oem_register_file.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "oem_register_file",
            |m: &CMsgClientRegisterOEMMachine| { &m.oem_register_file },
            |m: &mut CMsgClientRegisterOEMMachine| { &mut m.oem_register_file },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterOEMMachine>(
            "CMsgClientRegisterOEMMachine",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRegisterOEMMachine {
    const NAME: &'static str = "CMsgClientRegisterOEMMachine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.oem_register_file = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.oem_register_file.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.oem_register_file.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterOEMMachine {
        CMsgClientRegisterOEMMachine::new()
    }

    fn clear(&mut self) {
        self.oem_register_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachine {
        static instance: CMsgClientRegisterOEMMachine = CMsgClientRegisterOEMMachine {
            oem_register_file: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRegisterOEMMachine {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterOEMMachine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterOEMMachine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRegisterOEMMachine {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRegisterOEMMachineResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterOEMMachineResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterOEMMachineResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterOEMMachineResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachineResponse {
    fn default() -> &'a CMsgClientRegisterOEMMachineResponse {
        <CMsgClientRegisterOEMMachineResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachineResponse {
    pub fn new() -> CMsgClientRegisterOEMMachineResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRegisterOEMMachineResponse| { &m.eresult },
            |m: &mut CMsgClientRegisterOEMMachineResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterOEMMachineResponse>(
            "CMsgClientRegisterOEMMachineResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRegisterOEMMachineResponse {
    const NAME: &'static str = "CMsgClientRegisterOEMMachineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterOEMMachineResponse {
        CMsgClientRegisterOEMMachineResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachineResponse {
        static instance: CMsgClientRegisterOEMMachineResponse = CMsgClientRegisterOEMMachineResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRegisterOEMMachineResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterOEMMachineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterOEMMachineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRegisterOEMMachineResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPurchaseWithMachineID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPurchaseWithMachineID {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPurchaseWithMachineID.package_id)
    pub package_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseWithMachineID.machine_info)
    pub machine_info: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPurchaseWithMachineID.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseWithMachineID {
    fn default() -> &'a CMsgClientPurchaseWithMachineID {
        <CMsgClientPurchaseWithMachineID as crate::Message>::default_instance()
    }
}

impl CMsgClientPurchaseWithMachineID {
    pub fn new() -> CMsgClientPurchaseWithMachineID {
        ::std::default::Default::default()
    }

    // optional uint32 package_id = 1;

    pub fn package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional bytes machine_info = 2;

    pub fn machine_info(&self) -> &[u8] {
        match self.machine_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_machine_info(&mut self) {
        self.machine_info = ::std::option::Option::None;
    }

    pub fn has_machine_info(&self) -> bool {
        self.machine_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_info(&mut self, v: ::bytes::Bytes) {
        self.machine_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_info(&mut self) -> &mut ::bytes::Bytes {
        if self.machine_info.is_none() {
            self.machine_info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.machine_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_info(&mut self) -> ::bytes::Bytes {
        self.machine_info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_id",
            |m: &CMsgClientPurchaseWithMachineID| { &m.package_id },
            |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.package_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_info",
            |m: &CMsgClientPurchaseWithMachineID| { &m.machine_info },
            |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.machine_info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPurchaseWithMachineID>(
            "CMsgClientPurchaseWithMachineID",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientPurchaseWithMachineID {
    const NAME: &'static str = "CMsgClientPurchaseWithMachineID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.machine_info = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.package_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.machine_info.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.package_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.machine_info.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPurchaseWithMachineID {
        CMsgClientPurchaseWithMachineID::new()
    }

    fn clear(&mut self) {
        self.package_id = ::std::option::Option::None;
        self.machine_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPurchaseWithMachineID {
        static instance: CMsgClientPurchaseWithMachineID = CMsgClientPurchaseWithMachineID {
            package_id: ::std::option::Option::None,
            machine_info: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientPurchaseWithMachineID {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPurchaseWithMachineID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPurchaseWithMachineID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientPurchaseWithMachineID {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_InitiateTradeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_InitiateTradeRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.trade_request_id)
    pub trade_request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.other_name)
    pub other_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_InitiateTradeRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeRequest {
    fn default() -> &'a CMsgTrading_InitiateTradeRequest {
        <CMsgTrading_InitiateTradeRequest as crate::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeRequest {
    pub fn new() -> CMsgTrading_InitiateTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint32 trade_request_id = 1;

    pub fn trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 2;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional string other_name = 3;

    pub fn other_name(&self) -> &str {
        match self.other_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_other_name(&mut self) {
        self.other_name = ::std::option::Option::None;
    }

    pub fn has_other_name(&self) -> bool {
        self.other_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_name(&mut self, v: ::std::string::String) {
        self.other_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_name(&mut self) -> &mut ::std::string::String {
        if self.other_name.is_none() {
            self.other_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.other_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_name(&mut self) -> ::std::string::String {
        self.other_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_request_id",
            |m: &CMsgTrading_InitiateTradeRequest| { &m.trade_request_id },
            |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.trade_request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_InitiateTradeRequest| { &m.other_steamid },
            |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_name",
            |m: &CMsgTrading_InitiateTradeRequest| { &m.other_name },
            |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_InitiateTradeRequest>(
            "CMsgTrading_InitiateTradeRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgTrading_InitiateTradeRequest {
    const NAME: &'static str = "CMsgTrading_InitiateTradeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.other_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trade_request_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.other_steamid {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.other_name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.trade_request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.other_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_InitiateTradeRequest {
        CMsgTrading_InitiateTradeRequest::new()
    }

    fn clear(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.other_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeRequest {
        static instance: CMsgTrading_InitiateTradeRequest = CMsgTrading_InitiateTradeRequest {
            trade_request_id: ::std::option::Option::None,
            other_steamid: ::std::option::Option::None,
            other_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgTrading_InitiateTradeRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_InitiateTradeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_InitiateTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgTrading_InitiateTradeRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_InitiateTradeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_InitiateTradeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.trade_request_id)
    pub trade_request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.steamguard_required_days)
    pub steamguard_required_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.new_device_cooldown_days)
    pub new_device_cooldown_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.default_password_reset_probation_days)
    pub default_password_reset_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.password_reset_probation_days)
    pub password_reset_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.default_email_change_probation_days)
    pub default_email_change_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.email_change_probation_days)
    pub email_change_probation_days: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_InitiateTradeResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeResponse {
    fn default() -> &'a CMsgTrading_InitiateTradeResponse {
        <CMsgTrading_InitiateTradeResponse as crate::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeResponse {
    pub fn new() -> CMsgTrading_InitiateTradeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint32 trade_request_id = 2;

    pub fn trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 3;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 steamguard_required_days = 4;

    pub fn steamguard_required_days(&self) -> u32 {
        self.steamguard_required_days.unwrap_or(0)
    }

    pub fn clear_steamguard_required_days(&mut self) {
        self.steamguard_required_days = ::std::option::Option::None;
    }

    pub fn has_steamguard_required_days(&self) -> bool {
        self.steamguard_required_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_required_days(&mut self, v: u32) {
        self.steamguard_required_days = ::std::option::Option::Some(v);
    }

    // optional uint32 new_device_cooldown_days = 5;

    pub fn new_device_cooldown_days(&self) -> u32 {
        self.new_device_cooldown_days.unwrap_or(0)
    }

    pub fn clear_new_device_cooldown_days(&mut self) {
        self.new_device_cooldown_days = ::std::option::Option::None;
    }

    pub fn has_new_device_cooldown_days(&self) -> bool {
        self.new_device_cooldown_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_device_cooldown_days(&mut self, v: u32) {
        self.new_device_cooldown_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_password_reset_probation_days = 6;

    pub fn default_password_reset_probation_days(&self) -> u32 {
        self.default_password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_default_password_reset_probation_days(&mut self) {
        self.default_password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_password_reset_probation_days(&self) -> bool {
        self.default_password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_password_reset_probation_days(&mut self, v: u32) {
        self.default_password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 password_reset_probation_days = 7;

    pub fn password_reset_probation_days(&self) -> u32 {
        self.password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_password_reset_probation_days(&mut self) {
        self.password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_password_reset_probation_days(&self) -> bool {
        self.password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_reset_probation_days(&mut self, v: u32) {
        self.password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_email_change_probation_days = 8;

    pub fn default_email_change_probation_days(&self) -> u32 {
        self.default_email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_default_email_change_probation_days(&mut self) {
        self.default_email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_email_change_probation_days(&self) -> bool {
        self.default_email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_email_change_probation_days(&mut self, v: u32) {
        self.default_email_change_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 email_change_probation_days = 9;

    pub fn email_change_probation_days(&self) -> u32 {
        self.email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_email_change_probation_days(&mut self) {
        self.email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_email_change_probation_days(&self) -> bool {
        self.email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_change_probation_days(&mut self, v: u32) {
        self.email_change_probation_days = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.response },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.response },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_request_id",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.trade_request_id },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.trade_request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.other_steamid },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.other_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamguard_required_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.steamguard_required_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.steamguard_required_days },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_device_cooldown_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.new_device_cooldown_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.new_device_cooldown_days },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_password_reset_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.default_password_reset_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_password_reset_probation_days },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "password_reset_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.password_reset_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.password_reset_probation_days },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_email_change_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.default_email_change_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_email_change_probation_days },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_change_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.email_change_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.email_change_probation_days },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_InitiateTradeResponse>(
            "CMsgTrading_InitiateTradeResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgTrading_InitiateTradeResponse {
    const NAME: &'static str = "CMsgTrading_InitiateTradeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.steamguard_required_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.new_device_cooldown_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.default_password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.default_email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trade_request_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.other_steamid {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamguard_required_days {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.new_device_cooldown_days {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.default_password_reset_probation_days {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.password_reset_probation_days {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.default_email_change_probation_days {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.email_change_probation_days {
            my_size += crate::rt::uint32_size(9, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trade_request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamguard_required_days {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.new_device_cooldown_days {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.default_password_reset_probation_days {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.password_reset_probation_days {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.default_email_change_probation_days {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.email_change_probation_days {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_InitiateTradeResponse {
        CMsgTrading_InitiateTradeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.steamguard_required_days = ::std::option::Option::None;
        self.new_device_cooldown_days = ::std::option::Option::None;
        self.default_password_reset_probation_days = ::std::option::Option::None;
        self.password_reset_probation_days = ::std::option::Option::None;
        self.default_email_change_probation_days = ::std::option::Option::None;
        self.email_change_probation_days = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeResponse {
        static instance: CMsgTrading_InitiateTradeResponse = CMsgTrading_InitiateTradeResponse {
            response: ::std::option::Option::None,
            trade_request_id: ::std::option::Option::None,
            other_steamid: ::std::option::Option::None,
            steamguard_required_days: ::std::option::Option::None,
            new_device_cooldown_days: ::std::option::Option::None,
            default_password_reset_probation_days: ::std::option::Option::None,
            password_reset_probation_days: ::std::option::Option::None,
            default_email_change_probation_days: ::std::option::Option::None,
            email_change_probation_days: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgTrading_InitiateTradeResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_InitiateTradeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_InitiateTradeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgTrading_InitiateTradeResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_CancelTradeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_CancelTradeRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_CancelTradeRequest.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_CancelTradeRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_CancelTradeRequest {
    fn default() -> &'a CMsgTrading_CancelTradeRequest {
        <CMsgTrading_CancelTradeRequest as crate::Message>::default_instance()
    }
}

impl CMsgTrading_CancelTradeRequest {
    pub fn new() -> CMsgTrading_CancelTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_CancelTradeRequest| { &m.other_steamid },
            |m: &mut CMsgTrading_CancelTradeRequest| { &mut m.other_steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_CancelTradeRequest>(
            "CMsgTrading_CancelTradeRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgTrading_CancelTradeRequest {
    const NAME: &'static str = "CMsgTrading_CancelTradeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_CancelTradeRequest {
        CMsgTrading_CancelTradeRequest::new()
    }

    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_CancelTradeRequest {
        static instance: CMsgTrading_CancelTradeRequest = CMsgTrading_CancelTradeRequest {
            other_steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgTrading_CancelTradeRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_CancelTradeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_CancelTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgTrading_CancelTradeRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_StartSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_StartSession {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_StartSession.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_StartSession.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_StartSession {
    fn default() -> &'a CMsgTrading_StartSession {
        <CMsgTrading_StartSession as crate::Message>::default_instance()
    }
}

impl CMsgTrading_StartSession {
    pub fn new() -> CMsgTrading_StartSession {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_StartSession| { &m.other_steamid },
            |m: &mut CMsgTrading_StartSession| { &mut m.other_steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_StartSession>(
            "CMsgTrading_StartSession",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgTrading_StartSession {
    const NAME: &'static str = "CMsgTrading_StartSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_StartSession {
        CMsgTrading_StartSession::new()
    }

    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_StartSession {
        static instance: CMsgTrading_StartSession = CMsgTrading_StartSession {
            other_steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgTrading_StartSession {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_StartSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_StartSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgTrading_StartSession {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetCDNAuthToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetCDNAuthToken {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.host_name)
    pub host_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetCDNAuthToken.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthToken {
    fn default() -> &'a CMsgClientGetCDNAuthToken {
        <CMsgClientGetCDNAuthToken as crate::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthToken {
    pub fn new() -> CMsgClientGetCDNAuthToken {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional string host_name = 2;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_id",
            |m: &CMsgClientGetCDNAuthToken| { &m.depot_id },
            |m: &mut CMsgClientGetCDNAuthToken| { &mut m.depot_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_name",
            |m: &CMsgClientGetCDNAuthToken| { &m.host_name },
            |m: &mut CMsgClientGetCDNAuthToken| { &mut m.host_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetCDNAuthToken| { &m.app_id },
            |m: &mut CMsgClientGetCDNAuthToken| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetCDNAuthToken>(
            "CMsgClientGetCDNAuthToken",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetCDNAuthToken {
    const NAME: &'static str = "CMsgClientGetCDNAuthToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.host_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetCDNAuthToken {
        CMsgClientGetCDNAuthToken::new()
    }

    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.host_name = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthToken {
        static instance: CMsgClientGetCDNAuthToken = CMsgClientGetCDNAuthToken {
            depot_id: ::std::option::Option::None,
            host_name: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetCDNAuthToken {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetCDNAuthToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetCDNAuthToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetCDNAuthToken {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetDepotDecryptionKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetDepotDecryptionKey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKey.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKey.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetDepotDecryptionKey.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKey {
    fn default() -> &'a CMsgClientGetDepotDecryptionKey {
        <CMsgClientGetDepotDecryptionKey as crate::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKey {
    pub fn new() -> CMsgClientGetDepotDecryptionKey {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_id",
            |m: &CMsgClientGetDepotDecryptionKey| { &m.depot_id },
            |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.depot_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetDepotDecryptionKey| { &m.app_id },
            |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetDepotDecryptionKey>(
            "CMsgClientGetDepotDecryptionKey",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetDepotDecryptionKey {
    const NAME: &'static str = "CMsgClientGetDepotDecryptionKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetDepotDecryptionKey {
        CMsgClientGetDepotDecryptionKey::new()
    }

    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKey {
        static instance: CMsgClientGetDepotDecryptionKey = CMsgClientGetDepotDecryptionKey {
            depot_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetDepotDecryptionKey {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetDepotDecryptionKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetDepotDecryptionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKey {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetDepotDecryptionKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetDepotDecryptionKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.depot_encryption_key)
    pub depot_encryption_key: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetDepotDecryptionKeyResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKeyResponse {
    fn default() -> &'a CMsgClientGetDepotDecryptionKeyResponse {
        <CMsgClientGetDepotDecryptionKeyResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKeyResponse {
    pub fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 2;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional bytes depot_encryption_key = 3;

    pub fn depot_encryption_key(&self) -> &[u8] {
        match self.depot_encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_depot_encryption_key(&mut self) {
        self.depot_encryption_key = ::std::option::Option::None;
    }

    pub fn has_depot_encryption_key(&self) -> bool {
        self.depot_encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_encryption_key(&mut self, v: ::bytes::Bytes) {
        self.depot_encryption_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_depot_encryption_key(&mut self) -> &mut ::bytes::Bytes {
        if self.depot_encryption_key.is_none() {
            self.depot_encryption_key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.depot_encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_depot_encryption_key(&mut self) -> ::bytes::Bytes {
        self.depot_encryption_key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.eresult },
            |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_id",
            |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_id },
            |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_encryption_key",
            |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_encryption_key },
            |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_encryption_key },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetDepotDecryptionKeyResponse>(
            "CMsgClientGetDepotDecryptionKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetDepotDecryptionKeyResponse {
    const NAME: &'static str = "CMsgClientGetDepotDecryptionKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.depot_encryption_key = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.depot_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        CMsgClientGetDepotDecryptionKeyResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.depot_encryption_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKeyResponse {
        static instance: CMsgClientGetDepotDecryptionKeyResponse = CMsgClientGetDepotDecryptionKeyResponse {
            eresult: ::std::option::Option::None,
            depot_id: ::std::option::Option::None,
            depot_encryption_key: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetDepotDecryptionKeyResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetDepotDecryptionKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetDepotDecryptionKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKeyResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCheckAppBetaPassword)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckAppBetaPassword {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.betapassword)
    pub betapassword: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.language)
    pub language: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPassword.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPassword {
    fn default() -> &'a CMsgClientCheckAppBetaPassword {
        <CMsgClientCheckAppBetaPassword as crate::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPassword {
    pub fn new() -> CMsgClientCheckAppBetaPassword {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string betapassword = 2;

    pub fn betapassword(&self) -> &str {
        match self.betapassword.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_betapassword(&mut self) {
        self.betapassword = ::std::option::Option::None;
    }

    pub fn has_betapassword(&self) -> bool {
        self.betapassword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_betapassword(&mut self, v: ::std::string::String) {
        self.betapassword = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
        if self.betapassword.is_none() {
            self.betapassword = ::std::option::Option::Some(::std::string::String::new());
        }
        self.betapassword.as_mut().unwrap()
    }

    // Take field
    pub fn take_betapassword(&mut self) -> ::std::string::String {
        self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 3;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientCheckAppBetaPassword| { &m.app_id },
            |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "betapassword",
            |m: &CMsgClientCheckAppBetaPassword| { &m.betapassword },
            |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.betapassword },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgClientCheckAppBetaPassword| { &m.language },
            |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.language },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckAppBetaPassword>(
            "CMsgClientCheckAppBetaPassword",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCheckAppBetaPassword {
    const NAME: &'static str = "CMsgClientCheckAppBetaPassword";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.betapassword = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.betapassword.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.language {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.betapassword.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckAppBetaPassword {
        CMsgClientCheckAppBetaPassword::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.betapassword = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPassword {
        static instance: CMsgClientCheckAppBetaPassword = CMsgClientCheckAppBetaPassword {
            app_id: ::std::option::Option::None,
            betapassword: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCheckAppBetaPassword {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckAppBetaPassword").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckAppBetaPassword {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCheckAppBetaPassword {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCheckAppBetaPasswordResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckAppBetaPasswordResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.betapasswords)
    pub betapasswords: ::std::vec::Vec<cmsg_client_check_app_beta_password_response::BetaPassword>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPasswordResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPasswordResponse {
    fn default() -> &'a CMsgClientCheckAppBetaPasswordResponse {
        <CMsgClientCheckAppBetaPasswordResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPasswordResponse {
    pub fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientCheckAppBetaPasswordResponse.BetaPassword betapasswords = 4;

    pub fn betapasswords(&self) -> &[cmsg_client_check_app_beta_password_response::BetaPassword] {
        &self.betapasswords
    }

    pub fn clear_betapasswords(&mut self) {
        self.betapasswords.clear();
    }

    // Param is passed by value, moved
    pub fn set_betapasswords(&mut self, v: ::std::vec::Vec<cmsg_client_check_app_beta_password_response::BetaPassword>) {
        self.betapasswords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_betapasswords(&mut self) -> &mut ::std::vec::Vec<cmsg_client_check_app_beta_password_response::BetaPassword> {
        &mut self.betapasswords
    }

    // Take field
    pub fn take_betapasswords(&mut self) -> ::std::vec::Vec<cmsg_client_check_app_beta_password_response::BetaPassword> {
        ::std::mem::replace(&mut self.betapasswords, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.eresult },
            |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "betapasswords",
            |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.betapasswords },
            |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.betapasswords },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckAppBetaPasswordResponse>(
            "CMsgClientCheckAppBetaPasswordResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCheckAppBetaPasswordResponse {
    const NAME: &'static str = "CMsgClientCheckAppBetaPasswordResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.betapasswords.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.betapasswords {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.betapasswords {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        CMsgClientCheckAppBetaPasswordResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.betapasswords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPasswordResponse {
        static instance: CMsgClientCheckAppBetaPasswordResponse = CMsgClientCheckAppBetaPasswordResponse {
            eresult: ::std::option::Option::None,
            betapasswords: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCheckAppBetaPasswordResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckAppBetaPasswordResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckAppBetaPasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCheckAppBetaPasswordResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientCheckAppBetaPasswordResponse`
pub mod cmsg_client_check_app_beta_password_response {
    // @@protoc_insertion_point(message:CMsgClientCheckAppBetaPasswordResponse.BetaPassword)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BetaPassword {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betaname)
        pub betaname: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betapassword)
        pub betapassword: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betadescription)
        pub betadescription: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BetaPassword {
        fn default() -> &'a BetaPassword {
            <BetaPassword as crate::Message>::default_instance()
        }
    }

    impl BetaPassword {
        pub fn new() -> BetaPassword {
            ::std::default::Default::default()
        }

        // optional string betaname = 1;

        pub fn betaname(&self) -> &str {
            match self.betaname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betaname(&mut self) {
            self.betaname = ::std::option::Option::None;
        }

        pub fn has_betaname(&self) -> bool {
            self.betaname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betaname(&mut self, v: ::std::string::String) {
            self.betaname = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betaname(&mut self) -> &mut ::std::string::String {
            if self.betaname.is_none() {
                self.betaname = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betaname.as_mut().unwrap()
        }

        // Take field
        pub fn take_betaname(&mut self) -> ::std::string::String {
            self.betaname.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string betapassword = 2;

        pub fn betapassword(&self) -> &str {
            match self.betapassword.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betapassword(&mut self) {
            self.betapassword = ::std::option::Option::None;
        }

        pub fn has_betapassword(&self) -> bool {
            self.betapassword.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betapassword(&mut self, v: ::std::string::String) {
            self.betapassword = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
            if self.betapassword.is_none() {
                self.betapassword = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betapassword.as_mut().unwrap()
        }

        // Take field
        pub fn take_betapassword(&mut self) -> ::std::string::String {
            self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string betadescription = 3;

        pub fn betadescription(&self) -> &str {
            match self.betadescription.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betadescription(&mut self) {
            self.betadescription = ::std::option::Option::None;
        }

        pub fn has_betadescription(&self) -> bool {
            self.betadescription.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betadescription(&mut self, v: ::std::string::String) {
            self.betadescription = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betadescription(&mut self) -> &mut ::std::string::String {
            if self.betadescription.is_none() {
                self.betadescription = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betadescription.as_mut().unwrap()
        }

        // Take field
        pub fn take_betadescription(&mut self) -> ::std::string::String {
            self.betadescription.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "betaname",
                |m: &BetaPassword| { &m.betaname },
                |m: &mut BetaPassword| { &mut m.betaname },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "betapassword",
                |m: &BetaPassword| { &m.betapassword },
                |m: &mut BetaPassword| { &mut m.betapassword },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "betadescription",
                |m: &BetaPassword| { &m.betadescription },
                |m: &mut BetaPassword| { &mut m.betadescription },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<BetaPassword>(
                "CMsgClientCheckAppBetaPasswordResponse.BetaPassword",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for BetaPassword {
        const NAME: &'static str = "BetaPassword";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.betaname = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.betapassword = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.betadescription = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.betaname.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.betapassword.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.betadescription.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.betaname.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.betapassword.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.betadescription.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BetaPassword {
            BetaPassword::new()
        }

        fn clear(&mut self) {
            self.betaname = ::std::option::Option::None;
            self.betapassword = ::std::option::Option::None;
            self.betadescription = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BetaPassword {
            static instance: BetaPassword = BetaPassword {
                betaname: ::std::option::Option::None,
                betapassword: ::std::option::Option::None,
                betadescription: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for BetaPassword {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientCheckAppBetaPasswordResponse.BetaPassword").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BetaPassword {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for BetaPassword {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientGetCDNAuthTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetCDNAuthTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetCDNAuthTokenResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthTokenResponse {
    fn default() -> &'a CMsgClientGetCDNAuthTokenResponse {
        <CMsgClientGetCDNAuthTokenResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthTokenResponse {
    pub fn new() -> CMsgClientGetCDNAuthTokenResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string token = 2;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetCDNAuthTokenResponse| { &m.eresult },
            |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientGetCDNAuthTokenResponse| { &m.token },
            |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_time",
            |m: &CMsgClientGetCDNAuthTokenResponse| { &m.expiration_time },
            |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.expiration_time },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetCDNAuthTokenResponse>(
            "CMsgClientGetCDNAuthTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetCDNAuthTokenResponse {
    const NAME: &'static str = "CMsgClientGetCDNAuthTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.expiration_time {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetCDNAuthTokenResponse {
        CMsgClientGetCDNAuthTokenResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthTokenResponse {
        static instance: CMsgClientGetCDNAuthTokenResponse = CMsgClientGetCDNAuthTokenResponse {
            eresult: ::std::option::Option::None,
            token: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetCDNAuthTokenResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetCDNAuthTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetCDNAuthTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetCDNAuthTokenResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDownloadRateStatistics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDownloadRateStatistics {
    // message fields
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.stats)
    pub stats: ::std::vec::Vec<cmsg_download_rate_statistics::StatsInfo>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.throttling_kbps)
    pub throttling_kbps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.steam_realm)
    pub steam_realm: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDownloadRateStatistics.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDownloadRateStatistics {
    fn default() -> &'a CMsgDownloadRateStatistics {
        <CMsgDownloadRateStatistics as crate::Message>::default_instance()
    }
}

impl CMsgDownloadRateStatistics {
    pub fn new() -> CMsgDownloadRateStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgDownloadRateStatistics.StatsInfo stats = 2;

    pub fn stats(&self) -> &[cmsg_download_rate_statistics::StatsInfo] {
        &self.stats
    }

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::vec::Vec<cmsg_download_rate_statistics::StatsInfo>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::vec::Vec<cmsg_download_rate_statistics::StatsInfo> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::vec::Vec<cmsg_download_rate_statistics::StatsInfo> {
        ::std::mem::replace(&mut self.stats, ::std::vec::Vec::new())
    }

    // optional uint32 throttling_kbps = 3;

    pub fn throttling_kbps(&self) -> u32 {
        self.throttling_kbps.unwrap_or(0)
    }

    pub fn clear_throttling_kbps(&mut self) {
        self.throttling_kbps = ::std::option::Option::None;
    }

    pub fn has_throttling_kbps(&self) -> bool {
        self.throttling_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_kbps(&mut self, v: u32) {
        self.throttling_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_realm = 4;

    pub fn steam_realm(&self) -> u32 {
        self.steam_realm.unwrap_or(0)
    }

    pub fn clear_steam_realm(&mut self) {
        self.steam_realm = ::std::option::Option::None;
    }

    pub fn has_steam_realm(&self) -> bool {
        self.steam_realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_realm(&mut self, v: u32) {
        self.steam_realm = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgDownloadRateStatistics| { &m.cell_id },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.cell_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMsgDownloadRateStatistics| { &m.stats },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.stats },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "throttling_kbps",
            |m: &CMsgDownloadRateStatistics| { &m.throttling_kbps },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.throttling_kbps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_realm",
            |m: &CMsgDownloadRateStatistics| { &m.steam_realm },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.steam_realm },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDownloadRateStatistics>(
            "CMsgDownloadRateStatistics",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDownloadRateStatistics {
    const NAME: &'static str = "CMsgDownloadRateStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                24 => {
                    self.throttling_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.steam_realm = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.throttling_kbps {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.steam_realm {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.throttling_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steam_realm {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDownloadRateStatistics {
        CMsgDownloadRateStatistics::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.stats.clear();
        self.throttling_kbps = ::std::option::Option::None;
        self.steam_realm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDownloadRateStatistics {
        static instance: CMsgDownloadRateStatistics = CMsgDownloadRateStatistics {
            cell_id: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            throttling_kbps: ::std::option::Option::None,
            steam_realm: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDownloadRateStatistics {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDownloadRateStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDownloadRateStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDownloadRateStatistics {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDownloadRateStatistics`
pub mod cmsg_download_rate_statistics {
    // @@protoc_insertion_point(message:CMsgDownloadRateStatistics.StatsInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatsInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.source_type)
        pub source_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.source_id)
        pub source_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.seconds)
        pub seconds: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.bytes)
        pub bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.host_name)
        pub host_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.microseconds)
        pub microseconds: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.used_ipv6)
        pub used_ipv6: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.proxied)
        pub proxied: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDownloadRateStatistics.StatsInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsInfo {
        fn default() -> &'a StatsInfo {
            <StatsInfo as crate::Message>::default_instance()
        }
    }

    impl StatsInfo {
        pub fn new() -> StatsInfo {
            ::std::default::Default::default()
        }

        // optional uint32 source_type = 1;

        pub fn source_type(&self) -> u32 {
            self.source_type.unwrap_or(0)
        }

        pub fn clear_source_type(&mut self) {
            self.source_type = ::std::option::Option::None;
        }

        pub fn has_source_type(&self) -> bool {
            self.source_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_type(&mut self, v: u32) {
            self.source_type = ::std::option::Option::Some(v);
        }

        // optional uint32 source_id = 2;

        pub fn source_id(&self) -> u32 {
            self.source_id.unwrap_or(0)
        }

        pub fn clear_source_id(&mut self) {
            self.source_id = ::std::option::Option::None;
        }

        pub fn has_source_id(&self) -> bool {
            self.source_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_id(&mut self, v: u32) {
            self.source_id = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds = 3;

        pub fn seconds(&self) -> u32 {
            self.seconds.unwrap_or(0)
        }

        pub fn clear_seconds(&mut self) {
            self.seconds = ::std::option::Option::None;
        }

        pub fn has_seconds(&self) -> bool {
            self.seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds(&mut self, v: u32) {
            self.seconds = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes = 4;

        pub fn bytes(&self) -> u64 {
            self.bytes.unwrap_or(0)
        }

        pub fn clear_bytes(&mut self) {
            self.bytes = ::std::option::Option::None;
        }

        pub fn has_bytes(&self) -> bool {
            self.bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes(&mut self, v: u64) {
            self.bytes = ::std::option::Option::Some(v);
        }

        // optional string host_name = 5;

        pub fn host_name(&self) -> &str {
            match self.host_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_host_name(&mut self) {
            self.host_name = ::std::option::Option::None;
        }

        pub fn has_host_name(&self) -> bool {
            self.host_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_host_name(&mut self, v: ::std::string::String) {
            self.host_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
            if self.host_name.is_none() {
                self.host_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.host_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_host_name(&mut self) -> ::std::string::String {
            self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 microseconds = 6;

        pub fn microseconds(&self) -> u64 {
            self.microseconds.unwrap_or(0)
        }

        pub fn clear_microseconds(&mut self) {
            self.microseconds = ::std::option::Option::None;
        }

        pub fn has_microseconds(&self) -> bool {
            self.microseconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_microseconds(&mut self, v: u64) {
            self.microseconds = ::std::option::Option::Some(v);
        }

        // optional bool used_ipv6 = 7;

        pub fn used_ipv6(&self) -> bool {
            self.used_ipv6.unwrap_or(false)
        }

        pub fn clear_used_ipv6(&mut self) {
            self.used_ipv6 = ::std::option::Option::None;
        }

        pub fn has_used_ipv6(&self) -> bool {
            self.used_ipv6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_ipv6(&mut self, v: bool) {
            self.used_ipv6 = ::std::option::Option::Some(v);
        }

        // optional bool proxied = 8;

        pub fn proxied(&self) -> bool {
            self.proxied.unwrap_or(false)
        }

        pub fn clear_proxied(&mut self) {
            self.proxied = ::std::option::Option::None;
        }

        pub fn has_proxied(&self) -> bool {
            self.proxied.is_some()
        }

        // Param is passed by value, moved
        pub fn set_proxied(&mut self, v: bool) {
            self.proxied = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_type",
                |m: &StatsInfo| { &m.source_type },
                |m: &mut StatsInfo| { &mut m.source_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_id",
                |m: &StatsInfo| { &m.source_id },
                |m: &mut StatsInfo| { &mut m.source_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "seconds",
                |m: &StatsInfo| { &m.seconds },
                |m: &mut StatsInfo| { &mut m.seconds },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes",
                |m: &StatsInfo| { &m.bytes },
                |m: &mut StatsInfo| { &mut m.bytes },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "host_name",
                |m: &StatsInfo| { &m.host_name },
                |m: &mut StatsInfo| { &mut m.host_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "microseconds",
                |m: &StatsInfo| { &m.microseconds },
                |m: &mut StatsInfo| { &mut m.microseconds },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "used_ipv6",
                |m: &StatsInfo| { &m.used_ipv6 },
                |m: &mut StatsInfo| { &mut m.used_ipv6 },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "proxied",
                |m: &StatsInfo| { &m.proxied },
                |m: &mut StatsInfo| { &mut m.proxied },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<StatsInfo>(
                "CMsgDownloadRateStatistics.StatsInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for StatsInfo {
        const NAME: &'static str = "StatsInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.source_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    42 => {
                        self.host_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.microseconds = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.used_ipv6 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.proxied = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_type {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.source_id {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.seconds {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.bytes {
                my_size += crate::rt::uint64_size(4, v);
            }
            if let Some(v) = self.host_name.as_ref() {
                my_size += crate::rt::string_size(5, &v);
            }
            if let Some(v) = self.microseconds {
                my_size += crate::rt::uint64_size(6, v);
            }
            if let Some(v) = self.used_ipv6 {
                my_size += 1 + 1;
            }
            if let Some(v) = self.proxied {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.source_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.source_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.seconds {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.bytes {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.host_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.microseconds {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.used_ipv6 {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.proxied {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsInfo {
            StatsInfo::new()
        }

        fn clear(&mut self) {
            self.source_type = ::std::option::Option::None;
            self.source_id = ::std::option::Option::None;
            self.seconds = ::std::option::Option::None;
            self.bytes = ::std::option::Option::None;
            self.host_name = ::std::option::Option::None;
            self.microseconds = ::std::option::Option::None;
            self.used_ipv6 = ::std::option::Option::None;
            self.proxied = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsInfo {
            static instance: StatsInfo = StatsInfo {
                source_type: ::std::option::Option::None,
                source_id: ::std::option::Option::None,
                seconds: ::std::option::Option::None,
                bytes: ::std::option::Option::None,
                host_name: ::std::option::Option::None,
                microseconds: ::std::option::Option::None,
                used_ipv6: ::std::option::Option::None,
                proxied: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for StatsInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDownloadRateStatistics.StatsInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatsInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for StatsInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestAccountData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestAccountData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestAccountData.account_or_email)
    pub account_or_email: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountData.action)
    pub action: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestAccountData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountData {
    fn default() -> &'a CMsgClientRequestAccountData {
        <CMsgClientRequestAccountData as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountData {
    pub fn new() -> CMsgClientRequestAccountData {
        ::std::default::Default::default()
    }

    // optional string account_or_email = 1;

    pub fn account_or_email(&self) -> &str {
        match self.account_or_email.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_or_email(&mut self) {
        self.account_or_email = ::std::option::Option::None;
    }

    pub fn has_account_or_email(&self) -> bool {
        self.account_or_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_or_email(&mut self, v: ::std::string::String) {
        self.account_or_email = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_or_email(&mut self) -> &mut ::std::string::String {
        if self.account_or_email.is_none() {
            self.account_or_email = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_or_email.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_or_email(&mut self) -> ::std::string::String {
        self.account_or_email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 action = 2;

    pub fn action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_or_email",
            |m: &CMsgClientRequestAccountData| { &m.account_or_email },
            |m: &mut CMsgClientRequestAccountData| { &mut m.account_or_email },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientRequestAccountData| { &m.action },
            |m: &mut CMsgClientRequestAccountData| { &mut m.action },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestAccountData>(
            "CMsgClientRequestAccountData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestAccountData {
    const NAME: &'static str = "CMsgClientRequestAccountData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_or_email = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_or_email.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.action {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.account_or_email.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestAccountData {
        CMsgClientRequestAccountData::new()
    }

    fn clear(&mut self) {
        self.account_or_email = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestAccountData {
        static instance: CMsgClientRequestAccountData = CMsgClientRequestAccountData {
            account_or_email: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestAccountData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestAccountData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestAccountData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestAccountData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestAccountDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestAccountDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.action)
    pub action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.ct_matches)
    pub ct_matches: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion1)
    pub account_name_suggestion1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion2)
    pub account_name_suggestion2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion3)
    pub account_name_suggestion3: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestAccountDataResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountDataResponse {
    fn default() -> &'a CMsgClientRequestAccountDataResponse {
        <CMsgClientRequestAccountDataResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountDataResponse {
    pub fn new() -> CMsgClientRequestAccountDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 action = 1;

    pub fn action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string account_name = 3;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ct_matches = 4;

    pub fn ct_matches(&self) -> u32 {
        self.ct_matches.unwrap_or(0)
    }

    pub fn clear_ct_matches(&mut self) {
        self.ct_matches = ::std::option::Option::None;
    }

    pub fn has_ct_matches(&self) -> bool {
        self.ct_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_matches(&mut self, v: u32) {
        self.ct_matches = ::std::option::Option::Some(v);
    }

    // optional string account_name_suggestion1 = 5;

    pub fn account_name_suggestion1(&self) -> &str {
        match self.account_name_suggestion1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion1(&mut self) {
        self.account_name_suggestion1 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion1(&self) -> bool {
        self.account_name_suggestion1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion1(&mut self, v: ::std::string::String) {
        self.account_name_suggestion1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion1(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion1.is_none() {
            self.account_name_suggestion1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion1.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion1(&mut self) -> ::std::string::String {
        self.account_name_suggestion1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion2 = 6;

    pub fn account_name_suggestion2(&self) -> &str {
        match self.account_name_suggestion2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion2(&mut self) {
        self.account_name_suggestion2 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion2(&self) -> bool {
        self.account_name_suggestion2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion2(&mut self, v: ::std::string::String) {
        self.account_name_suggestion2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion2(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion2.is_none() {
            self.account_name_suggestion2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion2.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion2(&mut self) -> ::std::string::String {
        self.account_name_suggestion2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion3 = 7;

    pub fn account_name_suggestion3(&self) -> &str {
        match self.account_name_suggestion3.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion3(&mut self) {
        self.account_name_suggestion3 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion3(&self) -> bool {
        self.account_name_suggestion3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion3(&mut self, v: ::std::string::String) {
        self.account_name_suggestion3 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion3(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion3.is_none() {
            self.account_name_suggestion3 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion3.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion3(&mut self) -> ::std::string::String {
        self.account_name_suggestion3.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientRequestAccountDataResponse| { &m.action },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.action },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestAccountDataResponse| { &m.eresult },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_matches",
            |m: &CMsgClientRequestAccountDataResponse| { &m.ct_matches },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.ct_matches },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name_suggestion1",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion1 },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion1 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name_suggestion2",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion2 },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion2 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name_suggestion3",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion3 },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion3 },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestAccountDataResponse>(
            "CMsgClientRequestAccountDataResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestAccountDataResponse {
    const NAME: &'static str = "CMsgClientRequestAccountDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.ct_matches = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.account_name_suggestion1 = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.account_name_suggestion2 = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.account_name_suggestion3 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.ct_matches {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.action {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ct_matches {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestAccountDataResponse {
        CMsgClientRequestAccountDataResponse::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.account_name = ::std::option::Option::None;
        self.ct_matches = ::std::option::Option::None;
        self.account_name_suggestion1 = ::std::option::Option::None;
        self.account_name_suggestion2 = ::std::option::Option::None;
        self.account_name_suggestion3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestAccountDataResponse {
        static instance: CMsgClientRequestAccountDataResponse = CMsgClientRequestAccountDataResponse {
            action: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            account_name: ::std::option::Option::None,
            ct_matches: ::std::option::Option::None,
            account_name_suggestion1: ::std::option::Option::None,
            account_name_suggestion2: ::std::option::Option::None,
            account_name_suggestion3: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestAccountDataResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestAccountDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestAccountDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestAccountDataResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUGSGetGlobalStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.history_days_requested)
    pub history_days_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.time_last_requested)
    pub time_last_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.first_day_cached)
    pub first_day_cached: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.days_cached)
    pub days_cached: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStats.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStats {
    fn default() -> &'a CMsgClientUGSGetGlobalStats {
        <CMsgClientUGSGetGlobalStats as crate::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStats {
    pub fn new() -> CMsgClientUGSGetGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 history_days_requested = 2;

    pub fn history_days_requested(&self) -> u32 {
        self.history_days_requested.unwrap_or(0)
    }

    pub fn clear_history_days_requested(&mut self) {
        self.history_days_requested = ::std::option::Option::None;
    }

    pub fn has_history_days_requested(&self) -> bool {
        self.history_days_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history_days_requested(&mut self, v: u32) {
        self.history_days_requested = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_last_requested = 3;

    pub fn time_last_requested(&self) -> u32 {
        self.time_last_requested.unwrap_or(0)
    }

    pub fn clear_time_last_requested(&mut self) {
        self.time_last_requested = ::std::option::Option::None;
    }

    pub fn has_time_last_requested(&self) -> bool {
        self.time_last_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_requested(&mut self, v: u32) {
        self.time_last_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 first_day_cached = 4;

    pub fn first_day_cached(&self) -> u32 {
        self.first_day_cached.unwrap_or(0)
    }

    pub fn clear_first_day_cached(&mut self) {
        self.first_day_cached = ::std::option::Option::None;
    }

    pub fn has_first_day_cached(&self) -> bool {
        self.first_day_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_day_cached(&mut self, v: u32) {
        self.first_day_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 days_cached = 5;

    pub fn days_cached(&self) -> u32 {
        self.days_cached.unwrap_or(0)
    }

    pub fn clear_days_cached(&mut self) {
        self.days_cached = ::std::option::Option::None;
    }

    pub fn has_days_cached(&self) -> bool {
        self.days_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days_cached(&mut self, v: u32) {
        self.days_cached = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgClientUGSGetGlobalStats| { &m.gameid },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.gameid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "history_days_requested",
            |m: &CMsgClientUGSGetGlobalStats| { &m.history_days_requested },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.history_days_requested },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_requested",
            |m: &CMsgClientUGSGetGlobalStats| { &m.time_last_requested },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.time_last_requested },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_day_cached",
            |m: &CMsgClientUGSGetGlobalStats| { &m.first_day_cached },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.first_day_cached },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "days_cached",
            |m: &CMsgClientUGSGetGlobalStats| { &m.days_cached },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.days_cached },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUGSGetGlobalStats>(
            "CMsgClientUGSGetGlobalStats",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUGSGetGlobalStats {
    const NAME: &'static str = "CMsgClientUGSGetGlobalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.history_days_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.time_last_requested = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.first_day_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.days_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.history_days_requested {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_last_requested {
            my_size += 1 + 4;
        }
        if let Some(v) = self.first_day_cached {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.days_cached {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.history_days_requested {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_requested {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.first_day_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.days_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUGSGetGlobalStats {
        CMsgClientUGSGetGlobalStats::new()
    }

    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.history_days_requested = ::std::option::Option::None;
        self.time_last_requested = ::std::option::Option::None;
        self.first_day_cached = ::std::option::Option::None;
        self.days_cached = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStats {
        static instance: CMsgClientUGSGetGlobalStats = CMsgClientUGSGetGlobalStats {
            gameid: ::std::option::Option::None,
            history_days_requested: ::std::option::Option::None,
            time_last_requested: ::std::option::Option::None,
            first_day_cached: ::std::option::Option::None,
            days_cached: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUGSGetGlobalStats {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUGSGetGlobalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUGSGetGlobalStats {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUGSGetGlobalStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.day_current)
    pub day_current: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.days)
    pub days: ::std::vec::Vec<cmsg_client_ugsget_global_stats_response::Day>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStatsResponse {
    fn default() -> &'a CMsgClientUGSGetGlobalStatsResponse {
        <CMsgClientUGSGetGlobalStatsResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStatsResponse {
    pub fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 day_current = 3;

    pub fn day_current(&self) -> i32 {
        self.day_current.unwrap_or(0)
    }

    pub fn clear_day_current(&mut self) {
        self.day_current = ::std::option::Option::None;
    }

    pub fn has_day_current(&self) -> bool {
        self.day_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day_current(&mut self, v: i32) {
        self.day_current = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUGSGetGlobalStatsResponse.Day days = 4;

    pub fn days(&self) -> &[cmsg_client_ugsget_global_stats_response::Day] {
        &self.days
    }

    pub fn clear_days(&mut self) {
        self.days.clear();
    }

    // Param is passed by value, moved
    pub fn set_days(&mut self, v: ::std::vec::Vec<cmsg_client_ugsget_global_stats_response::Day>) {
        self.days = v;
    }

    // Mutable pointer to the field.
    pub fn mut_days(&mut self) -> &mut ::std::vec::Vec<cmsg_client_ugsget_global_stats_response::Day> {
        &mut self.days
    }

    // Take field
    pub fn take_days(&mut self) -> ::std::vec::Vec<cmsg_client_ugsget_global_stats_response::Day> {
        ::std::mem::replace(&mut self.days, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.eresult },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.timestamp },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "day_current",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.day_current },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.day_current },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "days",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.days },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.days },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUGSGetGlobalStatsResponse>(
            "CMsgClientUGSGetGlobalStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUGSGetGlobalStatsResponse {
    const NAME: &'static str = "CMsgClientUGSGetGlobalStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.day_current = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.days.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.day_current {
            my_size += crate::rt::int32_size(3, v);
        }
        for value in &self.days {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.day_current {
            os.write_int32(3, v)?;
        }
        for v in &self.days {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        CMsgClientUGSGetGlobalStatsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.day_current = ::std::option::Option::None;
        self.days.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStatsResponse {
        static instance: CMsgClientUGSGetGlobalStatsResponse = CMsgClientUGSGetGlobalStatsResponse {
            eresult: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            day_current: ::std::option::Option::None,
            days: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUGSGetGlobalStatsResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUGSGetGlobalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUGSGetGlobalStatsResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUGSGetGlobalStatsResponse`
pub mod cmsg_client_ugsget_global_stats_response {
    // @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse.Day)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Day {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.day_id)
        pub day_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.stats)
        pub stats: ::std::vec::Vec<day::Stat>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.Day.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Day {
        fn default() -> &'a Day {
            <Day as crate::Message>::default_instance()
        }
    }

    impl Day {
        pub fn new() -> Day {
            ::std::default::Default::default()
        }

        // optional uint32 day_id = 1;

        pub fn day_id(&self) -> u32 {
            self.day_id.unwrap_or(0)
        }

        pub fn clear_day_id(&mut self) {
            self.day_id = ::std::option::Option::None;
        }

        pub fn has_day_id(&self) -> bool {
            self.day_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_day_id(&mut self, v: u32) {
            self.day_id = ::std::option::Option::Some(v);
        }

        // repeated .CMsgClientUGSGetGlobalStatsResponse.Day.Stat stats = 2;

        pub fn stats(&self) -> &[day::Stat] {
            &self.stats
        }

        pub fn clear_stats(&mut self) {
            self.stats.clear();
        }

        // Param is passed by value, moved
        pub fn set_stats(&mut self, v: ::std::vec::Vec<day::Stat>) {
            self.stats = v;
        }

        // Mutable pointer to the field.
        pub fn mut_stats(&mut self) -> &mut ::std::vec::Vec<day::Stat> {
            &mut self.stats
        }

        // Take field
        pub fn take_stats(&mut self) -> ::std::vec::Vec<day::Stat> {
            ::std::mem::replace(&mut self.stats, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "day_id",
                |m: &Day| { &m.day_id },
                |m: &mut Day| { &mut m.day_id },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "stats",
                |m: &Day| { &m.stats },
                |m: &mut Day| { &mut m.stats },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Day>(
                "CMsgClientUGSGetGlobalStatsResponse.Day",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Day {
        const NAME: &'static str = "Day";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.day_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.stats.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.day_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            for value in &self.stats {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.day_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.stats {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Day {
            Day::new()
        }

        fn clear(&mut self) {
            self.day_id = ::std::option::Option::None;
            self.stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Day {
            static instance: Day = Day {
                day_id: ::std::option::Option::None,
                stats: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Day {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStatsResponse.Day").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Day {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Day {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Day`
    pub mod day {
        // @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse.Day.Stat)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Stat {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.stat_id)
            pub stat_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.data)
            pub data: ::std::option::Option<i64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Stat {
            fn default() -> &'a Stat {
                <Stat as crate::Message>::default_instance()
            }
        }

        impl Stat {
            pub fn new() -> Stat {
                ::std::default::Default::default()
            }

            // optional int32 stat_id = 1;

            pub fn stat_id(&self) -> i32 {
                self.stat_id.unwrap_or(0)
            }

            pub fn clear_stat_id(&mut self) {
                self.stat_id = ::std::option::Option::None;
            }

            pub fn has_stat_id(&self) -> bool {
                self.stat_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_id(&mut self, v: i32) {
                self.stat_id = ::std::option::Option::Some(v);
            }

            // optional int64 data = 2;

            pub fn data(&self) -> i64 {
                self.data.unwrap_or(0)
            }

            pub fn clear_data(&mut self) {
                self.data = ::std::option::Option::None;
            }

            pub fn has_data(&self) -> bool {
                self.data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_data(&mut self, v: i64) {
                self.data = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "stat_id",
                    |m: &Stat| { &m.stat_id },
                    |m: &mut Stat| { &mut m.stat_id },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "data",
                    |m: &Stat| { &m.data },
                    |m: &mut Stat| { &mut m.data },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<Stat>(
                    "CMsgClientUGSGetGlobalStatsResponse.Day.Stat",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for Stat {
            const NAME: &'static str = "Stat";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.stat_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.data = ::std::option::Option::Some(is.read_int64()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.stat_id {
                    my_size += crate::rt::int32_size(1, v);
                }
                if let Some(v) = self.data {
                    my_size += crate::rt::int64_size(2, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.stat_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.data {
                    os.write_int64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Stat {
                Stat::new()
            }

            fn clear(&mut self) {
                self.stat_id = ::std::option::Option::None;
                self.data = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Stat {
                static instance: Stat = Stat {
                    stat_id: ::std::option::Option::None,
                    data: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for Stat {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStatsResponse.Day.Stat").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Stat {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for Stat {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientRedeemGuestPass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRedeemGuestPass {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPass.guest_pass_id)
    pub guest_pass_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRedeemGuestPass.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPass {
    fn default() -> &'a CMsgClientRedeemGuestPass {
        <CMsgClientRedeemGuestPass as crate::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPass {
    pub fn new() -> CMsgClientRedeemGuestPass {
        ::std::default::Default::default()
    }

    // optional fixed64 guest_pass_id = 1;

    pub fn guest_pass_id(&self) -> u64 {
        self.guest_pass_id.unwrap_or(0)
    }

    pub fn clear_guest_pass_id(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
    }

    pub fn has_guest_pass_id(&self) -> bool {
        self.guest_pass_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guest_pass_id(&mut self, v: u64) {
        self.guest_pass_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "guest_pass_id",
            |m: &CMsgClientRedeemGuestPass| { &m.guest_pass_id },
            |m: &mut CMsgClientRedeemGuestPass| { &mut m.guest_pass_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRedeemGuestPass>(
            "CMsgClientRedeemGuestPass",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRedeemGuestPass {
    const NAME: &'static str = "CMsgClientRedeemGuestPass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.guest_pass_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guest_pass_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.guest_pass_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRedeemGuestPass {
        CMsgClientRedeemGuestPass::new()
    }

    fn clear(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPass {
        static instance: CMsgClientRedeemGuestPass = CMsgClientRedeemGuestPass {
            guest_pass_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRedeemGuestPass {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRedeemGuestPass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRedeemGuestPass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRedeemGuestPass {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRedeemGuestPassResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRedeemGuestPassResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.package_id)
    pub package_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.must_own_appid)
    pub must_own_appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRedeemGuestPassResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPassResponse {
    fn default() -> &'a CMsgClientRedeemGuestPassResponse {
        <CMsgClientRedeemGuestPassResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPassResponse {
    pub fn new() -> CMsgClientRedeemGuestPassResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 package_id = 2;

    pub fn package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_appid = 3;

    pub fn must_own_appid(&self) -> u32 {
        self.must_own_appid.unwrap_or(0)
    }

    pub fn clear_must_own_appid(&mut self) {
        self.must_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_own_appid(&self) -> bool {
        self.must_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_appid(&mut self, v: u32) {
        self.must_own_appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRedeemGuestPassResponse| { &m.eresult },
            |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_id",
            |m: &CMsgClientRedeemGuestPassResponse| { &m.package_id },
            |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.package_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "must_own_appid",
            |m: &CMsgClientRedeemGuestPassResponse| { &m.must_own_appid },
            |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.must_own_appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRedeemGuestPassResponse>(
            "CMsgClientRedeemGuestPassResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRedeemGuestPassResponse {
    const NAME: &'static str = "CMsgClientRedeemGuestPassResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.must_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.package_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.must_own_appid {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.package_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.must_own_appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRedeemGuestPassResponse {
        CMsgClientRedeemGuestPassResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.package_id = ::std::option::Option::None;
        self.must_own_appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPassResponse {
        static instance: CMsgClientRedeemGuestPassResponse = CMsgClientRedeemGuestPassResponse {
            eresult: ::std::option::Option::None,
            package_id: ::std::option::Option::None,
            must_own_appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRedeemGuestPassResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRedeemGuestPassResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRedeemGuestPassResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRedeemGuestPassResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClanActivityCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClanActivityCounts {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClanActivityCounts.steamid_clans)
    pub steamid_clans: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClanActivityCounts.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCounts {
    fn default() -> &'a CMsgClientGetClanActivityCounts {
        <CMsgClientGetClanActivityCounts as crate::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCounts {
    pub fn new() -> CMsgClientGetClanActivityCounts {
        ::std::default::Default::default()
    }

    // repeated uint64 steamid_clans = 1;

    pub fn steamid_clans(&self) -> &[u64] {
        &self.steamid_clans
    }

    pub fn clear_steamid_clans(&mut self) {
        self.steamid_clans.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_clans(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_clans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_clans(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_clans
    }

    // Take field
    pub fn take_steamid_clans(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_clans, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_clans",
            |m: &CMsgClientGetClanActivityCounts| { &m.steamid_clans },
            |m: &mut CMsgClientGetClanActivityCounts| { &mut m.steamid_clans },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClanActivityCounts>(
            "CMsgClientGetClanActivityCounts",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetClanActivityCounts {
    const NAME: &'static str = "CMsgClientGetClanActivityCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.steamid_clans)?;
                },
                8 => {
                    self.steamid_clans.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.steamid_clans {
            my_size += crate::rt::uint64_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.steamid_clans {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClanActivityCounts {
        CMsgClientGetClanActivityCounts::new()
    }

    fn clear(&mut self) {
        self.steamid_clans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCounts {
        static instance: CMsgClientGetClanActivityCounts = CMsgClientGetClanActivityCounts {
            steamid_clans: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetClanActivityCounts {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClanActivityCounts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClanActivityCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetClanActivityCounts {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClanActivityCountsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClanActivityCountsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClanActivityCountsResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClanActivityCountsResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCountsResponse {
    fn default() -> &'a CMsgClientGetClanActivityCountsResponse {
        <CMsgClientGetClanActivityCountsResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCountsResponse {
    pub fn new() -> CMsgClientGetClanActivityCountsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetClanActivityCountsResponse| { &m.eresult },
            |m: &mut CMsgClientGetClanActivityCountsResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClanActivityCountsResponse>(
            "CMsgClientGetClanActivityCountsResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetClanActivityCountsResponse {
    const NAME: &'static str = "CMsgClientGetClanActivityCountsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClanActivityCountsResponse {
        CMsgClientGetClanActivityCountsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCountsResponse {
        static instance: CMsgClientGetClanActivityCountsResponse = CMsgClientGetClanActivityCountsResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetClanActivityCountsResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClanActivityCountsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClanActivityCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetClanActivityCountsResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientOGSReportString)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOGSReportString {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.accumulated)
    pub accumulated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.sessionid)
    pub sessionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.severity)
    pub severity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.formatter)
    pub formatter: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.varargs)
    pub varargs: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOGSReportString.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportString {
    fn default() -> &'a CMsgClientOGSReportString {
        <CMsgClientOGSReportString as crate::Message>::default_instance()
    }
}

impl CMsgClientOGSReportString {
    pub fn new() -> CMsgClientOGSReportString {
        ::std::default::Default::default()
    }

    // optional bool accumulated = 1;

    pub fn accumulated(&self) -> bool {
        self.accumulated.unwrap_or(false)
    }

    pub fn clear_accumulated(&mut self) {
        self.accumulated = ::std::option::Option::None;
    }

    pub fn has_accumulated(&self) -> bool {
        self.accumulated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accumulated(&mut self, v: bool) {
        self.accumulated = ::std::option::Option::Some(v);
    }

    // optional uint64 sessionid = 2;

    pub fn sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 3;

    pub fn severity(&self) -> i32 {
        self.severity.unwrap_or(0)
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string formatter = 4;

    pub fn formatter(&self) -> &str {
        match self.formatter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_formatter(&mut self) {
        self.formatter = ::std::option::Option::None;
    }

    pub fn has_formatter(&self) -> bool {
        self.formatter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formatter(&mut self, v: ::std::string::String) {
        self.formatter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_formatter(&mut self) -> &mut ::std::string::String {
        if self.formatter.is_none() {
            self.formatter = ::std::option::Option::Some(::std::string::String::new());
        }
        self.formatter.as_mut().unwrap()
    }

    // Take field
    pub fn take_formatter(&mut self) -> ::std::string::String {
        self.formatter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes varargs = 5;

    pub fn varargs(&self) -> &[u8] {
        match self.varargs.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_varargs(&mut self) {
        self.varargs = ::std::option::Option::None;
    }

    pub fn has_varargs(&self) -> bool {
        self.varargs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_varargs(&mut self, v: ::bytes::Bytes) {
        self.varargs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_varargs(&mut self) -> &mut ::bytes::Bytes {
        if self.varargs.is_none() {
            self.varargs = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.varargs.as_mut().unwrap()
    }

    // Take field
    pub fn take_varargs(&mut self) -> ::bytes::Bytes {
        self.varargs.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accumulated",
            |m: &CMsgClientOGSReportString| { &m.accumulated },
            |m: &mut CMsgClientOGSReportString| { &mut m.accumulated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionid",
            |m: &CMsgClientOGSReportString| { &m.sessionid },
            |m: &mut CMsgClientOGSReportString| { &mut m.sessionid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "severity",
            |m: &CMsgClientOGSReportString| { &m.severity },
            |m: &mut CMsgClientOGSReportString| { &mut m.severity },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "formatter",
            |m: &CMsgClientOGSReportString| { &m.formatter },
            |m: &mut CMsgClientOGSReportString| { &mut m.formatter },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "varargs",
            |m: &CMsgClientOGSReportString| { &m.varargs },
            |m: &mut CMsgClientOGSReportString| { &mut m.varargs },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientOGSReportString>(
            "CMsgClientOGSReportString",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientOGSReportString {
    const NAME: &'static str = "CMsgClientOGSReportString";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accumulated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.severity = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.formatter = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.varargs = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accumulated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sessionid {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.severity {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.formatter.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.varargs.as_ref() {
            my_size += crate::rt::bytes_size(5, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.accumulated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sessionid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.formatter.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.varargs.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOGSReportString {
        CMsgClientOGSReportString::new()
    }

    fn clear(&mut self) {
        self.accumulated = ::std::option::Option::None;
        self.sessionid = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.formatter = ::std::option::Option::None;
        self.varargs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOGSReportString {
        static instance: CMsgClientOGSReportString = CMsgClientOGSReportString {
            accumulated: ::std::option::Option::None,
            sessionid: ::std::option::Option::None,
            severity: ::std::option::Option::None,
            formatter: ::std::option::Option::None,
            varargs: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientOGSReportString {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientOGSReportString").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientOGSReportString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientOGSReportString {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientOGSReportBug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOGSReportBug {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.sessionid)
    pub sessionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.bugtext)
    pub bugtext: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.screenshot)
    pub screenshot: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOGSReportBug.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportBug {
    fn default() -> &'a CMsgClientOGSReportBug {
        <CMsgClientOGSReportBug as crate::Message>::default_instance()
    }
}

impl CMsgClientOGSReportBug {
    pub fn new() -> CMsgClientOGSReportBug {
        ::std::default::Default::default()
    }

    // optional uint64 sessionid = 1;

    pub fn sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional string bugtext = 2;

    pub fn bugtext(&self) -> &str {
        match self.bugtext.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bugtext(&mut self) {
        self.bugtext = ::std::option::Option::None;
    }

    pub fn has_bugtext(&self) -> bool {
        self.bugtext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bugtext(&mut self, v: ::std::string::String) {
        self.bugtext = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bugtext(&mut self) -> &mut ::std::string::String {
        if self.bugtext.is_none() {
            self.bugtext = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bugtext.as_mut().unwrap()
    }

    // Take field
    pub fn take_bugtext(&mut self) -> ::std::string::String {
        self.bugtext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes screenshot = 3;

    pub fn screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenshot(&mut self) {
        self.screenshot = ::std::option::Option::None;
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::bytes::Bytes) {
        self.screenshot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::bytes::Bytes {
        if self.screenshot.is_none() {
            self.screenshot = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::bytes::Bytes {
        self.screenshot.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionid",
            |m: &CMsgClientOGSReportBug| { &m.sessionid },
            |m: &mut CMsgClientOGSReportBug| { &mut m.sessionid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bugtext",
            |m: &CMsgClientOGSReportBug| { &m.bugtext },
            |m: &mut CMsgClientOGSReportBug| { &mut m.bugtext },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshot",
            |m: &CMsgClientOGSReportBug| { &m.screenshot },
            |m: &mut CMsgClientOGSReportBug| { &mut m.screenshot },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientOGSReportBug>(
            "CMsgClientOGSReportBug",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientOGSReportBug {
    const NAME: &'static str = "CMsgClientOGSReportBug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.bugtext = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.screenshot = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sessionid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.bugtext.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.screenshot.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.sessionid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bugtext.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOGSReportBug {
        CMsgClientOGSReportBug::new()
    }

    fn clear(&mut self) {
        self.sessionid = ::std::option::Option::None;
        self.bugtext = ::std::option::Option::None;
        self.screenshot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOGSReportBug {
        static instance: CMsgClientOGSReportBug = CMsgClientOGSReportBug {
            sessionid: ::std::option::Option::None,
            bugtext: ::std::option::Option::None,
            screenshot: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientOGSReportBug {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientOGSReportBug").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientOGSReportBug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientOGSReportBug {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSentLogs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSentLogs {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSentLogs.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSentLogs {
    fn default() -> &'a CMsgClientSentLogs {
        <CMsgClientSentLogs as crate::Message>::default_instance()
    }
}

impl CMsgClientSentLogs {
    pub fn new() -> CMsgClientSentLogs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSentLogs>(
            "CMsgClientSentLogs",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSentLogs {
    const NAME: &'static str = "CMsgClientSentLogs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSentLogs {
        CMsgClientSentLogs::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSentLogs {
        static instance: CMsgClientSentLogs = CMsgClientSentLogs {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSentLogs {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSentLogs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSentLogs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSentLogs {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClient.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClient.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClient.payload)
    pub payload: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgGCClient.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCClient.gcname)
    pub gcname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClient.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClient.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClient {
    fn default() -> &'a CMsgGCClient {
        <CMsgGCClient as crate::Message>::default_instance()
    }
}

impl CMsgGCClient {
    pub fn new() -> CMsgGCClient {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 msgtype = 2;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::bytes::Bytes) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::bytes::Bytes {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::bytes::Bytes {
        self.payload.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string gcname = 5;

    pub fn gcname(&self) -> &str {
        match self.gcname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gcname(&mut self) {
        self.gcname = ::std::option::Option::None;
    }

    pub fn has_gcname(&self) -> bool {
        self.gcname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcname(&mut self, v: ::std::string::String) {
        self.gcname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcname(&mut self) -> &mut ::std::string::String {
        if self.gcname.is_none() {
            self.gcname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gcname.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcname(&mut self) -> ::std::string::String {
        self.gcname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ip = 6;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgGCClient| { &m.appid },
            |m: &mut CMsgGCClient| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgtype",
            |m: &CMsgGCClient| { &m.msgtype },
            |m: &mut CMsgGCClient| { &mut m.msgtype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgGCClient| { &m.payload },
            |m: &mut CMsgGCClient| { &mut m.payload },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCClient| { &m.steamid },
            |m: &mut CMsgGCClient| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gcname",
            |m: &CMsgGCClient| { &m.gcname },
            |m: &mut CMsgGCClient| { &mut m.gcname },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgGCClient| { &m.ip },
            |m: &mut CMsgGCClient| { &mut m.ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClient>(
            "CMsgGCClient",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGCClient {
    const NAME: &'static str = "CMsgGCClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    self.gcname = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.msgtype {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gcname.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.ip {
            my_size += crate::rt::uint32_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.msgtype {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.gcname.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClient {
        CMsgGCClient::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gcname = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClient {
        static instance: CMsgGCClient = CMsgGCClient {
            appid: ::std::option::Option::None,
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gcname: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGCClient {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGCClient {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestFreeLicense)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFreeLicense {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicense.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFreeLicense.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicense {
    fn default() -> &'a CMsgClientRequestFreeLicense {
        <CMsgClientRequestFreeLicense as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicense {
    pub fn new() -> CMsgClientRequestFreeLicense {
        ::std::default::Default::default()
    }

    // repeated uint32 appids = 2;

    pub fn appids(&self) -> &[u32] {
        &self.appids
    }

    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CMsgClientRequestFreeLicense| { &m.appids },
            |m: &mut CMsgClientRequestFreeLicense| { &mut m.appids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestFreeLicense>(
            "CMsgClientRequestFreeLicense",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestFreeLicense {
    const NAME: &'static str = "CMsgClientRequestFreeLicense";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                16 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += crate::rt::uint32_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFreeLicense {
        CMsgClientRequestFreeLicense::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicense {
        static instance: CMsgClientRequestFreeLicense = CMsgClientRequestFreeLicense {
            appids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestFreeLicense {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestFreeLicense").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestFreeLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestFreeLicense {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestFreeLicenseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFreeLicenseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.granted_packageids)
    pub granted_packageids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.granted_appids)
    pub granted_appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFreeLicenseResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicenseResponse {
    fn default() -> &'a CMsgClientRequestFreeLicenseResponse {
        <CMsgClientRequestFreeLicenseResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicenseResponse {
    pub fn new() -> CMsgClientRequestFreeLicenseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated uint32 granted_packageids = 2;

    pub fn granted_packageids(&self) -> &[u32] {
        &self.granted_packageids
    }

    pub fn clear_granted_packageids(&mut self) {
        self.granted_packageids.clear();
    }

    // Param is passed by value, moved
    pub fn set_granted_packageids(&mut self, v: ::std::vec::Vec<u32>) {
        self.granted_packageids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_granted_packageids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_packageids
    }

    // Take field
    pub fn take_granted_packageids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.granted_packageids, ::std::vec::Vec::new())
    }

    // repeated uint32 granted_appids = 3;

    pub fn granted_appids(&self) -> &[u32] {
        &self.granted_appids
    }

    pub fn clear_granted_appids(&mut self) {
        self.granted_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_granted_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.granted_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_granted_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_appids
    }

    // Take field
    pub fn take_granted_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.granted_appids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestFreeLicenseResponse| { &m.eresult },
            |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "granted_packageids",
            |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_packageids },
            |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_packageids },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "granted_appids",
            |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_appids },
            |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_appids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestFreeLicenseResponse>(
            "CMsgClientRequestFreeLicenseResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestFreeLicenseResponse {
    const NAME: &'static str = "CMsgClientRequestFreeLicenseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.granted_packageids)?;
                },
                16 => {
                    self.granted_packageids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.granted_appids)?;
                },
                24 => {
                    self.granted_appids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.granted_packageids {
            my_size += crate::rt::uint32_size(2, *value);
        };
        for value in &self.granted_appids {
            my_size += crate::rt::uint32_size(3, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        for v in &self.granted_packageids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.granted_appids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFreeLicenseResponse {
        CMsgClientRequestFreeLicenseResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.granted_packageids.clear();
        self.granted_appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicenseResponse {
        static instance: CMsgClientRequestFreeLicenseResponse = CMsgClientRequestFreeLicenseResponse {
            eresult: ::std::option::Option::None,
            granted_packageids: ::std::vec::Vec::new(),
            granted_appids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestFreeLicenseResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestFreeLicenseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestFreeLicenseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestFreeLicenseResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDRMDownloadRequestWithCrashData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMDownloadRequestWithCrashData {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.download_flags)
    pub download_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.download_types_known)
    pub download_types_known: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_drm)
    pub guid_drm: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_split)
    pub guid_split: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_merge)
    pub guid_merge: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.module_name)
    pub module_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.module_path)
    pub module_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.crash_data)
    pub crash_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMDownloadRequestWithCrashData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadRequestWithCrashData {
    fn default() -> &'a CMsgDRMDownloadRequestWithCrashData {
        <CMsgDRMDownloadRequestWithCrashData as crate::Message>::default_instance()
    }
}

impl CMsgDRMDownloadRequestWithCrashData {
    pub fn new() -> CMsgDRMDownloadRequestWithCrashData {
        ::std::default::Default::default()
    }

    // optional uint32 download_flags = 1;

    pub fn download_flags(&self) -> u32 {
        self.download_flags.unwrap_or(0)
    }

    pub fn clear_download_flags(&mut self) {
        self.download_flags = ::std::option::Option::None;
    }

    pub fn has_download_flags(&self) -> bool {
        self.download_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_flags(&mut self, v: u32) {
        self.download_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 download_types_known = 2;

    pub fn download_types_known(&self) -> u32 {
        self.download_types_known.unwrap_or(0)
    }

    pub fn clear_download_types_known(&mut self) {
        self.download_types_known = ::std::option::Option::None;
    }

    pub fn has_download_types_known(&self) -> bool {
        self.download_types_known.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_types_known(&mut self, v: u32) {
        self.download_types_known = ::std::option::Option::Some(v);
    }

    // optional bytes guid_drm = 3;

    pub fn guid_drm(&self) -> &[u8] {
        match self.guid_drm.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_drm(&mut self) {
        self.guid_drm = ::std::option::Option::None;
    }

    pub fn has_guid_drm(&self) -> bool {
        self.guid_drm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_drm(&mut self, v: ::bytes::Bytes) {
        self.guid_drm = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_drm(&mut self) -> &mut ::bytes::Bytes {
        if self.guid_drm.is_none() {
            self.guid_drm = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.guid_drm.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_drm(&mut self) -> ::bytes::Bytes {
        self.guid_drm.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes guid_split = 4;

    pub fn guid_split(&self) -> &[u8] {
        match self.guid_split.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_split(&mut self) {
        self.guid_split = ::std::option::Option::None;
    }

    pub fn has_guid_split(&self) -> bool {
        self.guid_split.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_split(&mut self, v: ::bytes::Bytes) {
        self.guid_split = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_split(&mut self) -> &mut ::bytes::Bytes {
        if self.guid_split.is_none() {
            self.guid_split = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.guid_split.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_split(&mut self) -> ::bytes::Bytes {
        self.guid_split.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes guid_merge = 5;

    pub fn guid_merge(&self) -> &[u8] {
        match self.guid_merge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_merge(&mut self) {
        self.guid_merge = ::std::option::Option::None;
    }

    pub fn has_guid_merge(&self) -> bool {
        self.guid_merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_merge(&mut self, v: ::bytes::Bytes) {
        self.guid_merge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_merge(&mut self) -> &mut ::bytes::Bytes {
        if self.guid_merge.is_none() {
            self.guid_merge = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.guid_merge.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_merge(&mut self) -> ::bytes::Bytes {
        self.guid_merge.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional string module_name = 6;

    pub fn module_name(&self) -> &str {
        match self.module_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_name(&mut self) {
        self.module_name = ::std::option::Option::None;
    }

    pub fn has_module_name(&self) -> bool {
        self.module_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        if self.module_name.is_none() {
            self.module_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        self.module_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 7;

    pub fn module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path = ::std::option::Option::None;
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes crash_data = 8;

    pub fn crash_data(&self) -> &[u8] {
        match self.crash_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_crash_data(&mut self) {
        self.crash_data = ::std::option::Option::None;
    }

    pub fn has_crash_data(&self) -> bool {
        self.crash_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crash_data(&mut self, v: ::bytes::Bytes) {
        self.crash_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crash_data(&mut self) -> &mut ::bytes::Bytes {
        if self.crash_data.is_none() {
            self.crash_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.crash_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_crash_data(&mut self) -> ::bytes::Bytes {
        self.crash_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_flags",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_flags },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_types_known",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_types_known },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_types_known },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid_drm",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_drm },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_drm },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid_split",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_split },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_split },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid_merge",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_merge },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_merge },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_name",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_name },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_path",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_path },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "crash_data",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.crash_data },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.crash_data },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDRMDownloadRequestWithCrashData>(
            "CMsgDRMDownloadRequestWithCrashData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDRMDownloadRequestWithCrashData {
    const NAME: &'static str = "CMsgDRMDownloadRequestWithCrashData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.download_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.download_types_known = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.guid_drm = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                34 => {
                    self.guid_split = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                42 => {
                    self.guid_merge = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                50 => {
                    self.module_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.module_path = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.crash_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.download_flags {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.download_types_known {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.guid_drm.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.guid_split.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.guid_merge.as_ref() {
            my_size += crate::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.module_name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.crash_data.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.download_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.download_types_known {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guid_drm.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.guid_split.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.guid_merge.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.crash_data.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMDownloadRequestWithCrashData {
        CMsgDRMDownloadRequestWithCrashData::new()
    }

    fn clear(&mut self) {
        self.download_flags = ::std::option::Option::None;
        self.download_types_known = ::std::option::Option::None;
        self.guid_drm = ::std::option::Option::None;
        self.guid_split = ::std::option::Option::None;
        self.guid_merge = ::std::option::Option::None;
        self.module_name = ::std::option::Option::None;
        self.module_path = ::std::option::Option::None;
        self.crash_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMDownloadRequestWithCrashData {
        static instance: CMsgDRMDownloadRequestWithCrashData = CMsgDRMDownloadRequestWithCrashData {
            download_flags: ::std::option::Option::None,
            download_types_known: ::std::option::Option::None,
            guid_drm: ::std::option::Option::None,
            guid_split: ::std::option::Option::None,
            guid_merge: ::std::option::Option::None,
            module_name: ::std::option::Option::None,
            module_path: ::std::option::Option::None,
            crash_data: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDRMDownloadRequestWithCrashData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDRMDownloadRequestWithCrashData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDRMDownloadRequestWithCrashData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDRMDownloadRequestWithCrashData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDRMDownloadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMDownloadResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.blob_download_type)
    pub blob_download_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.merge_guid)
    pub merge_guid: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_dfs_ip)
    pub download_file_dfs_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_dfs_port)
    pub download_file_dfs_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_url)
    pub download_file_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.module_path)
    pub module_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMDownloadResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadResponse {
    fn default() -> &'a CMsgDRMDownloadResponse {
        <CMsgDRMDownloadResponse as crate::Message>::default_instance()
    }
}

impl CMsgDRMDownloadResponse {
    pub fn new() -> CMsgDRMDownloadResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 4;

    pub fn merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid = ::std::option::Option::None;
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::bytes::Bytes) {
        self.merge_guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::bytes::Bytes {
        if self.merge_guid.is_none() {
            self.merge_guid = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::bytes::Bytes {
        self.merge_guid.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 download_file_dfs_ip = 5;

    pub fn download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 6;

    pub fn download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 7;

    pub fn download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url = ::std::option::Option::None;
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 8;

    pub fn module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path = ::std::option::Option::None;
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgDRMDownloadResponse| { &m.eresult },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgDRMDownloadResponse| { &m.app_id },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob_download_type",
            |m: &CMsgDRMDownloadResponse| { &m.blob_download_type },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.blob_download_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "merge_guid",
            |m: &CMsgDRMDownloadResponse| { &m.merge_guid },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.merge_guid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_ip",
            |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_ip },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_port",
            |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_port },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_url",
            |m: &CMsgDRMDownloadResponse| { &m.download_file_url },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_path",
            |m: &CMsgDRMDownloadResponse| { &m.module_path },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.module_path },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDRMDownloadResponse>(
            "CMsgDRMDownloadResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDRMDownloadResponse {
    const NAME: &'static str = "CMsgDRMDownloadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.merge_guid = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.download_file_url = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.module_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.blob_download_type {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMDownloadResponse {
        CMsgDRMDownloadResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.merge_guid = ::std::option::Option::None;
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url = ::std::option::Option::None;
        self.module_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMDownloadResponse {
        static instance: CMsgDRMDownloadResponse = CMsgDRMDownloadResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            blob_download_type: ::std::option::Option::None,
            merge_guid: ::std::option::Option::None,
            download_file_dfs_ip: ::std::option::Option::None,
            download_file_dfs_port: ::std::option::Option::None,
            download_file_url: ::std::option::Option::None,
            module_path: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDRMDownloadResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDRMDownloadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDRMDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDRMDownloadResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDRMFinalResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMFinalResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.blob_download_type)
    pub blob_download_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.error_detail)
    pub error_detail: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.merge_guid)
    pub merge_guid: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_dfs_ip)
    pub download_file_dfs_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_dfs_port)
    pub download_file_dfs_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_url)
    pub download_file_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMFinalResult.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMFinalResult {
    fn default() -> &'a CMsgDRMFinalResult {
        <CMsgDRMFinalResult as crate::Message>::default_instance()
    }
}

impl CMsgDRMFinalResult {
    pub fn new() -> CMsgDRMFinalResult {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional uint32 error_detail = 4;

    pub fn error_detail(&self) -> u32 {
        self.error_detail.unwrap_or(0)
    }

    pub fn clear_error_detail(&mut self) {
        self.error_detail = ::std::option::Option::None;
    }

    pub fn has_error_detail(&self) -> bool {
        self.error_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_detail(&mut self, v: u32) {
        self.error_detail = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 5;

    pub fn merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid = ::std::option::Option::None;
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::bytes::Bytes) {
        self.merge_guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::bytes::Bytes {
        if self.merge_guid.is_none() {
            self.merge_guid = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::bytes::Bytes {
        self.merge_guid.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 download_file_dfs_ip = 6;

    pub fn download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 7;

    pub fn download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 8;

    pub fn download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url = ::std::option::Option::None;
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgDRMFinalResult| { &m.eResult },
            |m: &mut CMsgDRMFinalResult| { &mut m.eResult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgDRMFinalResult| { &m.app_id },
            |m: &mut CMsgDRMFinalResult| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob_download_type",
            |m: &CMsgDRMFinalResult| { &m.blob_download_type },
            |m: &mut CMsgDRMFinalResult| { &mut m.blob_download_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_detail",
            |m: &CMsgDRMFinalResult| { &m.error_detail },
            |m: &mut CMsgDRMFinalResult| { &mut m.error_detail },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "merge_guid",
            |m: &CMsgDRMFinalResult| { &m.merge_guid },
            |m: &mut CMsgDRMFinalResult| { &mut m.merge_guid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_ip",
            |m: &CMsgDRMFinalResult| { &m.download_file_dfs_ip },
            |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_port",
            |m: &CMsgDRMFinalResult| { &m.download_file_dfs_port },
            |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_url",
            |m: &CMsgDRMFinalResult| { &m.download_file_url },
            |m: &mut CMsgDRMFinalResult| { &mut m.download_file_url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDRMFinalResult>(
            "CMsgDRMFinalResult",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDRMFinalResult {
    const NAME: &'static str = "CMsgDRMFinalResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.error_detail = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.merge_guid = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                48 => {
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.download_file_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.blob_download_type {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.error_detail {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += crate::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.error_detail {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMFinalResult {
        CMsgDRMFinalResult::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.error_detail = ::std::option::Option::None;
        self.merge_guid = ::std::option::Option::None;
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMFinalResult {
        static instance: CMsgDRMFinalResult = CMsgDRMFinalResult {
            eResult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            blob_download_type: ::std::option::Option::None,
            error_detail: ::std::option::Option::None,
            merge_guid: ::std::option::Option::None,
            download_file_dfs_ip: ::std::option::Option::None,
            download_file_dfs_port: ::std::option::Option::None,
            download_file_url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDRMFinalResult {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDRMFinalResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDRMFinalResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDRMFinalResult {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPCheckSpecialSurvey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPCheckSpecialSurvey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurvey.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPCheckSpecialSurvey.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurvey {
    fn default() -> &'a CMsgClientDPCheckSpecialSurvey {
        <CMsgClientDPCheckSpecialSurvey as crate::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurvey {
    pub fn new() -> CMsgClientDPCheckSpecialSurvey {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_id",
            |m: &CMsgClientDPCheckSpecialSurvey| { &m.survey_id },
            |m: &mut CMsgClientDPCheckSpecialSurvey| { &mut m.survey_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPCheckSpecialSurvey>(
            "CMsgClientDPCheckSpecialSurvey",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDPCheckSpecialSurvey {
    const NAME: &'static str = "CMsgClientDPCheckSpecialSurvey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPCheckSpecialSurvey {
        CMsgClientDPCheckSpecialSurvey::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurvey {
        static instance: CMsgClientDPCheckSpecialSurvey = CMsgClientDPCheckSpecialSurvey {
            survey_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDPCheckSpecialSurvey {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPCheckSpecialSurvey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPCheckSpecialSurvey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurvey {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPCheckSpecialSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPCheckSpecialSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.state)
    pub state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.custom_url)
    pub custom_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.include_software)
    pub include_software: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPCheckSpecialSurveyResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPCheckSpecialSurveyResponse {
        <CMsgClientDPCheckSpecialSurveyResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 2;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_url = 4;

    pub fn custom_url(&self) -> &str {
        match self.custom_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_url(&mut self) {
        self.custom_url = ::std::option::Option::None;
    }

    pub fn has_custom_url(&self) -> bool {
        self.custom_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_url(&mut self, v: ::std::string::String) {
        self.custom_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_url(&mut self) -> &mut ::std::string::String {
        if self.custom_url.is_none() {
            self.custom_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_url(&mut self) -> ::std::string::String {
        self.custom_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool include_software = 5;

    pub fn include_software(&self) -> bool {
        self.include_software.unwrap_or(false)
    }

    pub fn clear_include_software(&mut self) {
        self.include_software = ::std::option::Option::None;
    }

    pub fn has_include_software(&self) -> bool {
        self.include_software.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_software(&mut self, v: bool) {
        self.include_software = ::std::option::Option::Some(v);
    }

    // optional bytes token = 6;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.eResult },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.eResult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.state },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.name },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_url",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.custom_url },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.custom_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_software",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.include_software },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.include_software },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.token },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPCheckSpecialSurveyResponse>(
            "CMsgClientDPCheckSpecialSurveyResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDPCheckSpecialSurveyResponse {
    const NAME: &'static str = "CMsgClientDPCheckSpecialSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.custom_url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.include_software = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.custom_url.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.include_software {
            my_size += 1 + 1;
        }
        if let Some(v) = self.token.as_ref() {
            my_size += crate::rt::bytes_size(6, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.custom_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.include_software {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        CMsgClientDPCheckSpecialSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.custom_url = ::std::option::Option::None;
        self.include_software = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurveyResponse {
        static instance: CMsgClientDPCheckSpecialSurveyResponse = CMsgClientDPCheckSpecialSurveyResponse {
            eResult: ::std::option::Option::None,
            state: ::std::option::Option::None,
            name: ::std::option::Option::None,
            custom_url: ::std::option::Option::None,
            include_software: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDPCheckSpecialSurveyResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPCheckSpecialSurveyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPCheckSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurveyResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPSendSpecialSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPSendSpecialSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponse.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponse.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPSendSpecialSurveyResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponse {
        <CMsgClientDPSendSpecialSurveyResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_id",
            |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.survey_id },
            |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.survey_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.data },
            |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.data },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPSendSpecialSurveyResponse>(
            "CMsgClientDPSendSpecialSurveyResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDPSendSpecialSurveyResponse {
    const NAME: &'static str = "CMsgClientDPSendSpecialSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        CMsgClientDPSendSpecialSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponse {
        static instance: CMsgClientDPSendSpecialSurveyResponse = CMsgClientDPSendSpecialSurveyResponse {
            survey_id: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDPSendSpecialSurveyResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPSendSpecialSurveyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPSendSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPSendSpecialSurveyResponseReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPSendSpecialSurveyResponseReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponseReply.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponseReply.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPSendSpecialSurveyResponseReply.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponseReply {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponseReply {
        <CMsgClientDPSendSpecialSurveyResponseReply as crate::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponseReply {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bytes token = 2;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.eResult },
            |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.eResult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.token },
            |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPSendSpecialSurveyResponseReply>(
            "CMsgClientDPSendSpecialSurveyResponseReply",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDPSendSpecialSurveyResponseReply {
    const NAME: &'static str = "CMsgClientDPSendSpecialSurveyResponseReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        CMsgClientDPSendSpecialSurveyResponseReply::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponseReply {
        static instance: CMsgClientDPSendSpecialSurveyResponseReply = CMsgClientDPSendSpecialSurveyResponseReply {
            eResult: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDPSendSpecialSurveyResponseReply {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPSendSpecialSurveyResponseReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPSendSpecialSurveyResponseReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponseReply {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestForgottenPasswordEmail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestForgottenPasswordEmail {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmail.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmail.password_tried)
    pub password_tried: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestForgottenPasswordEmail.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmail {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmail {
        <CMsgClientRequestForgottenPasswordEmail as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmail {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmail {
        ::std::default::Default::default()
    }

    // optional string account_name = 1;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password_tried = 2;

    pub fn password_tried(&self) -> &str {
        match self.password_tried.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_password_tried(&mut self) {
        self.password_tried = ::std::option::Option::None;
    }

    pub fn has_password_tried(&self) -> bool {
        self.password_tried.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_tried(&mut self, v: ::std::string::String) {
        self.password_tried = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password_tried(&mut self) -> &mut ::std::string::String {
        if self.password_tried.is_none() {
            self.password_tried = ::std::option::Option::Some(::std::string::String::new());
        }
        self.password_tried.as_mut().unwrap()
    }

    // Take field
    pub fn take_password_tried(&mut self) -> ::std::string::String {
        self.password_tried.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name",
            |m: &CMsgClientRequestForgottenPasswordEmail| { &m.account_name },
            |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.account_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "password_tried",
            |m: &CMsgClientRequestForgottenPasswordEmail| { &m.password_tried },
            |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.password_tried },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestForgottenPasswordEmail>(
            "CMsgClientRequestForgottenPasswordEmail",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestForgottenPasswordEmail {
    const NAME: &'static str = "CMsgClientRequestForgottenPasswordEmail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.password_tried = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.password_tried.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.password_tried.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmail {
        CMsgClientRequestForgottenPasswordEmail::new()
    }

    fn clear(&mut self) {
        self.account_name = ::std::option::Option::None;
        self.password_tried = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmail {
        static instance: CMsgClientRequestForgottenPasswordEmail = CMsgClientRequestForgottenPasswordEmail {
            account_name: ::std::option::Option::None,
            password_tried: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestForgottenPasswordEmail {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestForgottenPasswordEmail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestForgottenPasswordEmail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmail {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestForgottenPasswordEmailResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestForgottenPasswordEmailResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmailResponse.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmailResponse.use_secret_question)
    pub use_secret_question: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestForgottenPasswordEmailResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmailResponse {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmailResponse {
        <CMsgClientRequestForgottenPasswordEmailResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmailResponse {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(0)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bool use_secret_question = 2;

    pub fn use_secret_question(&self) -> bool {
        self.use_secret_question.unwrap_or(false)
    }

    pub fn clear_use_secret_question(&mut self) {
        self.use_secret_question = ::std::option::Option::None;
    }

    pub fn has_use_secret_question(&self) -> bool {
        self.use_secret_question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_secret_question(&mut self, v: bool) {
        self.use_secret_question = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.eResult },
            |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.eResult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_secret_question",
            |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.use_secret_question },
            |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.use_secret_question },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestForgottenPasswordEmailResponse>(
            "CMsgClientRequestForgottenPasswordEmailResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestForgottenPasswordEmailResponse {
    const NAME: &'static str = "CMsgClientRequestForgottenPasswordEmailResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.use_secret_question = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.use_secret_question {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.use_secret_question {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        CMsgClientRequestForgottenPasswordEmailResponse::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.use_secret_question = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmailResponse {
        static instance: CMsgClientRequestForgottenPasswordEmailResponse = CMsgClientRequestForgottenPasswordEmailResponse {
            eResult: ::std::option::Option::None,
            use_secret_question: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestForgottenPasswordEmailResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestForgottenPasswordEmailResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestForgottenPasswordEmailResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmailResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientItemAnnouncements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientItemAnnouncements {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.count_new_items)
    pub count_new_items: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.unseen_items)
    pub unseen_items: ::std::vec::Vec<cmsg_client_item_announcements::UnseenItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientItemAnnouncements.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientItemAnnouncements {
    fn default() -> &'a CMsgClientItemAnnouncements {
        <CMsgClientItemAnnouncements as crate::Message>::default_instance()
    }
}

impl CMsgClientItemAnnouncements {
    pub fn new() -> CMsgClientItemAnnouncements {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_items = 1;

    pub fn count_new_items(&self) -> u32 {
        self.count_new_items.unwrap_or(0)
    }

    pub fn clear_count_new_items(&mut self) {
        self.count_new_items = ::std::option::Option::None;
    }

    pub fn has_count_new_items(&self) -> bool {
        self.count_new_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_items(&mut self, v: u32) {
        self.count_new_items = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientItemAnnouncements.UnseenItem unseen_items = 2;

    pub fn unseen_items(&self) -> &[cmsg_client_item_announcements::UnseenItem] {
        &self.unseen_items
    }

    pub fn clear_unseen_items(&mut self) {
        self.unseen_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_unseen_items(&mut self, v: ::std::vec::Vec<cmsg_client_item_announcements::UnseenItem>) {
        self.unseen_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unseen_items(&mut self) -> &mut ::std::vec::Vec<cmsg_client_item_announcements::UnseenItem> {
        &mut self.unseen_items
    }

    // Take field
    pub fn take_unseen_items(&mut self) -> ::std::vec::Vec<cmsg_client_item_announcements::UnseenItem> {
        ::std::mem::replace(&mut self.unseen_items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_items",
            |m: &CMsgClientItemAnnouncements| { &m.count_new_items },
            |m: &mut CMsgClientItemAnnouncements| { &mut m.count_new_items },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unseen_items",
            |m: &CMsgClientItemAnnouncements| { &m.unseen_items },
            |m: &mut CMsgClientItemAnnouncements| { &mut m.unseen_items },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientItemAnnouncements>(
            "CMsgClientItemAnnouncements",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientItemAnnouncements {
    const NAME: &'static str = "CMsgClientItemAnnouncements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count_new_items = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.unseen_items.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_items {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.unseen_items {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.count_new_items {
            os.write_uint32(1, v)?;
        }
        for v in &self.unseen_items {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientItemAnnouncements {
        CMsgClientItemAnnouncements::new()
    }

    fn clear(&mut self) {
        self.count_new_items = ::std::option::Option::None;
        self.unseen_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientItemAnnouncements {
        static instance: CMsgClientItemAnnouncements = CMsgClientItemAnnouncements {
            count_new_items: ::std::option::Option::None,
            unseen_items: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientItemAnnouncements {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientItemAnnouncements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientItemAnnouncements {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientItemAnnouncements`
pub mod cmsg_client_item_announcements {
    // @@protoc_insertion_point(message:CMsgClientItemAnnouncements.UnseenItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UnseenItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.context_id)
        pub context_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.asset_id)
        pub asset_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.amount)
        pub amount: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.rtime32_gained)
        pub rtime32_gained: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.source_appid)
        pub source_appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientItemAnnouncements.UnseenItem.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UnseenItem {
        fn default() -> &'a UnseenItem {
            <UnseenItem as crate::Message>::default_instance()
        }
    }

    impl UnseenItem {
        pub fn new() -> UnseenItem {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 context_id = 2;

        pub fn context_id(&self) -> u64 {
            self.context_id.unwrap_or(0)
        }

        pub fn clear_context_id(&mut self) {
            self.context_id = ::std::option::Option::None;
        }

        pub fn has_context_id(&self) -> bool {
            self.context_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context_id(&mut self, v: u64) {
            self.context_id = ::std::option::Option::Some(v);
        }

        // optional uint64 asset_id = 3;

        pub fn asset_id(&self) -> u64 {
            self.asset_id.unwrap_or(0)
        }

        pub fn clear_asset_id(&mut self) {
            self.asset_id = ::std::option::Option::None;
        }

        pub fn has_asset_id(&self) -> bool {
            self.asset_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_asset_id(&mut self, v: u64) {
            self.asset_id = ::std::option::Option::Some(v);
        }

        // optional uint64 amount = 4;

        pub fn amount(&self) -> u64 {
            self.amount.unwrap_or(0)
        }

        pub fn clear_amount(&mut self) {
            self.amount = ::std::option::Option::None;
        }

        pub fn has_amount(&self) -> bool {
            self.amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_amount(&mut self, v: u64) {
            self.amount = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_gained = 5;

        pub fn rtime32_gained(&self) -> u32 {
            self.rtime32_gained.unwrap_or(0)
        }

        pub fn clear_rtime32_gained(&mut self) {
            self.rtime32_gained = ::std::option::Option::None;
        }

        pub fn has_rtime32_gained(&self) -> bool {
            self.rtime32_gained.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_gained(&mut self, v: u32) {
            self.rtime32_gained = ::std::option::Option::Some(v);
        }

        // optional uint32 source_appid = 6;

        pub fn source_appid(&self) -> u32 {
            self.source_appid.unwrap_or(0)
        }

        pub fn clear_source_appid(&mut self) {
            self.source_appid = ::std::option::Option::None;
        }

        pub fn has_source_appid(&self) -> bool {
            self.source_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_appid(&mut self, v: u32) {
            self.source_appid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &UnseenItem| { &m.appid },
                |m: &mut UnseenItem| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "context_id",
                |m: &UnseenItem| { &m.context_id },
                |m: &mut UnseenItem| { &mut m.context_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "asset_id",
                |m: &UnseenItem| { &m.asset_id },
                |m: &mut UnseenItem| { &mut m.asset_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "amount",
                |m: &UnseenItem| { &m.amount },
                |m: &mut UnseenItem| { &mut m.amount },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime32_gained",
                |m: &UnseenItem| { &m.rtime32_gained },
                |m: &mut UnseenItem| { &mut m.rtime32_gained },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_appid",
                |m: &UnseenItem| { &m.source_appid },
                |m: &mut UnseenItem| { &mut m.source_appid },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<UnseenItem>(
                "CMsgClientItemAnnouncements.UnseenItem",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for UnseenItem {
        const NAME: &'static str = "UnseenItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.asset_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.amount = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    45 => {
                        self.rtime32_gained = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    48 => {
                        self.source_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.context_id {
                my_size += crate::rt::uint64_size(2, v);
            }
            if let Some(v) = self.asset_id {
                my_size += crate::rt::uint64_size(3, v);
            }
            if let Some(v) = self.amount {
                my_size += crate::rt::uint64_size(4, v);
            }
            if let Some(v) = self.rtime32_gained {
                my_size += 1 + 4;
            }
            if let Some(v) = self.source_appid {
                my_size += crate::rt::uint32_size(6, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.context_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.asset_id {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.amount {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.rtime32_gained {
                os.write_fixed32(5, v)?;
            }
            if let Some(v) = self.source_appid {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UnseenItem {
            UnseenItem::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.context_id = ::std::option::Option::None;
            self.asset_id = ::std::option::Option::None;
            self.amount = ::std::option::Option::None;
            self.rtime32_gained = ::std::option::Option::None;
            self.source_appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UnseenItem {
            static instance: UnseenItem = UnseenItem {
                appid: ::std::option::Option::None,
                context_id: ::std::option::Option::None,
                asset_id: ::std::option::Option::None,
                amount: ::std::option::Option::None,
                rtime32_gained: ::std::option::Option::None,
                source_appid: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for UnseenItem {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientItemAnnouncements.UnseenItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UnseenItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for UnseenItem {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestItemAnnouncements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestItemAnnouncements {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestItemAnnouncements.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestItemAnnouncements {
    fn default() -> &'a CMsgClientRequestItemAnnouncements {
        <CMsgClientRequestItemAnnouncements as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestItemAnnouncements {
    pub fn new() -> CMsgClientRequestItemAnnouncements {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestItemAnnouncements>(
            "CMsgClientRequestItemAnnouncements",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestItemAnnouncements {
    const NAME: &'static str = "CMsgClientRequestItemAnnouncements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestItemAnnouncements {
        CMsgClientRequestItemAnnouncements::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestItemAnnouncements {
        static instance: CMsgClientRequestItemAnnouncements = CMsgClientRequestItemAnnouncements {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestItemAnnouncements {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestItemAnnouncements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestItemAnnouncements {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUserNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUserNotifications {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUserNotifications.notifications)
    pub notifications: ::std::vec::Vec<cmsg_client_user_notifications::Notification>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUserNotifications.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUserNotifications {
    fn default() -> &'a CMsgClientUserNotifications {
        <CMsgClientUserNotifications as crate::Message>::default_instance()
    }
}

impl CMsgClientUserNotifications {
    pub fn new() -> CMsgClientUserNotifications {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientUserNotifications.Notification notifications = 1;

    pub fn notifications(&self) -> &[cmsg_client_user_notifications::Notification] {
        &self.notifications
    }

    pub fn clear_notifications(&mut self) {
        self.notifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: ::std::vec::Vec<cmsg_client_user_notifications::Notification>) {
        self.notifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut ::std::vec::Vec<cmsg_client_user_notifications::Notification> {
        &mut self.notifications
    }

    // Take field
    pub fn take_notifications(&mut self) -> ::std::vec::Vec<cmsg_client_user_notifications::Notification> {
        ::std::mem::replace(&mut self.notifications, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notifications",
            |m: &CMsgClientUserNotifications| { &m.notifications },
            |m: &mut CMsgClientUserNotifications| { &mut m.notifications },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUserNotifications>(
            "CMsgClientUserNotifications",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUserNotifications {
    const NAME: &'static str = "CMsgClientUserNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notifications.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.notifications {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUserNotifications {
        CMsgClientUserNotifications::new()
    }

    fn clear(&mut self) {
        self.notifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUserNotifications {
        static instance: CMsgClientUserNotifications = CMsgClientUserNotifications {
            notifications: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUserNotifications {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUserNotifications").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUserNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUserNotifications {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUserNotifications`
pub mod cmsg_client_user_notifications {
    // @@protoc_insertion_point(message:CMsgClientUserNotifications.Notification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Notification {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUserNotifications.Notification.user_notification_type)
        pub user_notification_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUserNotifications.Notification.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUserNotifications.Notification.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Notification {
        fn default() -> &'a Notification {
            <Notification as crate::Message>::default_instance()
        }
    }

    impl Notification {
        pub fn new() -> Notification {
            ::std::default::Default::default()
        }

        // optional uint32 user_notification_type = 1;

        pub fn user_notification_type(&self) -> u32 {
            self.user_notification_type.unwrap_or(0)
        }

        pub fn clear_user_notification_type(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
        }

        pub fn has_user_notification_type(&self) -> bool {
            self.user_notification_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_notification_type(&mut self, v: u32) {
            self.user_notification_type = ::std::option::Option::Some(v);
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_notification_type",
                |m: &Notification| { &m.user_notification_type },
                |m: &mut Notification| { &mut m.user_notification_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &Notification| { &m.count },
                |m: &mut Notification| { &mut m.count },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Notification>(
                "CMsgClientUserNotifications.Notification",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Notification {
        const NAME: &'static str = "Notification";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.user_notification_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.user_notification_type {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.user_notification_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Notification {
            Notification::new()
        }

        fn clear(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Notification {
            static instance: Notification = Notification {
                user_notification_type: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Notification {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUserNotifications.Notification").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Notification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Notification {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientCommentNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCommentNotifications {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments)
    pub count_new_comments: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments_owner)
    pub count_new_comments_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments_subscriptions)
    pub count_new_comments_subscriptions: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCommentNotifications.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCommentNotifications {
    fn default() -> &'a CMsgClientCommentNotifications {
        <CMsgClientCommentNotifications as crate::Message>::default_instance()
    }
}

impl CMsgClientCommentNotifications {
    pub fn new() -> CMsgClientCommentNotifications {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_comments = 1;

    pub fn count_new_comments(&self) -> u32 {
        self.count_new_comments.unwrap_or(0)
    }

    pub fn clear_count_new_comments(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
    }

    pub fn has_count_new_comments(&self) -> bool {
        self.count_new_comments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments(&mut self, v: u32) {
        self.count_new_comments = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_owner = 2;

    pub fn count_new_comments_owner(&self) -> u32 {
        self.count_new_comments_owner.unwrap_or(0)
    }

    pub fn clear_count_new_comments_owner(&mut self) {
        self.count_new_comments_owner = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_owner(&self) -> bool {
        self.count_new_comments_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_owner(&mut self, v: u32) {
        self.count_new_comments_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_subscriptions = 3;

    pub fn count_new_comments_subscriptions(&self) -> u32 {
        self.count_new_comments_subscriptions.unwrap_or(0)
    }

    pub fn clear_count_new_comments_subscriptions(&mut self) {
        self.count_new_comments_subscriptions = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_subscriptions(&self) -> bool {
        self.count_new_comments_subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_subscriptions(&mut self, v: u32) {
        self.count_new_comments_subscriptions = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_comments",
            |m: &CMsgClientCommentNotifications| { &m.count_new_comments },
            |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_comments_owner",
            |m: &CMsgClientCommentNotifications| { &m.count_new_comments_owner },
            |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_comments_subscriptions",
            |m: &CMsgClientCommentNotifications| { &m.count_new_comments_subscriptions },
            |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_subscriptions },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCommentNotifications>(
            "CMsgClientCommentNotifications",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCommentNotifications {
    const NAME: &'static str = "CMsgClientCommentNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count_new_comments = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.count_new_comments_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count_new_comments_subscriptions = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_comments {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.count_new_comments_owner {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.count_new_comments {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count_new_comments_owner {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCommentNotifications {
        CMsgClientCommentNotifications::new()
    }

    fn clear(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
        self.count_new_comments_owner = ::std::option::Option::None;
        self.count_new_comments_subscriptions = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCommentNotifications {
        static instance: CMsgClientCommentNotifications = CMsgClientCommentNotifications {
            count_new_comments: ::std::option::Option::None,
            count_new_comments_owner: ::std::option::Option::None,
            count_new_comments_subscriptions: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCommentNotifications {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCommentNotifications").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCommentNotifications {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestCommentNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestCommentNotifications {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestCommentNotifications.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestCommentNotifications {
    fn default() -> &'a CMsgClientRequestCommentNotifications {
        <CMsgClientRequestCommentNotifications as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestCommentNotifications {
    pub fn new() -> CMsgClientRequestCommentNotifications {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestCommentNotifications>(
            "CMsgClientRequestCommentNotifications",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestCommentNotifications {
    const NAME: &'static str = "CMsgClientRequestCommentNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestCommentNotifications {
        CMsgClientRequestCommentNotifications::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestCommentNotifications {
        static instance: CMsgClientRequestCommentNotifications = CMsgClientRequestCommentNotifications {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestCommentNotifications {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestCommentNotifications").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestCommentNotifications {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientOfflineMessageNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOfflineMessageNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOfflineMessageNotification.offline_messages)
    pub offline_messages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientOfflineMessageNotification.friends_with_offline_messages)
    pub friends_with_offline_messages: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOfflineMessageNotification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOfflineMessageNotification {
    fn default() -> &'a CMsgClientOfflineMessageNotification {
        <CMsgClientOfflineMessageNotification as crate::Message>::default_instance()
    }
}

impl CMsgClientOfflineMessageNotification {
    pub fn new() -> CMsgClientOfflineMessageNotification {
        ::std::default::Default::default()
    }

    // optional uint32 offline_messages = 1;

    pub fn offline_messages(&self) -> u32 {
        self.offline_messages.unwrap_or(0)
    }

    pub fn clear_offline_messages(&mut self) {
        self.offline_messages = ::std::option::Option::None;
    }

    pub fn has_offline_messages(&self) -> bool {
        self.offline_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline_messages(&mut self, v: u32) {
        self.offline_messages = ::std::option::Option::Some(v);
    }

    // repeated uint32 friends_with_offline_messages = 2;

    pub fn friends_with_offline_messages(&self) -> &[u32] {
        &self.friends_with_offline_messages
    }

    pub fn clear_friends_with_offline_messages(&mut self) {
        self.friends_with_offline_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends_with_offline_messages(&mut self, v: ::std::vec::Vec<u32>) {
        self.friends_with_offline_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends_with_offline_messages(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.friends_with_offline_messages
    }

    // Take field
    pub fn take_friends_with_offline_messages(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.friends_with_offline_messages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offline_messages",
            |m: &CMsgClientOfflineMessageNotification| { &m.offline_messages },
            |m: &mut CMsgClientOfflineMessageNotification| { &mut m.offline_messages },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends_with_offline_messages",
            |m: &CMsgClientOfflineMessageNotification| { &m.friends_with_offline_messages },
            |m: &mut CMsgClientOfflineMessageNotification| { &mut m.friends_with_offline_messages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientOfflineMessageNotification>(
            "CMsgClientOfflineMessageNotification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientOfflineMessageNotification {
    const NAME: &'static str = "CMsgClientOfflineMessageNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offline_messages = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.friends_with_offline_messages)?;
                },
                16 => {
                    self.friends_with_offline_messages.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offline_messages {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.friends_with_offline_messages {
            my_size += crate::rt::uint32_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.offline_messages {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends_with_offline_messages {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOfflineMessageNotification {
        CMsgClientOfflineMessageNotification::new()
    }

    fn clear(&mut self) {
        self.offline_messages = ::std::option::Option::None;
        self.friends_with_offline_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOfflineMessageNotification {
        static instance: CMsgClientOfflineMessageNotification = CMsgClientOfflineMessageNotification {
            offline_messages: ::std::option::Option::None,
            friends_with_offline_messages: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientOfflineMessageNotification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientOfflineMessageNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientOfflineMessageNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientOfflineMessageNotification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestOfflineMessageCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestOfflineMessageCount {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestOfflineMessageCount.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestOfflineMessageCount {
    fn default() -> &'a CMsgClientRequestOfflineMessageCount {
        <CMsgClientRequestOfflineMessageCount as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestOfflineMessageCount {
    pub fn new() -> CMsgClientRequestOfflineMessageCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestOfflineMessageCount>(
            "CMsgClientRequestOfflineMessageCount",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestOfflineMessageCount {
    const NAME: &'static str = "CMsgClientRequestOfflineMessageCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestOfflineMessageCount {
        CMsgClientRequestOfflineMessageCount::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestOfflineMessageCount {
        static instance: CMsgClientRequestOfflineMessageCount = CMsgClientRequestOfflineMessageCount {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestOfflineMessageCount {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestOfflineMessageCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestOfflineMessageCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestOfflineMessageCount {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistory.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistory.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistory {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistory {
        <CMsgClientChatGetFriendMessageHistory as crate::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistory {
    pub fn new() -> CMsgClientChatGetFriendMessageHistory {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientChatGetFriendMessageHistory| { &m.steamid },
            |m: &mut CMsgClientChatGetFriendMessageHistory| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatGetFriendMessageHistory>(
            "CMsgClientChatGetFriendMessageHistory",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientChatGetFriendMessageHistory {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistory {
        CMsgClientChatGetFriendMessageHistory::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistory {
        static instance: CMsgClientChatGetFriendMessageHistory = CMsgClientChatGetFriendMessageHistory {
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientChatGetFriendMessageHistory {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatGetFriendMessageHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistory {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.success)
    pub success: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.messages)
    pub messages: ::std::vec::Vec<cmsg_client_chat_get_friend_message_history_response::FriendMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryResponse {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryResponse {
        <CMsgClientChatGetFriendMessageHistoryResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryResponse {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 success = 2;

    pub fn success(&self) -> u32 {
        self.success.unwrap_or(0)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage messages = 3;

    pub fn messages(&self) -> &[cmsg_client_chat_get_friend_message_history_response::FriendMessage] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<cmsg_client_chat_get_friend_message_history_response::FriendMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<cmsg_client_chat_get_friend_message_history_response::FriendMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<cmsg_client_chat_get_friend_message_history_response::FriendMessage> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.steamid },
            |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.success },
            |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.success },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.messages },
            |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.messages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatGetFriendMessageHistoryResponse>(
            "CMsgClientChatGetFriendMessageHistoryResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientChatGetFriendMessageHistoryResponse {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.success = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.success {
            my_size += crate::rt::uint32_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.success {
            os.write_uint32(2, v)?;
        }
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        CMsgClientChatGetFriendMessageHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryResponse {
        static instance: CMsgClientChatGetFriendMessageHistoryResponse = CMsgClientChatGetFriendMessageHistoryResponse {
            steamid: ::std::option::Option::None,
            success: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientChatGetFriendMessageHistoryResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatGetFriendMessageHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientChatGetFriendMessageHistoryResponse`
pub mod cmsg_client_chat_get_friend_message_history_response {
    // @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendMessage {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.unread)
        pub unread: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendMessage {
        fn default() -> &'a FriendMessage {
            <FriendMessage as crate::Message>::default_instance()
        }
    }

    impl FriendMessage {
        pub fn new() -> FriendMessage {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool unread = 4;

        pub fn unread(&self) -> bool {
            self.unread.unwrap_or(false)
        }

        pub fn clear_unread(&mut self) {
            self.unread = ::std::option::Option::None;
        }

        pub fn has_unread(&self) -> bool {
            self.unread.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread(&mut self, v: bool) {
            self.unread = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &FriendMessage| { &m.accountid },
                |m: &mut FriendMessage| { &mut m.accountid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &FriendMessage| { &m.timestamp },
                |m: &mut FriendMessage| { &mut m.timestamp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &FriendMessage| { &m.message },
                |m: &mut FriendMessage| { &mut m.message },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "unread",
                |m: &FriendMessage| { &m.unread },
                |m: &mut FriendMessage| { &mut m.unread },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<FriendMessage>(
                "CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for FriendMessage {
        const NAME: &'static str = "FriendMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.unread = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.unread {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.unread {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendMessage {
            FriendMessage::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.unread = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendMessage {
            static instance: FriendMessage = FriendMessage {
                accountid: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                unread: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for FriendMessage {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FriendMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for FriendMessage {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryForOfflineMessages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryForOfflineMessages.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        <CMsgClientChatGetFriendMessageHistoryForOfflineMessages as crate::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatGetFriendMessageHistoryForOfflineMessages>(
            "CMsgClientChatGetFriendMessageHistoryForOfflineMessages",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistoryForOfflineMessages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        CMsgClientChatGetFriendMessageHistoryForOfflineMessages::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        static instance: CMsgClientChatGetFriendMessageHistoryForOfflineMessages = CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistoryForOfflineMessages").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevels)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFSGetFriendsSteamLevels {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevels.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevels.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevels {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevels {
        <CMsgClientFSGetFriendsSteamLevels as crate::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevels {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevels {
        ::std::default::Default::default()
    }

    // repeated uint32 accountids = 1;

    pub fn accountids(&self) -> &[u32] {
        &self.accountids
    }

    pub fn clear_accountids(&mut self) {
        self.accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }

    // Take field
    pub fn take_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accountids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accountids",
            |m: &CMsgClientFSGetFriendsSteamLevels| { &m.accountids },
            |m: &mut CMsgClientFSGetFriendsSteamLevels| { &mut m.accountids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFSGetFriendsSteamLevels>(
            "CMsgClientFSGetFriendsSteamLevels",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFSGetFriendsSteamLevels {
    const NAME: &'static str = "CMsgClientFSGetFriendsSteamLevels";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                8 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accountids {
            my_size += crate::rt::uint32_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.accountids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevels {
        CMsgClientFSGetFriendsSteamLevels::new()
    }

    fn clear(&mut self) {
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevels {
        static instance: CMsgClientFSGetFriendsSteamLevels = CMsgClientFSGetFriendsSteamLevels {
            accountids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFSGetFriendsSteamLevels {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFSGetFriendsSteamLevels").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFSGetFriendsSteamLevels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevels {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevelsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFSGetFriendsSteamLevelsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.friends)
    pub friends: ::std::vec::Vec<cmsg_client_fsget_friends_steam_levels_response::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevelsResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevelsResponse {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevelsResponse {
        <CMsgClientFSGetFriendsSteamLevelsResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevelsResponse {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientFSGetFriendsSteamLevelsResponse.Friend friends = 1;

    pub fn friends(&self) -> &[cmsg_client_fsget_friends_steam_levels_response::Friend] {
        &self.friends
    }

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::std::vec::Vec<cmsg_client_fsget_friends_steam_levels_response::Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::std::vec::Vec<cmsg_client_fsget_friends_steam_levels_response::Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::std::vec::Vec<cmsg_client_fsget_friends_steam_levels_response::Friend> {
        ::std::mem::replace(&mut self.friends, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends",
            |m: &CMsgClientFSGetFriendsSteamLevelsResponse| { &m.friends },
            |m: &mut CMsgClientFSGetFriendsSteamLevelsResponse| { &mut m.friends },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFSGetFriendsSteamLevelsResponse>(
            "CMsgClientFSGetFriendsSteamLevelsResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFSGetFriendsSteamLevelsResponse {
    const NAME: &'static str = "CMsgClientFSGetFriendsSteamLevelsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.friends.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.friends {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        CMsgClientFSGetFriendsSteamLevelsResponse::new()
    }

    fn clear(&mut self) {
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevelsResponse {
        static instance: CMsgClientFSGetFriendsSteamLevelsResponse = CMsgClientFSGetFriendsSteamLevelsResponse {
            friends: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFSGetFriendsSteamLevelsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevelsResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientFSGetFriendsSteamLevelsResponse`
pub mod cmsg_client_fsget_friends_steam_levels_response {
    // @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevelsResponse.Friend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Friend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.level)
        pub level: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as crate::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 2;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Friend| { &m.accountid },
                |m: &mut Friend| { &mut m.accountid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &Friend| { &m.level },
                |m: &mut Friend| { &mut m.level },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Friend>(
                "CMsgClientFSGetFriendsSteamLevelsResponse.Friend",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Friend {
        const NAME: &'static str = "Friend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.level {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Friend {
            static instance: Friend = Friend {
                accountid: ::std::option::Option::None,
                level: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Friend {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientFSGetFriendsSteamLevelsResponse.Friend").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Friend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Friend {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientEmailAddrInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEmailAddrInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_address)
    pub email_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_is_validated)
    pub email_is_validated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_validation_changed)
    pub email_validation_changed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.credential_change_requires_code)
    pub credential_change_requires_code: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.password_or_secretqa_change_requires_code)
    pub password_or_secretqa_change_requires_code: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEmailAddrInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmailAddrInfo {
    fn default() -> &'a CMsgClientEmailAddrInfo {
        <CMsgClientEmailAddrInfo as crate::Message>::default_instance()
    }
}

impl CMsgClientEmailAddrInfo {
    pub fn new() -> CMsgClientEmailAddrInfo {
        ::std::default::Default::default()
    }

    // optional string email_address = 1;

    pub fn email_address(&self) -> &str {
        match self.email_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_email_address(&mut self) {
        self.email_address = ::std::option::Option::None;
    }

    pub fn has_email_address(&self) -> bool {
        self.email_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        if self.email_address.is_none() {
            self.email_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.email_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool email_is_validated = 2;

    pub fn email_is_validated(&self) -> bool {
        self.email_is_validated.unwrap_or(false)
    }

    pub fn clear_email_is_validated(&mut self) {
        self.email_is_validated = ::std::option::Option::None;
    }

    pub fn has_email_is_validated(&self) -> bool {
        self.email_is_validated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_is_validated(&mut self, v: bool) {
        self.email_is_validated = ::std::option::Option::Some(v);
    }

    // optional bool email_validation_changed = 3;

    pub fn email_validation_changed(&self) -> bool {
        self.email_validation_changed.unwrap_or(false)
    }

    pub fn clear_email_validation_changed(&mut self) {
        self.email_validation_changed = ::std::option::Option::None;
    }

    pub fn has_email_validation_changed(&self) -> bool {
        self.email_validation_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_validation_changed(&mut self, v: bool) {
        self.email_validation_changed = ::std::option::Option::Some(v);
    }

    // optional bool credential_change_requires_code = 4;

    pub fn credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.unwrap_or(false)
    }

    pub fn clear_credential_change_requires_code(&mut self) {
        self.credential_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_change_requires_code(&mut self, v: bool) {
        self.credential_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool password_or_secretqa_change_requires_code = 5;

    pub fn password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.unwrap_or(false)
    }

    pub fn clear_password_or_secretqa_change_requires_code(&mut self) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_or_secretqa_change_requires_code(&mut self, v: bool) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_address",
            |m: &CMsgClientEmailAddrInfo| { &m.email_address },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_address },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_is_validated",
            |m: &CMsgClientEmailAddrInfo| { &m.email_is_validated },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_is_validated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_validation_changed",
            |m: &CMsgClientEmailAddrInfo| { &m.email_validation_changed },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_validation_changed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "credential_change_requires_code",
            |m: &CMsgClientEmailAddrInfo| { &m.credential_change_requires_code },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.credential_change_requires_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "password_or_secretqa_change_requires_code",
            |m: &CMsgClientEmailAddrInfo| { &m.password_or_secretqa_change_requires_code },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.password_or_secretqa_change_requires_code },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientEmailAddrInfo>(
            "CMsgClientEmailAddrInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientEmailAddrInfo {
    const NAME: &'static str = "CMsgClientEmailAddrInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.email_address = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.email_is_validated = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.email_validation_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.credential_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.email_address.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.email_is_validated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.email_validation_changed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.credential_change_requires_code {
            my_size += 1 + 1;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.email_address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.email_is_validated {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.email_validation_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.credential_change_requires_code {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEmailAddrInfo {
        CMsgClientEmailAddrInfo::new()
    }

    fn clear(&mut self) {
        self.email_address = ::std::option::Option::None;
        self.email_is_validated = ::std::option::Option::None;
        self.email_validation_changed = ::std::option::Option::None;
        self.credential_change_requires_code = ::std::option::Option::None;
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEmailAddrInfo {
        static instance: CMsgClientEmailAddrInfo = CMsgClientEmailAddrInfo {
            email_address: ::std::option::Option::None,
            email_is_validated: ::std::option::Option::None,
            email_validation_changed: ::std::option::Option::None,
            credential_change_requires_code: ::std::option::Option::None,
            password_or_secretqa_change_requires_code: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientEmailAddrInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientEmailAddrInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientEmailAddrInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientEmailAddrInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCREItemVoteSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREItemVoteSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummary.published_file_ids)
    pub published_file_ids: ::std::vec::Vec<cmsg_creitem_vote_summary::PublishedFileId>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummary.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummary {
    fn default() -> &'a CMsgCREItemVoteSummary {
        <CMsgCREItemVoteSummary as crate::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummary {
    pub fn new() -> CMsgCREItemVoteSummary {
        ::std::default::Default::default()
    }

    // repeated .CMsgCREItemVoteSummary.PublishedFileId published_file_ids = 1;

    pub fn published_file_ids(&self) -> &[cmsg_creitem_vote_summary::PublishedFileId] {
        &self.published_file_ids
    }

    pub fn clear_published_file_ids(&mut self) {
        self.published_file_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_file_ids(&mut self, v: ::std::vec::Vec<cmsg_creitem_vote_summary::PublishedFileId>) {
        self.published_file_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_file_ids(&mut self) -> &mut ::std::vec::Vec<cmsg_creitem_vote_summary::PublishedFileId> {
        &mut self.published_file_ids
    }

    // Take field
    pub fn take_published_file_ids(&mut self) -> ::std::vec::Vec<cmsg_creitem_vote_summary::PublishedFileId> {
        ::std::mem::replace(&mut self.published_file_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_file_ids",
            |m: &CMsgCREItemVoteSummary| { &m.published_file_ids },
            |m: &mut CMsgCREItemVoteSummary| { &mut m.published_file_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREItemVoteSummary>(
            "CMsgCREItemVoteSummary",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCREItemVoteSummary {
    const NAME: &'static str = "CMsgCREItemVoteSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.published_file_ids.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.published_file_ids {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREItemVoteSummary {
        CMsgCREItemVoteSummary::new()
    }

    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummary {
        static instance: CMsgCREItemVoteSummary = CMsgCREItemVoteSummary {
            published_file_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCREItemVoteSummary {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREItemVoteSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCREItemVoteSummary {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREItemVoteSummary`
pub mod cmsg_creitem_vote_summary {
    // @@protoc_insertion_point(message:CMsgCREItemVoteSummary.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummary.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummary.PublishedFileId.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as crate::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgCREItemVoteSummary.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PublishedFileId {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummary.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgCREItemVoteSummaryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREItemVoteSummaryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.item_vote_summaries)
    pub item_vote_summaries: ::std::vec::Vec<cmsg_creitem_vote_summary_response::ItemVoteSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummaryResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummaryResponse {
    fn default() -> &'a CMsgCREItemVoteSummaryResponse {
        <CMsgCREItemVoteSummaryResponse as crate::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummaryResponse {
    pub fn new() -> CMsgCREItemVoteSummaryResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgCREItemVoteSummaryResponse.ItemVoteSummary item_vote_summaries = 2;

    pub fn item_vote_summaries(&self) -> &[cmsg_creitem_vote_summary_response::ItemVoteSummary] {
        &self.item_vote_summaries
    }

    pub fn clear_item_vote_summaries(&mut self) {
        self.item_vote_summaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_vote_summaries(&mut self, v: ::std::vec::Vec<cmsg_creitem_vote_summary_response::ItemVoteSummary>) {
        self.item_vote_summaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_vote_summaries(&mut self) -> &mut ::std::vec::Vec<cmsg_creitem_vote_summary_response::ItemVoteSummary> {
        &mut self.item_vote_summaries
    }

    // Take field
    pub fn take_item_vote_summaries(&mut self) -> ::std::vec::Vec<cmsg_creitem_vote_summary_response::ItemVoteSummary> {
        ::std::mem::replace(&mut self.item_vote_summaries, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgCREItemVoteSummaryResponse| { &m.eresult },
            |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_vote_summaries",
            |m: &CMsgCREItemVoteSummaryResponse| { &m.item_vote_summaries },
            |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.item_vote_summaries },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREItemVoteSummaryResponse>(
            "CMsgCREItemVoteSummaryResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCREItemVoteSummaryResponse {
    const NAME: &'static str = "CMsgCREItemVoteSummaryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.item_vote_summaries.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.item_vote_summaries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.item_vote_summaries {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREItemVoteSummaryResponse {
        CMsgCREItemVoteSummaryResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.item_vote_summaries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummaryResponse {
        static instance: CMsgCREItemVoteSummaryResponse = CMsgCREItemVoteSummaryResponse {
            eresult: ::std::option::Option::None,
            item_vote_summaries: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCREItemVoteSummaryResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummaryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREItemVoteSummaryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCREItemVoteSummaryResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREItemVoteSummaryResponse`
pub mod cmsg_creitem_vote_summary_response {
    // @@protoc_insertion_point(message:CMsgCREItemVoteSummaryResponse.ItemVoteSummary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemVoteSummary {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.votes_for)
        pub votes_for: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.votes_against)
        pub votes_against: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.reports)
        pub reports: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.score)
        pub score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemVoteSummary {
        fn default() -> &'a ItemVoteSummary {
            <ItemVoteSummary as crate::Message>::default_instance()
        }
    }

    impl ItemVoteSummary {
        pub fn new() -> ItemVoteSummary {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 votes_for = 2;

        pub fn votes_for(&self) -> i32 {
            self.votes_for.unwrap_or(0)
        }

        pub fn clear_votes_for(&mut self) {
            self.votes_for = ::std::option::Option::None;
        }

        pub fn has_votes_for(&self) -> bool {
            self.votes_for.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_for(&mut self, v: i32) {
            self.votes_for = ::std::option::Option::Some(v);
        }

        // optional int32 votes_against = 3;

        pub fn votes_against(&self) -> i32 {
            self.votes_against.unwrap_or(0)
        }

        pub fn clear_votes_against(&mut self) {
            self.votes_against = ::std::option::Option::None;
        }

        pub fn has_votes_against(&self) -> bool {
            self.votes_against.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_against(&mut self, v: i32) {
            self.votes_against = ::std::option::Option::Some(v);
        }

        // optional int32 reports = 4;

        pub fn reports(&self) -> i32 {
            self.reports.unwrap_or(0)
        }

        pub fn clear_reports(&mut self) {
            self.reports = ::std::option::Option::None;
        }

        pub fn has_reports(&self) -> bool {
            self.reports.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reports(&mut self, v: i32) {
            self.reports = ::std::option::Option::Some(v);
        }

        // optional float score = 5;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &ItemVoteSummary| { &m.published_file_id },
                |m: &mut ItemVoteSummary| { &mut m.published_file_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "votes_for",
                |m: &ItemVoteSummary| { &m.votes_for },
                |m: &mut ItemVoteSummary| { &mut m.votes_for },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "votes_against",
                |m: &ItemVoteSummary| { &m.votes_against },
                |m: &mut ItemVoteSummary| { &mut m.votes_against },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "reports",
                |m: &ItemVoteSummary| { &m.reports },
                |m: &mut ItemVoteSummary| { &mut m.reports },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &ItemVoteSummary| { &m.score },
                |m: &mut ItemVoteSummary| { &mut m.score },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ItemVoteSummary>(
                "CMsgCREItemVoteSummaryResponse.ItemVoteSummary",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ItemVoteSummary {
        const NAME: &'static str = "ItemVoteSummary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.votes_for = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.votes_against = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.reports = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.votes_for {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.votes_against {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.reports {
                my_size += crate::rt::int32_size(4, v);
            }
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.votes_for {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.votes_against {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.reports {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.score {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemVoteSummary {
            ItemVoteSummary::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.votes_for = ::std::option::Option::None;
            self.votes_against = ::std::option::Option::None;
            self.reports = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemVoteSummary {
            static instance: ItemVoteSummary = ItemVoteSummary {
                published_file_id: ::std::option::Option::None,
                votes_for: ::std::option::Option::None,
                votes_against: ::std::option::Option::None,
                reports: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ItemVoteSummary {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummaryResponse.ItemVoteSummary").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemVoteSummary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ItemVoteSummary {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgCREUpdateUserPublishedItemVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREUpdateUserPublishedItemVote {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVote.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVote.vote_up)
    pub vote_up: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREUpdateUserPublishedItemVote.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVote {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVote {
        <CMsgCREUpdateUserPublishedItemVote as crate::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVote {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVote {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool vote_up = 2;

    pub fn vote_up(&self) -> bool {
        self.vote_up.unwrap_or(false)
    }

    pub fn clear_vote_up(&mut self) {
        self.vote_up = ::std::option::Option::None;
    }

    pub fn has_vote_up(&self) -> bool {
        self.vote_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_up(&mut self, v: bool) {
        self.vote_up = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgCREUpdateUserPublishedItemVote| { &m.published_file_id },
            |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.published_file_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_up",
            |m: &CMsgCREUpdateUserPublishedItemVote| { &m.vote_up },
            |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.vote_up },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREUpdateUserPublishedItemVote>(
            "CMsgCREUpdateUserPublishedItemVote",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCREUpdateUserPublishedItemVote {
    const NAME: &'static str = "CMsgCREUpdateUserPublishedItemVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.vote_up = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.vote_up {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote_up {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVote {
        CMsgCREUpdateUserPublishedItemVote::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.vote_up = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVote {
        static instance: CMsgCREUpdateUserPublishedItemVote = CMsgCREUpdateUserPublishedItemVote {
            published_file_id: ::std::option::Option::None,
            vote_up: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCREUpdateUserPublishedItemVote {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREUpdateUserPublishedItemVote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREUpdateUserPublishedItemVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVote {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCREUpdateUserPublishedItemVoteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREUpdateUserPublishedItemVoteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVoteResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREUpdateUserPublishedItemVoteResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVoteResponse {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVoteResponse {
        <CMsgCREUpdateUserPublishedItemVoteResponse as crate::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVoteResponse {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgCREUpdateUserPublishedItemVoteResponse| { &m.eresult },
            |m: &mut CMsgCREUpdateUserPublishedItemVoteResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREUpdateUserPublishedItemVoteResponse>(
            "CMsgCREUpdateUserPublishedItemVoteResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCREUpdateUserPublishedItemVoteResponse {
    const NAME: &'static str = "CMsgCREUpdateUserPublishedItemVoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        CMsgCREUpdateUserPublishedItemVoteResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVoteResponse {
        static instance: CMsgCREUpdateUserPublishedItemVoteResponse = CMsgCREUpdateUserPublishedItemVoteResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREUpdateUserPublishedItemVoteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVoteResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREGetUserPublishedItemVoteDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetails.published_file_ids)
    pub published_file_ids: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details::PublishedFileId>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetails.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetails {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetails {
        <CMsgCREGetUserPublishedItemVoteDetails as crate::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetails {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        ::std::default::Default::default()
    }

    // repeated .CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId published_file_ids = 1;

    pub fn published_file_ids(&self) -> &[cmsg_creget_user_published_item_vote_details::PublishedFileId] {
        &self.published_file_ids
    }

    pub fn clear_published_file_ids(&mut self) {
        self.published_file_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_file_ids(&mut self, v: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details::PublishedFileId>) {
        self.published_file_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_file_ids(&mut self) -> &mut ::std::vec::Vec<cmsg_creget_user_published_item_vote_details::PublishedFileId> {
        &mut self.published_file_ids
    }

    // Take field
    pub fn take_published_file_ids(&mut self) -> ::std::vec::Vec<cmsg_creget_user_published_item_vote_details::PublishedFileId> {
        ::std::mem::replace(&mut self.published_file_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_file_ids",
            |m: &CMsgCREGetUserPublishedItemVoteDetails| { &m.published_file_ids },
            |m: &mut CMsgCREGetUserPublishedItemVoteDetails| { &mut m.published_file_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREGetUserPublishedItemVoteDetails>(
            "CMsgCREGetUserPublishedItemVoteDetails",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCREGetUserPublishedItemVoteDetails {
    const NAME: &'static str = "CMsgCREGetUserPublishedItemVoteDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.published_file_ids.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.published_file_ids {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        CMsgCREGetUserPublishedItemVoteDetails::new()
    }

    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetails {
        static instance: CMsgCREGetUserPublishedItemVoteDetails = CMsgCREGetUserPublishedItemVoteDetails {
            published_file_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCREGetUserPublishedItemVoteDetails {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREGetUserPublishedItemVoteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetails {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetails`
pub mod cmsg_creget_user_published_item_vote_details {
    // @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as crate::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PublishedFileId {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.user_item_vote_details)
    pub user_item_vote_details: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetailsResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
        <CMsgCREGetUserPublishedItemVoteDetailsResponse as crate::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetailsResponse {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail user_item_vote_details = 2;

    pub fn user_item_vote_details(&self) -> &[cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail] {
        &self.user_item_vote_details
    }

    pub fn clear_user_item_vote_details(&mut self) {
        self.user_item_vote_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_item_vote_details(&mut self, v: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail>) {
        self.user_item_vote_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_item_vote_details(&mut self) -> &mut ::std::vec::Vec<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail> {
        &mut self.user_item_vote_details
    }

    // Take field
    pub fn take_user_item_vote_details(&mut self) -> ::std::vec::Vec<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail> {
        ::std::mem::replace(&mut self.user_item_vote_details, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.eresult },
            |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_item_vote_details",
            |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.user_item_vote_details },
            |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.user_item_vote_details },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREGetUserPublishedItemVoteDetailsResponse>(
            "CMsgCREGetUserPublishedItemVoteDetailsResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    const NAME: &'static str = "CMsgCREGetUserPublishedItemVoteDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.user_item_vote_details.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.user_item_vote_details {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.user_item_vote_details {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        CMsgCREGetUserPublishedItemVoteDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.user_item_vote_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetailsResponse {
        static instance: CMsgCREGetUserPublishedItemVoteDetailsResponse = CMsgCREGetUserPublishedItemVoteDetailsResponse {
            eresult: ::std::option::Option::None,
            user_item_vote_details: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetailsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetailsResponse`
pub mod cmsg_creget_user_published_item_vote_details_response {
    // @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserItemVoteDetail {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.vote)
        pub vote: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserItemVoteDetail {
        fn default() -> &'a UserItemVoteDetail {
            <UserItemVoteDetail as crate::Message>::default_instance()
        }
    }

    impl UserItemVoteDetail {
        pub fn new() -> UserItemVoteDetail {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 vote = 2;

        pub fn vote(&self) -> i32 {
            self.vote.unwrap_or(0i32)
        }

        pub fn clear_vote(&mut self) {
            self.vote = ::std::option::Option::None;
        }

        pub fn has_vote(&self) -> bool {
            self.vote.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote(&mut self, v: i32) {
            self.vote = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &UserItemVoteDetail| { &m.published_file_id },
                |m: &mut UserItemVoteDetail| { &mut m.published_file_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "vote",
                |m: &UserItemVoteDetail| { &m.vote },
                |m: &mut UserItemVoteDetail| { &mut m.vote },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<UserItemVoteDetail>(
                "CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for UserItemVoteDetail {
        const NAME: &'static str = "UserItemVoteDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.vote = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.vote {
                my_size += crate::rt::int32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.vote {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserItemVoteDetail {
            UserItemVoteDetail::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.vote = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserItemVoteDetail {
            static instance: UserItemVoteDetail = UserItemVoteDetail {
                published_file_id: ::std::option::Option::None,
                vote: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for UserItemVoteDetail {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserItemVoteDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for UserItemVoteDetail {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgFSGetFollowerCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetFollowerCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCount.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetFollowerCount.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCount {
    fn default() -> &'a CMsgFSGetFollowerCount {
        <CMsgFSGetFollowerCount as crate::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCount {
    pub fn new() -> CMsgFSGetFollowerCount {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgFSGetFollowerCount| { &m.steam_id },
            |m: &mut CMsgFSGetFollowerCount| { &mut m.steam_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetFollowerCount>(
            "CMsgFSGetFollowerCount",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFSGetFollowerCount {
    const NAME: &'static str = "CMsgFSGetFollowerCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetFollowerCount {
        CMsgFSGetFollowerCount::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCount {
        static instance: CMsgFSGetFollowerCount = CMsgFSGetFollowerCount {
            steam_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFSGetFollowerCount {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetFollowerCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetFollowerCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFSGetFollowerCount {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSGetFollowerCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetFollowerCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCountResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCountResponse.count)
    pub count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetFollowerCountResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCountResponse {
    fn default() -> &'a CMsgFSGetFollowerCountResponse {
        <CMsgFSGetFollowerCountResponse as crate::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCountResponse {
    pub fn new() -> CMsgFSGetFollowerCountResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0i32)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgFSGetFollowerCountResponse| { &m.eresult },
            |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CMsgFSGetFollowerCountResponse| { &m.count },
            |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetFollowerCountResponse>(
            "CMsgFSGetFollowerCountResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFSGetFollowerCountResponse {
    const NAME: &'static str = "CMsgFSGetFollowerCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetFollowerCountResponse {
        CMsgFSGetFollowerCountResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCountResponse {
        static instance: CMsgFSGetFollowerCountResponse = CMsgFSGetFollowerCountResponse {
            eresult: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFSGetFollowerCountResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetFollowerCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetFollowerCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFSGetFollowerCountResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSGetIsFollowing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetIsFollowing {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowing.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetIsFollowing.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowing {
    fn default() -> &'a CMsgFSGetIsFollowing {
        <CMsgFSGetIsFollowing as crate::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowing {
    pub fn new() -> CMsgFSGetIsFollowing {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgFSGetIsFollowing| { &m.steam_id },
            |m: &mut CMsgFSGetIsFollowing| { &mut m.steam_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetIsFollowing>(
            "CMsgFSGetIsFollowing",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFSGetIsFollowing {
    const NAME: &'static str = "CMsgFSGetIsFollowing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetIsFollowing {
        CMsgFSGetIsFollowing::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowing {
        static instance: CMsgFSGetIsFollowing = CMsgFSGetIsFollowing {
            steam_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFSGetIsFollowing {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetIsFollowing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetIsFollowing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFSGetIsFollowing {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSGetIsFollowingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetIsFollowingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowingResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowingResponse.is_following)
    pub is_following: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetIsFollowingResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowingResponse {
    fn default() -> &'a CMsgFSGetIsFollowingResponse {
        <CMsgFSGetIsFollowingResponse as crate::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowingResponse {
    pub fn new() -> CMsgFSGetIsFollowingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_following = 2;

    pub fn is_following(&self) -> bool {
        self.is_following.unwrap_or(false)
    }

    pub fn clear_is_following(&mut self) {
        self.is_following = ::std::option::Option::None;
    }

    pub fn has_is_following(&self) -> bool {
        self.is_following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_following(&mut self, v: bool) {
        self.is_following = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgFSGetIsFollowingResponse| { &m.eresult },
            |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_following",
            |m: &CMsgFSGetIsFollowingResponse| { &m.is_following },
            |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.is_following },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetIsFollowingResponse>(
            "CMsgFSGetIsFollowingResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFSGetIsFollowingResponse {
    const NAME: &'static str = "CMsgFSGetIsFollowingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.is_following = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.is_following {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.is_following {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetIsFollowingResponse {
        CMsgFSGetIsFollowingResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.is_following = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowingResponse {
        static instance: CMsgFSGetIsFollowingResponse = CMsgFSGetIsFollowingResponse {
            eresult: ::std::option::Option::None,
            is_following: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFSGetIsFollowingResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetIsFollowingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetIsFollowingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFSGetIsFollowingResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSEnumerateFollowingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSEnumerateFollowingList {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingList.start_index)
    pub start_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSEnumerateFollowingList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingList {
    fn default() -> &'a CMsgFSEnumerateFollowingList {
        <CMsgFSEnumerateFollowingList as crate::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingList {
    pub fn new() -> CMsgFSEnumerateFollowingList {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgFSEnumerateFollowingList| { &m.start_index },
            |m: &mut CMsgFSEnumerateFollowingList| { &mut m.start_index },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSEnumerateFollowingList>(
            "CMsgFSEnumerateFollowingList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFSEnumerateFollowingList {
    const NAME: &'static str = "CMsgFSEnumerateFollowingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSEnumerateFollowingList {
        CMsgFSEnumerateFollowingList::new()
    }

    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingList {
        static instance: CMsgFSEnumerateFollowingList = CMsgFSEnumerateFollowingList {
            start_index: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFSEnumerateFollowingList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSEnumerateFollowingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSEnumerateFollowingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFSEnumerateFollowingList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSEnumerateFollowingListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSEnumerateFollowingListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.total_results)
    pub total_results: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.steam_ids)
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSEnumerateFollowingListResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingListResponse {
    fn default() -> &'a CMsgFSEnumerateFollowingListResponse {
        <CMsgFSEnumerateFollowingListResponse as crate::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingListResponse {
    pub fn new() -> CMsgFSEnumerateFollowingListResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 total_results = 2;

    pub fn total_results(&self) -> i32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: i32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    // repeated fixed64 steam_ids = 3;

    pub fn steam_ids(&self) -> &[u64] {
        &self.steam_ids
    }

    pub fn clear_steam_ids(&mut self) {
        self.steam_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_steam_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.steam_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steam_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steam_ids
    }

    // Take field
    pub fn take_steam_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steam_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgFSEnumerateFollowingListResponse| { &m.eresult },
            |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgFSEnumerateFollowingListResponse| { &m.total_results },
            |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.total_results },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steam_ids",
            |m: &CMsgFSEnumerateFollowingListResponse| { &m.steam_ids },
            |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.steam_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSEnumerateFollowingListResponse>(
            "CMsgFSEnumerateFollowingListResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFSEnumerateFollowingListResponse {
    const NAME: &'static str = "CMsgFSEnumerateFollowingListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.total_results = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_ids)?;
                },
                25 => {
                    self.steam_ids.push(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.total_results {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += 9 * self.steam_ids.len() as u64;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.total_results {
            os.write_int32(2, v)?;
        }
        for v in &self.steam_ids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSEnumerateFollowingListResponse {
        CMsgFSEnumerateFollowingListResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.total_results = ::std::option::Option::None;
        self.steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingListResponse {
        static instance: CMsgFSEnumerateFollowingListResponse = CMsgFSEnumerateFollowingListResponse {
            eresult: ::std::option::Option::None,
            total_results: ::std::option::Option::None,
            steam_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFSEnumerateFollowingListResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSEnumerateFollowingListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSEnumerateFollowingListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFSEnumerateFollowingListResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDPGetNumberOfCurrentPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPGetNumberOfCurrentPlayers {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayers.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPGetNumberOfCurrentPlayers.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayers {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayers {
        <CMsgDPGetNumberOfCurrentPlayers as crate::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayers {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgDPGetNumberOfCurrentPlayers| { &m.appid },
            |m: &mut CMsgDPGetNumberOfCurrentPlayers| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDPGetNumberOfCurrentPlayers>(
            "CMsgDPGetNumberOfCurrentPlayers",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDPGetNumberOfCurrentPlayers {
    const NAME: &'static str = "CMsgDPGetNumberOfCurrentPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        CMsgDPGetNumberOfCurrentPlayers::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayers {
        static instance: CMsgDPGetNumberOfCurrentPlayers = CMsgDPGetNumberOfCurrentPlayers {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDPGetNumberOfCurrentPlayers {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDPGetNumberOfCurrentPlayers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDPGetNumberOfCurrentPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayers {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDPGetNumberOfCurrentPlayersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPGetNumberOfCurrentPlayersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayersResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayersResponse.player_count)
    pub player_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPGetNumberOfCurrentPlayersResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayersResponse {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayersResponse {
        <CMsgDPGetNumberOfCurrentPlayersResponse as crate::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayersResponse {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 player_count = 2;

    pub fn player_count(&self) -> i32 {
        self.player_count.unwrap_or(0)
    }

    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: i32) {
        self.player_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.eresult },
            |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_count",
            |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.player_count },
            |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.player_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDPGetNumberOfCurrentPlayersResponse>(
            "CMsgDPGetNumberOfCurrentPlayersResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDPGetNumberOfCurrentPlayersResponse {
    const NAME: &'static str = "CMsgDPGetNumberOfCurrentPlayersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_count {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        CMsgDPGetNumberOfCurrentPlayersResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.player_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayersResponse {
        static instance: CMsgDPGetNumberOfCurrentPlayersResponse = CMsgDPGetNumberOfCurrentPlayersResponse {
            eresult: ::std::option::Option::None,
            player_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDPGetNumberOfCurrentPlayersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayersResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFriendUserStatusPublished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendUserStatusPublished {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.friend_steamid)
    pub friend_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.status_text)
    pub status_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendUserStatusPublished.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendUserStatusPublished {
    fn default() -> &'a CMsgClientFriendUserStatusPublished {
        <CMsgClientFriendUserStatusPublished as crate::Message>::default_instance()
    }
}

impl CMsgClientFriendUserStatusPublished {
    pub fn new() -> CMsgClientFriendUserStatusPublished {
        ::std::default::Default::default()
    }

    // optional fixed64 friend_steamid = 1;

    pub fn friend_steamid(&self) -> u64 {
        self.friend_steamid.unwrap_or(0)
    }

    pub fn clear_friend_steamid(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
    }

    pub fn has_friend_steamid(&self) -> bool {
        self.friend_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_steamid(&mut self, v: u64) {
        self.friend_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;

    pub fn status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_text(&mut self) {
        self.status_text = ::std::option::Option::None;
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "friend_steamid",
            |m: &CMsgClientFriendUserStatusPublished| { &m.friend_steamid },
            |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.friend_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientFriendUserStatusPublished| { &m.appid },
            |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_text",
            |m: &CMsgClientFriendUserStatusPublished| { &m.status_text },
            |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.status_text },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendUserStatusPublished>(
            "CMsgClientFriendUserStatusPublished",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFriendUserStatusPublished {
    const NAME: &'static str = "CMsgClientFriendUserStatusPublished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.friend_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.status_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.friend_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.status_text.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.friend_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.status_text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendUserStatusPublished {
        CMsgClientFriendUserStatusPublished::new()
    }

    fn clear(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.status_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendUserStatusPublished {
        static instance: CMsgClientFriendUserStatusPublished = CMsgClientFriendUserStatusPublished {
            friend_steamid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            status_text: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFriendUserStatusPublished {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendUserStatusPublished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendUserStatusPublished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFriendUserStatusPublished {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceMethodLegacy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceMethodLegacy {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.serialized_method)
    pub serialized_method: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.is_notification)
    pub is_notification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceMethodLegacy.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacy {
    fn default() -> &'a CMsgClientServiceMethodLegacy {
        <CMsgClientServiceMethodLegacy as crate::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacy {
    pub fn new() -> CMsgClientServiceMethodLegacy {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method = 2;

    pub fn serialized_method(&self) -> &[u8] {
        match self.serialized_method.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method(&mut self) {
        self.serialized_method = ::std::option::Option::None;
    }

    pub fn has_serialized_method(&self) -> bool {
        self.serialized_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method(&mut self, v: ::bytes::Bytes) {
        self.serialized_method = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method(&mut self) -> &mut ::bytes::Bytes {
        if self.serialized_method.is_none() {
            self.serialized_method = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.serialized_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method(&mut self) -> ::bytes::Bytes {
        self.serialized_method.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool is_notification = 3;

    pub fn is_notification(&self) -> bool {
        self.is_notification.unwrap_or(false)
    }

    pub fn clear_is_notification(&mut self) {
        self.is_notification = ::std::option::Option::None;
    }

    pub fn has_is_notification(&self) -> bool {
        self.is_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_notification(&mut self, v: bool) {
        self.is_notification = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_name",
            |m: &CMsgClientServiceMethodLegacy| { &m.method_name },
            |m: &mut CMsgClientServiceMethodLegacy| { &mut m.method_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_method",
            |m: &CMsgClientServiceMethodLegacy| { &m.serialized_method },
            |m: &mut CMsgClientServiceMethodLegacy| { &mut m.serialized_method },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_notification",
            |m: &CMsgClientServiceMethodLegacy| { &m.is_notification },
            |m: &mut CMsgClientServiceMethodLegacy| { &mut m.is_notification },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceMethodLegacy>(
            "CMsgClientServiceMethodLegacy",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientServiceMethodLegacy {
    const NAME: &'static str = "CMsgClientServiceMethodLegacy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.serialized_method = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.is_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.is_notification {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.is_notification {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceMethodLegacy {
        CMsgClientServiceMethodLegacy::new()
    }

    fn clear(&mut self) {
        self.method_name = ::std::option::Option::None;
        self.serialized_method = ::std::option::Option::None;
        self.is_notification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacy {
        static instance: CMsgClientServiceMethodLegacy = CMsgClientServiceMethodLegacy {
            method_name: ::std::option::Option::None,
            serialized_method: ::std::option::Option::None,
            is_notification: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientServiceMethodLegacy {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceMethodLegacy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceMethodLegacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientServiceMethodLegacy {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceMethodLegacyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceMethodLegacyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacyResponse.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacyResponse.serialized_method_response)
    pub serialized_method_response: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceMethodLegacyResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacyResponse {
    fn default() -> &'a CMsgClientServiceMethodLegacyResponse {
        <CMsgClientServiceMethodLegacyResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacyResponse {
    pub fn new() -> CMsgClientServiceMethodLegacyResponse {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method_response = 2;

    pub fn serialized_method_response(&self) -> &[u8] {
        match self.serialized_method_response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method_response(&mut self) {
        self.serialized_method_response = ::std::option::Option::None;
    }

    pub fn has_serialized_method_response(&self) -> bool {
        self.serialized_method_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method_response(&mut self, v: ::bytes::Bytes) {
        self.serialized_method_response = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method_response(&mut self) -> &mut ::bytes::Bytes {
        if self.serialized_method_response.is_none() {
            self.serialized_method_response = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.serialized_method_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method_response(&mut self) -> ::bytes::Bytes {
        self.serialized_method_response.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_name",
            |m: &CMsgClientServiceMethodLegacyResponse| { &m.method_name },
            |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.method_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_method_response",
            |m: &CMsgClientServiceMethodLegacyResponse| { &m.serialized_method_response },
            |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.serialized_method_response },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceMethodLegacyResponse>(
            "CMsgClientServiceMethodLegacyResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientServiceMethodLegacyResponse {
    const NAME: &'static str = "CMsgClientServiceMethodLegacyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.serialized_method_response = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceMethodLegacyResponse {
        CMsgClientServiceMethodLegacyResponse::new()
    }

    fn clear(&mut self) {
        self.method_name = ::std::option::Option::None;
        self.serialized_method_response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacyResponse {
        static instance: CMsgClientServiceMethodLegacyResponse = CMsgClientServiceMethodLegacyResponse {
            method_name: ::std::option::Option::None,
            serialized_method_response: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientServiceMethodLegacyResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceMethodLegacyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceMethodLegacyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientServiceMethodLegacyResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUIMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUIMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUIMode.uimode)
    pub uimode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUIMode.chat_mode)
    pub chat_mode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUIMode.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUIMode {
    fn default() -> &'a CMsgClientUIMode {
        <CMsgClientUIMode as crate::Message>::default_instance()
    }
}

impl CMsgClientUIMode {
    pub fn new() -> CMsgClientUIMode {
        ::std::default::Default::default()
    }

    // optional uint32 uimode = 1;

    pub fn uimode(&self) -> u32 {
        self.uimode.unwrap_or(0)
    }

    pub fn clear_uimode(&mut self) {
        self.uimode = ::std::option::Option::None;
    }

    pub fn has_uimode(&self) -> bool {
        self.uimode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uimode(&mut self, v: u32) {
        self.uimode = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_mode = 2;

    pub fn chat_mode(&self) -> u32 {
        self.chat_mode.unwrap_or(0)
    }

    pub fn clear_chat_mode(&mut self) {
        self.chat_mode = ::std::option::Option::None;
    }

    pub fn has_chat_mode(&self) -> bool {
        self.chat_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_mode(&mut self, v: u32) {
        self.chat_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "uimode",
            |m: &CMsgClientUIMode| { &m.uimode },
            |m: &mut CMsgClientUIMode| { &mut m.uimode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_mode",
            |m: &CMsgClientUIMode| { &m.chat_mode },
            |m: &mut CMsgClientUIMode| { &mut m.chat_mode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUIMode>(
            "CMsgClientUIMode",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUIMode {
    const NAME: &'static str = "CMsgClientUIMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uimode = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.chat_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uimode {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.chat_mode {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.uimode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.chat_mode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUIMode {
        CMsgClientUIMode::new()
    }

    fn clear(&mut self) {
        self.uimode = ::std::option::Option::None;
        self.chat_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUIMode {
        static instance: CMsgClientUIMode = CMsgClientUIMode {
            uimode: ::std::option::Option::None,
            chat_mode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUIMode {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUIMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUIMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUIMode {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientVanityURLChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVanityURLChangedNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVanityURLChangedNotification.vanity_url)
    pub vanity_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVanityURLChangedNotification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVanityURLChangedNotification {
    fn default() -> &'a CMsgClientVanityURLChangedNotification {
        <CMsgClientVanityURLChangedNotification as crate::Message>::default_instance()
    }
}

impl CMsgClientVanityURLChangedNotification {
    pub fn new() -> CMsgClientVanityURLChangedNotification {
        ::std::default::Default::default()
    }

    // optional string vanity_url = 1;

    pub fn vanity_url(&self) -> &str {
        match self.vanity_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vanity_url(&mut self) {
        self.vanity_url = ::std::option::Option::None;
    }

    pub fn has_vanity_url(&self) -> bool {
        self.vanity_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vanity_url(&mut self, v: ::std::string::String) {
        self.vanity_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vanity_url(&mut self) -> &mut ::std::string::String {
        if self.vanity_url.is_none() {
            self.vanity_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vanity_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_vanity_url(&mut self) -> ::std::string::String {
        self.vanity_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vanity_url",
            |m: &CMsgClientVanityURLChangedNotification| { &m.vanity_url },
            |m: &mut CMsgClientVanityURLChangedNotification| { &mut m.vanity_url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientVanityURLChangedNotification>(
            "CMsgClientVanityURLChangedNotification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientVanityURLChangedNotification {
    const NAME: &'static str = "CMsgClientVanityURLChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vanity_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vanity_url.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.vanity_url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVanityURLChangedNotification {
        CMsgClientVanityURLChangedNotification::new()
    }

    fn clear(&mut self) {
        self.vanity_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVanityURLChangedNotification {
        static instance: CMsgClientVanityURLChangedNotification = CMsgClientVanityURLChangedNotification {
            vanity_url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientVanityURLChangedNotification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientVanityURLChangedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientVanityURLChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientVanityURLChangedNotification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.device_description)
    pub device_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.local_device_token)
    pub local_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDeviceRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceRequest {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceRequest {
        <CMsgClientAuthorizeLocalDeviceRequest as crate::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceRequest {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        ::std::default::Default::default()
    }

    // optional string device_description = 1;

    pub fn device_description(&self) -> &str {
        match self.device_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_description(&mut self) {
        self.device_description = ::std::option::Option::None;
    }

    pub fn has_device_description(&self) -> bool {
        self.device_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_description(&mut self, v: ::std::string::String) {
        self.device_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_description(&mut self) -> &mut ::std::string::String {
        if self.device_description.is_none() {
            self.device_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_description(&mut self) -> ::std::string::String {
        self.device_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_description",
            |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.device_description },
            |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.device_description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_account_id",
            |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.owner_account_id },
            |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.owner_account_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_device_token",
            |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.local_device_token },
            |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.local_device_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthorizeLocalDeviceRequest>(
            "CMsgClientAuthorizeLocalDeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAuthorizeLocalDeviceRequest {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_description = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_description.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.local_device_token {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.device_description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        CMsgClientAuthorizeLocalDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.device_description = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceRequest {
        static instance: CMsgClientAuthorizeLocalDeviceRequest = CMsgClientAuthorizeLocalDeviceRequest {
            device_description: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            local_device_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAuthorizeLocalDeviceRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthorizeLocalDeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthorizeLocalDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.authed_device_token)
    pub authed_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDevice.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDevice {
    fn default() -> &'a CMsgClientAuthorizeLocalDevice {
        <CMsgClientAuthorizeLocalDevice as crate::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDevice {
    pub fn new() -> CMsgClientAuthorizeLocalDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 authed_device_token = 3;

    pub fn authed_device_token(&self) -> u64 {
        self.authed_device_token.unwrap_or(0)
    }

    pub fn clear_authed_device_token(&mut self) {
        self.authed_device_token = ::std::option::Option::None;
    }

    pub fn has_authed_device_token(&self) -> bool {
        self.authed_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authed_device_token(&mut self, v: u64) {
        self.authed_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAuthorizeLocalDevice| { &m.eresult },
            |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_account_id",
            |m: &CMsgClientAuthorizeLocalDevice| { &m.owner_account_id },
            |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.owner_account_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "authed_device_token",
            |m: &CMsgClientAuthorizeLocalDevice| { &m.authed_device_token },
            |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.authed_device_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthorizeLocalDevice>(
            "CMsgClientAuthorizeLocalDevice",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAuthorizeLocalDevice {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.authed_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.authed_device_token {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.authed_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDevice {
        CMsgClientAuthorizeLocalDevice::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.authed_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDevice {
        static instance: CMsgClientAuthorizeLocalDevice = CMsgClientAuthorizeLocalDevice {
            eresult: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            authed_device_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAuthorizeLocalDevice {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthorizeLocalDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthorizeLocalDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAuthorizeLocalDevice {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDeviceNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDeviceNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.local_device_token)
    pub local_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDeviceNotification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceNotification {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceNotification {
        <CMsgClientAuthorizeLocalDeviceNotification as crate::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceNotification {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.eresult },
            |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_account_id",
            |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.owner_account_id },
            |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.owner_account_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_device_token",
            |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.local_device_token },
            |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.local_device_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthorizeLocalDeviceNotification>(
            "CMsgClientAuthorizeLocalDeviceNotification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAuthorizeLocalDeviceNotification {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDeviceNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.local_device_token {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        CMsgClientAuthorizeLocalDeviceNotification::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceNotification {
        static instance: CMsgClientAuthorizeLocalDeviceNotification = CMsgClientAuthorizeLocalDeviceNotification {
            eresult: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            local_device_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAuthorizeLocalDeviceNotification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthorizeLocalDeviceNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthorizeLocalDeviceNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceNotification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDeauthorizeDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeauthorizeDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDeviceRequest.deauthorization_account_id)
    pub deauthorization_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDeviceRequest.deauthorization_device_token)
    pub deauthorization_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeauthorizeDeviceRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDeviceRequest {
    fn default() -> &'a CMsgClientDeauthorizeDeviceRequest {
        <CMsgClientDeauthorizeDeviceRequest as crate::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDeviceRequest {
    pub fn new() -> CMsgClientDeauthorizeDeviceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 deauthorization_account_id = 1;

    pub fn deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 deauthorization_device_token = 2;

    pub fn deauthorization_device_token(&self) -> u64 {
        self.deauthorization_device_token.unwrap_or(0)
    }

    pub fn clear_deauthorization_device_token(&mut self) {
        self.deauthorization_device_token = ::std::option::Option::None;
    }

    pub fn has_deauthorization_device_token(&self) -> bool {
        self.deauthorization_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_device_token(&mut self, v: u64) {
        self.deauthorization_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deauthorization_account_id",
            |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_account_id },
            |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_account_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deauthorization_device_token",
            |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_device_token },
            |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_device_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeauthorizeDeviceRequest>(
            "CMsgClientDeauthorizeDeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDeauthorizeDeviceRequest {
    const NAME: &'static str = "CMsgClientDeauthorizeDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deauthorization_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deauthorization_account_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deauthorization_device_token {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deauthorization_device_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeauthorizeDeviceRequest {
        CMsgClientDeauthorizeDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
        self.deauthorization_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDeviceRequest {
        static instance: CMsgClientDeauthorizeDeviceRequest = CMsgClientDeauthorizeDeviceRequest {
            deauthorization_account_id: ::std::option::Option::None,
            deauthorization_device_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDeauthorizeDeviceRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeauthorizeDeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeauthorizeDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDeauthorizeDeviceRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDeauthorizeDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeauthorizeDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDevice.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDevice.deauthorization_account_id)
    pub deauthorization_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeauthorizeDevice.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDevice {
    fn default() -> &'a CMsgClientDeauthorizeDevice {
        <CMsgClientDeauthorizeDevice as crate::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDevice {
    pub fn new() -> CMsgClientDeauthorizeDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 deauthorization_account_id = 2;

    pub fn deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientDeauthorizeDevice| { &m.eresult },
            |m: &mut CMsgClientDeauthorizeDevice| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deauthorization_account_id",
            |m: &CMsgClientDeauthorizeDevice| { &m.deauthorization_account_id },
            |m: &mut CMsgClientDeauthorizeDevice| { &mut m.deauthorization_account_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeauthorizeDevice>(
            "CMsgClientDeauthorizeDevice",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDeauthorizeDevice {
    const NAME: &'static str = "CMsgClientDeauthorizeDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.deauthorization_account_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeauthorizeDevice {
        CMsgClientDeauthorizeDevice::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.deauthorization_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDevice {
        static instance: CMsgClientDeauthorizeDevice = CMsgClientDeauthorizeDevice {
            eresult: ::std::option::Option::None,
            deauthorization_account_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDeauthorizeDevice {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeauthorizeDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeauthorizeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDeauthorizeDevice {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUseLocalDeviceAuthorizations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUseLocalDeviceAuthorizations {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.authorization_account_id)
    pub authorization_account_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.device_tokens)
    pub device_tokens: ::std::vec::Vec<cmsg_client_use_local_device_authorizations::DeviceToken>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUseLocalDeviceAuthorizations.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUseLocalDeviceAuthorizations {
    fn default() -> &'a CMsgClientUseLocalDeviceAuthorizations {
        <CMsgClientUseLocalDeviceAuthorizations as crate::Message>::default_instance()
    }
}

impl CMsgClientUseLocalDeviceAuthorizations {
    pub fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        ::std::default::Default::default()
    }

    // repeated uint32 authorization_account_id = 1;

    pub fn authorization_account_id(&self) -> &[u32] {
        &self.authorization_account_id
    }

    pub fn clear_authorization_account_id(&mut self) {
        self.authorization_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorization_account_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.authorization_account_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorization_account_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.authorization_account_id
    }

    // Take field
    pub fn take_authorization_account_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.authorization_account_id, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientUseLocalDeviceAuthorizations.DeviceToken device_tokens = 2;

    pub fn device_tokens(&self) -> &[cmsg_client_use_local_device_authorizations::DeviceToken] {
        &self.device_tokens
    }

    pub fn clear_device_tokens(&mut self) {
        self.device_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_tokens(&mut self, v: ::std::vec::Vec<cmsg_client_use_local_device_authorizations::DeviceToken>) {
        self.device_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_tokens(&mut self) -> &mut ::std::vec::Vec<cmsg_client_use_local_device_authorizations::DeviceToken> {
        &mut self.device_tokens
    }

    // Take field
    pub fn take_device_tokens(&mut self) -> ::std::vec::Vec<cmsg_client_use_local_device_authorizations::DeviceToken> {
        ::std::mem::replace(&mut self.device_tokens, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "authorization_account_id",
            |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.authorization_account_id },
            |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.authorization_account_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "device_tokens",
            |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.device_tokens },
            |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.device_tokens },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUseLocalDeviceAuthorizations>(
            "CMsgClientUseLocalDeviceAuthorizations",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUseLocalDeviceAuthorizations {
    const NAME: &'static str = "CMsgClientUseLocalDeviceAuthorizations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.authorization_account_id)?;
                },
                8 => {
                    self.authorization_account_id.push(is.read_uint32()?);
                },
                18 => {
                    self.device_tokens.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.authorization_account_id {
            my_size += crate::rt::uint32_size(1, *value);
        };
        for value in &self.device_tokens {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.authorization_account_id {
            os.write_uint32(1, *v)?;
        };
        for v in &self.device_tokens {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        CMsgClientUseLocalDeviceAuthorizations::new()
    }

    fn clear(&mut self) {
        self.authorization_account_id.clear();
        self.device_tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUseLocalDeviceAuthorizations {
        static instance: CMsgClientUseLocalDeviceAuthorizations = CMsgClientUseLocalDeviceAuthorizations {
            authorization_account_id: ::std::vec::Vec::new(),
            device_tokens: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUseLocalDeviceAuthorizations {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUseLocalDeviceAuthorizations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUseLocalDeviceAuthorizations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUseLocalDeviceAuthorizations {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUseLocalDeviceAuthorizations`
pub mod cmsg_client_use_local_device_authorizations {
    // @@protoc_insertion_point(message:CMsgClientUseLocalDeviceAuthorizations.DeviceToken)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceToken {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.owner_account_id)
        pub owner_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.token_id)
        pub token_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceToken {
        fn default() -> &'a DeviceToken {
            <DeviceToken as crate::Message>::default_instance()
        }
    }

    impl DeviceToken {
        pub fn new() -> DeviceToken {
            ::std::default::Default::default()
        }

        // optional uint32 owner_account_id = 1;

        pub fn owner_account_id(&self) -> u32 {
            self.owner_account_id.unwrap_or(0)
        }

        pub fn clear_owner_account_id(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
        }

        pub fn has_owner_account_id(&self) -> bool {
            self.owner_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_account_id(&mut self, v: u32) {
            self.owner_account_id = ::std::option::Option::Some(v);
        }

        // optional uint64 token_id = 2;

        pub fn token_id(&self) -> u64 {
            self.token_id.unwrap_or(0)
        }

        pub fn clear_token_id(&mut self) {
            self.token_id = ::std::option::Option::None;
        }

        pub fn has_token_id(&self) -> bool {
            self.token_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token_id(&mut self, v: u64) {
            self.token_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_account_id",
                |m: &DeviceToken| { &m.owner_account_id },
                |m: &mut DeviceToken| { &mut m.owner_account_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "token_id",
                |m: &DeviceToken| { &m.token_id },
                |m: &mut DeviceToken| { &mut m.token_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceToken>(
                "CMsgClientUseLocalDeviceAuthorizations.DeviceToken",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceToken {
        const NAME: &'static str = "DeviceToken";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.token_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.owner_account_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.token_id {
                my_size += crate::rt::uint64_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.owner_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.token_id {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceToken {
            DeviceToken::new()
        }

        fn clear(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
            self.token_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceToken {
            static instance: DeviceToken = DeviceToken {
                owner_account_id: ::std::option::Option::None,
                token_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceToken {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUseLocalDeviceAuthorizations.DeviceToken").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceToken {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevices)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAuthorizedDevices {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevices.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevices {
    fn default() -> &'a CMsgClientGetAuthorizedDevices {
        <CMsgClientGetAuthorizedDevices as crate::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevices {
    pub fn new() -> CMsgClientGetAuthorizedDevices {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAuthorizedDevices>(
            "CMsgClientGetAuthorizedDevices",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetAuthorizedDevices {
    const NAME: &'static str = "CMsgClientGetAuthorizedDevices";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAuthorizedDevices {
        CMsgClientGetAuthorizedDevices::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevices {
        static instance: CMsgClientGetAuthorizedDevices = CMsgClientGetAuthorizedDevices {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetAuthorizedDevices {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAuthorizedDevices").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAuthorizedDevices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetAuthorizedDevices {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevicesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAuthorizedDevicesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.authorized_device)
    pub authorized_device: ::std::vec::Vec<cmsg_client_get_authorized_devices_response::AuthorizedDevice>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevicesResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevicesResponse {
    fn default() -> &'a CMsgClientGetAuthorizedDevicesResponse {
        <CMsgClientGetAuthorizedDevicesResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevicesResponse {
    pub fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice authorized_device = 2;

    pub fn authorized_device(&self) -> &[cmsg_client_get_authorized_devices_response::AuthorizedDevice] {
        &self.authorized_device
    }

    pub fn clear_authorized_device(&mut self) {
        self.authorized_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorized_device(&mut self, v: ::std::vec::Vec<cmsg_client_get_authorized_devices_response::AuthorizedDevice>) {
        self.authorized_device = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorized_device(&mut self) -> &mut ::std::vec::Vec<cmsg_client_get_authorized_devices_response::AuthorizedDevice> {
        &mut self.authorized_device
    }

    // Take field
    pub fn take_authorized_device(&mut self) -> ::std::vec::Vec<cmsg_client_get_authorized_devices_response::AuthorizedDevice> {
        ::std::mem::replace(&mut self.authorized_device, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.eresult },
            |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "authorized_device",
            |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.authorized_device },
            |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.authorized_device },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAuthorizedDevicesResponse>(
            "CMsgClientGetAuthorizedDevicesResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetAuthorizedDevicesResponse {
    const NAME: &'static str = "CMsgClientGetAuthorizedDevicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.authorized_device.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.authorized_device {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.authorized_device {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        CMsgClientGetAuthorizedDevicesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.authorized_device.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevicesResponse {
        static instance: CMsgClientGetAuthorizedDevicesResponse = CMsgClientGetAuthorizedDevicesResponse {
            eresult: ::std::option::Option::None,
            authorized_device: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetAuthorizedDevicesResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAuthorizedDevicesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAuthorizedDevicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetAuthorizedDevicesResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGetAuthorizedDevicesResponse`
pub mod cmsg_client_get_authorized_devices_response {
    // @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AuthorizedDevice {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.auth_device_token)
        pub auth_device_token: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.device_name)
        pub device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.last_access_time)
        pub last_access_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.borrower_id)
        pub borrower_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.is_pending)
        pub is_pending: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.app_played)
        pub app_played: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AuthorizedDevice {
        fn default() -> &'a AuthorizedDevice {
            <AuthorizedDevice as crate::Message>::default_instance()
        }
    }

    impl AuthorizedDevice {
        pub fn new() -> AuthorizedDevice {
            ::std::default::Default::default()
        }

        // optional uint64 auth_device_token = 1;

        pub fn auth_device_token(&self) -> u64 {
            self.auth_device_token.unwrap_or(0)
        }

        pub fn clear_auth_device_token(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
        }

        pub fn has_auth_device_token(&self) -> bool {
            self.auth_device_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_device_token(&mut self, v: u64) {
            self.auth_device_token = ::std::option::Option::Some(v);
        }

        // optional string device_name = 2;

        pub fn device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name = ::std::option::Option::None;
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 last_access_time = 3;

        pub fn last_access_time(&self) -> u32 {
            self.last_access_time.unwrap_or(0)
        }

        pub fn clear_last_access_time(&mut self) {
            self.last_access_time = ::std::option::Option::None;
        }

        pub fn has_last_access_time(&self) -> bool {
            self.last_access_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_access_time(&mut self, v: u32) {
            self.last_access_time = ::std::option::Option::Some(v);
        }

        // optional uint32 borrower_id = 4;

        pub fn borrower_id(&self) -> u32 {
            self.borrower_id.unwrap_or(0)
        }

        pub fn clear_borrower_id(&mut self) {
            self.borrower_id = ::std::option::Option::None;
        }

        pub fn has_borrower_id(&self) -> bool {
            self.borrower_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_borrower_id(&mut self, v: u32) {
            self.borrower_id = ::std::option::Option::Some(v);
        }

        // optional bool is_pending = 5;

        pub fn is_pending(&self) -> bool {
            self.is_pending.unwrap_or(false)
        }

        pub fn clear_is_pending(&mut self) {
            self.is_pending = ::std::option::Option::None;
        }

        pub fn has_is_pending(&self) -> bool {
            self.is_pending.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_pending(&mut self, v: bool) {
            self.is_pending = ::std::option::Option::Some(v);
        }

        // optional uint32 app_played = 6;

        pub fn app_played(&self) -> u32 {
            self.app_played.unwrap_or(0)
        }

        pub fn clear_app_played(&mut self) {
            self.app_played = ::std::option::Option::None;
        }

        pub fn has_app_played(&self) -> bool {
            self.app_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_played(&mut self, v: u32) {
            self.app_played = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "auth_device_token",
                |m: &AuthorizedDevice| { &m.auth_device_token },
                |m: &mut AuthorizedDevice| { &mut m.auth_device_token },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_name",
                |m: &AuthorizedDevice| { &m.device_name },
                |m: &mut AuthorizedDevice| { &mut m.device_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_access_time",
                |m: &AuthorizedDevice| { &m.last_access_time },
                |m: &mut AuthorizedDevice| { &mut m.last_access_time },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "borrower_id",
                |m: &AuthorizedDevice| { &m.borrower_id },
                |m: &mut AuthorizedDevice| { &mut m.borrower_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_pending",
                |m: &AuthorizedDevice| { &m.is_pending },
                |m: &mut AuthorizedDevice| { &mut m.is_pending },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_played",
                |m: &AuthorizedDevice| { &m.app_played },
                |m: &mut AuthorizedDevice| { &mut m.app_played },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<AuthorizedDevice>(
                "CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for AuthorizedDevice {
        const NAME: &'static str = "AuthorizedDevice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.auth_device_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.last_access_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.borrower_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.is_pending = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.app_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.auth_device_token {
                my_size += crate::rt::uint64_size(1, v);
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.last_access_time {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.borrower_id {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.is_pending {
                my_size += 1 + 1;
            }
            if let Some(v) = self.app_played {
                my_size += crate::rt::uint32_size(6, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.auth_device_token {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.last_access_time {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.borrower_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_pending {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.app_played {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AuthorizedDevice {
            AuthorizedDevice::new()
        }

        fn clear(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
            self.device_name = ::std::option::Option::None;
            self.last_access_time = ::std::option::Option::None;
            self.borrower_id = ::std::option::Option::None;
            self.is_pending = ::std::option::Option::None;
            self.app_played = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AuthorizedDevice {
            static instance: AuthorizedDevice = AuthorizedDevice {
                auth_device_token: ::std::option::Option::None,
                device_name: ::std::option::Option::None,
                last_access_time: ::std::option::Option::None,
                borrower_id: ::std::option::Option::None,
                is_pending: ::std::option::Option::None,
                app_played: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for AuthorizedDevice {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AuthorizedDevice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for AuthorizedDevice {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientSharedLibraryLockStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSharedLibraryLockStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.locked_library)
    pub locked_library: ::std::vec::Vec<cmsg_client_shared_library_lock_status::LockedLibrary>,
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.own_library_locked_by)
    pub own_library_locked_by: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryLockStatus.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryLockStatus {
    fn default() -> &'a CMsgClientSharedLibraryLockStatus {
        <CMsgClientSharedLibraryLockStatus as crate::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryLockStatus {
    pub fn new() -> CMsgClientSharedLibraryLockStatus {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientSharedLibraryLockStatus.LockedLibrary locked_library = 1;

    pub fn locked_library(&self) -> &[cmsg_client_shared_library_lock_status::LockedLibrary] {
        &self.locked_library
    }

    pub fn clear_locked_library(&mut self) {
        self.locked_library.clear();
    }

    // Param is passed by value, moved
    pub fn set_locked_library(&mut self, v: ::std::vec::Vec<cmsg_client_shared_library_lock_status::LockedLibrary>) {
        self.locked_library = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locked_library(&mut self) -> &mut ::std::vec::Vec<cmsg_client_shared_library_lock_status::LockedLibrary> {
        &mut self.locked_library
    }

    // Take field
    pub fn take_locked_library(&mut self) -> ::std::vec::Vec<cmsg_client_shared_library_lock_status::LockedLibrary> {
        ::std::mem::replace(&mut self.locked_library, ::std::vec::Vec::new())
    }

    // optional uint32 own_library_locked_by = 2;

    pub fn own_library_locked_by(&self) -> u32 {
        self.own_library_locked_by.unwrap_or(0)
    }

    pub fn clear_own_library_locked_by(&mut self) {
        self.own_library_locked_by = ::std::option::Option::None;
    }

    pub fn has_own_library_locked_by(&self) -> bool {
        self.own_library_locked_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_own_library_locked_by(&mut self, v: u32) {
        self.own_library_locked_by = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "locked_library",
            |m: &CMsgClientSharedLibraryLockStatus| { &m.locked_library },
            |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.locked_library },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "own_library_locked_by",
            |m: &CMsgClientSharedLibraryLockStatus| { &m.own_library_locked_by },
            |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.own_library_locked_by },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSharedLibraryLockStatus>(
            "CMsgClientSharedLibraryLockStatus",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSharedLibraryLockStatus {
    const NAME: &'static str = "CMsgClientSharedLibraryLockStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.locked_library.push(is.read_message()?);
                },
                16 => {
                    self.own_library_locked_by = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.locked_library {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.own_library_locked_by {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.locked_library {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.own_library_locked_by {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSharedLibraryLockStatus {
        CMsgClientSharedLibraryLockStatus::new()
    }

    fn clear(&mut self) {
        self.locked_library.clear();
        self.own_library_locked_by = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryLockStatus {
        static instance: CMsgClientSharedLibraryLockStatus = CMsgClientSharedLibraryLockStatus {
            locked_library: ::std::vec::Vec::new(),
            own_library_locked_by: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSharedLibraryLockStatus {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryLockStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSharedLibraryLockStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSharedLibraryLockStatus {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientSharedLibraryLockStatus`
pub mod cmsg_client_shared_library_lock_status {
    // @@protoc_insertion_point(message:CMsgClientSharedLibraryLockStatus.LockedLibrary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LockedLibrary {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.LockedLibrary.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.LockedLibrary.locked_by)
        pub locked_by: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryLockStatus.LockedLibrary.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LockedLibrary {
        fn default() -> &'a LockedLibrary {
            <LockedLibrary as crate::Message>::default_instance()
        }
    }

    impl LockedLibrary {
        pub fn new() -> LockedLibrary {
            ::std::default::Default::default()
        }

        // optional uint32 owner_id = 1;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 locked_by = 2;

        pub fn locked_by(&self) -> u32 {
            self.locked_by.unwrap_or(0)
        }

        pub fn clear_locked_by(&mut self) {
            self.locked_by = ::std::option::Option::None;
        }

        pub fn has_locked_by(&self) -> bool {
            self.locked_by.is_some()
        }

        // Param is passed by value, moved
        pub fn set_locked_by(&mut self, v: u32) {
            self.locked_by = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &LockedLibrary| { &m.owner_id },
                |m: &mut LockedLibrary| { &mut m.owner_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "locked_by",
                |m: &LockedLibrary| { &m.locked_by },
                |m: &mut LockedLibrary| { &mut m.locked_by },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<LockedLibrary>(
                "CMsgClientSharedLibraryLockStatus.LockedLibrary",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for LockedLibrary {
        const NAME: &'static str = "LockedLibrary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.locked_by = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.owner_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.locked_by {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.owner_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.locked_by {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LockedLibrary {
            LockedLibrary::new()
        }

        fn clear(&mut self) {
            self.owner_id = ::std::option::Option::None;
            self.locked_by = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LockedLibrary {
            static instance: LockedLibrary = LockedLibrary {
                owner_id: ::std::option::Option::None,
                locked_by: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for LockedLibrary {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryLockStatus.LockedLibrary").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LockedLibrary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for LockedLibrary {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientSharedLibraryStopPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSharedLibraryStopPlaying {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.seconds_left)
    pub seconds_left: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.stop_apps)
    pub stop_apps: ::std::vec::Vec<cmsg_client_shared_library_stop_playing::StopApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryStopPlaying.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryStopPlaying {
    fn default() -> &'a CMsgClientSharedLibraryStopPlaying {
        <CMsgClientSharedLibraryStopPlaying as crate::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryStopPlaying {
    pub fn new() -> CMsgClientSharedLibraryStopPlaying {
        ::std::default::Default::default()
    }

    // optional int32 seconds_left = 1;

    pub fn seconds_left(&self) -> i32 {
        self.seconds_left.unwrap_or(0)
    }

    pub fn clear_seconds_left(&mut self) {
        self.seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        self.seconds_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: i32) {
        self.seconds_left = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientSharedLibraryStopPlaying.StopApp stop_apps = 2;

    pub fn stop_apps(&self) -> &[cmsg_client_shared_library_stop_playing::StopApp] {
        &self.stop_apps
    }

    pub fn clear_stop_apps(&mut self) {
        self.stop_apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_stop_apps(&mut self, v: ::std::vec::Vec<cmsg_client_shared_library_stop_playing::StopApp>) {
        self.stop_apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stop_apps(&mut self) -> &mut ::std::vec::Vec<cmsg_client_shared_library_stop_playing::StopApp> {
        &mut self.stop_apps
    }

    // Take field
    pub fn take_stop_apps(&mut self) -> ::std::vec::Vec<cmsg_client_shared_library_stop_playing::StopApp> {
        ::std::mem::replace(&mut self.stop_apps, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_left",
            |m: &CMsgClientSharedLibraryStopPlaying| { &m.seconds_left },
            |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.seconds_left },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stop_apps",
            |m: &CMsgClientSharedLibraryStopPlaying| { &m.stop_apps },
            |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.stop_apps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSharedLibraryStopPlaying>(
            "CMsgClientSharedLibraryStopPlaying",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSharedLibraryStopPlaying {
    const NAME: &'static str = "CMsgClientSharedLibraryStopPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds_left = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.stop_apps.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_left {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.stop_apps {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.seconds_left {
            os.write_int32(1, v)?;
        }
        for v in &self.stop_apps {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSharedLibraryStopPlaying {
        CMsgClientSharedLibraryStopPlaying::new()
    }

    fn clear(&mut self) {
        self.seconds_left = ::std::option::Option::None;
        self.stop_apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryStopPlaying {
        static instance: CMsgClientSharedLibraryStopPlaying = CMsgClientSharedLibraryStopPlaying {
            seconds_left: ::std::option::Option::None,
            stop_apps: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSharedLibraryStopPlaying {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryStopPlaying").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSharedLibraryStopPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSharedLibraryStopPlaying {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientSharedLibraryStopPlaying`
pub mod cmsg_client_shared_library_stop_playing {
    // @@protoc_insertion_point(message:CMsgClientSharedLibraryStopPlaying.StopApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StopApp {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.StopApp.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.StopApp.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryStopPlaying.StopApp.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StopApp {
        fn default() -> &'a StopApp {
            <StopApp as crate::Message>::default_instance()
        }
    }

    impl StopApp {
        pub fn new() -> StopApp {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 2;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &StopApp| { &m.app_id },
                |m: &mut StopApp| { &mut m.app_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &StopApp| { &m.owner_id },
                |m: &mut StopApp| { &mut m.owner_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<StopApp>(
                "CMsgClientSharedLibraryStopPlaying.StopApp",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for StopApp {
        const NAME: &'static str = "StopApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.owner_id {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StopApp {
            StopApp::new()
        }

        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StopApp {
            static instance: StopApp = StopApp {
                app_id: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for StopApp {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryStopPlaying.StopApp").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StopApp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for StopApp {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientServiceCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceCall {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceCall.sysid_routing)
    pub sysid_routing: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.call_handle)
    pub call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.module_hash)
    pub module_hash: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.function_id)
    pub function_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.cub_output_max)
    pub cub_output_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.callparameter)
    pub callparameter: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.ping_only)
    pub ping_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.max_outstanding_calls)
    pub max_outstanding_calls: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceCall.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCall {
    fn default() -> &'a CMsgClientServiceCall {
        <CMsgClientServiceCall as crate::Message>::default_instance()
    }
}

impl CMsgClientServiceCall {
    pub fn new() -> CMsgClientServiceCall {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::bytes::Bytes) {
        self.sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::bytes::Bytes {
        if self.sysid_routing.is_none() {
            self.sysid_routing = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::bytes::Bytes {
        self.sysid_routing.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 call_handle = 2;

    pub fn call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::bytes::Bytes) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::bytes::Bytes {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::bytes::Bytes {
        self.module_hash.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 function_id = 5;

    pub fn function_id(&self) -> u32 {
        self.function_id.unwrap_or(0)
    }

    pub fn clear_function_id(&mut self) {
        self.function_id = ::std::option::Option::None;
    }

    pub fn has_function_id(&self) -> bool {
        self.function_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: u32) {
        self.function_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cub_output_max = 6;

    pub fn cub_output_max(&self) -> u32 {
        self.cub_output_max.unwrap_or(0)
    }

    pub fn clear_cub_output_max(&mut self) {
        self.cub_output_max = ::std::option::Option::None;
    }

    pub fn has_cub_output_max(&self) -> bool {
        self.cub_output_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cub_output_max(&mut self, v: u32) {
        self.cub_output_max = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes callparameter = 8;

    pub fn callparameter(&self) -> &[u8] {
        match self.callparameter.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callparameter(&mut self) {
        self.callparameter = ::std::option::Option::None;
    }

    pub fn has_callparameter(&self) -> bool {
        self.callparameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callparameter(&mut self, v: ::bytes::Bytes) {
        self.callparameter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callparameter(&mut self) -> &mut ::bytes::Bytes {
        if self.callparameter.is_none() {
            self.callparameter = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.callparameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_callparameter(&mut self) -> ::bytes::Bytes {
        self.callparameter.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool ping_only = 9;

    pub fn ping_only(&self) -> bool {
        self.ping_only.unwrap_or(false)
    }

    pub fn clear_ping_only(&mut self) {
        self.ping_only = ::std::option::Option::None;
    }

    pub fn has_ping_only(&self) -> bool {
        self.ping_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_only(&mut self, v: bool) {
        self.ping_only = ::std::option::Option::Some(v);
    }

    // optional uint32 max_outstanding_calls = 10;

    pub fn max_outstanding_calls(&self) -> u32 {
        self.max_outstanding_calls.unwrap_or(0)
    }

    pub fn clear_max_outstanding_calls(&mut self) {
        self.max_outstanding_calls = ::std::option::Option::None;
    }

    pub fn has_max_outstanding_calls(&self) -> bool {
        self.max_outstanding_calls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_outstanding_calls(&mut self, v: u32) {
        self.max_outstanding_calls = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 11;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sysid_routing",
            |m: &CMsgClientServiceCall| { &m.sysid_routing },
            |m: &mut CMsgClientServiceCall| { &mut m.sysid_routing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "call_handle",
            |m: &CMsgClientServiceCall| { &m.call_handle },
            |m: &mut CMsgClientServiceCall| { &mut m.call_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_crc",
            |m: &CMsgClientServiceCall| { &m.module_crc },
            |m: &mut CMsgClientServiceCall| { &mut m.module_crc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_hash",
            |m: &CMsgClientServiceCall| { &m.module_hash },
            |m: &mut CMsgClientServiceCall| { &mut m.module_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_id",
            |m: &CMsgClientServiceCall| { &m.function_id },
            |m: &mut CMsgClientServiceCall| { &mut m.function_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cub_output_max",
            |m: &CMsgClientServiceCall| { &m.cub_output_max },
            |m: &mut CMsgClientServiceCall| { &mut m.cub_output_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgClientServiceCall| { &m.flags },
            |m: &mut CMsgClientServiceCall| { &mut m.flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "callparameter",
            |m: &CMsgClientServiceCall| { &m.callparameter },
            |m: &mut CMsgClientServiceCall| { &mut m.callparameter },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_only",
            |m: &CMsgClientServiceCall| { &m.ping_only },
            |m: &mut CMsgClientServiceCall| { &mut m.ping_only },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_outstanding_calls",
            |m: &CMsgClientServiceCall| { &m.max_outstanding_calls },
            |m: &mut CMsgClientServiceCall| { &mut m.max_outstanding_calls },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientServiceCall| { &m.app_id },
            |m: &mut CMsgClientServiceCall| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceCall>(
            "CMsgClientServiceCall",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientServiceCall {
    const NAME: &'static str = "CMsgClientServiceCall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sysid_routing = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.module_hash = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.function_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.cub_output_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.callparameter = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                72 => {
                    self.ping_only = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.max_outstanding_calls = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.module_crc {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.function_id {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.cub_output_max {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.flags {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.callparameter.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ping_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.max_outstanding_calls {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(11, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.function_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cub_output_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.callparameter.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.ping_only {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.max_outstanding_calls {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceCall {
        CMsgClientServiceCall::new()
    }

    fn clear(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.function_id = ::std::option::Option::None;
        self.cub_output_max = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.callparameter = ::std::option::Option::None;
        self.ping_only = ::std::option::Option::None;
        self.max_outstanding_calls = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceCall {
        static instance: CMsgClientServiceCall = CMsgClientServiceCall {
            sysid_routing: ::std::option::Option::None,
            call_handle: ::std::option::Option::None,
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            function_id: ::std::option::Option::None,
            cub_output_max: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            callparameter: ::std::option::Option::None,
            ping_only: ::std::option::Option::None,
            max_outstanding_calls: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientServiceCall {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceCall").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientServiceCall {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceModule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceModule {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_hash)
    pub module_hash: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_content)
    pub module_content: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceModule.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceModule {
    fn default() -> &'a CMsgClientServiceModule {
        <CMsgClientServiceModule as crate::Message>::default_instance()
    }
}

impl CMsgClientServiceModule {
    pub fn new() -> CMsgClientServiceModule {
        ::std::default::Default::default()
    }

    // optional uint32 module_crc = 1;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 2;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::bytes::Bytes) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::bytes::Bytes {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::bytes::Bytes {
        self.module_hash.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes module_content = 3;

    pub fn module_content(&self) -> &[u8] {
        match self.module_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_content(&mut self) {
        self.module_content = ::std::option::Option::None;
    }

    pub fn has_module_content(&self) -> bool {
        self.module_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_content(&mut self, v: ::bytes::Bytes) {
        self.module_content = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_content(&mut self) -> &mut ::bytes::Bytes {
        if self.module_content.is_none() {
            self.module_content = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.module_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_content(&mut self) -> ::bytes::Bytes {
        self.module_content.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_crc",
            |m: &CMsgClientServiceModule| { &m.module_crc },
            |m: &mut CMsgClientServiceModule| { &mut m.module_crc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_hash",
            |m: &CMsgClientServiceModule| { &m.module_hash },
            |m: &mut CMsgClientServiceModule| { &mut m.module_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_content",
            |m: &CMsgClientServiceModule| { &m.module_content },
            |m: &mut CMsgClientServiceModule| { &mut m.module_content },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceModule>(
            "CMsgClientServiceModule",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientServiceModule {
    const NAME: &'static str = "CMsgClientServiceModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.module_hash = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                26 => {
                    self.module_content = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module_crc {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.module_content.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.module_crc {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.module_content.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceModule {
        CMsgClientServiceModule::new()
    }

    fn clear(&mut self) {
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.module_content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceModule {
        static instance: CMsgClientServiceModule = CMsgClientServiceModule {
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            module_content: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientServiceModule {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientServiceModule {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceCallResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceCallResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.sysid_routing)
    pub sysid_routing: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.call_handle)
    pub call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.module_hash)
    pub module_hash: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.ecallresult)
    pub ecallresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.result_content)
    pub result_content: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.os_version_info)
    pub os_version_info: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.system_info)
    pub system_info: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.load_address)
    pub load_address: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.exception_record)
    pub exception_record: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.portable_os_version_info)
    pub portable_os_version_info: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.portable_system_info)
    pub portable_system_info: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.was_converted)
    pub was_converted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.internal_result)
    pub internal_result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.current_count)
    pub current_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_handle)
    pub last_call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_module_crc)
    pub last_call_module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_sysid_routing)
    pub last_call_sysid_routing: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_ecallresult)
    pub last_ecallresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_callissue_delta)
    pub last_callissue_delta: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_callcomplete_delta)
    pub last_callcomplete_delta: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceCallResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCallResponse {
    fn default() -> &'a CMsgClientServiceCallResponse {
        <CMsgClientServiceCallResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientServiceCallResponse {
    pub fn new() -> CMsgClientServiceCallResponse {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::bytes::Bytes) {
        self.sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::bytes::Bytes {
        if self.sysid_routing.is_none() {
            self.sysid_routing = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::bytes::Bytes {
        self.sysid_routing.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 call_handle = 2;

    pub fn call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::bytes::Bytes) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::bytes::Bytes {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::bytes::Bytes {
        self.module_hash.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 ecallresult = 5;

    pub fn ecallresult(&self) -> u32 {
        self.ecallresult.unwrap_or(0)
    }

    pub fn clear_ecallresult(&mut self) {
        self.ecallresult = ::std::option::Option::None;
    }

    pub fn has_ecallresult(&self) -> bool {
        self.ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecallresult(&mut self, v: u32) {
        self.ecallresult = ::std::option::Option::Some(v);
    }

    // optional bytes result_content = 6;

    pub fn result_content(&self) -> &[u8] {
        match self.result_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_result_content(&mut self) {
        self.result_content = ::std::option::Option::None;
    }

    pub fn has_result_content(&self) -> bool {
        self.result_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_content(&mut self, v: ::bytes::Bytes) {
        self.result_content = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_content(&mut self) -> &mut ::bytes::Bytes {
        if self.result_content.is_none() {
            self.result_content = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.result_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_content(&mut self) -> ::bytes::Bytes {
        self.result_content.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes os_version_info = 7;

    pub fn os_version_info(&self) -> &[u8] {
        match self.os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_os_version_info(&mut self) {
        self.os_version_info = ::std::option::Option::None;
    }

    pub fn has_os_version_info(&self) -> bool {
        self.os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version_info(&mut self, v: ::bytes::Bytes) {
        self.os_version_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version_info(&mut self) -> &mut ::bytes::Bytes {
        if self.os_version_info.is_none() {
            self.os_version_info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version_info(&mut self) -> ::bytes::Bytes {
        self.os_version_info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes system_info = 8;

    pub fn system_info(&self) -> &[u8] {
        match self.system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_system_info(&mut self) {
        self.system_info = ::std::option::Option::None;
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::bytes::Bytes) {
        self.system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::bytes::Bytes {
        if self.system_info.is_none() {
            self.system_info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::bytes::Bytes {
        self.system_info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed64 load_address = 9;

    pub fn load_address(&self) -> u64 {
        self.load_address.unwrap_or(0)
    }

    pub fn clear_load_address(&mut self) {
        self.load_address = ::std::option::Option::None;
    }

    pub fn has_load_address(&self) -> bool {
        self.load_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_address(&mut self, v: u64) {
        self.load_address = ::std::option::Option::Some(v);
    }

    // optional bytes exception_record = 10;

    pub fn exception_record(&self) -> &[u8] {
        match self.exception_record.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_exception_record(&mut self) {
        self.exception_record = ::std::option::Option::None;
    }

    pub fn has_exception_record(&self) -> bool {
        self.exception_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception_record(&mut self, v: ::bytes::Bytes) {
        self.exception_record = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception_record(&mut self) -> &mut ::bytes::Bytes {
        if self.exception_record.is_none() {
            self.exception_record = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.exception_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception_record(&mut self) -> ::bytes::Bytes {
        self.exception_record.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes portable_os_version_info = 11;

    pub fn portable_os_version_info(&self) -> &[u8] {
        match self.portable_os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_os_version_info(&mut self) {
        self.portable_os_version_info = ::std::option::Option::None;
    }

    pub fn has_portable_os_version_info(&self) -> bool {
        self.portable_os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_os_version_info(&mut self, v: ::bytes::Bytes) {
        self.portable_os_version_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_os_version_info(&mut self) -> &mut ::bytes::Bytes {
        if self.portable_os_version_info.is_none() {
            self.portable_os_version_info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.portable_os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_os_version_info(&mut self) -> ::bytes::Bytes {
        self.portable_os_version_info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes portable_system_info = 12;

    pub fn portable_system_info(&self) -> &[u8] {
        match self.portable_system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_system_info(&mut self) {
        self.portable_system_info = ::std::option::Option::None;
    }

    pub fn has_portable_system_info(&self) -> bool {
        self.portable_system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_system_info(&mut self, v: ::bytes::Bytes) {
        self.portable_system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_system_info(&mut self) -> &mut ::bytes::Bytes {
        if self.portable_system_info.is_none() {
            self.portable_system_info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.portable_system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_system_info(&mut self) -> ::bytes::Bytes {
        self.portable_system_info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool was_converted = 13;

    pub fn was_converted(&self) -> bool {
        self.was_converted.unwrap_or(false)
    }

    pub fn clear_was_converted(&mut self) {
        self.was_converted = ::std::option::Option::None;
    }

    pub fn has_was_converted(&self) -> bool {
        self.was_converted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_converted(&mut self, v: bool) {
        self.was_converted = ::std::option::Option::Some(v);
    }

    // optional uint32 internal_result = 14;

    pub fn internal_result(&self) -> u32 {
        self.internal_result.unwrap_or(0)
    }

    pub fn clear_internal_result(&mut self) {
        self.internal_result = ::std::option::Option::None;
    }

    pub fn has_internal_result(&self) -> bool {
        self.internal_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_result(&mut self, v: u32) {
        self.internal_result = ::std::option::Option::Some(v);
    }

    // optional uint32 current_count = 15;

    pub fn current_count(&self) -> u32 {
        self.current_count.unwrap_or(0)
    }

    pub fn clear_current_count(&mut self) {
        self.current_count = ::std::option::Option::None;
    }

    pub fn has_current_count(&self) -> bool {
        self.current_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_count(&mut self, v: u32) {
        self.current_count = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_handle = 16;

    pub fn last_call_handle(&self) -> u32 {
        self.last_call_handle.unwrap_or(0)
    }

    pub fn clear_last_call_handle(&mut self) {
        self.last_call_handle = ::std::option::Option::None;
    }

    pub fn has_last_call_handle(&self) -> bool {
        self.last_call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_handle(&mut self, v: u32) {
        self.last_call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_module_crc = 17;

    pub fn last_call_module_crc(&self) -> u32 {
        self.last_call_module_crc.unwrap_or(0)
    }

    pub fn clear_last_call_module_crc(&mut self) {
        self.last_call_module_crc = ::std::option::Option::None;
    }

    pub fn has_last_call_module_crc(&self) -> bool {
        self.last_call_module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_module_crc(&mut self, v: u32) {
        self.last_call_module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes last_call_sysid_routing = 18;

    pub fn last_call_sysid_routing(&self) -> &[u8] {
        match self.last_call_sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_last_call_sysid_routing(&mut self) {
        self.last_call_sysid_routing = ::std::option::Option::None;
    }

    pub fn has_last_call_sysid_routing(&self) -> bool {
        self.last_call_sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_sysid_routing(&mut self, v: ::bytes::Bytes) {
        self.last_call_sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_call_sysid_routing(&mut self) -> &mut ::bytes::Bytes {
        if self.last_call_sysid_routing.is_none() {
            self.last_call_sysid_routing = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.last_call_sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_call_sysid_routing(&mut self) -> ::bytes::Bytes {
        self.last_call_sysid_routing.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 last_ecallresult = 19;

    pub fn last_ecallresult(&self) -> u32 {
        self.last_ecallresult.unwrap_or(0)
    }

    pub fn clear_last_ecallresult(&mut self) {
        self.last_ecallresult = ::std::option::Option::None;
    }

    pub fn has_last_ecallresult(&self) -> bool {
        self.last_ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ecallresult(&mut self, v: u32) {
        self.last_ecallresult = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callissue_delta = 20;

    pub fn last_callissue_delta(&self) -> u32 {
        self.last_callissue_delta.unwrap_or(0)
    }

    pub fn clear_last_callissue_delta(&mut self) {
        self.last_callissue_delta = ::std::option::Option::None;
    }

    pub fn has_last_callissue_delta(&self) -> bool {
        self.last_callissue_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callissue_delta(&mut self, v: u32) {
        self.last_callissue_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callcomplete_delta = 21;

    pub fn last_callcomplete_delta(&self) -> u32 {
        self.last_callcomplete_delta.unwrap_or(0)
    }

    pub fn clear_last_callcomplete_delta(&mut self) {
        self.last_callcomplete_delta = ::std::option::Option::None;
    }

    pub fn has_last_callcomplete_delta(&self) -> bool {
        self.last_callcomplete_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callcomplete_delta(&mut self, v: u32) {
        self.last_callcomplete_delta = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sysid_routing",
            |m: &CMsgClientServiceCallResponse| { &m.sysid_routing },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.sysid_routing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "call_handle",
            |m: &CMsgClientServiceCallResponse| { &m.call_handle },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.call_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_crc",
            |m: &CMsgClientServiceCallResponse| { &m.module_crc },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.module_crc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_hash",
            |m: &CMsgClientServiceCallResponse| { &m.module_hash },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.module_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ecallresult",
            |m: &CMsgClientServiceCallResponse| { &m.ecallresult },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.ecallresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result_content",
            |m: &CMsgClientServiceCallResponse| { &m.result_content },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.result_content },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_version_info",
            |m: &CMsgClientServiceCallResponse| { &m.os_version_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.os_version_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_info",
            |m: &CMsgClientServiceCallResponse| { &m.system_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.system_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "load_address",
            |m: &CMsgClientServiceCallResponse| { &m.load_address },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.load_address },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exception_record",
            |m: &CMsgClientServiceCallResponse| { &m.exception_record },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.exception_record },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "portable_os_version_info",
            |m: &CMsgClientServiceCallResponse| { &m.portable_os_version_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_os_version_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "portable_system_info",
            |m: &CMsgClientServiceCallResponse| { &m.portable_system_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_system_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "was_converted",
            |m: &CMsgClientServiceCallResponse| { &m.was_converted },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.was_converted },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "internal_result",
            |m: &CMsgClientServiceCallResponse| { &m.internal_result },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.internal_result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_count",
            |m: &CMsgClientServiceCallResponse| { &m.current_count },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.current_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_call_handle",
            |m: &CMsgClientServiceCallResponse| { &m.last_call_handle },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_call_module_crc",
            |m: &CMsgClientServiceCallResponse| { &m.last_call_module_crc },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_module_crc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_call_sysid_routing",
            |m: &CMsgClientServiceCallResponse| { &m.last_call_sysid_routing },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_sysid_routing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_ecallresult",
            |m: &CMsgClientServiceCallResponse| { &m.last_ecallresult },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_ecallresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_callissue_delta",
            |m: &CMsgClientServiceCallResponse| { &m.last_callissue_delta },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callissue_delta },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_callcomplete_delta",
            |m: &CMsgClientServiceCallResponse| { &m.last_callcomplete_delta },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callcomplete_delta },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceCallResponse>(
            "CMsgClientServiceCallResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientServiceCallResponse {
    const NAME: &'static str = "CMsgClientServiceCallResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sysid_routing = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.module_hash = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.result_content = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                58 => {
                    self.os_version_info = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                66 => {
                    self.system_info = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                73 => {
                    self.load_address = ::std::option::Option::Some(is.read_fixed64()?);
                },
                82 => {
                    self.exception_record = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                90 => {
                    self.portable_os_version_info = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                98 => {
                    self.portable_system_info = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                104 => {
                    self.was_converted = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.internal_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.current_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.last_call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.last_call_module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.last_call_sysid_routing = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                152 => {
                    self.last_ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.last_callissue_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.last_callcomplete_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.module_crc {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ecallresult {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.result_content.as_ref() {
            my_size += crate::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.os_version_info.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.system_info.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.load_address {
            my_size += 1 + 8;
        }
        if let Some(v) = self.exception_record.as_ref() {
            my_size += crate::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            my_size += crate::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            my_size += crate::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.was_converted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.internal_result {
            my_size += crate::rt::uint32_size(14, v);
        }
        if let Some(v) = self.current_count {
            my_size += crate::rt::uint32_size(15, v);
        }
        if let Some(v) = self.last_call_handle {
            my_size += crate::rt::uint32_size(16, v);
        }
        if let Some(v) = self.last_call_module_crc {
            my_size += crate::rt::uint32_size(17, v);
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            my_size += crate::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.last_ecallresult {
            my_size += crate::rt::uint32_size(19, v);
        }
        if let Some(v) = self.last_callissue_delta {
            my_size += crate::rt::uint32_size(20, v);
        }
        if let Some(v) = self.last_callcomplete_delta {
            my_size += crate::rt::uint32_size(21, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ecallresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.result_content.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.os_version_info.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.system_info.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.load_address {
            os.write_fixed64(9, v)?;
        }
        if let Some(v) = self.exception_record.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.was_converted {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.internal_result {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.current_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_call_handle {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.last_call_module_crc {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.last_ecallresult {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_callissue_delta {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.last_callcomplete_delta {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceCallResponse {
        CMsgClientServiceCallResponse::new()
    }

    fn clear(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.ecallresult = ::std::option::Option::None;
        self.result_content = ::std::option::Option::None;
        self.os_version_info = ::std::option::Option::None;
        self.system_info = ::std::option::Option::None;
        self.load_address = ::std::option::Option::None;
        self.exception_record = ::std::option::Option::None;
        self.portable_os_version_info = ::std::option::Option::None;
        self.portable_system_info = ::std::option::Option::None;
        self.was_converted = ::std::option::Option::None;
        self.internal_result = ::std::option::Option::None;
        self.current_count = ::std::option::Option::None;
        self.last_call_handle = ::std::option::Option::None;
        self.last_call_module_crc = ::std::option::Option::None;
        self.last_call_sysid_routing = ::std::option::Option::None;
        self.last_ecallresult = ::std::option::Option::None;
        self.last_callissue_delta = ::std::option::Option::None;
        self.last_callcomplete_delta = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceCallResponse {
        static instance: CMsgClientServiceCallResponse = CMsgClientServiceCallResponse {
            sysid_routing: ::std::option::Option::None,
            call_handle: ::std::option::Option::None,
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            ecallresult: ::std::option::Option::None,
            result_content: ::std::option::Option::None,
            os_version_info: ::std::option::Option::None,
            system_info: ::std::option::Option::None,
            load_address: ::std::option::Option::None,
            exception_record: ::std::option::Option::None,
            portable_os_version_info: ::std::option::Option::None,
            portable_system_info: ::std::option::Option::None,
            was_converted: ::std::option::Option::None,
            internal_result: ::std::option::Option::None,
            current_count: ::std::option::Option::None,
            last_call_handle: ::std::option::Option::None,
            last_call_module_crc: ::std::option::Option::None,
            last_call_sysid_routing: ::std::option::Option::None,
            last_ecallresult: ::std::option::Option::None,
            last_callissue_delta: ::std::option::Option::None,
            last_callcomplete_delta: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientServiceCallResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceCallResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientServiceCallResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAMUnlockH264)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockH264 {
    // message fields
    // @@protoc_insertion_point(field:CMsgAMUnlockH264.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAMUnlockH264.platform)
    pub platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAMUnlockH264.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockH264.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockH264 {
    fn default() -> &'a CMsgAMUnlockH264 {
        <CMsgAMUnlockH264 as crate::Message>::default_instance()
    }
}

impl CMsgAMUnlockH264 {
    pub fn new() -> CMsgAMUnlockH264 {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 2;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 3;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgAMUnlockH264| { &m.appid },
            |m: &mut CMsgAMUnlockH264| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &CMsgAMUnlockH264| { &m.platform },
            |m: &mut CMsgAMUnlockH264| { &mut m.platform },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgAMUnlockH264| { &m.reason },
            |m: &mut CMsgAMUnlockH264| { &mut m.reason },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAMUnlockH264>(
            "CMsgAMUnlockH264",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAMUnlockH264 {
    const NAME: &'static str = "CMsgAMUnlockH264";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.platform {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.reason {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockH264 {
        CMsgAMUnlockH264::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockH264 {
        static instance: CMsgAMUnlockH264 = CMsgAMUnlockH264 {
            appid: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAMUnlockH264 {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAMUnlockH264").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAMUnlockH264 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAMUnlockH264 {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAMUnlockH264Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockH264Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgAMUnlockH264Response.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAMUnlockH264Response.encryption_key)
    pub encryption_key: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockH264Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockH264Response {
    fn default() -> &'a CMsgAMUnlockH264Response {
        <CMsgAMUnlockH264Response as crate::Message>::default_instance()
    }
}

impl CMsgAMUnlockH264Response {
    pub fn new() -> CMsgAMUnlockH264Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes encryption_key = 2;

    pub fn encryption_key(&self) -> &[u8] {
        match self.encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encryption_key(&mut self) {
        self.encryption_key = ::std::option::Option::None;
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: ::bytes::Bytes) {
        self.encryption_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_key(&mut self) -> &mut ::bytes::Bytes {
        if self.encryption_key.is_none() {
            self.encryption_key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_key(&mut self) -> ::bytes::Bytes {
        self.encryption_key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgAMUnlockH264Response| { &m.eresult },
            |m: &mut CMsgAMUnlockH264Response| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryption_key",
            |m: &CMsgAMUnlockH264Response| { &m.encryption_key },
            |m: &mut CMsgAMUnlockH264Response| { &mut m.encryption_key },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAMUnlockH264Response>(
            "CMsgAMUnlockH264Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAMUnlockH264Response {
    const NAME: &'static str = "CMsgAMUnlockH264Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.encryption_key = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.encryption_key.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.encryption_key.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockH264Response {
        CMsgAMUnlockH264Response::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.encryption_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockH264Response {
        static instance: CMsgAMUnlockH264Response = CMsgAMUnlockH264Response {
            eresult: ::std::option::Option::None,
            encryption_key: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAMUnlockH264Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAMUnlockH264Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAMUnlockH264Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAMUnlockH264Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPlayingSessionState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPlayingSessionState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPlayingSessionState.playing_blocked)
    pub playing_blocked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPlayingSessionState.playing_app)
    pub playing_app: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPlayingSessionState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayingSessionState {
    fn default() -> &'a CMsgClientPlayingSessionState {
        <CMsgClientPlayingSessionState as crate::Message>::default_instance()
    }
}

impl CMsgClientPlayingSessionState {
    pub fn new() -> CMsgClientPlayingSessionState {
        ::std::default::Default::default()
    }

    // optional bool playing_blocked = 2;

    pub fn playing_blocked(&self) -> bool {
        self.playing_blocked.unwrap_or(false)
    }

    pub fn clear_playing_blocked(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
    }

    pub fn has_playing_blocked(&self) -> bool {
        self.playing_blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_blocked(&mut self, v: bool) {
        self.playing_blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 playing_app = 3;

    pub fn playing_app(&self) -> u32 {
        self.playing_app.unwrap_or(0)
    }

    pub fn clear_playing_app(&mut self) {
        self.playing_app = ::std::option::Option::None;
    }

    pub fn has_playing_app(&self) -> bool {
        self.playing_app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_app(&mut self, v: u32) {
        self.playing_app = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "playing_blocked",
            |m: &CMsgClientPlayingSessionState| { &m.playing_blocked },
            |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_blocked },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "playing_app",
            |m: &CMsgClientPlayingSessionState| { &m.playing_app },
            |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_app },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPlayingSessionState>(
            "CMsgClientPlayingSessionState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientPlayingSessionState {
    const NAME: &'static str = "CMsgClientPlayingSessionState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.playing_blocked = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.playing_app = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playing_blocked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.playing_app {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.playing_blocked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.playing_app {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPlayingSessionState {
        CMsgClientPlayingSessionState::new()
    }

    fn clear(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
        self.playing_app = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPlayingSessionState {
        static instance: CMsgClientPlayingSessionState = CMsgClientPlayingSessionState {
            playing_blocked: ::std::option::Option::None,
            playing_app: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientPlayingSessionState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPlayingSessionState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPlayingSessionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientPlayingSessionState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientKickPlayingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientKickPlayingSession {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientKickPlayingSession.only_stop_game)
    pub only_stop_game: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientKickPlayingSession.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientKickPlayingSession {
    fn default() -> &'a CMsgClientKickPlayingSession {
        <CMsgClientKickPlayingSession as crate::Message>::default_instance()
    }
}

impl CMsgClientKickPlayingSession {
    pub fn new() -> CMsgClientKickPlayingSession {
        ::std::default::Default::default()
    }

    // optional bool only_stop_game = 1;

    pub fn only_stop_game(&self) -> bool {
        self.only_stop_game.unwrap_or(false)
    }

    pub fn clear_only_stop_game(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
    }

    pub fn has_only_stop_game(&self) -> bool {
        self.only_stop_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_stop_game(&mut self, v: bool) {
        self.only_stop_game = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_stop_game",
            |m: &CMsgClientKickPlayingSession| { &m.only_stop_game },
            |m: &mut CMsgClientKickPlayingSession| { &mut m.only_stop_game },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientKickPlayingSession>(
            "CMsgClientKickPlayingSession",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientKickPlayingSession {
    const NAME: &'static str = "CMsgClientKickPlayingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.only_stop_game = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.only_stop_game {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.only_stop_game {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientKickPlayingSession {
        CMsgClientKickPlayingSession::new()
    }

    fn clear(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientKickPlayingSession {
        static instance: CMsgClientKickPlayingSession = CMsgClientKickPlayingSession {
            only_stop_game: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientKickPlayingSession {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientKickPlayingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientKickPlayingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientKickPlayingSession {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientVoiceCallPreAuthorize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVoiceCallPreAuthorize {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.caller_steamid)
    pub caller_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.caller_id)
    pub caller_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.hangup)
    pub hangup: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVoiceCallPreAuthorize.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorize {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorize {
        <CMsgClientVoiceCallPreAuthorize as crate::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorize {
    pub fn new() -> CMsgClientVoiceCallPreAuthorize {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 3;

    pub fn caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    // optional bool hangup = 4;

    pub fn hangup(&self) -> bool {
        self.hangup.unwrap_or(false)
    }

    pub fn clear_hangup(&mut self) {
        self.hangup = ::std::option::Option::None;
    }

    pub fn has_hangup(&self) -> bool {
        self.hangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hangup(&mut self, v: bool) {
        self.hangup = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_steamid",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_steamid",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.receiver_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.receiver_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_id",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_id },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hangup",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.hangup },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.hangup },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientVoiceCallPreAuthorize>(
            "CMsgClientVoiceCallPreAuthorize",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientVoiceCallPreAuthorize {
    const NAME: &'static str = "CMsgClientVoiceCallPreAuthorize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.hangup = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.caller_id {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.hangup {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hangup {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVoiceCallPreAuthorize {
        CMsgClientVoiceCallPreAuthorize::new()
    }

    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.hangup = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorize {
        static instance: CMsgClientVoiceCallPreAuthorize = CMsgClientVoiceCallPreAuthorize {
            caller_steamid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            caller_id: ::std::option::Option::None,
            hangup: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientVoiceCallPreAuthorize {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientVoiceCallPreAuthorize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientVoiceCallPreAuthorize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorize {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientVoiceCallPreAuthorizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVoiceCallPreAuthorizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.caller_steamid)
    pub caller_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.caller_id)
    pub caller_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVoiceCallPreAuthorizeResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorizeResponse {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorizeResponse {
        <CMsgClientVoiceCallPreAuthorizeResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorizeResponse {
    pub fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 4;

    pub fn caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_steamid",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_steamid",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.receiver_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.receiver_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.eresult },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_id",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_id },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientVoiceCallPreAuthorizeResponse>(
            "CMsgClientVoiceCallPreAuthorizeResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientVoiceCallPreAuthorizeResponse {
    const NAME: &'static str = "CMsgClientVoiceCallPreAuthorizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.caller_id {
            my_size += crate::rt::int32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        CMsgClientVoiceCallPreAuthorizeResponse::new()
    }

    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorizeResponse {
        static instance: CMsgClientVoiceCallPreAuthorizeResponse = CMsgClientVoiceCallPreAuthorizeResponse {
            caller_steamid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            caller_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientVoiceCallPreAuthorizeResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientVoiceCallPreAuthorizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientVoiceCallPreAuthorizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorizeResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBadgeCraftedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBadgeCraftedNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgBadgeCraftedNotification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBadgeCraftedNotification.badge_level)
    pub badge_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBadgeCraftedNotification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBadgeCraftedNotification {
    fn default() -> &'a CMsgBadgeCraftedNotification {
        <CMsgBadgeCraftedNotification as crate::Message>::default_instance()
    }
}

impl CMsgBadgeCraftedNotification {
    pub fn new() -> CMsgBadgeCraftedNotification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 2;

    pub fn badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgBadgeCraftedNotification| { &m.appid },
            |m: &mut CMsgBadgeCraftedNotification| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "badge_level",
            |m: &CMsgBadgeCraftedNotification| { &m.badge_level },
            |m: &mut CMsgBadgeCraftedNotification| { &mut m.badge_level },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBadgeCraftedNotification>(
            "CMsgBadgeCraftedNotification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBadgeCraftedNotification {
    const NAME: &'static str = "CMsgBadgeCraftedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.badge_level {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBadgeCraftedNotification {
        CMsgBadgeCraftedNotification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBadgeCraftedNotification {
        static instance: CMsgBadgeCraftedNotification = CMsgBadgeCraftedNotification {
            appid: ::std::option::Option::None,
            badge_level: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBadgeCraftedNotification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBadgeCraftedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBadgeCraftedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBadgeCraftedNotification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientStartPeerContentServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStartPeerContentServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.client_remote_id)
    pub client_remote_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.current_build_id)
    pub current_build_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStartPeerContentServer.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStartPeerContentServer {
    fn default() -> &'a CMsgClientStartPeerContentServer {
        <CMsgClientStartPeerContentServer as crate::Message>::default_instance()
    }
}

impl CMsgClientStartPeerContentServer {
    pub fn new() -> CMsgClientStartPeerContentServer {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_remote_id = 2;

    pub fn client_remote_id(&self) -> u64 {
        self.client_remote_id.unwrap_or(0)
    }

    pub fn clear_client_remote_id(&mut self) {
        self.client_remote_id = ::std::option::Option::None;
    }

    pub fn has_client_remote_id(&self) -> bool {
        self.client_remote_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_remote_id(&mut self, v: u64) {
        self.client_remote_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 current_build_id = 4;

    pub fn current_build_id(&self) -> u32 {
        self.current_build_id.unwrap_or(0)
    }

    pub fn clear_current_build_id(&mut self) {
        self.current_build_id = ::std::option::Option::None;
    }

    pub fn has_current_build_id(&self) -> bool {
        self.current_build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_build_id(&mut self, v: u32) {
        self.current_build_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientStartPeerContentServer| { &m.steamid },
            |m: &mut CMsgClientStartPeerContentServer| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_remote_id",
            |m: &CMsgClientStartPeerContentServer| { &m.client_remote_id },
            |m: &mut CMsgClientStartPeerContentServer| { &mut m.client_remote_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientStartPeerContentServer| { &m.app_id },
            |m: &mut CMsgClientStartPeerContentServer| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_build_id",
            |m: &CMsgClientStartPeerContentServer| { &m.current_build_id },
            |m: &mut CMsgClientStartPeerContentServer| { &mut m.current_build_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStartPeerContentServer>(
            "CMsgClientStartPeerContentServer",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientStartPeerContentServer {
    const NAME: &'static str = "CMsgClientStartPeerContentServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.client_remote_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.current_build_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_remote_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.current_build_id {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_remote_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.current_build_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStartPeerContentServer {
        CMsgClientStartPeerContentServer::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_remote_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.current_build_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStartPeerContentServer {
        static instance: CMsgClientStartPeerContentServer = CMsgClientStartPeerContentServer {
            steamid: ::std::option::Option::None,
            client_remote_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            current_build_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientStartPeerContentServer {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStartPeerContentServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStartPeerContentServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientStartPeerContentServer {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientStartPeerContentServerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStartPeerContentServerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServerResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServerResponse.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServerResponse.installed_depots)
    pub installed_depots: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServerResponse.access_token)
    pub access_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStartPeerContentServerResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStartPeerContentServerResponse {
    fn default() -> &'a CMsgClientStartPeerContentServerResponse {
        <CMsgClientStartPeerContentServerResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientStartPeerContentServerResponse {
    pub fn new() -> CMsgClientStartPeerContentServerResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 2;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // repeated uint32 installed_depots = 3;

    pub fn installed_depots(&self) -> &[u32] {
        &self.installed_depots
    }

    pub fn clear_installed_depots(&mut self) {
        self.installed_depots.clear();
    }

    // Param is passed by value, moved
    pub fn set_installed_depots(&mut self, v: ::std::vec::Vec<u32>) {
        self.installed_depots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_installed_depots(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.installed_depots
    }

    // Take field
    pub fn take_installed_depots(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.installed_depots, ::std::vec::Vec::new())
    }

    // optional uint64 access_token = 4;

    pub fn access_token(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientStartPeerContentServerResponse| { &m.result },
            |m: &mut CMsgClientStartPeerContentServerResponse| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgClientStartPeerContentServerResponse| { &m.server_port },
            |m: &mut CMsgClientStartPeerContentServerResponse| { &mut m.server_port },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "installed_depots",
            |m: &CMsgClientStartPeerContentServerResponse| { &m.installed_depots },
            |m: &mut CMsgClientStartPeerContentServerResponse| { &mut m.installed_depots },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_token",
            |m: &CMsgClientStartPeerContentServerResponse| { &m.access_token },
            |m: &mut CMsgClientStartPeerContentServerResponse| { &mut m.access_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStartPeerContentServerResponse>(
            "CMsgClientStartPeerContentServerResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientStartPeerContentServerResponse {
    const NAME: &'static str = "CMsgClientStartPeerContentServerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.installed_depots)?;
                },
                24 => {
                    self.installed_depots.push(is.read_uint32()?);
                },
                32 => {
                    self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.server_port {
            my_size += crate::rt::uint32_size(2, v);
        }
        for value in &self.installed_depots {
            my_size += crate::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.access_token {
            my_size += crate::rt::uint64_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(2, v)?;
        }
        for v in &self.installed_depots {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.access_token {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStartPeerContentServerResponse {
        CMsgClientStartPeerContentServerResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.installed_depots.clear();
        self.access_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStartPeerContentServerResponse {
        static instance: CMsgClientStartPeerContentServerResponse = CMsgClientStartPeerContentServerResponse {
            result: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            installed_depots: ::std::vec::Vec::new(),
            access_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientStartPeerContentServerResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStartPeerContentServerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStartPeerContentServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientStartPeerContentServerResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetPeerContentInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetPeerContentInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfo.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfo.client_remote_id)
    pub client_remote_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfo.owned_games_visible)
    pub owned_games_visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetPeerContentInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetPeerContentInfo {
    fn default() -> &'a CMsgClientGetPeerContentInfo {
        <CMsgClientGetPeerContentInfo as crate::Message>::default_instance()
    }
}

impl CMsgClientGetPeerContentInfo {
    pub fn new() -> CMsgClientGetPeerContentInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_remote_id = 2;

    pub fn client_remote_id(&self) -> u64 {
        self.client_remote_id.unwrap_or(0)
    }

    pub fn clear_client_remote_id(&mut self) {
        self.client_remote_id = ::std::option::Option::None;
    }

    pub fn has_client_remote_id(&self) -> bool {
        self.client_remote_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_remote_id(&mut self, v: u64) {
        self.client_remote_id = ::std::option::Option::Some(v);
    }

    // optional bool owned_games_visible = 3;

    pub fn owned_games_visible(&self) -> bool {
        self.owned_games_visible.unwrap_or(false)
    }

    pub fn clear_owned_games_visible(&mut self) {
        self.owned_games_visible = ::std::option::Option::None;
    }

    pub fn has_owned_games_visible(&self) -> bool {
        self.owned_games_visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned_games_visible(&mut self, v: bool) {
        self.owned_games_visible = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientGetPeerContentInfo| { &m.steamid },
            |m: &mut CMsgClientGetPeerContentInfo| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_remote_id",
            |m: &CMsgClientGetPeerContentInfo| { &m.client_remote_id },
            |m: &mut CMsgClientGetPeerContentInfo| { &mut m.client_remote_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owned_games_visible",
            |m: &CMsgClientGetPeerContentInfo| { &m.owned_games_visible },
            |m: &mut CMsgClientGetPeerContentInfo| { &mut m.owned_games_visible },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetPeerContentInfo>(
            "CMsgClientGetPeerContentInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetPeerContentInfo {
    const NAME: &'static str = "CMsgClientGetPeerContentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.client_remote_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.owned_games_visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_remote_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owned_games_visible {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_remote_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.owned_games_visible {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetPeerContentInfo {
        CMsgClientGetPeerContentInfo::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_remote_id = ::std::option::Option::None;
        self.owned_games_visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetPeerContentInfo {
        static instance: CMsgClientGetPeerContentInfo = CMsgClientGetPeerContentInfo {
            steamid: ::std::option::Option::None,
            client_remote_id: ::std::option::Option::None,
            owned_games_visible: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetPeerContentInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetPeerContentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetPeerContentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetPeerContentInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetPeerContentInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetPeerContentInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfoResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfoResponse.apps)
    pub apps: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetPeerContentInfoResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetPeerContentInfoResponse {
    fn default() -> &'a CMsgClientGetPeerContentInfoResponse {
        <CMsgClientGetPeerContentInfoResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetPeerContentInfoResponse {
    pub fn new() -> CMsgClientGetPeerContentInfoResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // repeated uint32 apps = 2;

    pub fn apps(&self) -> &[u32] {
        &self.apps
    }

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::std::vec::Vec<u32>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.apps, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientGetPeerContentInfoResponse| { &m.result },
            |m: &mut CMsgClientGetPeerContentInfoResponse| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientGetPeerContentInfoResponse| { &m.apps },
            |m: &mut CMsgClientGetPeerContentInfoResponse| { &mut m.apps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetPeerContentInfoResponse>(
            "CMsgClientGetPeerContentInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetPeerContentInfoResponse {
    const NAME: &'static str = "CMsgClientGetPeerContentInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.apps)?;
                },
                16 => {
                    self.apps.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.apps {
            my_size += crate::rt::uint32_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.apps {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetPeerContentInfoResponse {
        CMsgClientGetPeerContentInfoResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetPeerContentInfoResponse {
        static instance: CMsgClientGetPeerContentInfoResponse = CMsgClientGetPeerContentInfoResponse {
            result: ::std::option::Option::None,
            apps: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetPeerContentInfoResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetPeerContentInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetPeerContentInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetPeerContentInfoResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPendingGameLaunch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPendingGameLaunch {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPendingGameLaunch.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPendingGameLaunch.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPendingGameLaunch {
    fn default() -> &'a CMsgClientPendingGameLaunch {
        <CMsgClientPendingGameLaunch as crate::Message>::default_instance()
    }
}

impl CMsgClientPendingGameLaunch {
    pub fn new() -> CMsgClientPendingGameLaunch {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientPendingGameLaunch| { &m.app_id },
            |m: &mut CMsgClientPendingGameLaunch| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPendingGameLaunch>(
            "CMsgClientPendingGameLaunch",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientPendingGameLaunch {
    const NAME: &'static str = "CMsgClientPendingGameLaunch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPendingGameLaunch {
        CMsgClientPendingGameLaunch::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPendingGameLaunch {
        static instance: CMsgClientPendingGameLaunch = CMsgClientPendingGameLaunch {
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientPendingGameLaunch {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPendingGameLaunch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPendingGameLaunch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientPendingGameLaunch {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPendingGameLaunchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPendingGameLaunchResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPendingGameLaunchResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientPendingGameLaunchResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPendingGameLaunchResponse.envkey)
    pub envkey: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPendingGameLaunchResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPendingGameLaunchResponse {
    fn default() -> &'a CMsgClientPendingGameLaunchResponse {
        <CMsgClientPendingGameLaunchResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientPendingGameLaunchResponse {
    pub fn new() -> CMsgClientPendingGameLaunchResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string envkey = 3;

    pub fn envkey(&self) -> &str {
        match self.envkey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_envkey(&mut self) {
        self.envkey = ::std::option::Option::None;
    }

    pub fn has_envkey(&self) -> bool {
        self.envkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_envkey(&mut self, v: ::std::string::String) {
        self.envkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_envkey(&mut self) -> &mut ::std::string::String {
        if self.envkey.is_none() {
            self.envkey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.envkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_envkey(&mut self) -> ::std::string::String {
        self.envkey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientPendingGameLaunchResponse| { &m.eresult },
            |m: &mut CMsgClientPendingGameLaunchResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientPendingGameLaunchResponse| { &m.app_id },
            |m: &mut CMsgClientPendingGameLaunchResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "envkey",
            |m: &CMsgClientPendingGameLaunchResponse| { &m.envkey },
            |m: &mut CMsgClientPendingGameLaunchResponse| { &mut m.envkey },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPendingGameLaunchResponse>(
            "CMsgClientPendingGameLaunchResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientPendingGameLaunchResponse {
    const NAME: &'static str = "CMsgClientPendingGameLaunchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.envkey = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.envkey.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.envkey.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPendingGameLaunchResponse {
        CMsgClientPendingGameLaunchResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.envkey = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPendingGameLaunchResponse {
        static instance: CMsgClientPendingGameLaunchResponse = CMsgClientPendingGameLaunchResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            envkey: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientPendingGameLaunchResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPendingGameLaunchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPendingGameLaunchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientPendingGameLaunchResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"steammessages_clientserver_2.proto\x1a\x18steammessages_base.proto\"\
    \xa5\x01\n\x1cCMsgClientUpdateUserGameInfo\x12!\n\x0csteamid_idgs\x18\
    \x01\x20\x01(\x06R\x0bsteamidIdgs\x12\x16\n\x06gameid\x18\x02\x20\x01(\
    \x06R\x06gameid\x12\x17\n\x07game_ip\x18\x03\x20\x01(\rR\x06gameIp\x12\
    \x1b\n\tgame_port\x18\x04\x20\x01(\rR\x08gamePort\x12\x14\n\x05token\x18\
    \x05\x20\x01(\x0cR\x05token\"u\n\x1cCMsgClientRichPresenceUpload\x12(\n\
    \x10rich_presence_kv\x18\x01\x20\x01(\x0cR\x0erichPresenceKv\x12+\n\x11s\
    teamid_broadcast\x18\x02\x20\x03(\x06R\x10steamidBroadcast\"H\n\x1dCMsgC\
    lientRichPresenceRequest\x12'\n\x0fsteamid_request\x18\x01\x20\x03(\x06R\
    \x0esteamidRequest\"\xc8\x01\n\x1aCMsgClientRichPresenceInfo\x12M\n\rric\
    h_presence\x18\x01\x20\x03(\x0b2(.CMsgClientRichPresenceInfo.RichPresenc\
    eR\x0crichPresence\x1a[\n\x0cRichPresence\x12!\n\x0csteamid_user\x18\x01\
    \x20\x01(\x06R\x0bsteamidUser\x12(\n\x10rich_presence_kv\x18\x02\x20\x01\
    (\x0cR\x0erichPresenceKv\"5\n\x1cCMsgClientCheckFileSignature\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\"\xf6\x02\n$CMsgClientCheckFileS\
    ignatureResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\
    \x10\n\x03pid\x18\x02\x20\x01(\rR\x03pid\x12\x18\n\x07eresult\x18\x03\
    \x20\x01(\rR\x07eresult\x12\x1a\n\x08filename\x18\x04\x20\x01(\tR\x08fil\
    ename\x12*\n\x10esignatureresult\x18\x05\x20\x01(\rR\x10esignatureresult\
    \x12\x19\n\x08sha_file\x18\x06\x20\x01(\x0cR\x07shaFile\x12(\n\x0fsignat\
    ureheader\x18\x07\x20\x01(\x0cR\x0fsignatureheader\x12\x1a\n\x08filesize\
    \x18\x08\x20\x01(\rR\x08filesize\x12\"\n\x0cgetlasterror\x18\t\x20\x01(\
    \rR\x0cgetlasterror\x12>\n\x1aevalvesignaturecheckdetail\x18\n\x20\x01(\
    \rR\x1aevalvesignaturecheckdetail\"m\n\x19CMsgClientReadMachineAuth\x12\
    \x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x16\n\x06offset\
    \x18\x02\x20\x01(\rR\x06offset\x12\x1c\n\tcubtoread\x18\x03\x20\x01(\rR\
    \tcubtoread\"\xae\x02\n!CMsgClientReadMachineAuthResponse\x12\x1a\n\x08f\
    ilename\x18\x01\x20\x01(\tR\x08filename\x12\x18\n\x07eresult\x18\x02\x20\
    \x01(\rR\x07eresult\x12\x1a\n\x08filesize\x18\x03\x20\x01(\rR\x08filesiz\
    e\x12\x19\n\x08sha_file\x18\x04\x20\x01(\x0cR\x07shaFile\x12\"\n\x0cgetl\
    asterror\x18\x05\x20\x01(\rR\x0cgetlasterror\x12\x16\n\x06offset\x18\x06\
    \x20\x01(\rR\x06offset\x12\x18\n\x07cubread\x18\x07\x20\x01(\rR\x07cubre\
    ad\x12\x1d\n\nbytes_read\x18\x08\x20\x01(\x0cR\tbytesRead\x12'\n\x0ffile\
    name_sentry\x18\t\x20\x01(\tR\x0efilenameSentry\"\x99\x02\n\x1bCMsgClien\
    tUpdateMachineAuth\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\
    \x12\x16\n\x06offset\x18\x02\x20\x01(\rR\x06offset\x12\x1e\n\ncubtowrite\
    \x18\x03\x20\x01(\rR\ncubtowrite\x12\x14\n\x05bytes\x18\x04\x20\x01(\x0c\
    R\x05bytes\x12\x19\n\x08otp_type\x18\x05\x20\x01(\rR\x07otpType\x12%\n\
    \x0eotp_identifier\x18\x06\x20\x01(\tR\rotpIdentifier\x12)\n\x10otp_shar\
    edsecret\x18\x07\x20\x01(\x0cR\x0fotpSharedsecret\x12#\n\rotp_timedrift\
    \x18\x08\x20\x01(\rR\x0cotpTimedrift\"\xc9\x02\n#CMsgClientUpdateMachine\
    AuthResponse\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\
    \x18\n\x07eresult\x18\x02\x20\x01(\rR\x07eresult\x12\x1a\n\x08filesize\
    \x18\x03\x20\x01(\rR\x08filesize\x12\x19\n\x08sha_file\x18\x04\x20\x01(\
    \x0cR\x07shaFile\x12\"\n\x0cgetlasterror\x18\x05\x20\x01(\rR\x0cgetlaste\
    rror\x12\x16\n\x06offset\x18\x06\x20\x01(\rR\x06offset\x12\x1a\n\x08cubw\
    rote\x18\x07\x20\x01(\rR\x08cubwrote\x12\x19\n\x08otp_type\x18\x08\x20\
    \x01(\x05R\x07otpType\x12\x1b\n\totp_value\x18\t\x20\x01(\rR\x08otpValue\
    \x12%\n\x0eotp_identifier\x18\n\x20\x01(\tR\rotpIdentifier\"\xc1\x03\n\
    \x1cCMsgClientRequestMachineAuth\x12\x1a\n\x08filename\x18\x01\x20\x01(\
    \tR\x08filename\x12-\n\x12eresult_sentryfile\x18\x02\x20\x01(\rR\x11eres\
    ultSentryfile\x12\x1a\n\x08filesize\x18\x03\x20\x01(\rR\x08filesize\x12%\
    \n\x0esha_sentryfile\x18\x04\x20\x01(\x0cR\rshaSentryfile\x12.\n\x13lock\
    _account_action\x18\x06\x20\x01(\x05R\x11lockAccountAction\x12\x19\n\x08\
    otp_type\x18\x07\x20\x01(\rR\x07otpType\x12%\n\x0eotp_identifier\x18\x08\
    \x20\x01(\tR\rotpIdentifier\x12)\n\x10otp_sharedsecret\x18\t\x20\x01(\
    \x0cR\x0fotpSharedsecret\x12\x1b\n\totp_value\x18\n\x20\x01(\rR\x08otpVa\
    lue\x12!\n\x0cmachine_name\x18\x0b\x20\x01(\tR\x0bmachineName\x126\n\x17\
    machine_name_userchosen\x18\x0c\x20\x01(\tR\x15machineNameUserchosen\"@\
    \n$CMsgClientRequestMachineAuthResponse\x12\x18\n\x07eresult\x18\x01\x20\
    \x01(\rR\x07eresult\")\n\x15CMsgClientRegisterKey\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\"\xa5\x01\n\x1aCMsgClientPurchaseResponse\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x126\n\x17purch\
    ase_result_details\x18\x02\x20\x01(\x05R\x15purchaseResultDetails\x122\n\
    \x15purchase_receipt_info\x18\x03\x20\x01(\x0cR\x13purchaseReceiptInfo\"\
    \xb6\x02\n\x1cCMsgClientActivateOEMLicense\x12+\n\x11bios_manufacturer\
    \x18\x01\x20\x01(\tR\x10biosManufacturer\x12+\n\x11bios_serialnumber\x18\
    \x02\x20\x01(\tR\x10biosSerialnumber\x12!\n\x0clicense_file\x18\x03\x20\
    \x01(\x0cR\x0blicenseFile\x125\n\x16mainboard_manufacturer\x18\x04\x20\
    \x01(\tR\x15mainboardManufacturer\x12+\n\x11mainboard_product\x18\x05\
    \x20\x01(\tR\x10mainboardProduct\x125\n\x16mainboard_serialnumber\x18\
    \x06\x20\x01(\tR\x15mainboardSerialnumber\"J\n\x1cCMsgClientRegisterOEMM\
    achine\x12*\n\x11oem_register_file\x18\x01\x20\x01(\x0cR\x0foemRegisterF\
    ile\"@\n$CMsgClientRegisterOEMMachineResponse\x12\x18\n\x07eresult\x18\
    \x01\x20\x01(\rR\x07eresult\"c\n\x1fCMsgClientPurchaseWithMachineID\x12\
    \x1d\n\npackage_id\x18\x01\x20\x01(\rR\tpackageId\x12!\n\x0cmachine_info\
    \x18\x02\x20\x01(\x0cR\x0bmachineInfo\"\x90\x01\n\x20CMsgTrading_Initiat\
    eTradeRequest\x12(\n\x10trade_request_id\x18\x01\x20\x01(\rR\x0etradeReq\
    uestId\x12#\n\rother_steamid\x18\x02\x20\x01(\x04R\x0cotherSteamid\x12\
    \x1d\n\nother_name\x18\x03\x20\x01(\tR\totherName\"\xa3\x04\n!CMsgTradin\
    g_InitiateTradeResponse\x12\x1a\n\x08response\x18\x01\x20\x01(\rR\x08res\
    ponse\x12(\n\x10trade_request_id\x18\x02\x20\x01(\rR\x0etradeRequestId\
    \x12#\n\rother_steamid\x18\x03\x20\x01(\x04R\x0cotherSteamid\x128\n\x18s\
    teamguard_required_days\x18\x04\x20\x01(\rR\x16steamguardRequiredDays\
    \x127\n\x18new_device_cooldown_days\x18\x05\x20\x01(\rR\x15newDeviceCool\
    downDays\x12P\n%default_password_reset_probation_days\x18\x06\x20\x01(\r\
    R!defaultPasswordResetProbationDays\x12A\n\x1dpassword_reset_probation_d\
    ays\x18\x07\x20\x01(\rR\x1apasswordResetProbationDays\x12L\n#default_ema\
    il_change_probation_days\x18\x08\x20\x01(\rR\x1fdefaultEmailChangeProbat\
    ionDays\x12=\n\x1bemail_change_probation_days\x18\t\x20\x01(\rR\x18email\
    ChangeProbationDays\"E\n\x1eCMsgTrading_CancelTradeRequest\x12#\n\rother\
    _steamid\x18\x01\x20\x01(\x04R\x0cotherSteamid\"?\n\x18CMsgTrading_Start\
    Session\x12#\n\rother_steamid\x18\x01\x20\x01(\x04R\x0cotherSteamid\"j\n\
    \x19CMsgClientGetCDNAuthToken\x12\x19\n\x08depot_id\x18\x01\x20\x01(\rR\
    \x07depotId\x12\x1b\n\thost_name\x18\x02\x20\x01(\tR\x08hostName\x12\x15\
    \n\x06app_id\x18\x03\x20\x01(\rR\x05appId\"S\n\x1fCMsgClientGetDepotDecr\
    yptionKey\x12\x19\n\x08depot_id\x18\x01\x20\x01(\rR\x07depotId\x12\x15\n\
    \x06app_id\x18\x02\x20\x01(\rR\x05appId\"\x93\x01\n'CMsgClientGetDepotDe\
    cryptionKeyResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07\
    eresult\x12\x19\n\x08depot_id\x18\x02\x20\x01(\rR\x07depotId\x120\n\x14d\
    epot_encryption_key\x18\x03\x20\x01(\x0cR\x12depotEncryptionKey\"w\n\x1e\
    CMsgClientCheckAppBetaPassword\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12\"\n\x0cbetapassword\x18\x02\x20\x01(\tR\x0cbetapassword\
    \x12\x1a\n\x08language\x18\x03\x20\x01(\x05R\x08language\"\x9b\x02\n&CMs\
    gClientCheckAppBetaPasswordResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01\
    (\x05:\x012R\x07eresult\x12Z\n\rbetapasswords\x18\x04\x20\x03(\x0b24.CMs\
    gClientCheckAppBetaPasswordResponse.BetaPasswordR\rbetapasswords\x1ax\n\
    \x0cBetaPassword\x12\x1a\n\x08betaname\x18\x01\x20\x01(\tR\x08betaname\
    \x12\"\n\x0cbetapassword\x18\x02\x20\x01(\tR\x0cbetapassword\x12(\n\x0fb\
    etadescription\x18\x03\x20\x01(\tR\x0fbetadescription\"\x7f\n!CMsgClient\
    GetCDNAuthTokenResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\
    \x07eresult\x12\x14\n\x05token\x18\x02\x20\x01(\tR\x05token\x12'\n\x0fex\
    piration_time\x18\x03\x20\x01(\rR\x0eexpirationTime\"\xb0\x03\n\x1aCMsgD\
    ownloadRateStatistics\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellId\
    \x12;\n\x05stats\x18\x02\x20\x03(\x0b2%.CMsgDownloadRateStatistics.Stats\
    InfoR\x05stats\x12'\n\x0fthrottling_kbps\x18\x03\x20\x01(\rR\x0ethrottli\
    ngKbps\x12\x1f\n\x0bsteam_realm\x18\x04\x20\x01(\rR\nsteamRealm\x1a\xf1\
    \x01\n\tStatsInfo\x12\x1f\n\x0bsource_type\x18\x01\x20\x01(\rR\nsourceTy\
    pe\x12\x1b\n\tsource_id\x18\x02\x20\x01(\rR\x08sourceId\x12\x18\n\x07sec\
    onds\x18\x03\x20\x01(\rR\x07seconds\x12\x14\n\x05bytes\x18\x04\x20\x01(\
    \x04R\x05bytes\x12\x1b\n\thost_name\x18\x05\x20\x01(\tR\x08hostName\x12\
    \"\n\x0cmicroseconds\x18\x06\x20\x01(\x04R\x0cmicroseconds\x12\x1b\n\tus\
    ed_ipv6\x18\x07\x20\x01(\x08R\x08usedIpv6\x12\x18\n\x07proxied\x18\x08\
    \x20\x01(\x08R\x07proxied\"`\n\x1cCMsgClientRequestAccountData\x12(\n\
    \x10account_or_email\x18\x01\x20\x01(\tR\x0eaccountOrEmail\x12\x16\n\x06\
    action\x18\x02\x20\x01(\rR\x06action\"\xc8\x02\n$CMsgClientRequestAccoun\
    tDataResponse\x12\x16\n\x06action\x18\x01\x20\x01(\rR\x06action\x12\x18\
    \n\x07eresult\x18\x02\x20\x01(\rR\x07eresult\x12!\n\x0caccount_name\x18\
    \x03\x20\x01(\tR\x0baccountName\x12\x1d\n\nct_matches\x18\x04\x20\x01(\r\
    R\tctMatches\x128\n\x18account_name_suggestion1\x18\x05\x20\x01(\tR\x16a\
    ccountNameSuggestion1\x128\n\x18account_name_suggestion2\x18\x06\x20\x01\
    (\tR\x16accountNameSuggestion2\x128\n\x18account_name_suggestion3\x18\
    \x07\x20\x01(\tR\x16accountNameSuggestion3\"\xe6\x01\n\x1bCMsgClientUGSG\
    etGlobalStats\x12\x16\n\x06gameid\x18\x01\x20\x01(\x04R\x06gameid\x124\n\
    \x16history_days_requested\x18\x02\x20\x01(\rR\x14historyDaysRequested\
    \x12.\n\x13time_last_requested\x18\x03\x20\x01(\x07R\x11timeLastRequeste\
    d\x12(\n\x10first_day_cached\x18\x04\x20\x01(\rR\x0efirstDayCached\x12\
    \x1f\n\x0bdays_cached\x18\x05\x20\x01(\rR\ndaysCached\"\xd8\x02\n#CMsgCl\
    ientUGSGetGlobalStatsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x07R\ttimestamp\
    \x12\x1f\n\x0bday_current\x18\x03\x20\x01(\x05R\ndayCurrent\x12<\n\x04da\
    ys\x18\x04\x20\x03(\x0b2(.CMsgClientUGSGetGlobalStatsResponse.DayR\x04da\
    ys\x1a\x96\x01\n\x03Day\x12\x15\n\x06day_id\x18\x01\x20\x01(\rR\x05dayId\
    \x12C\n\x05stats\x18\x02\x20\x03(\x0b2-.CMsgClientUGSGetGlobalStatsRespo\
    nse.Day.StatR\x05stats\x1a3\n\x04Stat\x12\x17\n\x07stat_id\x18\x01\x20\
    \x01(\x05R\x06statId\x12\x12\n\x04data\x18\x02\x20\x01(\x03R\x04data\"?\
    \n\x19CMsgClientRedeemGuestPass\x12\"\n\rguest_pass_id\x18\x01\x20\x01(\
    \x06R\x0bguestPassId\"\x85\x01\n!CMsgClientRedeemGuestPassResponse\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\x12\x1d\n\npackag\
    e_id\x18\x02\x20\x01(\rR\tpackageId\x12$\n\x0emust_own_appid\x18\x03\x20\
    \x01(\rR\x0cmustOwnAppid\"F\n\x1fCMsgClientGetClanActivityCounts\x12#\n\
    \rsteamid_clans\x18\x01\x20\x03(\x04R\x0csteamidClans\"F\n'CMsgClientGet\
    ClanActivityCountsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012\
    R\x07eresult\"\xaf\x01\n\x19CMsgClientOGSReportString\x12\x20\n\x0baccum\
    ulated\x18\x01\x20\x01(\x08R\x0baccumulated\x12\x1c\n\tsessionid\x18\x02\
    \x20\x01(\x04R\tsessionid\x12\x1a\n\x08severity\x18\x03\x20\x01(\x05R\
    \x08severity\x12\x1c\n\tformatter\x18\x04\x20\x01(\tR\tformatter\x12\x18\
    \n\x07varargs\x18\x05\x20\x01(\x0cR\x07varargs\"p\n\x16CMsgClientOGSRepo\
    rtBug\x12\x1c\n\tsessionid\x18\x01\x20\x01(\x04R\tsessionid\x12\x18\n\
    \x07bugtext\x18\x02\x20\x01(\tR\x07bugtext\x12\x1e\n\nscreenshot\x18\x03\
    \x20\x01(\x0cR\nscreenshot\"\x14\n\x12CMsgClientSentLogs\"\x9a\x01\n\x0c\
    CMsgGCClient\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x18\n\
    \x07msgtype\x18\x02\x20\x01(\rR\x07msgtype\x12\x18\n\x07payload\x18\x03\
    \x20\x01(\x0cR\x07payload\x12\x18\n\x07steamid\x18\x04\x20\x01(\x06R\x07\
    steamid\x12\x16\n\x06gcname\x18\x05\x20\x01(\tR\x06gcname\x12\x0e\n\x02i\
    p\x18\x06\x20\x01(\rR\x02ip\"6\n\x1cCMsgClientRequestFreeLicense\x12\x16\
    \n\x06appids\x18\x02\x20\x03(\rR\x06appids\"\x99\x01\n$CMsgClientRequest\
    FreeLicenseResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07er\
    esult\x12-\n\x12granted_packageids\x18\x02\x20\x03(\rR\x11grantedPackage\
    ids\x12%\n\x0egranted_appids\x18\x03\x20\x03(\rR\rgrantedAppids\"\xb8\
    \x02\n#CMsgDRMDownloadRequestWithCrashData\x12%\n\x0edownload_flags\x18\
    \x01\x20\x01(\rR\rdownloadFlags\x120\n\x14download_types_known\x18\x02\
    \x20\x01(\rR\x12downloadTypesKnown\x12\x19\n\x08guid_drm\x18\x03\x20\x01\
    (\x0cR\x07guidDrm\x12\x1d\n\nguid_split\x18\x04\x20\x01(\x0cR\tguidSplit\
    \x12\x1d\n\nguid_merge\x18\x05\x20\x01(\x0cR\tguidMerge\x12\x1f\n\x0bmod\
    ule_name\x18\x06\x20\x01(\tR\nmoduleName\x12\x1f\n\x0bmodule_path\x18\
    \x07\x20\x01(\tR\nmodulePath\x12\x1d\n\ncrash_data\x18\x08\x20\x01(\x0cR\
    \tcrashData\"\xcd\x02\n\x17CMsgDRMDownloadResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\r:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\
    \x01(\rR\x05appId\x12,\n\x12blob_download_type\x18\x03\x20\x01(\rR\x10bl\
    obDownloadType\x12\x1d\n\nmerge_guid\x18\x04\x20\x01(\x0cR\tmergeGuid\
    \x12/\n\x14download_file_dfs_ip\x18\x05\x20\x01(\rR\x11downloadFileDfsIp\
    \x123\n\x16download_file_dfs_port\x18\x06\x20\x01(\rR\x13downloadFileDfs\
    Port\x12*\n\x11download_file_url\x18\x07\x20\x01(\tR\x0fdownloadFileUrl\
    \x12\x1f\n\x0bmodule_path\x18\x08\x20\x01(\tR\nmodulePath\"\xca\x02\n\
    \x12CMsgDRMFinalResult\x12\x1b\n\x07eResult\x18\x01\x20\x01(\r:\x012R\
    \x07eResult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12,\n\x12b\
    lob_download_type\x18\x03\x20\x01(\rR\x10blobDownloadType\x12!\n\x0cerro\
    r_detail\x18\x04\x20\x01(\rR\x0berrorDetail\x12\x1d\n\nmerge_guid\x18\
    \x05\x20\x01(\x0cR\tmergeGuid\x12/\n\x14download_file_dfs_ip\x18\x06\x20\
    \x01(\rR\x11downloadFileDfsIp\x123\n\x16download_file_dfs_port\x18\x07\
    \x20\x01(\rR\x13downloadFileDfsPort\x12*\n\x11download_file_url\x18\x08\
    \x20\x01(\tR\x0fdownloadFileUrl\"=\n\x1eCMsgClientDPCheckSpecialSurvey\
    \x12\x1b\n\tsurvey_id\x18\x01\x20\x01(\rR\x08surveyId\"\xcf\x01\n&CMsgCl\
    ientDPCheckSpecialSurveyResponse\x12\x1b\n\x07eResult\x18\x01\x20\x01(\r\
    :\x012R\x07eResult\x12\x14\n\x05state\x18\x02\x20\x01(\rR\x05state\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1d\n\ncustom_url\x18\x04\
    \x20\x01(\tR\tcustomUrl\x12)\n\x10include_software\x18\x05\x20\x01(\x08R\
    \x0fincludeSoftware\x12\x14\n\x05token\x18\x06\x20\x01(\x0cR\x05token\"X\
    \n%CMsgClientDPSendSpecialSurveyResponse\x12\x1b\n\tsurvey_id\x18\x01\
    \x20\x01(\rR\x08surveyId\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \"_\n*CMsgClientDPSendSpecialSurveyResponseReply\x12\x1b\n\x07eResult\
    \x18\x01\x20\x01(\r:\x012R\x07eResult\x12\x14\n\x05token\x18\x02\x20\x01\
    (\x0cR\x05token\"s\n'CMsgClientRequestForgottenPasswordEmail\x12!\n\x0ca\
    ccount_name\x18\x01\x20\x01(\tR\x0baccountName\x12%\n\x0epassword_tried\
    \x18\x02\x20\x01(\tR\rpasswordTried\"{\n/CMsgClientRequestForgottenPassw\
    ordEmailResponse\x12\x18\n\x07eResult\x18\x01\x20\x01(\rR\x07eResult\x12\
    .\n\x13use_secret_question\x18\x02\x20\x01(\x08R\x11useSecretQuestion\"\
    \xd2\x02\n\x1bCMsgClientItemAnnouncements\x12&\n\x0fcount_new_items\x18\
    \x01\x20\x01(\rR\rcountNewItems\x12J\n\x0cunseen_items\x18\x02\x20\x03(\
    \x0b2'.CMsgClientItemAnnouncements.UnseenItemR\x0bunseenItems\x1a\xbe\
    \x01\n\nUnseenItem\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x1d\n\ncontext_id\x18\x02\x20\x01(\x04R\tcontextId\x12\x19\n\x08asset_i\
    d\x18\x03\x20\x01(\x04R\x07assetId\x12\x16\n\x06amount\x18\x04\x20\x01(\
    \x04R\x06amount\x12%\n\x0ertime32_gained\x18\x05\x20\x01(\x07R\rrtime32G\
    ained\x12!\n\x0csource_appid\x18\x06\x20\x01(\rR\x0bsourceAppid\"$\n\"CM\
    sgClientRequestItemAnnouncements\"\xca\x01\n\x1bCMsgClientUserNotificati\
    ons\x12O\n\rnotifications\x18\x01\x20\x03(\x0b2).CMsgClientUserNotificat\
    ions.NotificationR\rnotifications\x1aZ\n\x0cNotification\x124\n\x16user_\
    notification_type\x18\x01\x20\x01(\rR\x14userNotificationType\x12\x14\n\
    \x05count\x18\x02\x20\x01(\rR\x05count\"\xd0\x01\n\x1eCMsgClientCommentN\
    otifications\x12,\n\x12count_new_comments\x18\x01\x20\x01(\rR\x10countNe\
    wComments\x127\n\x18count_new_comments_owner\x18\x02\x20\x01(\rR\x15coun\
    tNewCommentsOwner\x12G\n\x20count_new_comments_subscriptions\x18\x03\x20\
    \x01(\rR\x1dcountNewCommentsSubscriptions\"'\n%CMsgClientRequestCommentN\
    otifications\"\x94\x01\n$CMsgClientOfflineMessageNotification\x12)\n\x10\
    offline_messages\x18\x01\x20\x01(\rR\x0fofflineMessages\x12A\n\x1dfriend\
    s_with_offline_messages\x18\x02\x20\x03(\rR\x1afriendsWithOfflineMessage\
    s\"&\n$CMsgClientRequestOfflineMessageCount\"A\n%CMsgClientChatGetFriend\
    MessageHistory\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\
    \xbc\x02\n-CMsgClientChatGetFriendMessageHistoryResponse\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x18\n\x07success\x18\x02\x20\
    \x01(\rR\x07success\x12X\n\x08messages\x18\x03\x20\x03(\x0b2<.CMsgClient\
    ChatGetFriendMessageHistoryResponse.FriendMessageR\x08messages\x1a}\n\rF\
    riendMessage\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x1c\
    \n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x18\n\x07message\x18\
    \x03\x20\x01(\tR\x07message\x12\x16\n\x06unread\x18\x04\x20\x01(\x08R\
    \x06unread\"9\n7CMsgClientChatGetFriendMessageHistoryForOfflineMessages\
    \"C\n!CMsgClientFSGetFriendsSteamLevels\x12\x1e\n\naccountids\x18\x01\
    \x20\x03(\rR\naccountids\"\xb6\x01\n)CMsgClientFSGetFriendsSteamLevelsRe\
    sponse\x12K\n\x07friends\x18\x01\x20\x03(\x0b21.CMsgClientFSGetFriendsSt\
    eamLevelsResponse.FriendR\x07friends\x1a<\n\x06Friend\x12\x1c\n\taccount\
    id\x18\x01\x20\x01(\rR\taccountid\x12\x14\n\x05level\x18\x02\x20\x01(\rR\
    \x05level\"\xc6\x02\n\x17CMsgClientEmailAddrInfo\x12#\n\remail_address\
    \x18\x01\x20\x01(\tR\x0cemailAddress\x12,\n\x12email_is_validated\x18\
    \x02\x20\x01(\x08R\x10emailIsValidated\x128\n\x18email_validation_change\
    d\x18\x03\x20\x01(\x08R\x16emailValidationChanged\x12E\n\x1fcredential_c\
    hange_requires_code\x18\x04\x20\x01(\x08R\x1ccredentialChangeRequiresCod\
    e\x12W\n)password_or_secretqa_change_requires_code\x18\x05\x20\x01(\x08R\
    $passwordOrSecretqaChangeRequiresCode\"\xae\x01\n\x16CMsgCREItemVoteSumm\
    ary\x12U\n\x12published_file_ids\x18\x01\x20\x03(\x0b2'.CMsgCREItemVoteS\
    ummary.PublishedFileIdR\x10publishedFileIds\x1a=\n\x0fPublishedFileId\
    \x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\"\
    \xd0\x02\n\x1eCMsgCREItemVoteSummaryResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12_\n\x13item_vote_summaries\x18\
    \x02\x20\x03(\x0b2/.CMsgCREItemVoteSummaryResponse.ItemVoteSummaryR\x11i\
    temVoteSummaries\x1a\xaf\x01\n\x0fItemVoteSummary\x12*\n\x11published_fi\
    le_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\tvotes_for\x18\
    \x02\x20\x01(\x05R\x08votesFor\x12#\n\rvotes_against\x18\x03\x20\x01(\
    \x05R\x0cvotesAgainst\x12\x18\n\x07reports\x18\x04\x20\x01(\x05R\x07repo\
    rts\x12\x14\n\x05score\x18\x05\x20\x01(\x02R\x05score\"i\n\"CMsgCREUpdat\
    eUserPublishedItemVote\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\
    \x0fpublishedFileId\x12\x17\n\x07vote_up\x18\x02\x20\x01(\x08R\x06voteUp\
    \"I\n*CMsgCREUpdateUserPublishedItemVoteResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\"\xce\x01\n&CMsgCREGetUserPublis\
    hedItemVoteDetails\x12e\n\x12published_file_ids\x18\x01\x20\x03(\x0b27.C\
    MsgCREGetUserPublishedItemVoteDetails.PublishedFileIdR\x10publishedFileI\
    ds\x1a=\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01\
    (\x06R\x0fpublishedFileId\"\x9f\x02\n.CMsgCREGetUserPublishedItemVoteDet\
    ailsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12w\n\x16user_item_vote_details\x18\x02\x20\x03(\x0b2B.CMsgCREGetUserP\
    ublishedItemVoteDetailsResponse.UserItemVoteDetailR\x13userItemVoteDetai\
    ls\x1aW\n\x12UserItemVoteDetail\x12*\n\x11published_file_id\x18\x01\x20\
    \x01(\x06R\x0fpublishedFileId\x12\x15\n\x04vote\x18\x02\x20\x01(\x05:\
    \x010R\x04vote\"3\n\x16CMsgFSGetFollowerCount\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\"V\n\x1eCMsgFSGetFollowerCountResponse\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x17\n\x05co\
    unt\x18\x02\x20\x01(\x05:\x010R\x05count\"1\n\x14CMsgFSGetIsFollowing\
    \x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"e\n\x1cCMsgFSGe\
    tIsFollowingResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12(\n\x0cis_following\x18\x02\x20\x01(\x08:\x05falseR\x0bis\
    Following\"?\n\x1cCMsgFSEnumerateFollowingList\x12\x1f\n\x0bstart_index\
    \x18\x01\x20\x01(\rR\nstartIndex\"\x85\x01\n$CMsgFSEnumerateFollowingLis\
    tResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12#\n\rtotal_results\x18\x02\x20\x01(\x05R\x0ctotalResults\x12\x1b\n\t\
    steam_ids\x18\x03\x20\x03(\x06R\x08steamIds\"7\n\x1fCMsgDPGetNumberOfCur\
    rentPlayers\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"i\n'CMsgDPG\
    etNumberOfCurrentPlayersResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12!\n\x0cplayer_count\x18\x02\x20\x01(\x05R\x0bp\
    layerCount\"\x83\x01\n#CMsgClientFriendUserStatusPublished\x12%\n\x0efri\
    end_steamid\x18\x01\x20\x01(\x06R\rfriendSteamid\x12\x14\n\x05appid\x18\
    \x02\x20\x01(\rR\x05appid\x12\x1f\n\x0bstatus_text\x18\x03\x20\x01(\tR\n\
    statusText\"\x96\x01\n\x1dCMsgClientServiceMethodLegacy\x12\x1f\n\x0bmet\
    hod_name\x18\x01\x20\x01(\tR\nmethodName\x12+\n\x11serialized_method\x18\
    \x02\x20\x01(\x0cR\x10serializedMethod\x12'\n\x0fis_notification\x18\x03\
    \x20\x01(\x08R\x0eisNotification\"\x86\x01\n%CMsgClientServiceMethodLega\
    cyResponse\x12\x1f\n\x0bmethod_name\x18\x01\x20\x01(\tR\nmethodName\x12<\
    \n\x1aserialized_method_response\x18\x02\x20\x01(\x0cR\x18serializedMeth\
    odResponse\"G\n\x10CMsgClientUIMode\x12\x16\n\x06uimode\x18\x01\x20\x01(\
    \rR\x06uimode\x12\x1b\n\tchat_mode\x18\x02\x20\x01(\rR\x08chatMode\"G\n&\
    CMsgClientVanityURLChangedNotification\x12\x1d\n\nvanity_url\x18\x01\x20\
    \x01(\tR\tvanityUrl\"\xae\x01\n%CMsgClientAuthorizeLocalDeviceRequest\
    \x12-\n\x12device_description\x18\x01\x20\x01(\tR\x11deviceDescription\
    \x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\n\
    \x12local_device_token\x18\x03\x20\x01(\x04R\x10localDeviceToken\"\x97\
    \x01\n\x1eCMsgClientAuthorizeLocalDevice\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\x12(\n\x10owner_account_id\x18\x02\x20\
    \x01(\rR\x0eownerAccountId\x12.\n\x13authed_device_token\x18\x03\x20\x01\
    (\x04R\x11authedDeviceToken\"\xa1\x01\n*CMsgClientAuthorizeLocalDeviceNo\
    tification\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\n\
    \x12local_device_token\x18\x03\x20\x01(\x04R\x10localDeviceToken\"\xa4\
    \x01\n\"CMsgClientDeauthorizeDeviceRequest\x12<\n\x1adeauthorization_acc\
    ount_id\x18\x01\x20\x01(\rR\x18deauthorizationAccountId\x12@\n\x1cdeauth\
    orization_device_token\x18\x02\x20\x01(\x04R\x1adeauthorizationDeviceTok\
    en\"x\n\x1bCMsgClientDeauthorizeDevice\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12<\n\x1adeauthorization_account_id\x18\x02\
    \x20\x01(\rR\x18deauthorizationAccountId\"\x90\x02\n&CMsgClientUseLocalD\
    eviceAuthorizations\x128\n\x18authorization_account_id\x18\x01\x20\x03(\
    \rR\x16authorizationAccountId\x12X\n\rdevice_tokens\x18\x02\x20\x03(\x0b\
    23.CMsgClientUseLocalDeviceAuthorizations.DeviceTokenR\x0cdeviceTokens\
    \x1aR\n\x0bDeviceToken\x12(\n\x10owner_account_id\x18\x01\x20\x01(\rR\
    \x0eownerAccountId\x12\x19\n\x08token_id\x18\x02\x20\x01(\x04R\x07tokenI\
    d\"\x20\n\x1eCMsgClientGetAuthorizedDevices\"\x97\x03\n&CMsgClientGetAut\
    horizedDevicesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12e\n\x11authorized_device\x18\x02\x20\x03(\x0b28.CMsgClien\
    tGetAuthorizedDevicesResponse.AuthorizedDeviceR\x10authorizedDevice\x1a\
    \xe8\x01\n\x10AuthorizedDevice\x12*\n\x11auth_device_token\x18\x01\x20\
    \x01(\x04R\x0fauthDeviceToken\x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\
    \tR\ndeviceName\x12(\n\x10last_access_time\x18\x03\x20\x01(\rR\x0elastAc\
    cessTime\x12\x1f\n\x0bborrower_id\x18\x04\x20\x01(\rR\nborrowerId\x12\
    \x1d\n\nis_pending\x18\x05\x20\x01(\x08R\tisPending\x12\x1d\n\napp_playe\
    d\x18\x06\x20\x01(\rR\tappPlayed\"\xf8\x01\n!CMsgClientSharedLibraryLock\
    Status\x12W\n\x0elocked_library\x18\x01\x20\x03(\x0b20.CMsgClientSharedL\
    ibraryLockStatus.LockedLibraryR\rlockedLibrary\x121\n\x15own_library_loc\
    ked_by\x18\x02\x20\x01(\rR\x12ownLibraryLockedBy\x1aG\n\rLockedLibrary\
    \x12\x19\n\x08owner_id\x18\x01\x20\x01(\rR\x07ownerId\x12\x1b\n\tlocked_\
    by\x18\x02\x20\x01(\rR\x08lockedBy\"\xce\x01\n\"CMsgClientSharedLibraryS\
    topPlaying\x12!\n\x0cseconds_left\x18\x01\x20\x01(\x05R\x0bsecondsLeft\
    \x12H\n\tstop_apps\x18\x02\x20\x03(\x0b2+.CMsgClientSharedLibraryStopPla\
    ying.StopAppR\x08stopApps\x1a;\n\x07StopApp\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12\x19\n\x08owner_id\x18\x02\x20\x01(\rR\x07owner\
    Id\"\x88\x03\n\x15CMsgClientServiceCall\x12#\n\rsysid_routing\x18\x01\
    \x20\x01(\x0cR\x0csysidRouting\x12\x1f\n\x0bcall_handle\x18\x02\x20\x01(\
    \rR\ncallHandle\x12\x1d\n\nmodule_crc\x18\x03\x20\x01(\rR\tmoduleCrc\x12\
    \x1f\n\x0bmodule_hash\x18\x04\x20\x01(\x0cR\nmoduleHash\x12\x1f\n\x0bfun\
    ction_id\x18\x05\x20\x01(\rR\nfunctionId\x12$\n\x0ecub_output_max\x18\
    \x06\x20\x01(\rR\x0ccubOutputMax\x12\x14\n\x05flags\x18\x07\x20\x01(\rR\
    \x05flags\x12$\n\rcallparameter\x18\x08\x20\x01(\x0cR\rcallparameter\x12\
    \x1b\n\tping_only\x18\t\x20\x01(\x08R\x08pingOnly\x122\n\x15max_outstand\
    ing_calls\x18\n\x20\x01(\rR\x13maxOutstandingCalls\x12\x15\n\x06app_id\
    \x18\x0b\x20\x01(\rR\x05appId\"\x80\x01\n\x17CMsgClientServiceModule\x12\
    \x1d\n\nmodule_crc\x18\x01\x20\x01(\rR\tmoduleCrc\x12\x1f\n\x0bmodule_ha\
    sh\x18\x02\x20\x01(\x0cR\nmoduleHash\x12%\n\x0emodule_content\x18\x03\
    \x20\x01(\x0cR\rmoduleContent\"\x8a\x07\n\x1dCMsgClientServiceCallRespon\
    se\x12#\n\rsysid_routing\x18\x01\x20\x01(\x0cR\x0csysidRouting\x12\x1f\n\
    \x0bcall_handle\x18\x02\x20\x01(\rR\ncallHandle\x12\x1d\n\nmodule_crc\
    \x18\x03\x20\x01(\rR\tmoduleCrc\x12\x1f\n\x0bmodule_hash\x18\x04\x20\x01\
    (\x0cR\nmoduleHash\x12\x20\n\x0becallresult\x18\x05\x20\x01(\rR\x0becall\
    result\x12%\n\x0eresult_content\x18\x06\x20\x01(\x0cR\rresultContent\x12\
    &\n\x0fos_version_info\x18\x07\x20\x01(\x0cR\rosVersionInfo\x12\x1f\n\
    \x0bsystem_info\x18\x08\x20\x01(\x0cR\nsystemInfo\x12!\n\x0cload_address\
    \x18\t\x20\x01(\x06R\x0bloadAddress\x12)\n\x10exception_record\x18\n\x20\
    \x01(\x0cR\x0fexceptionRecord\x127\n\x18portable_os_version_info\x18\x0b\
    \x20\x01(\x0cR\x15portableOsVersionInfo\x120\n\x14portable_system_info\
    \x18\x0c\x20\x01(\x0cR\x12portableSystemInfo\x12#\n\rwas_converted\x18\r\
    \x20\x01(\x08R\x0cwasConverted\x12'\n\x0finternal_result\x18\x0e\x20\x01\
    (\rR\x0einternalResult\x12#\n\rcurrent_count\x18\x0f\x20\x01(\rR\x0ccurr\
    entCount\x12(\n\x10last_call_handle\x18\x10\x20\x01(\rR\x0elastCallHandl\
    e\x12/\n\x14last_call_module_crc\x18\x11\x20\x01(\rR\x11lastCallModuleCr\
    c\x125\n\x17last_call_sysid_routing\x18\x12\x20\x01(\x0cR\x14lastCallSys\
    idRouting\x12)\n\x10last_ecallresult\x18\x13\x20\x01(\rR\x0flastEcallres\
    ult\x120\n\x14last_callissue_delta\x18\x14\x20\x01(\rR\x12lastCallissueD\
    elta\x126\n\x17last_callcomplete_delta\x18\x15\x20\x01(\rR\x15lastCallco\
    mpleteDelta\"\\\n\x10CMsgAMUnlockH264\x12\x14\n\x05appid\x18\x01\x20\x01\
    (\rR\x05appid\x12\x1a\n\x08platform\x18\x02\x20\x01(\x05R\x08platform\
    \x12\x16\n\x06reason\x18\x03\x20\x01(\x05R\x06reason\"^\n\x18CMsgAMUnloc\
    kH264Response\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresul\
    t\x12%\n\x0eencryption_key\x18\x02\x20\x01(\x0cR\rencryptionKey\"i\n\x1d\
    CMsgClientPlayingSessionState\x12'\n\x0fplaying_blocked\x18\x02\x20\x01(\
    \x08R\x0eplayingBlocked\x12\x1f\n\x0bplaying_app\x18\x03\x20\x01(\rR\npl\
    ayingApp\"D\n\x1cCMsgClientKickPlayingSession\x12$\n\x0eonly_stop_game\
    \x18\x01\x20\x01(\x08R\x0conlyStopGame\"\xa8\x01\n\x1fCMsgClientVoiceCal\
    lPreAuthorize\x12%\n\x0ecaller_steamid\x18\x01\x20\x01(\x06R\rcallerStea\
    mid\x12)\n\x10receiver_steamid\x18\x02\x20\x01(\x06R\x0freceiverSteamid\
    \x12\x1b\n\tcaller_id\x18\x03\x20\x01(\x05R\x08callerId\x12\x16\n\x06han\
    gup\x18\x04\x20\x01(\x08R\x06hangup\"\xb5\x01\n'CMsgClientVoiceCallPreAu\
    thorizeResponse\x12%\n\x0ecaller_steamid\x18\x01\x20\x01(\x06R\rcallerSt\
    eamid\x12)\n\x10receiver_steamid\x18\x02\x20\x01(\x06R\x0freceiverSteami\
    d\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\x07eresult\x12\x1b\n\
    \tcaller_id\x18\x04\x20\x01(\x05R\x08callerId\"U\n\x1cCMsgBadgeCraftedNo\
    tification\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1f\n\x0b\
    badge_level\x18\x02\x20\x01(\rR\nbadgeLevel\"\xa7\x01\n\x20CMsgClientSta\
    rtPeerContentServer\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steami\
    d\x12(\n\x10client_remote_id\x18\x02\x20\x01(\x06R\x0eclientRemoteId\x12\
    \x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\x12(\n\x10current_build_id\
    \x18\x04\x20\x01(\rR\x0ecurrentBuildId\"\xb1\x01\n(CMsgClientStartPeerCo\
    ntentServerResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\
    \x12\x1f\n\x0bserver_port\x18\x02\x20\x01(\rR\nserverPort\x12)\n\x10inst\
    alled_depots\x18\x03\x20\x03(\rR\x0finstalledDepots\x12!\n\x0caccess_tok\
    en\x18\x04\x20\x01(\x04R\x0baccessToken\"\x92\x01\n\x1cCMsgClientGetPeer\
    ContentInfo\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12(\n\
    \x10client_remote_id\x18\x02\x20\x01(\x06R\x0eclientRemoteId\x12.\n\x13o\
    wned_games_visible\x18\x03\x20\x01(\x08R\x11ownedGamesVisible\"R\n$CMsgC\
    lientGetPeerContentInfoResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\
    \x06result\x12\x12\n\x04apps\x18\x02\x20\x03(\rR\x04apps\"4\n\x1bCMsgCli\
    entPendingGameLaunch\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\"q\
    \n#CMsgClientPendingGameLaunchResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05a\
    ppId\x12\x16\n\x06envkey\x18\x03\x20\x01(\tR\x06envkeyB\x05H\x01\x80\x01\
    \0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(127);
            messages.push(CMsgClientUpdateUserGameInfo::generated_message_descriptor_data());
            messages.push(CMsgClientRichPresenceUpload::generated_message_descriptor_data());
            messages.push(CMsgClientRichPresenceRequest::generated_message_descriptor_data());
            messages.push(CMsgClientRichPresenceInfo::generated_message_descriptor_data());
            messages.push(CMsgClientCheckFileSignature::generated_message_descriptor_data());
            messages.push(CMsgClientCheckFileSignatureResponse::generated_message_descriptor_data());
            messages.push(CMsgClientReadMachineAuth::generated_message_descriptor_data());
            messages.push(CMsgClientReadMachineAuthResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUpdateMachineAuth::generated_message_descriptor_data());
            messages.push(CMsgClientUpdateMachineAuthResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRequestMachineAuth::generated_message_descriptor_data());
            messages.push(CMsgClientRequestMachineAuthResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRegisterKey::generated_message_descriptor_data());
            messages.push(CMsgClientPurchaseResponse::generated_message_descriptor_data());
            messages.push(CMsgClientActivateOEMLicense::generated_message_descriptor_data());
            messages.push(CMsgClientRegisterOEMMachine::generated_message_descriptor_data());
            messages.push(CMsgClientRegisterOEMMachineResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPurchaseWithMachineID::generated_message_descriptor_data());
            messages.push(CMsgTrading_InitiateTradeRequest::generated_message_descriptor_data());
            messages.push(CMsgTrading_InitiateTradeResponse::generated_message_descriptor_data());
            messages.push(CMsgTrading_CancelTradeRequest::generated_message_descriptor_data());
            messages.push(CMsgTrading_StartSession::generated_message_descriptor_data());
            messages.push(CMsgClientGetCDNAuthToken::generated_message_descriptor_data());
            messages.push(CMsgClientGetDepotDecryptionKey::generated_message_descriptor_data());
            messages.push(CMsgClientGetDepotDecryptionKeyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientCheckAppBetaPassword::generated_message_descriptor_data());
            messages.push(CMsgClientCheckAppBetaPasswordResponse::generated_message_descriptor_data());
            messages.push(CMsgClientGetCDNAuthTokenResponse::generated_message_descriptor_data());
            messages.push(CMsgDownloadRateStatistics::generated_message_descriptor_data());
            messages.push(CMsgClientRequestAccountData::generated_message_descriptor_data());
            messages.push(CMsgClientRequestAccountDataResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUGSGetGlobalStats::generated_message_descriptor_data());
            messages.push(CMsgClientUGSGetGlobalStatsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRedeemGuestPass::generated_message_descriptor_data());
            messages.push(CMsgClientRedeemGuestPassResponse::generated_message_descriptor_data());
            messages.push(CMsgClientGetClanActivityCounts::generated_message_descriptor_data());
            messages.push(CMsgClientGetClanActivityCountsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientOGSReportString::generated_message_descriptor_data());
            messages.push(CMsgClientOGSReportBug::generated_message_descriptor_data());
            messages.push(CMsgClientSentLogs::generated_message_descriptor_data());
            messages.push(CMsgGCClient::generated_message_descriptor_data());
            messages.push(CMsgClientRequestFreeLicense::generated_message_descriptor_data());
            messages.push(CMsgClientRequestFreeLicenseResponse::generated_message_descriptor_data());
            messages.push(CMsgDRMDownloadRequestWithCrashData::generated_message_descriptor_data());
            messages.push(CMsgDRMDownloadResponse::generated_message_descriptor_data());
            messages.push(CMsgDRMFinalResult::generated_message_descriptor_data());
            messages.push(CMsgClientDPCheckSpecialSurvey::generated_message_descriptor_data());
            messages.push(CMsgClientDPCheckSpecialSurveyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientDPSendSpecialSurveyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientDPSendSpecialSurveyResponseReply::generated_message_descriptor_data());
            messages.push(CMsgClientRequestForgottenPasswordEmail::generated_message_descriptor_data());
            messages.push(CMsgClientRequestForgottenPasswordEmailResponse::generated_message_descriptor_data());
            messages.push(CMsgClientItemAnnouncements::generated_message_descriptor_data());
            messages.push(CMsgClientRequestItemAnnouncements::generated_message_descriptor_data());
            messages.push(CMsgClientUserNotifications::generated_message_descriptor_data());
            messages.push(CMsgClientCommentNotifications::generated_message_descriptor_data());
            messages.push(CMsgClientRequestCommentNotifications::generated_message_descriptor_data());
            messages.push(CMsgClientOfflineMessageNotification::generated_message_descriptor_data());
            messages.push(CMsgClientRequestOfflineMessageCount::generated_message_descriptor_data());
            messages.push(CMsgClientChatGetFriendMessageHistory::generated_message_descriptor_data());
            messages.push(CMsgClientChatGetFriendMessageHistoryResponse::generated_message_descriptor_data());
            messages.push(CMsgClientChatGetFriendMessageHistoryForOfflineMessages::generated_message_descriptor_data());
            messages.push(CMsgClientFSGetFriendsSteamLevels::generated_message_descriptor_data());
            messages.push(CMsgClientFSGetFriendsSteamLevelsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientEmailAddrInfo::generated_message_descriptor_data());
            messages.push(CMsgCREItemVoteSummary::generated_message_descriptor_data());
            messages.push(CMsgCREItemVoteSummaryResponse::generated_message_descriptor_data());
            messages.push(CMsgCREUpdateUserPublishedItemVote::generated_message_descriptor_data());
            messages.push(CMsgCREUpdateUserPublishedItemVoteResponse::generated_message_descriptor_data());
            messages.push(CMsgCREGetUserPublishedItemVoteDetails::generated_message_descriptor_data());
            messages.push(CMsgCREGetUserPublishedItemVoteDetailsResponse::generated_message_descriptor_data());
            messages.push(CMsgFSGetFollowerCount::generated_message_descriptor_data());
            messages.push(CMsgFSGetFollowerCountResponse::generated_message_descriptor_data());
            messages.push(CMsgFSGetIsFollowing::generated_message_descriptor_data());
            messages.push(CMsgFSGetIsFollowingResponse::generated_message_descriptor_data());
            messages.push(CMsgFSEnumerateFollowingList::generated_message_descriptor_data());
            messages.push(CMsgFSEnumerateFollowingListResponse::generated_message_descriptor_data());
            messages.push(CMsgDPGetNumberOfCurrentPlayers::generated_message_descriptor_data());
            messages.push(CMsgDPGetNumberOfCurrentPlayersResponse::generated_message_descriptor_data());
            messages.push(CMsgClientFriendUserStatusPublished::generated_message_descriptor_data());
            messages.push(CMsgClientServiceMethodLegacy::generated_message_descriptor_data());
            messages.push(CMsgClientServiceMethodLegacyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUIMode::generated_message_descriptor_data());
            messages.push(CMsgClientVanityURLChangedNotification::generated_message_descriptor_data());
            messages.push(CMsgClientAuthorizeLocalDeviceRequest::generated_message_descriptor_data());
            messages.push(CMsgClientAuthorizeLocalDevice::generated_message_descriptor_data());
            messages.push(CMsgClientAuthorizeLocalDeviceNotification::generated_message_descriptor_data());
            messages.push(CMsgClientDeauthorizeDeviceRequest::generated_message_descriptor_data());
            messages.push(CMsgClientDeauthorizeDevice::generated_message_descriptor_data());
            messages.push(CMsgClientUseLocalDeviceAuthorizations::generated_message_descriptor_data());
            messages.push(CMsgClientGetAuthorizedDevices::generated_message_descriptor_data());
            messages.push(CMsgClientGetAuthorizedDevicesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientSharedLibraryLockStatus::generated_message_descriptor_data());
            messages.push(CMsgClientSharedLibraryStopPlaying::generated_message_descriptor_data());
            messages.push(CMsgClientServiceCall::generated_message_descriptor_data());
            messages.push(CMsgClientServiceModule::generated_message_descriptor_data());
            messages.push(CMsgClientServiceCallResponse::generated_message_descriptor_data());
            messages.push(CMsgAMUnlockH264::generated_message_descriptor_data());
            messages.push(CMsgAMUnlockH264Response::generated_message_descriptor_data());
            messages.push(CMsgClientPlayingSessionState::generated_message_descriptor_data());
            messages.push(CMsgClientKickPlayingSession::generated_message_descriptor_data());
            messages.push(CMsgClientVoiceCallPreAuthorize::generated_message_descriptor_data());
            messages.push(CMsgClientVoiceCallPreAuthorizeResponse::generated_message_descriptor_data());
            messages.push(CMsgBadgeCraftedNotification::generated_message_descriptor_data());
            messages.push(CMsgClientStartPeerContentServer::generated_message_descriptor_data());
            messages.push(CMsgClientStartPeerContentServerResponse::generated_message_descriptor_data());
            messages.push(CMsgClientGetPeerContentInfo::generated_message_descriptor_data());
            messages.push(CMsgClientGetPeerContentInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPendingGameLaunch::generated_message_descriptor_data());
            messages.push(CMsgClientPendingGameLaunchResponse::generated_message_descriptor_data());
            messages.push(cmsg_client_rich_presence_info::RichPresence::generated_message_descriptor_data());
            messages.push(cmsg_client_check_app_beta_password_response::BetaPassword::generated_message_descriptor_data());
            messages.push(cmsg_download_rate_statistics::StatsInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_ugsget_global_stats_response::Day::generated_message_descriptor_data());
            messages.push(cmsg_client_ugsget_global_stats_response::day::Stat::generated_message_descriptor_data());
            messages.push(cmsg_client_item_announcements::UnseenItem::generated_message_descriptor_data());
            messages.push(cmsg_client_user_notifications::Notification::generated_message_descriptor_data());
            messages.push(cmsg_client_chat_get_friend_message_history_response::FriendMessage::generated_message_descriptor_data());
            messages.push(cmsg_client_fsget_friends_steam_levels_response::Friend::generated_message_descriptor_data());
            messages.push(cmsg_creitem_vote_summary::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_creitem_vote_summary_response::ItemVoteSummary::generated_message_descriptor_data());
            messages.push(cmsg_creget_user_published_item_vote_details::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail::generated_message_descriptor_data());
            messages.push(cmsg_client_use_local_device_authorizations::DeviceToken::generated_message_descriptor_data());
            messages.push(cmsg_client_get_authorized_devices_response::AuthorizedDevice::generated_message_descriptor_data());
            messages.push(cmsg_client_shared_library_lock_status::LockedLibrary::generated_message_descriptor_data());
            messages.push(cmsg_client_shared_library_stop_playing::StopApp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
