// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `htmlmessages.proto`

// @@protoc_insertion_point(message:CMsgKeyUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyUp.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyUp.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyUp {
    fn default() -> &'a CMsgKeyUp {
        <CMsgKeyUp as crate::Message>::default_instance()
    }
}

impl CMsgKeyUp {
    pub fn new() -> CMsgKeyUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 4;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgKeyUp| { &m.browser_handle },
            |m: &mut CMsgKeyUp| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyCode",
            |m: &CMsgKeyUp| { &m.keyCode },
            |m: &mut CMsgKeyUp| { &mut m.keyCode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgKeyUp| { &m.modifiers },
            |m: &mut CMsgKeyUp| { &mut m.modifiers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nativeKeyCode",
            |m: &CMsgKeyUp| { &m.nativeKeyCode },
            |m: &mut CMsgKeyUp| { &mut m.nativeKeyCode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyUp>(
            "CMsgKeyUp",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgKeyUp {
    const NAME: &'static str = "CMsgKeyUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.keyCode {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyUp {
        CMsgKeyUp::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyUp {
        static instance: CMsgKeyUp = CMsgKeyUp {
            browser_handle: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgKeyUp {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyUp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgKeyUp {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.is_system_key)
    pub is_system_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgKeyDown.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyDown.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyDown {
    fn default() -> &'a CMsgKeyDown {
        <CMsgKeyDown as crate::Message>::default_instance()
    }
}

impl CMsgKeyDown {
    pub fn new() -> CMsgKeyDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_system_key = 4;

    pub fn is_system_key(&self) -> bool {
        self.is_system_key.unwrap_or(false)
    }

    pub fn clear_is_system_key(&mut self) {
        self.is_system_key = ::std::option::Option::None;
    }

    pub fn has_is_system_key(&self) -> bool {
        self.is_system_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_system_key(&mut self, v: bool) {
        self.is_system_key = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgKeyDown| { &m.browser_handle },
            |m: &mut CMsgKeyDown| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyCode",
            |m: &CMsgKeyDown| { &m.keyCode },
            |m: &mut CMsgKeyDown| { &mut m.keyCode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgKeyDown| { &m.modifiers },
            |m: &mut CMsgKeyDown| { &mut m.modifiers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_system_key",
            |m: &CMsgKeyDown| { &m.is_system_key },
            |m: &mut CMsgKeyDown| { &mut m.is_system_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nativeKeyCode",
            |m: &CMsgKeyDown| { &m.nativeKeyCode },
            |m: &mut CMsgKeyDown| { &mut m.nativeKeyCode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyDown>(
            "CMsgKeyDown",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgKeyDown {
    const NAME: &'static str = "CMsgKeyDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_system_key = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.keyCode {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_system_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_system_key {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyDown {
        CMsgKeyDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_system_key = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyDown {
        static instance: CMsgKeyDown = CMsgKeyDown {
            browser_handle: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            is_system_key: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgKeyDown {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgKeyDown {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyChar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyChar {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyChar.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.unichar)
    pub unichar: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyChar.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyChar {
    fn default() -> &'a CMsgKeyChar {
        <CMsgKeyChar as crate::Message>::default_instance()
    }
}

impl CMsgKeyChar {
    pub fn new() -> CMsgKeyChar {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 unichar = 2;

    pub fn unichar(&self) -> u32 {
        self.unichar.unwrap_or(0)
    }

    pub fn clear_unichar(&mut self) {
        self.unichar = ::std::option::Option::None;
    }

    pub fn has_unichar(&self) -> bool {
        self.unichar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unichar(&mut self, v: u32) {
        self.unichar = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 4;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgKeyChar| { &m.browser_handle },
            |m: &mut CMsgKeyChar| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unichar",
            |m: &CMsgKeyChar| { &m.unichar },
            |m: &mut CMsgKeyChar| { &mut m.unichar },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgKeyChar| { &m.modifiers },
            |m: &mut CMsgKeyChar| { &mut m.modifiers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyCode",
            |m: &CMsgKeyChar| { &m.keyCode },
            |m: &mut CMsgKeyChar| { &mut m.keyCode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nativeKeyCode",
            |m: &CMsgKeyChar| { &m.nativeKeyCode },
            |m: &mut CMsgKeyChar| { &mut m.nativeKeyCode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyChar>(
            "CMsgKeyChar",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgKeyChar {
    const NAME: &'static str = "CMsgKeyChar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.unichar = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.unichar {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.keyCode {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unichar {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyChar {
        CMsgKeyChar::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unichar = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyChar {
        static instance: CMsgKeyChar = CMsgKeyChar {
            browser_handle: ::std::option::Option::None,
            unichar: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgKeyChar {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyChar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyChar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgKeyChar {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDown.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDown.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseDown.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDown {
    fn default() -> &'a CMsgMouseDown {
        <CMsgMouseDown as crate::Message>::default_instance()
    }
}

impl CMsgMouseDown {
    pub fn new() -> CMsgMouseDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseDown| { &m.browser_handle },
            |m: &mut CMsgMouseDown| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_button",
            |m: &CMsgMouseDown| { &m.mouse_button },
            |m: &mut CMsgMouseDown| { &mut m.mouse_button },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseDown| { &m.modifiers },
            |m: &mut CMsgMouseDown| { &mut m.modifiers },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseDown>(
            "CMsgMouseDown",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMouseDown {
    const NAME: &'static str = "CMsgMouseDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseDown {
        CMsgMouseDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseDown {
        static instance: CMsgMouseDown = CMsgMouseDown {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMouseDown {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMouseDown {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseUp.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.is_off_panel)
    pub is_off_panel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgMouseUp.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.y)
    pub y: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseUp.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseUp {
    fn default() -> &'a CMsgMouseUp {
        <CMsgMouseUp as crate::Message>::default_instance()
    }
}

impl CMsgMouseUp {
    pub fn new() -> CMsgMouseUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_off_panel = 4;

    pub fn is_off_panel(&self) -> bool {
        self.is_off_panel.unwrap_or(false)
    }

    pub fn clear_is_off_panel(&mut self) {
        self.is_off_panel = ::std::option::Option::None;
    }

    pub fn has_is_off_panel(&self) -> bool {
        self.is_off_panel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_off_panel(&mut self, v: bool) {
        self.is_off_panel = ::std::option::Option::Some(v);
    }

    // optional int32 x = 5;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 6;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseUp| { &m.browser_handle },
            |m: &mut CMsgMouseUp| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_button",
            |m: &CMsgMouseUp| { &m.mouse_button },
            |m: &mut CMsgMouseUp| { &mut m.mouse_button },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseUp| { &m.modifiers },
            |m: &mut CMsgMouseUp| { &mut m.modifiers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_off_panel",
            |m: &CMsgMouseUp| { &m.is_off_panel },
            |m: &mut CMsgMouseUp| { &mut m.is_off_panel },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgMouseUp| { &m.x },
            |m: &mut CMsgMouseUp| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgMouseUp| { &m.y },
            |m: &mut CMsgMouseUp| { &mut m.y },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseUp>(
            "CMsgMouseUp",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMouseUp {
    const NAME: &'static str = "CMsgMouseUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_off_panel = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_off_panel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.x {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::int32_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_off_panel {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseUp {
        CMsgMouseUp::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_off_panel = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseUp {
        static instance: CMsgMouseUp = CMsgMouseUp {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            is_off_panel: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMouseUp {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseUp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMouseUp {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseDblClick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseDblClick {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseDblClick.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDblClick.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDblClick.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseDblClick.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDblClick {
    fn default() -> &'a CMsgMouseDblClick {
        <CMsgMouseDblClick as crate::Message>::default_instance()
    }
}

impl CMsgMouseDblClick {
    pub fn new() -> CMsgMouseDblClick {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseDblClick| { &m.browser_handle },
            |m: &mut CMsgMouseDblClick| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_button",
            |m: &CMsgMouseDblClick| { &m.mouse_button },
            |m: &mut CMsgMouseDblClick| { &mut m.mouse_button },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseDblClick| { &m.modifiers },
            |m: &mut CMsgMouseDblClick| { &mut m.modifiers },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseDblClick>(
            "CMsgMouseDblClick",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMouseDblClick {
    const NAME: &'static str = "CMsgMouseDblClick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseDblClick {
        CMsgMouseDblClick::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseDblClick {
        static instance: CMsgMouseDblClick = CMsgMouseDblClick {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMouseDblClick {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseDblClick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseDblClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMouseDblClick {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseWheel {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseWheel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.deltax)
    pub deltax: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.deltay)
    pub deltay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseWheel.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseWheel {
    fn default() -> &'a CMsgMouseWheel {
        <CMsgMouseWheel as crate::Message>::default_instance()
    }
}

impl CMsgMouseWheel {
    pub fn new() -> CMsgMouseWheel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 deltax = 2;

    pub fn deltax(&self) -> i32 {
        self.deltax.unwrap_or(0)
    }

    pub fn clear_deltax(&mut self) {
        self.deltax = ::std::option::Option::None;
    }

    pub fn has_deltax(&self) -> bool {
        self.deltax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltax(&mut self, v: i32) {
        self.deltax = ::std::option::Option::Some(v);
    }

    // optional int32 deltay = 3;

    pub fn deltay(&self) -> i32 {
        self.deltay.unwrap_or(0)
    }

    pub fn clear_deltay(&mut self) {
        self.deltay = ::std::option::Option::None;
    }

    pub fn has_deltay(&self) -> bool {
        self.deltay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltay(&mut self, v: i32) {
        self.deltay = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseWheel| { &m.browser_handle },
            |m: &mut CMsgMouseWheel| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deltax",
            |m: &CMsgMouseWheel| { &m.deltax },
            |m: &mut CMsgMouseWheel| { &mut m.deltax },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deltay",
            |m: &CMsgMouseWheel| { &m.deltay },
            |m: &mut CMsgMouseWheel| { &mut m.deltay },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseWheel| { &m.modifiers },
            |m: &mut CMsgMouseWheel| { &mut m.modifiers },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseWheel>(
            "CMsgMouseWheel",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMouseWheel {
    const NAME: &'static str = "CMsgMouseWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deltax = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.deltay = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deltax {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.deltay {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deltax {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deltay {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseWheel {
        CMsgMouseWheel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.deltax = ::std::option::Option::None;
        self.deltay = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseWheel {
        static instance: CMsgMouseWheel = CMsgMouseWheel {
            browser_handle: ::std::option::Option::None,
            deltax: ::std::option::Option::None,
            deltay: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMouseWheel {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseWheel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseWheel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMouseWheel {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseMove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseMove {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseMove.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseMove.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseMove {
    fn default() -> &'a CMsgMouseMove {
        <CMsgMouseMove as crate::Message>::default_instance()
    }
}

impl CMsgMouseMove {
    pub fn new() -> CMsgMouseMove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseMove| { &m.browser_handle },
            |m: &mut CMsgMouseMove| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgMouseMove| { &m.x },
            |m: &mut CMsgMouseMove| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgMouseMove| { &m.y },
            |m: &mut CMsgMouseMove| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseMove| { &m.modifiers },
            |m: &mut CMsgMouseMove| { &mut m.modifiers },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseMove>(
            "CMsgMouseMove",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMouseMove {
    const NAME: &'static str = "CMsgMouseMove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.modifiers {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseMove {
        CMsgMouseMove::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseMove {
        static instance: CMsgMouseMove = CMsgMouseMove {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMouseMove {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseMove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMouseMove {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseLeave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseLeave {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseLeave.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseLeave.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseLeave {
    fn default() -> &'a CMsgMouseLeave {
        <CMsgMouseLeave as crate::Message>::default_instance()
    }
}

impl CMsgMouseLeave {
    pub fn new() -> CMsgMouseLeave {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseLeave| { &m.browser_handle },
            |m: &mut CMsgMouseLeave| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseLeave>(
            "CMsgMouseLeave",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMouseLeave {
    const NAME: &'static str = "CMsgMouseLeave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseLeave {
        CMsgMouseLeave::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseLeave {
        static instance: CMsgMouseLeave = CMsgMouseLeave {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMouseLeave {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseLeave").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseLeave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMouseLeave {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserCreate {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserCreate.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.useragent)
    pub useragent: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.user_css)
    pub user_css: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.native_dropdowns)
    pub native_dropdowns: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.dpi_scaling)
    pub dpi_scaling: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.offscreen)
    pub offscreen: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_width)
    pub initial_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_height)
    pub initial_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.window_icon)
    pub window_icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.borderless)
    pub borderless: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.vroverlay_key)
    pub vroverlay_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.browser_type)
    pub browser_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_top)
    pub initial_top: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_left)
    pub initial_left: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.only_allow_trusted_popups)
    pub only_allow_trusted_popups: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_url)
    pub initial_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.hwnd_parent)
    pub hwnd_parent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.creation_flags)
    pub creation_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserCreate.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreate {
    fn default() -> &'a CMsgBrowserCreate {
        <CMsgBrowserCreate as crate::Message>::default_instance()
    }
}

impl CMsgBrowserCreate {
    pub fn new() -> CMsgBrowserCreate {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional string useragent = 3;

    pub fn useragent(&self) -> &str {
        match self.useragent.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_useragent(&mut self) {
        self.useragent = ::std::option::Option::None;
    }

    pub fn has_useragent(&self) -> bool {
        self.useragent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_useragent(&mut self, v: ::std::string::String) {
        self.useragent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_useragent(&mut self) -> &mut ::std::string::String {
        if self.useragent.is_none() {
            self.useragent = ::std::option::Option::Some(::std::string::String::new());
        }
        self.useragent.as_mut().unwrap()
    }

    // Take field
    pub fn take_useragent(&mut self) -> ::std::string::String {
        self.useragent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user_css = 5;

    pub fn user_css(&self) -> &str {
        match self.user_css.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_css(&mut self) {
        self.user_css = ::std::option::Option::None;
    }

    pub fn has_user_css(&self) -> bool {
        self.user_css.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_css(&mut self, v: ::std::string::String) {
        self.user_css = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_css(&mut self) -> &mut ::std::string::String {
        if self.user_css.is_none() {
            self.user_css = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_css.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_css(&mut self) -> ::std::string::String {
        self.user_css.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool native_dropdowns = 6;

    pub fn native_dropdowns(&self) -> bool {
        self.native_dropdowns.unwrap_or(false)
    }

    pub fn clear_native_dropdowns(&mut self) {
        self.native_dropdowns = ::std::option::Option::None;
    }

    pub fn has_native_dropdowns(&self) -> bool {
        self.native_dropdowns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_dropdowns(&mut self, v: bool) {
        self.native_dropdowns = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 7;

    pub fn dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }

    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }

    // optional bool offscreen = 8;

    pub fn offscreen(&self) -> bool {
        self.offscreen.unwrap_or(true)
    }

    pub fn clear_offscreen(&mut self) {
        self.offscreen = ::std::option::Option::None;
    }

    pub fn has_offscreen(&self) -> bool {
        self.offscreen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offscreen(&mut self, v: bool) {
        self.offscreen = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_width = 9;

    pub fn initial_width(&self) -> u32 {
        self.initial_width.unwrap_or(0u32)
    }

    pub fn clear_initial_width(&mut self) {
        self.initial_width = ::std::option::Option::None;
    }

    pub fn has_initial_width(&self) -> bool {
        self.initial_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_width(&mut self, v: u32) {
        self.initial_width = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_height = 10;

    pub fn initial_height(&self) -> u32 {
        self.initial_height.unwrap_or(0u32)
    }

    pub fn clear_initial_height(&mut self) {
        self.initial_height = ::std::option::Option::None;
    }

    pub fn has_initial_height(&self) -> bool {
        self.initial_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_height(&mut self, v: u32) {
        self.initial_height = ::std::option::Option::Some(v);
    }

    // optional string window_icon = 11;

    pub fn window_icon(&self) -> &str {
        match self.window_icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_window_icon(&mut self) {
        self.window_icon = ::std::option::Option::None;
    }

    pub fn has_window_icon(&self) -> bool {
        self.window_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_icon(&mut self, v: ::std::string::String) {
        self.window_icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_icon(&mut self) -> &mut ::std::string::String {
        if self.window_icon.is_none() {
            self.window_icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.window_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_icon(&mut self) -> ::std::string::String {
        self.window_icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool borderless = 12;

    pub fn borderless(&self) -> bool {
        self.borderless.unwrap_or(false)
    }

    pub fn clear_borderless(&mut self) {
        self.borderless = ::std::option::Option::None;
    }

    pub fn has_borderless(&self) -> bool {
        self.borderless.is_some()
    }

    // Param is passed by value, moved
    pub fn set_borderless(&mut self, v: bool) {
        self.borderless = ::std::option::Option::Some(v);
    }

    // optional string vroverlay_key = 13;

    pub fn vroverlay_key(&self) -> &str {
        match self.vroverlay_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vroverlay_key(&mut self) {
        self.vroverlay_key = ::std::option::Option::None;
    }

    pub fn has_vroverlay_key(&self) -> bool {
        self.vroverlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vroverlay_key(&mut self, v: ::std::string::String) {
        self.vroverlay_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vroverlay_key(&mut self) -> &mut ::std::string::String {
        if self.vroverlay_key.is_none() {
            self.vroverlay_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vroverlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vroverlay_key(&mut self) -> ::std::string::String {
        self.vroverlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 browser_type = 14;

    pub fn browser_type(&self) -> u32 {
        self.browser_type.unwrap_or(0u32)
    }

    pub fn clear_browser_type(&mut self) {
        self.browser_type = ::std::option::Option::None;
    }

    pub fn has_browser_type(&self) -> bool {
        self.browser_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_type(&mut self, v: u32) {
        self.browser_type = ::std::option::Option::Some(v);
    }

    // optional int32 initial_top = 15;

    pub fn initial_top(&self) -> i32 {
        self.initial_top.unwrap_or(-2147483648i32)
    }

    pub fn clear_initial_top(&mut self) {
        self.initial_top = ::std::option::Option::None;
    }

    pub fn has_initial_top(&self) -> bool {
        self.initial_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_top(&mut self, v: i32) {
        self.initial_top = ::std::option::Option::Some(v);
    }

    // optional int32 initial_left = 16;

    pub fn initial_left(&self) -> i32 {
        self.initial_left.unwrap_or(-2147483648i32)
    }

    pub fn clear_initial_left(&mut self) {
        self.initial_left = ::std::option::Option::None;
    }

    pub fn has_initial_left(&self) -> bool {
        self.initial_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_left(&mut self, v: i32) {
        self.initial_left = ::std::option::Option::Some(v);
    }

    // optional bool only_allow_trusted_popups = 17;

    pub fn only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.unwrap_or(false)
    }

    pub fn clear_only_allow_trusted_popups(&mut self) {
        self.only_allow_trusted_popups = ::std::option::Option::None;
    }

    pub fn has_only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_allow_trusted_popups(&mut self, v: bool) {
        self.only_allow_trusted_popups = ::std::option::Option::Some(v);
    }

    // optional string initial_url = 18;

    pub fn initial_url(&self) -> &str {
        match self.initial_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initial_url(&mut self) {
        self.initial_url = ::std::option::Option::None;
    }

    pub fn has_initial_url(&self) -> bool {
        self.initial_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_url(&mut self, v: ::std::string::String) {
        self.initial_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_url(&mut self) -> &mut ::std::string::String {
        if self.initial_url.is_none() {
            self.initial_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initial_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_initial_url(&mut self) -> ::std::string::String {
        self.initial_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_parent = 19;

    pub fn hwnd_parent(&self) -> u64 {
        self.hwnd_parent.unwrap_or(0)
    }

    pub fn clear_hwnd_parent(&mut self) {
        self.hwnd_parent = ::std::option::Option::None;
    }

    pub fn has_hwnd_parent(&self) -> bool {
        self.hwnd_parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_parent(&mut self, v: u64) {
        self.hwnd_parent = ::std::option::Option::Some(v);
    }

    // optional uint32 creation_flags = 20;

    pub fn creation_flags(&self) -> u32 {
        self.creation_flags.unwrap_or(0u32)
    }

    pub fn clear_creation_flags(&mut self) {
        self.creation_flags = ::std::option::Option::None;
    }

    pub fn has_creation_flags(&self) -> bool {
        self.creation_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_flags(&mut self, v: u32) {
        self.creation_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgBrowserCreate| { &m.request_id },
            |m: &mut CMsgBrowserCreate| { &mut m.request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "useragent",
            |m: &CMsgBrowserCreate| { &m.useragent },
            |m: &mut CMsgBrowserCreate| { &mut m.useragent },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_css",
            |m: &CMsgBrowserCreate| { &m.user_css },
            |m: &mut CMsgBrowserCreate| { &mut m.user_css },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "native_dropdowns",
            |m: &CMsgBrowserCreate| { &m.native_dropdowns },
            |m: &mut CMsgBrowserCreate| { &mut m.native_dropdowns },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dpi_scaling",
            |m: &CMsgBrowserCreate| { &m.dpi_scaling },
            |m: &mut CMsgBrowserCreate| { &mut m.dpi_scaling },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offscreen",
            |m: &CMsgBrowserCreate| { &m.offscreen },
            |m: &mut CMsgBrowserCreate| { &mut m.offscreen },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_width",
            |m: &CMsgBrowserCreate| { &m.initial_width },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_height",
            |m: &CMsgBrowserCreate| { &m.initial_height },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "window_icon",
            |m: &CMsgBrowserCreate| { &m.window_icon },
            |m: &mut CMsgBrowserCreate| { &mut m.window_icon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "borderless",
            |m: &CMsgBrowserCreate| { &m.borderless },
            |m: &mut CMsgBrowserCreate| { &mut m.borderless },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vroverlay_key",
            |m: &CMsgBrowserCreate| { &m.vroverlay_key },
            |m: &mut CMsgBrowserCreate| { &mut m.vroverlay_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_type",
            |m: &CMsgBrowserCreate| { &m.browser_type },
            |m: &mut CMsgBrowserCreate| { &mut m.browser_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_top",
            |m: &CMsgBrowserCreate| { &m.initial_top },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_top },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_left",
            |m: &CMsgBrowserCreate| { &m.initial_left },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_left },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_allow_trusted_popups",
            |m: &CMsgBrowserCreate| { &m.only_allow_trusted_popups },
            |m: &mut CMsgBrowserCreate| { &mut m.only_allow_trusted_popups },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_url",
            |m: &CMsgBrowserCreate| { &m.initial_url },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hwnd_parent",
            |m: &CMsgBrowserCreate| { &m.hwnd_parent },
            |m: &mut CMsgBrowserCreate| { &mut m.hwnd_parent },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "creation_flags",
            |m: &CMsgBrowserCreate| { &m.creation_flags },
            |m: &mut CMsgBrowserCreate| { &mut m.creation_flags },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserCreate>(
            "CMsgBrowserCreate",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserCreate {
    const NAME: &'static str = "CMsgBrowserCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.useragent = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.user_css = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.native_dropdowns = ::std::option::Option::Some(is.read_bool()?);
                },
                61 => {
                    self.dpi_scaling = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.offscreen = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.initial_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.initial_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.window_icon = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.borderless = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    self.vroverlay_key = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.browser_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.initial_top = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.initial_left = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.only_allow_trusted_popups = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    self.initial_url = ::std::option::Option::Some(is.read_string()?);
                },
                153 => {
                    self.hwnd_parent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                160 => {
                    self.creation_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.useragent.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.user_css.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.native_dropdowns {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 1 + 4;
        }
        if let Some(v) = self.offscreen {
            my_size += 1 + 1;
        }
        if let Some(v) = self.initial_width {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.initial_height {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.window_icon.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        if let Some(v) = self.borderless {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vroverlay_key.as_ref() {
            my_size += crate::rt::string_size(13, &v);
        }
        if let Some(v) = self.browser_type {
            my_size += crate::rt::uint32_size(14, v);
        }
        if let Some(v) = self.initial_top {
            my_size += crate::rt::int32_size(15, v);
        }
        if let Some(v) = self.initial_left {
            my_size += crate::rt::int32_size(16, v);
        }
        if let Some(v) = self.only_allow_trusted_popups {
            my_size += 2 + 1;
        }
        if let Some(v) = self.initial_url.as_ref() {
            my_size += crate::rt::string_size(18, &v);
        }
        if let Some(v) = self.hwnd_parent {
            my_size += 2 + 8;
        }
        if let Some(v) = self.creation_flags {
            my_size += crate::rt::uint32_size(20, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.useragent.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.user_css.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.native_dropdowns {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.offscreen {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.initial_width {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.initial_height {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.window_icon.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.borderless {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.vroverlay_key.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.browser_type {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.initial_top {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.initial_left {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.only_allow_trusted_popups {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.initial_url.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.hwnd_parent {
            os.write_fixed64(19, v)?;
        }
        if let Some(v) = self.creation_flags {
            os.write_uint32(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserCreate {
        CMsgBrowserCreate::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.useragent = ::std::option::Option::None;
        self.user_css = ::std::option::Option::None;
        self.native_dropdowns = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.offscreen = ::std::option::Option::None;
        self.initial_width = ::std::option::Option::None;
        self.initial_height = ::std::option::Option::None;
        self.window_icon = ::std::option::Option::None;
        self.borderless = ::std::option::Option::None;
        self.vroverlay_key = ::std::option::Option::None;
        self.browser_type = ::std::option::Option::None;
        self.initial_top = ::std::option::Option::None;
        self.initial_left = ::std::option::Option::None;
        self.only_allow_trusted_popups = ::std::option::Option::None;
        self.initial_url = ::std::option::Option::None;
        self.hwnd_parent = ::std::option::Option::None;
        self.creation_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserCreate {
        static instance: CMsgBrowserCreate = CMsgBrowserCreate {
            request_id: ::std::option::Option::None,
            useragent: ::std::option::Option::None,
            user_css: ::std::option::Option::None,
            native_dropdowns: ::std::option::Option::None,
            dpi_scaling: ::std::option::Option::None,
            offscreen: ::std::option::Option::None,
            initial_width: ::std::option::Option::None,
            initial_height: ::std::option::Option::None,
            window_icon: ::std::option::Option::None,
            borderless: ::std::option::Option::None,
            vroverlay_key: ::std::option::Option::None,
            browser_type: ::std::option::Option::None,
            initial_top: ::std::option::Option::None,
            initial_left: ::std::option::Option::None,
            only_allow_trusted_popups: ::std::option::Option::None,
            initial_url: ::std::option::Option::None,
            hwnd_parent: ::std::option::Option::None,
            creation_flags: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserCreate {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserCreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserCreate {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserCreateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserCreateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserCreateResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreateResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserCreateResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreateResponse {
    fn default() -> &'a CMsgBrowserCreateResponse {
        <CMsgBrowserCreateResponse as crate::Message>::default_instance()
    }
}

impl CMsgBrowserCreateResponse {
    pub fn new() -> CMsgBrowserCreateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserCreateResponse| { &m.browser_handle },
            |m: &mut CMsgBrowserCreateResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgBrowserCreateResponse| { &m.request_id },
            |m: &mut CMsgBrowserCreateResponse| { &mut m.request_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserCreateResponse>(
            "CMsgBrowserCreateResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserCreateResponse {
    const NAME: &'static str = "CMsgBrowserCreateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserCreateResponse {
        CMsgBrowserCreateResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserCreateResponse {
        static instance: CMsgBrowserCreateResponse = CMsgBrowserCreateResponse {
            browser_handle: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserCreateResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserCreateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserCreateResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserRemove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserRemove {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserRemove.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserRemove.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserRemove {
    fn default() -> &'a CMsgBrowserRemove {
        <CMsgBrowserRemove as crate::Message>::default_instance()
    }
}

impl CMsgBrowserRemove {
    pub fn new() -> CMsgBrowserRemove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserRemove| { &m.browser_handle },
            |m: &mut CMsgBrowserRemove| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserRemove>(
            "CMsgBrowserRemove",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserRemove {
    const NAME: &'static str = "CMsgBrowserRemove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserRemove {
        CMsgBrowserRemove::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserRemove {
        static instance: CMsgBrowserRemove = CMsgBrowserRemove {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserRemove {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserRemove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserRemove {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetLocalFileRequestMapping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetLocalFileRequestMapping {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.request_url)
    pub request_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.default_local_path)
    pub default_local_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.routes)
    pub routes: ::std::vec::Vec<cmsg_set_local_file_request_mapping::AdditionalRoute>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetLocalFileRequestMapping.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetLocalFileRequestMapping {
    fn default() -> &'a CMsgSetLocalFileRequestMapping {
        <CMsgSetLocalFileRequestMapping as crate::Message>::default_instance()
    }
}

impl CMsgSetLocalFileRequestMapping {
    pub fn new() -> CMsgSetLocalFileRequestMapping {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string request_url = 2;

    pub fn request_url(&self) -> &str {
        match self.request_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_request_url(&mut self) {
        self.request_url = ::std::option::Option::None;
    }

    pub fn has_request_url(&self) -> bool {
        self.request_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_url(&mut self, v: ::std::string::String) {
        self.request_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_url(&mut self) -> &mut ::std::string::String {
        if self.request_url.is_none() {
            self.request_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.request_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_url(&mut self) -> ::std::string::String {
        self.request_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_local_path = 3;

    pub fn default_local_path(&self) -> &str {
        match self.default_local_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default_local_path(&mut self) {
        self.default_local_path = ::std::option::Option::None;
    }

    pub fn has_default_local_path(&self) -> bool {
        self.default_local_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_local_path(&mut self, v: ::std::string::String) {
        self.default_local_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_local_path(&mut self) -> &mut ::std::string::String {
        if self.default_local_path.is_none() {
            self.default_local_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default_local_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_local_path(&mut self) -> ::std::string::String {
        self.default_local_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgSetLocalFileRequestMapping.AdditionalRoute routes = 4;

    pub fn routes(&self) -> &[cmsg_set_local_file_request_mapping::AdditionalRoute] {
        &self.routes
    }

    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<cmsg_set_local_file_request_mapping::AdditionalRoute>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<cmsg_set_local_file_request_mapping::AdditionalRoute> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<cmsg_set_local_file_request_mapping::AdditionalRoute> {
        ::std::mem::replace(&mut self.routes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetLocalFileRequestMapping| { &m.browser_handle },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_url",
            |m: &CMsgSetLocalFileRequestMapping| { &m.request_url },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.request_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_local_path",
            |m: &CMsgSetLocalFileRequestMapping| { &m.default_local_path },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.default_local_path },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "routes",
            |m: &CMsgSetLocalFileRequestMapping| { &m.routes },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.routes },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetLocalFileRequestMapping>(
            "CMsgSetLocalFileRequestMapping",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetLocalFileRequestMapping {
    const NAME: &'static str = "CMsgSetLocalFileRequestMapping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.request_url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.default_local_path = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.routes.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.request_url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_local_path.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_local_path.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.routes {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetLocalFileRequestMapping {
        CMsgSetLocalFileRequestMapping::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_url = ::std::option::Option::None;
        self.default_local_path = ::std::option::Option::None;
        self.routes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetLocalFileRequestMapping {
        static instance: CMsgSetLocalFileRequestMapping = CMsgSetLocalFileRequestMapping {
            browser_handle: ::std::option::Option::None,
            request_url: ::std::option::Option::None,
            default_local_path: ::std::option::Option::None,
            routes: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetLocalFileRequestMapping {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetLocalFileRequestMapping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetLocalFileRequestMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetLocalFileRequestMapping {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSetLocalFileRequestMapping`
pub mod cmsg_set_local_file_request_mapping {
    // @@protoc_insertion_point(message:CMsgSetLocalFileRequestMapping.AdditionalRoute)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalRoute {
        // message fields
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.relative_url)
        pub relative_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.local_path)
        pub local_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.allowed_extensions)
        pub allowed_extensions: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.url_rewrite)
        pub url_rewrite: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSetLocalFileRequestMapping.AdditionalRoute.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalRoute {
        fn default() -> &'a AdditionalRoute {
            <AdditionalRoute as crate::Message>::default_instance()
        }
    }

    impl AdditionalRoute {
        pub fn new() -> AdditionalRoute {
            ::std::default::Default::default()
        }

        // optional string relative_url = 1;

        pub fn relative_url(&self) -> &str {
            match self.relative_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_relative_url(&mut self) {
            self.relative_url = ::std::option::Option::None;
        }

        pub fn has_relative_url(&self) -> bool {
            self.relative_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_relative_url(&mut self, v: ::std::string::String) {
            self.relative_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_relative_url(&mut self) -> &mut ::std::string::String {
            if self.relative_url.is_none() {
                self.relative_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.relative_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_relative_url(&mut self) -> ::std::string::String {
            self.relative_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string local_path = 2;

        pub fn local_path(&self) -> &str {
            match self.local_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_local_path(&mut self) {
            self.local_path = ::std::option::Option::None;
        }

        pub fn has_local_path(&self) -> bool {
            self.local_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_local_path(&mut self, v: ::std::string::String) {
            self.local_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_local_path(&mut self) -> &mut ::std::string::String {
            if self.local_path.is_none() {
                self.local_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.local_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_local_path(&mut self) -> ::std::string::String {
            self.local_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string allowed_extensions = 3;

        pub fn allowed_extensions(&self) -> &str {
            match self.allowed_extensions.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_allowed_extensions(&mut self) {
            self.allowed_extensions = ::std::option::Option::None;
        }

        pub fn has_allowed_extensions(&self) -> bool {
            self.allowed_extensions.is_some()
        }

        // Param is passed by value, moved
        pub fn set_allowed_extensions(&mut self, v: ::std::string::String) {
            self.allowed_extensions = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_allowed_extensions(&mut self) -> &mut ::std::string::String {
            if self.allowed_extensions.is_none() {
                self.allowed_extensions = ::std::option::Option::Some(::std::string::String::new());
            }
            self.allowed_extensions.as_mut().unwrap()
        }

        // Take field
        pub fn take_allowed_extensions(&mut self) -> ::std::string::String {
            self.allowed_extensions.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool url_rewrite = 4;

        pub fn url_rewrite(&self) -> bool {
            self.url_rewrite.unwrap_or(false)
        }

        pub fn clear_url_rewrite(&mut self) {
            self.url_rewrite = ::std::option::Option::None;
        }

        pub fn has_url_rewrite(&self) -> bool {
            self.url_rewrite.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url_rewrite(&mut self, v: bool) {
            self.url_rewrite = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "relative_url",
                |m: &AdditionalRoute| { &m.relative_url },
                |m: &mut AdditionalRoute| { &mut m.relative_url },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "local_path",
                |m: &AdditionalRoute| { &m.local_path },
                |m: &mut AdditionalRoute| { &mut m.local_path },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "allowed_extensions",
                |m: &AdditionalRoute| { &m.allowed_extensions },
                |m: &mut AdditionalRoute| { &mut m.allowed_extensions },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "url_rewrite",
                |m: &AdditionalRoute| { &m.url_rewrite },
                |m: &mut AdditionalRoute| { &mut m.url_rewrite },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalRoute>(
                "CMsgSetLocalFileRequestMapping.AdditionalRoute",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for AdditionalRoute {
        const NAME: &'static str = "AdditionalRoute";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.relative_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.local_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.allowed_extensions = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.url_rewrite = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.relative_url.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.local_path.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.allowed_extensions.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.url_rewrite {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.relative_url.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.local_path.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.allowed_extensions.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.url_rewrite {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalRoute {
            AdditionalRoute::new()
        }

        fn clear(&mut self) {
            self.relative_url = ::std::option::Option::None;
            self.local_path = ::std::option::Option::None;
            self.allowed_extensions = ::std::option::Option::None;
            self.url_rewrite = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalRoute {
            static instance: AdditionalRoute = AdditionalRoute {
                relative_url: ::std::option::Option::None,
                local_path: ::std::option::Option::None,
                allowed_extensions: ::std::option::Option::None,
                url_rewrite: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for AdditionalRoute {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSetLocalFileRequestMapping.AdditionalRoute").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdditionalRoute {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for AdditionalRoute {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgBrowserErrorStrings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserErrorStrings {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.header)
    pub header: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.cache_miss)
    pub cache_miss: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.bad_url)
    pub bad_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.connection_problem)
    pub connection_problem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.proxy_problem)
    pub proxy_problem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.unknown)
    pub unknown: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserErrorStrings.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserErrorStrings {
    fn default() -> &'a CMsgBrowserErrorStrings {
        <CMsgBrowserErrorStrings as crate::Message>::default_instance()
    }
}

impl CMsgBrowserErrorStrings {
    pub fn new() -> CMsgBrowserErrorStrings {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string header = 3;

    pub fn header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_header(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::string::String) {
        self.header = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::string::String {
        if self.header.is_none() {
            self.header = ::std::option::Option::Some(::std::string::String::new());
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::string::String {
        self.header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cache_miss = 4;

    pub fn cache_miss(&self) -> &str {
        match self.cache_miss.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cache_miss(&mut self) {
        self.cache_miss = ::std::option::Option::None;
    }

    pub fn has_cache_miss(&self) -> bool {
        self.cache_miss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_miss(&mut self, v: ::std::string::String) {
        self.cache_miss = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cache_miss(&mut self) -> &mut ::std::string::String {
        if self.cache_miss.is_none() {
            self.cache_miss = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cache_miss.as_mut().unwrap()
    }

    // Take field
    pub fn take_cache_miss(&mut self) -> ::std::string::String {
        self.cache_miss.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bad_url = 5;

    pub fn bad_url(&self) -> &str {
        match self.bad_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bad_url(&mut self) {
        self.bad_url = ::std::option::Option::None;
    }

    pub fn has_bad_url(&self) -> bool {
        self.bad_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bad_url(&mut self, v: ::std::string::String) {
        self.bad_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bad_url(&mut self) -> &mut ::std::string::String {
        if self.bad_url.is_none() {
            self.bad_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bad_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_bad_url(&mut self) -> ::std::string::String {
        self.bad_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string connection_problem = 6;

    pub fn connection_problem(&self) -> &str {
        match self.connection_problem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connection_problem(&mut self) {
        self.connection_problem = ::std::option::Option::None;
    }

    pub fn has_connection_problem(&self) -> bool {
        self.connection_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_problem(&mut self, v: ::std::string::String) {
        self.connection_problem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_problem(&mut self) -> &mut ::std::string::String {
        if self.connection_problem.is_none() {
            self.connection_problem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connection_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_problem(&mut self) -> ::std::string::String {
        self.connection_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string proxy_problem = 7;

    pub fn proxy_problem(&self) -> &str {
        match self.proxy_problem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_proxy_problem(&mut self) {
        self.proxy_problem = ::std::option::Option::None;
    }

    pub fn has_proxy_problem(&self) -> bool {
        self.proxy_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_problem(&mut self, v: ::std::string::String) {
        self.proxy_problem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_problem(&mut self) -> &mut ::std::string::String {
        if self.proxy_problem.is_none() {
            self.proxy_problem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.proxy_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_problem(&mut self) -> ::std::string::String {
        self.proxy_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unknown = 8;

    pub fn unknown(&self) -> &str {
        match self.unknown.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unknown(&mut self) {
        self.unknown = ::std::option::Option::None;
    }

    pub fn has_unknown(&self) -> bool {
        self.unknown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown(&mut self, v: ::std::string::String) {
        self.unknown = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unknown(&mut self) -> &mut ::std::string::String {
        if self.unknown.is_none() {
            self.unknown = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unknown.as_mut().unwrap()
    }

    // Take field
    pub fn take_unknown(&mut self) -> ::std::string::String {
        self.unknown.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserErrorStrings| { &m.browser_handle },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgBrowserErrorStrings| { &m.title },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "header",
            |m: &CMsgBrowserErrorStrings| { &m.header },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.header },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_miss",
            |m: &CMsgBrowserErrorStrings| { &m.cache_miss },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.cache_miss },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bad_url",
            |m: &CMsgBrowserErrorStrings| { &m.bad_url },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.bad_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_problem",
            |m: &CMsgBrowserErrorStrings| { &m.connection_problem },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.connection_problem },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "proxy_problem",
            |m: &CMsgBrowserErrorStrings| { &m.proxy_problem },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.proxy_problem },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unknown",
            |m: &CMsgBrowserErrorStrings| { &m.unknown },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.unknown },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserErrorStrings>(
            "CMsgBrowserErrorStrings",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserErrorStrings {
    const NAME: &'static str = "CMsgBrowserErrorStrings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.header = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.cache_miss = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.bad_url = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.connection_problem = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.proxy_problem = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.unknown = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.header.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.cache_miss.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.bad_url.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.connection_problem.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.proxy_problem.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.unknown.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.header.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.cache_miss.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bad_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.connection_problem.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.proxy_problem.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.unknown.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserErrorStrings {
        CMsgBrowserErrorStrings::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.cache_miss = ::std::option::Option::None;
        self.bad_url = ::std::option::Option::None;
        self.connection_problem = ::std::option::Option::None;
        self.proxy_problem = ::std::option::Option::None;
        self.unknown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserErrorStrings {
        static instance: CMsgBrowserErrorStrings = CMsgBrowserErrorStrings {
            browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            header: ::std::option::Option::None,
            cache_miss: ::std::option::Option::None,
            bad_url: ::std::option::Option::None,
            connection_problem: ::std::option::Option::None,
            proxy_problem: ::std::option::Option::None,
            unknown: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserErrorStrings {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserErrorStrings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserErrorStrings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserErrorStrings {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserSetName)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSetName {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSetName.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSetName.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSetName.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSetName {
    fn default() -> &'a CMsgBrowserSetName {
        <CMsgBrowserSetName as crate::Message>::default_instance()
    }
}

impl CMsgBrowserSetName {
    pub fn new() -> CMsgBrowserSetName {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserSetName| { &m.browser_handle },
            |m: &mut CMsgBrowserSetName| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgBrowserSetName| { &m.name },
            |m: &mut CMsgBrowserSetName| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserSetName>(
            "CMsgBrowserSetName",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserSetName {
    const NAME: &'static str = "CMsgBrowserSetName";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSetName {
        CMsgBrowserSetName::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSetName {
        static instance: CMsgBrowserSetName = CMsgBrowserSetName {
            browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserSetName {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserSetName").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserSetName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserSetName {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSize.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserSize.height)
    pub height: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSize.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSize {
    fn default() -> &'a CMsgBrowserSize {
        <CMsgBrowserSize as crate::Message>::default_instance()
    }
}

impl CMsgBrowserSize {
    pub fn new() -> CMsgBrowserSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double width = 2;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 3;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserSize| { &m.browser_handle },
            |m: &mut CMsgBrowserSize| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgBrowserSize| { &m.width },
            |m: &mut CMsgBrowserSize| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgBrowserSize| { &m.height },
            |m: &mut CMsgBrowserSize| { &mut m.height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserSize>(
            "CMsgBrowserSize",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserSize {
    const NAME: &'static str = "CMsgBrowserSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSize {
        CMsgBrowserSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSize {
        static instance: CMsgBrowserSize = CMsgBrowserSize {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserSize {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserSize {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserSetMinSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSetMinSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.height)
    pub height: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSetMinSize.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSetMinSize {
    fn default() -> &'a CMsgBrowserSetMinSize {
        <CMsgBrowserSetMinSize as crate::Message>::default_instance()
    }
}

impl CMsgBrowserSetMinSize {
    pub fn new() -> CMsgBrowserSetMinSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double width = 2;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 3;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserSetMinSize| { &m.browser_handle },
            |m: &mut CMsgBrowserSetMinSize| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgBrowserSetMinSize| { &m.width },
            |m: &mut CMsgBrowserSetMinSize| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgBrowserSetMinSize| { &m.height },
            |m: &mut CMsgBrowserSetMinSize| { &mut m.height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserSetMinSize>(
            "CMsgBrowserSetMinSize",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserSetMinSize {
    const NAME: &'static str = "CMsgBrowserSetMinSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSetMinSize {
        CMsgBrowserSetMinSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSetMinSize {
        static instance: CMsgBrowserSetMinSize = CMsgBrowserSetMinSize {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserSetMinSize {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserSetMinSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserSetMinSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserSetMinSize {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.x_local)
    pub x_local: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.y_local)
    pub y_local: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserPosition.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserPosition {
    fn default() -> &'a CMsgBrowserPosition {
        <CMsgBrowserPosition as crate::Message>::default_instance()
    }
}

impl CMsgBrowserPosition {
    pub fn new() -> CMsgBrowserPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double x = 2;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 3;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double x_local = 4;

    pub fn x_local(&self) -> f64 {
        self.x_local.unwrap_or(0.)
    }

    pub fn clear_x_local(&mut self) {
        self.x_local = ::std::option::Option::None;
    }

    pub fn has_x_local(&self) -> bool {
        self.x_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_local(&mut self, v: f64) {
        self.x_local = ::std::option::Option::Some(v);
    }

    // optional double y_local = 5;

    pub fn y_local(&self) -> f64 {
        self.y_local.unwrap_or(0.)
    }

    pub fn clear_y_local(&mut self) {
        self.y_local = ::std::option::Option::None;
    }

    pub fn has_y_local(&self) -> bool {
        self.y_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_local(&mut self, v: f64) {
        self.y_local = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserPosition| { &m.browser_handle },
            |m: &mut CMsgBrowserPosition| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgBrowserPosition| { &m.x },
            |m: &mut CMsgBrowserPosition| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgBrowserPosition| { &m.y },
            |m: &mut CMsgBrowserPosition| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_local",
            |m: &CMsgBrowserPosition| { &m.x_local },
            |m: &mut CMsgBrowserPosition| { &mut m.x_local },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_local",
            |m: &CMsgBrowserPosition| { &m.y_local },
            |m: &mut CMsgBrowserPosition| { &mut m.y_local },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserPosition>(
            "CMsgBrowserPosition",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserPosition {
    const NAME: &'static str = "CMsgBrowserPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.x_local = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.y_local = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.x_local {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y_local {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.x_local {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.y_local {
            os.write_double(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserPosition {
        CMsgBrowserPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.x_local = ::std::option::Option::None;
        self.y_local = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserPosition {
        static instance: CMsgBrowserPosition = CMsgBrowserPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            x_local: ::std::option::Option::None,
            y_local: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserPosition {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserPosition {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserResized)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserResized {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserResized.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.dpi_horizontal)
    pub dpi_horizontal: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.dpi_vertical)
    pub dpi_vertical: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserResized.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserResized {
    fn default() -> &'a CMsgBrowserResized {
        <CMsgBrowserResized as crate::Message>::default_instance()
    }
}

impl CMsgBrowserResized {
    pub fn new() -> CMsgBrowserResized {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double x = 2;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 3;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double width = 4;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 5;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double dpi_horizontal = 6;

    pub fn dpi_horizontal(&self) -> f64 {
        self.dpi_horizontal.unwrap_or(0.)
    }

    pub fn clear_dpi_horizontal(&mut self) {
        self.dpi_horizontal = ::std::option::Option::None;
    }

    pub fn has_dpi_horizontal(&self) -> bool {
        self.dpi_horizontal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_horizontal(&mut self, v: f64) {
        self.dpi_horizontal = ::std::option::Option::Some(v);
    }

    // optional double dpi_vertical = 7;

    pub fn dpi_vertical(&self) -> f64 {
        self.dpi_vertical.unwrap_or(0.)
    }

    pub fn clear_dpi_vertical(&mut self) {
        self.dpi_vertical = ::std::option::Option::None;
    }

    pub fn has_dpi_vertical(&self) -> bool {
        self.dpi_vertical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_vertical(&mut self, v: f64) {
        self.dpi_vertical = ::std::option::Option::Some(v);
    }

    // optional string display_name = 8;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserResized| { &m.browser_handle },
            |m: &mut CMsgBrowserResized| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgBrowserResized| { &m.x },
            |m: &mut CMsgBrowserResized| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgBrowserResized| { &m.y },
            |m: &mut CMsgBrowserResized| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgBrowserResized| { &m.width },
            |m: &mut CMsgBrowserResized| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgBrowserResized| { &m.height },
            |m: &mut CMsgBrowserResized| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dpi_horizontal",
            |m: &CMsgBrowserResized| { &m.dpi_horizontal },
            |m: &mut CMsgBrowserResized| { &mut m.dpi_horizontal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dpi_vertical",
            |m: &CMsgBrowserResized| { &m.dpi_vertical },
            |m: &mut CMsgBrowserResized| { &mut m.dpi_vertical },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &CMsgBrowserResized| { &m.display_name },
            |m: &mut CMsgBrowserResized| { &mut m.display_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserResized>(
            "CMsgBrowserResized",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserResized {
    const NAME: &'static str = "CMsgBrowserResized";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.dpi_horizontal = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.dpi_vertical = ::std::option::Option::Some(is.read_double()?);
                },
                66 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.dpi_horizontal {
            my_size += 1 + 8;
        }
        if let Some(v) = self.dpi_vertical {
            my_size += 1 + 8;
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.dpi_horizontal {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.dpi_vertical {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserResized {
        CMsgBrowserResized::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.dpi_horizontal = ::std::option::Option::None;
        self.dpi_vertical = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserResized {
        static instance: CMsgBrowserResized = CMsgBrowserResized {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            dpi_horizontal: ::std::option::Option::None,
            dpi_vertical: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserResized {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserResized").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserResized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserResized {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPostURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPostURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgPostURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPostURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPostURL.post)
    pub post: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPostURL.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPostURL.replace_entry)
    pub replace_entry: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPostURL.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPostURL {
    fn default() -> &'a CMsgPostURL {
        <CMsgPostURL as crate::Message>::default_instance()
    }
}

impl CMsgPostURL {
    pub fn new() -> CMsgPostURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string post = 3;

    pub fn post(&self) -> &str {
        match self.post.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_post(&mut self) {
        self.post = ::std::option::Option::None;
    }

    pub fn has_post(&self) -> bool {
        self.post.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post(&mut self, v: ::std::string::String) {
        self.post = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post(&mut self) -> &mut ::std::string::String {
        if self.post.is_none() {
            self.post = ::std::option::Option::Some(::std::string::String::new());
        }
        self.post.as_mut().unwrap()
    }

    // Take field
    pub fn take_post(&mut self) -> ::std::string::String {
        self.post.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 pageserial = 4;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    // optional bool replace_entry = 5;

    pub fn replace_entry(&self) -> bool {
        self.replace_entry.unwrap_or(false)
    }

    pub fn clear_replace_entry(&mut self) {
        self.replace_entry = ::std::option::Option::None;
    }

    pub fn has_replace_entry(&self) -> bool {
        self.replace_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replace_entry(&mut self, v: bool) {
        self.replace_entry = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPostURL| { &m.browser_handle },
            |m: &mut CMsgPostURL| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgPostURL| { &m.url },
            |m: &mut CMsgPostURL| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "post",
            |m: &CMsgPostURL| { &m.post },
            |m: &mut CMsgPostURL| { &mut m.post },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgPostURL| { &m.pageserial },
            |m: &mut CMsgPostURL| { &mut m.pageserial },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "replace_entry",
            |m: &CMsgPostURL| { &m.replace_entry },
            |m: &mut CMsgPostURL| { &mut m.replace_entry },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPostURL>(
            "CMsgPostURL",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPostURL {
    const NAME: &'static str = "CMsgPostURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.post = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.replace_entry = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.post.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.pageserial {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.replace_entry {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.post.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.replace_entry {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPostURL {
        CMsgPostURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.post = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.replace_entry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPostURL {
        static instance: CMsgPostURL = CMsgPostURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            post: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            replace_entry: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPostURL {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPostURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPostURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPostURL {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAddHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddHeader.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAddHeader.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgAddHeader.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddHeader.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddHeader {
    fn default() -> &'a CMsgAddHeader {
        <CMsgAddHeader as crate::Message>::default_instance()
    }
}

impl CMsgAddHeader {
    pub fn new() -> CMsgAddHeader {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgAddHeader| { &m.browser_handle },
            |m: &mut CMsgAddHeader| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CMsgAddHeader| { &m.key },
            |m: &mut CMsgAddHeader| { &mut m.key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgAddHeader| { &m.value },
            |m: &mut CMsgAddHeader| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAddHeader>(
            "CMsgAddHeader",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAddHeader {
    const NAME: &'static str = "CMsgAddHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.key.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddHeader {
        CMsgAddHeader::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddHeader {
        static instance: CMsgAddHeader = CMsgAddHeader {
            browser_handle: ::std::option::Option::None,
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAddHeader {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAddHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAddHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAddHeader {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStopLoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopLoad {
    // message fields
    // @@protoc_insertion_point(field:CMsgStopLoad.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStopLoad.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopLoad {
    fn default() -> &'a CMsgStopLoad {
        <CMsgStopLoad as crate::Message>::default_instance()
    }
}

impl CMsgStopLoad {
    pub fn new() -> CMsgStopLoad {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStopLoad| { &m.browser_handle },
            |m: &mut CMsgStopLoad| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStopLoad>(
            "CMsgStopLoad",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgStopLoad {
    const NAME: &'static str = "CMsgStopLoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopLoad {
        CMsgStopLoad::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopLoad {
        static instance: CMsgStopLoad = CMsgStopLoad {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgStopLoad {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStopLoad").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStopLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgStopLoad {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgReload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReload {
    // message fields
    // @@protoc_insertion_point(field:CMsgReload.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReload.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReload {
    fn default() -> &'a CMsgReload {
        <CMsgReload as crate::Message>::default_instance()
    }
}

impl CMsgReload {
    pub fn new() -> CMsgReload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgReload| { &m.browser_handle },
            |m: &mut CMsgReload| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReload>(
            "CMsgReload",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgReload {
    const NAME: &'static str = "CMsgReload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReload {
        CMsgReload::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReload {
        static instance: CMsgReload = CMsgReload {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgReload {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgReload {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGoForward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGoForward {
    // message fields
    // @@protoc_insertion_point(field:CMsgGoForward.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGoForward.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGoForward {
    fn default() -> &'a CMsgGoForward {
        <CMsgGoForward as crate::Message>::default_instance()
    }
}

impl CMsgGoForward {
    pub fn new() -> CMsgGoForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGoForward| { &m.browser_handle },
            |m: &mut CMsgGoForward| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGoForward>(
            "CMsgGoForward",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGoForward {
    const NAME: &'static str = "CMsgGoForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGoForward {
        CMsgGoForward::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGoForward {
        static instance: CMsgGoForward = CMsgGoForward {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGoForward {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGoForward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGoForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGoForward {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGoBack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGoBack {
    // message fields
    // @@protoc_insertion_point(field:CMsgGoBack.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGoBack.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGoBack {
    fn default() -> &'a CMsgGoBack {
        <CMsgGoBack as crate::Message>::default_instance()
    }
}

impl CMsgGoBack {
    pub fn new() -> CMsgGoBack {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGoBack| { &m.browser_handle },
            |m: &mut CMsgGoBack| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGoBack>(
            "CMsgGoBack",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGoBack {
    const NAME: &'static str = "CMsgGoBack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGoBack {
        CMsgGoBack::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGoBack {
        static instance: CMsgGoBack = CMsgGoBack {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGoBack {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGoBack").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGoBack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGoBack {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgWasHidden)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgWasHidden {
    // message fields
    // @@protoc_insertion_point(field:CMsgWasHidden.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgWasHidden.hidden)
    pub hidden: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgWasHidden.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgWasHidden {
    fn default() -> &'a CMsgWasHidden {
        <CMsgWasHidden as crate::Message>::default_instance()
    }
}

impl CMsgWasHidden {
    pub fn new() -> CMsgWasHidden {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 2;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgWasHidden| { &m.browser_handle },
            |m: &mut CMsgWasHidden| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &CMsgWasHidden| { &m.hidden },
            |m: &mut CMsgWasHidden| { &mut m.hidden },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgWasHidden>(
            "CMsgWasHidden",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgWasHidden {
    const NAME: &'static str = "CMsgWasHidden";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgWasHidden {
        CMsgWasHidden::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgWasHidden {
        static instance: CMsgWasHidden = CMsgWasHidden {
            browser_handle: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgWasHidden {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgWasHidden").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgWasHidden {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgWasHidden {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetWindowVisibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetWindowVisibility {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetWindowVisibility.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetWindowVisibility.visible)
    pub visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetWindowVisibility.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetWindowVisibility {
    fn default() -> &'a CMsgSetWindowVisibility {
        <CMsgSetWindowVisibility as crate::Message>::default_instance()
    }
}

impl CMsgSetWindowVisibility {
    pub fn new() -> CMsgSetWindowVisibility {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool visible = 2;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetWindowVisibility| { &m.browser_handle },
            |m: &mut CMsgSetWindowVisibility| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &CMsgSetWindowVisibility| { &m.visible },
            |m: &mut CMsgSetWindowVisibility| { &mut m.visible },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetWindowVisibility>(
            "CMsgSetWindowVisibility",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetWindowVisibility {
    const NAME: &'static str = "CMsgSetWindowVisibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetWindowVisibility {
        CMsgSetWindowVisibility::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetWindowVisibility {
        static instance: CMsgSetWindowVisibility = CMsgSetWindowVisibility {
            browser_handle: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetWindowVisibility {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetWindowVisibility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetWindowVisibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetWindowVisibility {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearHistory.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearHistory.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearHistory {
    fn default() -> &'a CMsgClearHistory {
        <CMsgClearHistory as crate::Message>::default_instance()
    }
}

impl CMsgClearHistory {
    pub fn new() -> CMsgClearHistory {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClearHistory| { &m.browser_handle },
            |m: &mut CMsgClearHistory| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearHistory>(
            "CMsgClearHistory",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClearHistory {
    const NAME: &'static str = "CMsgClearHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearHistory {
        CMsgClearHistory::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearHistory {
        static instance: CMsgClearHistory = CMsgClearHistory {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClearHistory {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClearHistory {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearAllBrowsingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearAllBrowsingData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearAllBrowsingData.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearAllBrowsingData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllBrowsingData {
    fn default() -> &'a CMsgClearAllBrowsingData {
        <CMsgClearAllBrowsingData as crate::Message>::default_instance()
    }
}

impl CMsgClearAllBrowsingData {
    pub fn new() -> CMsgClearAllBrowsingData {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClearAllBrowsingData| { &m.browser_handle },
            |m: &mut CMsgClearAllBrowsingData| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearAllBrowsingData>(
            "CMsgClearAllBrowsingData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClearAllBrowsingData {
    const NAME: &'static str = "CMsgClearAllBrowsingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearAllBrowsingData {
        CMsgClearAllBrowsingData::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearAllBrowsingData {
        static instance: CMsgClearAllBrowsingData = CMsgClearAllBrowsingData {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClearAllBrowsingData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearAllBrowsingData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearAllBrowsingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClearAllBrowsingData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCopy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCopy {
    // message fields
    // @@protoc_insertion_point(field:CMsgCopy.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCopy.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCopy {
    fn default() -> &'a CMsgCopy {
        <CMsgCopy as crate::Message>::default_instance()
    }
}

impl CMsgCopy {
    pub fn new() -> CMsgCopy {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgCopy| { &m.browser_handle },
            |m: &mut CMsgCopy| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCopy>(
            "CMsgCopy",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCopy {
    const NAME: &'static str = "CMsgCopy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCopy {
        CMsgCopy::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCopy {
        static instance: CMsgCopy = CMsgCopy {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCopy {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCopy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCopy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCopy {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaste)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaste {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaste.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaste.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaste {
    fn default() -> &'a CMsgPaste {
        <CMsgPaste as crate::Message>::default_instance()
    }
}

impl CMsgPaste {
    pub fn new() -> CMsgPaste {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPaste| { &m.browser_handle },
            |m: &mut CMsgPaste| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaste>(
            "CMsgPaste",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPaste {
    const NAME: &'static str = "CMsgPaste";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaste {
        CMsgPaste::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaste {
        static instance: CMsgPaste = CMsgPaste {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPaste {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaste").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaste {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPaste {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgExecuteJavaScript)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExecuteJavaScript {
    // message fields
    // @@protoc_insertion_point(field:CMsgExecuteJavaScript.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgExecuteJavaScript.script)
    pub script: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExecuteJavaScript.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExecuteJavaScript {
    fn default() -> &'a CMsgExecuteJavaScript {
        <CMsgExecuteJavaScript as crate::Message>::default_instance()
    }
}

impl CMsgExecuteJavaScript {
    pub fn new() -> CMsgExecuteJavaScript {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string script = 2;

    pub fn script(&self) -> &str {
        match self.script.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_script(&mut self) {
        self.script = ::std::option::Option::None;
    }

    pub fn has_script(&self) -> bool {
        self.script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::string::String) {
        self.script = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::string::String {
        if self.script.is_none() {
            self.script = ::std::option::Option::Some(::std::string::String::new());
        }
        self.script.as_mut().unwrap()
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::string::String {
        self.script.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgExecuteJavaScript| { &m.browser_handle },
            |m: &mut CMsgExecuteJavaScript| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "script",
            |m: &CMsgExecuteJavaScript| { &m.script },
            |m: &mut CMsgExecuteJavaScript| { &mut m.script },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgExecuteJavaScript>(
            "CMsgExecuteJavaScript",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgExecuteJavaScript {
    const NAME: &'static str = "CMsgExecuteJavaScript";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.script = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.script.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.script.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExecuteJavaScript {
        CMsgExecuteJavaScript::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.script = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExecuteJavaScript {
        static instance: CMsgExecuteJavaScript = CMsgExecuteJavaScript {
            browser_handle: ::std::option::Option::None,
            script: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgExecuteJavaScript {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgExecuteJavaScript").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgExecuteJavaScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgExecuteJavaScript {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetFocus {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetFocus.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetFocus.focus)
    pub focus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetFocus.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetFocus {
    fn default() -> &'a CMsgSetFocus {
        <CMsgSetFocus as crate::Message>::default_instance()
    }
}

impl CMsgSetFocus {
    pub fn new() -> CMsgSetFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool focus = 2;

    pub fn focus(&self) -> bool {
        self.focus.unwrap_or(false)
    }

    pub fn clear_focus(&mut self) {
        self.focus = ::std::option::Option::None;
    }

    pub fn has_focus(&self) -> bool {
        self.focus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus(&mut self, v: bool) {
        self.focus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetFocus| { &m.browser_handle },
            |m: &mut CMsgSetFocus| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "focus",
            |m: &CMsgSetFocus| { &m.focus },
            |m: &mut CMsgSetFocus| { &mut m.focus },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetFocus>(
            "CMsgSetFocus",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetFocus {
    const NAME: &'static str = "CMsgSetFocus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.focus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.focus {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.focus {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetFocus {
        CMsgSetFocus::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.focus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetFocus {
        static instance: CMsgSetFocus = CMsgSetFocus {
            browser_handle: ::std::option::Option::None,
            focus: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetFocus {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetFocus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetFocus {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHorizontalScrollBarSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHorizontalScrollBarSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHorizontalScrollBarSize.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSize {
    fn default() -> &'a CMsgHorizontalScrollBarSize {
        <CMsgHorizontalScrollBarSize as crate::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSize {
    pub fn new() -> CMsgHorizontalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHorizontalScrollBarSize| { &m.browser_handle },
            |m: &mut CMsgHorizontalScrollBarSize| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHorizontalScrollBarSize>(
            "CMsgHorizontalScrollBarSize",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHorizontalScrollBarSize {
    const NAME: &'static str = "CMsgHorizontalScrollBarSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHorizontalScrollBarSize {
        CMsgHorizontalScrollBarSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSize {
        static instance: CMsgHorizontalScrollBarSize = CMsgHorizontalScrollBarSize {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHorizontalScrollBarSize {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHorizontalScrollBarSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHorizontalScrollBarSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHorizontalScrollBarSize {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHorizontalScrollBarSizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHorizontalScrollBarSizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.scroll_max)
    pub scroll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.scroll)
    pub scroll: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.page_size)
    pub page_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHorizontalScrollBarSizeResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSizeResponse {
    fn default() -> &'a CMsgHorizontalScrollBarSizeResponse {
        <CMsgHorizontalScrollBarSizeResponse as crate::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSizeResponse {
    pub fn new() -> CMsgHorizontalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;

    pub fn scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }

    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;

    pub fn page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }

    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.browser_handle },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll_max",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.scroll_max },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.scroll_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.scroll },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.scroll },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.zoom },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.zoom },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.visible },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.visible },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.page_size },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.page_size },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHorizontalScrollBarSizeResponse>(
            "CMsgHorizontalScrollBarSizeResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHorizontalScrollBarSizeResponse {
    const NAME: &'static str = "CMsgHorizontalScrollBarSizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scroll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll_max {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.scroll {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.page_size {
            my_size += crate::rt::uint32_size(10, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHorizontalScrollBarSizeResponse {
        CMsgHorizontalScrollBarSizeResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSizeResponse {
        static instance: CMsgHorizontalScrollBarSizeResponse = CMsgHorizontalScrollBarSizeResponse {
            browser_handle: ::std::option::Option::None,
            scroll_max: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHorizontalScrollBarSizeResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHorizontalScrollBarSizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHorizontalScrollBarSizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHorizontalScrollBarSizeResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVerticalScrollBarSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVerticalScrollBarSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVerticalScrollBarSize.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSize {
    fn default() -> &'a CMsgVerticalScrollBarSize {
        <CMsgVerticalScrollBarSize as crate::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSize {
    pub fn new() -> CMsgVerticalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgVerticalScrollBarSize| { &m.browser_handle },
            |m: &mut CMsgVerticalScrollBarSize| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVerticalScrollBarSize>(
            "CMsgVerticalScrollBarSize",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgVerticalScrollBarSize {
    const NAME: &'static str = "CMsgVerticalScrollBarSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVerticalScrollBarSize {
        CMsgVerticalScrollBarSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSize {
        static instance: CMsgVerticalScrollBarSize = CMsgVerticalScrollBarSize {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgVerticalScrollBarSize {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVerticalScrollBarSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVerticalScrollBarSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgVerticalScrollBarSize {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVerticalScrollBarSizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVerticalScrollBarSizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.scroll_max)
    pub scroll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.scroll)
    pub scroll: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.page_size)
    pub page_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVerticalScrollBarSizeResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSizeResponse {
    fn default() -> &'a CMsgVerticalScrollBarSizeResponse {
        <CMsgVerticalScrollBarSizeResponse as crate::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSizeResponse {
    pub fn new() -> CMsgVerticalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;

    pub fn scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }

    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;

    pub fn page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }

    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.browser_handle },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll_max",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.scroll_max },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.scroll_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.scroll },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.scroll },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.zoom },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.zoom },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.visible },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.visible },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.page_size },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.page_size },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVerticalScrollBarSizeResponse>(
            "CMsgVerticalScrollBarSizeResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgVerticalScrollBarSizeResponse {
    const NAME: &'static str = "CMsgVerticalScrollBarSizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scroll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll_max {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.scroll {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.page_size {
            my_size += crate::rt::uint32_size(10, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVerticalScrollBarSizeResponse {
        CMsgVerticalScrollBarSizeResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSizeResponse {
        static instance: CMsgVerticalScrollBarSizeResponse = CMsgVerticalScrollBarSizeResponse {
            browser_handle: ::std::option::Option::None,
            scroll_max: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgVerticalScrollBarSizeResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVerticalScrollBarSizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVerticalScrollBarSizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgVerticalScrollBarSizeResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFind {
    // message fields
    // @@protoc_insertion_point(field:CMsgFind.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFind.find)
    pub find: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFind.infind)
    pub infind: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFind.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFind.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFind {
    fn default() -> &'a CMsgFind {
        <CMsgFind as crate::Message>::default_instance()
    }
}

impl CMsgFind {
    pub fn new() -> CMsgFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string find = 2;

    pub fn find(&self) -> &str {
        match self.find.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_find(&mut self) {
        self.find = ::std::option::Option::None;
    }

    pub fn has_find(&self) -> bool {
        self.find.is_some()
    }

    // Param is passed by value, moved
    pub fn set_find(&mut self, v: ::std::string::String) {
        self.find = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_find(&mut self) -> &mut ::std::string::String {
        if self.find.is_none() {
            self.find = ::std::option::Option::Some(::std::string::String::new());
        }
        self.find.as_mut().unwrap()
    }

    // Take field
    pub fn take_find(&mut self) -> ::std::string::String {
        self.find.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool infind = 3;

    pub fn infind(&self) -> bool {
        self.infind.unwrap_or(false)
    }

    pub fn clear_infind(&mut self) {
        self.infind = ::std::option::Option::None;
    }

    pub fn has_infind(&self) -> bool {
        self.infind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infind(&mut self, v: bool) {
        self.infind = ::std::option::Option::Some(v);
    }

    // optional bool reverse = 4;

    pub fn reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }

    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::Option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFind| { &m.browser_handle },
            |m: &mut CMsgFind| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "find",
            |m: &CMsgFind| { &m.find },
            |m: &mut CMsgFind| { &mut m.find },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "infind",
            |m: &CMsgFind| { &m.infind },
            |m: &mut CMsgFind| { &mut m.infind },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &CMsgFind| { &m.reverse },
            |m: &mut CMsgFind| { &mut m.reverse },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFind>(
            "CMsgFind",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFind {
    const NAME: &'static str = "CMsgFind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.find = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.infind = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.find.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.infind {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.find.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.infind {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFind {
        CMsgFind::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.find = ::std::option::Option::None;
        self.infind = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFind {
        static instance: CMsgFind = CMsgFind {
            browser_handle: ::std::option::Option::None,
            find: ::std::option::Option::None,
            infind: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFind {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFind {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStopFind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopFind {
    // message fields
    // @@protoc_insertion_point(field:CMsgStopFind.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStopFind.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopFind {
    fn default() -> &'a CMsgStopFind {
        <CMsgStopFind as crate::Message>::default_instance()
    }
}

impl CMsgStopFind {
    pub fn new() -> CMsgStopFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStopFind| { &m.browser_handle },
            |m: &mut CMsgStopFind| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStopFind>(
            "CMsgStopFind",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgStopFind {
    const NAME: &'static str = "CMsgStopFind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopFind {
        CMsgStopFind::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopFind {
        static instance: CMsgStopFind = CMsgStopFind {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgStopFind {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStopFind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStopFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgStopFind {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetHorizontalScroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetHorizontalScroll {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHorizontalScroll.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetHorizontalScroll.scroll)
    pub scroll: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHorizontalScroll.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHorizontalScroll {
    fn default() -> &'a CMsgSetHorizontalScroll {
        <CMsgSetHorizontalScroll as crate::Message>::default_instance()
    }
}

impl CMsgSetHorizontalScroll {
    pub fn new() -> CMsgSetHorizontalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetHorizontalScroll| { &m.browser_handle },
            |m: &mut CMsgSetHorizontalScroll| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgSetHorizontalScroll| { &m.scroll },
            |m: &mut CMsgSetHorizontalScroll| { &mut m.scroll },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetHorizontalScroll>(
            "CMsgSetHorizontalScroll",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetHorizontalScroll {
    const NAME: &'static str = "CMsgSetHorizontalScroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHorizontalScroll {
        CMsgSetHorizontalScroll::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHorizontalScroll {
        static instance: CMsgSetHorizontalScroll = CMsgSetHorizontalScroll {
            browser_handle: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetHorizontalScroll {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetHorizontalScroll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetHorizontalScroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetHorizontalScroll {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetVerticalScroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetVerticalScroll {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetVerticalScroll.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetVerticalScroll.scroll)
    pub scroll: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetVerticalScroll.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetVerticalScroll {
    fn default() -> &'a CMsgSetVerticalScroll {
        <CMsgSetVerticalScroll as crate::Message>::default_instance()
    }
}

impl CMsgSetVerticalScroll {
    pub fn new() -> CMsgSetVerticalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetVerticalScroll| { &m.browser_handle },
            |m: &mut CMsgSetVerticalScroll| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgSetVerticalScroll| { &m.scroll },
            |m: &mut CMsgSetVerticalScroll| { &mut m.scroll },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetVerticalScroll>(
            "CMsgSetVerticalScroll",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetVerticalScroll {
    const NAME: &'static str = "CMsgSetVerticalScroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetVerticalScroll {
        CMsgSetVerticalScroll::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetVerticalScroll {
        static instance: CMsgSetVerticalScroll = CMsgSetVerticalScroll {
            browser_handle: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetVerticalScroll {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetVerticalScroll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetVerticalScroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetVerticalScroll {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetZoomLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetZoomLevel {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetZoomLevel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetZoomLevel.zoom)
    pub zoom: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetZoomLevel.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetZoomLevel {
    fn default() -> &'a CMsgSetZoomLevel {
        <CMsgSetZoomLevel as crate::Message>::default_instance()
    }
}

impl CMsgSetZoomLevel {
    pub fn new() -> CMsgSetZoomLevel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double zoom = 2;

    pub fn zoom(&self) -> f64 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f64) {
        self.zoom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetZoomLevel| { &m.browser_handle },
            |m: &mut CMsgSetZoomLevel| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgSetZoomLevel| { &m.zoom },
            |m: &mut CMsgSetZoomLevel| { &mut m.zoom },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetZoomLevel>(
            "CMsgSetZoomLevel",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetZoomLevel {
    const NAME: &'static str = "CMsgSetZoomLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.zoom = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetZoomLevel {
        CMsgSetZoomLevel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetZoomLevel {
        static instance: CMsgSetZoomLevel = CMsgSetZoomLevel {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetZoomLevel {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetZoomLevel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetZoomLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetZoomLevel {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgViewSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgViewSource {
    // message fields
    // @@protoc_insertion_point(field:CMsgViewSource.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgViewSource.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgViewSource {
    fn default() -> &'a CMsgViewSource {
        <CMsgViewSource as crate::Message>::default_instance()
    }
}

impl CMsgViewSource {
    pub fn new() -> CMsgViewSource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgViewSource| { &m.browser_handle },
            |m: &mut CMsgViewSource| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgViewSource>(
            "CMsgViewSource",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgViewSource {
    const NAME: &'static str = "CMsgViewSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgViewSource {
        CMsgViewSource::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgViewSource {
        static instance: CMsgViewSource = CMsgViewSource {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgViewSource {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgViewSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgViewSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgViewSource {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserReady)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserReady {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserReady.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserReady.vr_overlay_key)
    pub vr_overlay_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserReady.hwnd_browser)
    pub hwnd_browser: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserReady.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserReady {
    fn default() -> &'a CMsgBrowserReady {
        <CMsgBrowserReady as crate::Message>::default_instance()
    }
}

impl CMsgBrowserReady {
    pub fn new() -> CMsgBrowserReady {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string vr_overlay_key = 2;

    pub fn vr_overlay_key(&self) -> &str {
        match self.vr_overlay_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vr_overlay_key(&mut self) {
        self.vr_overlay_key = ::std::option::Option::None;
    }

    pub fn has_vr_overlay_key(&self) -> bool {
        self.vr_overlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_overlay_key(&mut self, v: ::std::string::String) {
        self.vr_overlay_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_overlay_key(&mut self) -> &mut ::std::string::String {
        if self.vr_overlay_key.is_none() {
            self.vr_overlay_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vr_overlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_overlay_key(&mut self) -> ::std::string::String {
        self.vr_overlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_browser = 3;

    pub fn hwnd_browser(&self) -> u64 {
        self.hwnd_browser.unwrap_or(0)
    }

    pub fn clear_hwnd_browser(&mut self) {
        self.hwnd_browser = ::std::option::Option::None;
    }

    pub fn has_hwnd_browser(&self) -> bool {
        self.hwnd_browser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_browser(&mut self, v: u64) {
        self.hwnd_browser = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserReady| { &m.browser_handle },
            |m: &mut CMsgBrowserReady| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_overlay_key",
            |m: &CMsgBrowserReady| { &m.vr_overlay_key },
            |m: &mut CMsgBrowserReady| { &mut m.vr_overlay_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hwnd_browser",
            |m: &CMsgBrowserReady| { &m.hwnd_browser },
            |m: &mut CMsgBrowserReady| { &mut m.hwnd_browser },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserReady>(
            "CMsgBrowserReady",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserReady {
    const NAME: &'static str = "CMsgBrowserReady";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.vr_overlay_key = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.hwnd_browser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.vr_overlay_key.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.hwnd_browser {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vr_overlay_key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.hwnd_browser {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserReady {
        CMsgBrowserReady::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.vr_overlay_key = ::std::option::Option::None;
        self.hwnd_browser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserReady {
        static instance: CMsgBrowserReady = CMsgBrowserReady {
            browser_handle: ::std::option::Option::None,
            vr_overlay_key: ::std::option::Option::None,
            hwnd_browser: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserReady {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserReady").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserReady {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserReady {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgURLChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgURLChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgURLChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgURLChanged.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.postData)
    pub postData: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.bIsRedirect)
    pub bIsRedirect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgURLChanged.pagetitle)
    pub pagetitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.bNewNavigation)
    pub bNewNavigation: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgURLChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgURLChanged {
    fn default() -> &'a CMsgURLChanged {
        <CMsgURLChanged as crate::Message>::default_instance()
    }
}

impl CMsgURLChanged {
    pub fn new() -> CMsgURLChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 3;

    pub fn postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postData(&mut self) {
        self.postData = ::std::option::Option::None;
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 4;

    pub fn bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }

    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }

    // optional string pagetitle = 5;

    pub fn pagetitle(&self) -> &str {
        match self.pagetitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pagetitle(&mut self) {
        self.pagetitle = ::std::option::Option::None;
    }

    pub fn has_pagetitle(&self) -> bool {
        self.pagetitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagetitle(&mut self, v: ::std::string::String) {
        self.pagetitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagetitle(&mut self) -> &mut ::std::string::String {
        if self.pagetitle.is_none() {
            self.pagetitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pagetitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagetitle(&mut self) -> ::std::string::String {
        self.pagetitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bNewNavigation = 6;

    pub fn bNewNavigation(&self) -> bool {
        self.bNewNavigation.unwrap_or(false)
    }

    pub fn clear_bNewNavigation(&mut self) {
        self.bNewNavigation = ::std::option::Option::None;
    }

    pub fn has_bNewNavigation(&self) -> bool {
        self.bNewNavigation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bNewNavigation(&mut self, v: bool) {
        self.bNewNavigation = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgURLChanged| { &m.browser_handle },
            |m: &mut CMsgURLChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgURLChanged| { &m.url },
            |m: &mut CMsgURLChanged| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "postData",
            |m: &CMsgURLChanged| { &m.postData },
            |m: &mut CMsgURLChanged| { &mut m.postData },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsRedirect",
            |m: &CMsgURLChanged| { &m.bIsRedirect },
            |m: &mut CMsgURLChanged| { &mut m.bIsRedirect },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagetitle",
            |m: &CMsgURLChanged| { &m.pagetitle },
            |m: &mut CMsgURLChanged| { &mut m.pagetitle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bNewNavigation",
            |m: &CMsgURLChanged| { &m.bNewNavigation },
            |m: &mut CMsgURLChanged| { &mut m.bNewNavigation },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgURLChanged>(
            "CMsgURLChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgURLChanged {
    const NAME: &'static str = "CMsgURLChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.postData = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.bIsRedirect = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.pagetitle = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.bNewNavigation = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.postData.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pagetitle.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.bNewNavigation {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.postData.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.pagetitle.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bNewNavigation {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgURLChanged {
        CMsgURLChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.postData = ::std::option::Option::None;
        self.bIsRedirect = ::std::option::Option::None;
        self.pagetitle = ::std::option::Option::None;
        self.bNewNavigation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgURLChanged {
        static instance: CMsgURLChanged = CMsgURLChanged {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            postData: ::std::option::Option::None,
            bIsRedirect: ::std::option::Option::None,
            pagetitle: ::std::option::Option::None,
            bNewNavigation: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgURLChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgURLChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgURLChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgURLChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHistoryEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHistoryEntry {
    // message fields
    // @@protoc_insertion_point(field:CHistoryEntry.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CHistoryEntry.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHistoryEntry {
    fn default() -> &'a CHistoryEntry {
        <CHistoryEntry as crate::Message>::default_instance()
    }
}

impl CHistoryEntry {
    pub fn new() -> CHistoryEntry {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CHistoryEntry| { &m.url },
            |m: &mut CHistoryEntry| { &mut m.url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHistoryEntry>(
            "CHistoryEntry",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHistoryEntry {
    const NAME: &'static str = "CHistoryEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHistoryEntry {
        CHistoryEntry::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHistoryEntry {
        static instance: CHistoryEntry = CHistoryEntry {
            url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHistoryEntry {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHistoryEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHistoryEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHistoryEntry {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHistoryChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHistoryChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgHistoryChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHistoryChanged.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHistoryChanged.entries)
    pub entries: ::std::vec::Vec<CHistoryEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHistoryChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHistoryChanged {
    fn default() -> &'a CMsgHistoryChanged {
        <CMsgHistoryChanged as crate::Message>::default_instance()
    }
}

impl CMsgHistoryChanged {
    pub fn new() -> CMsgHistoryChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 index = 2;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // repeated .CHistoryEntry entries = 3;

    pub fn entries(&self) -> &[CHistoryEntry] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<CHistoryEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<CHistoryEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<CHistoryEntry> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHistoryChanged| { &m.browser_handle },
            |m: &mut CMsgHistoryChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CMsgHistoryChanged| { &m.index },
            |m: &mut CMsgHistoryChanged| { &mut m.index },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgHistoryChanged| { &m.entries },
            |m: &mut CMsgHistoryChanged| { &mut m.entries },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHistoryChanged>(
            "CMsgHistoryChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHistoryChanged {
    const NAME: &'static str = "CMsgHistoryChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += crate::rt::uint32_size(2, v);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(2, v)?;
        }
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHistoryChanged {
        CMsgHistoryChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHistoryChanged {
        static instance: CMsgHistoryChanged = CMsgHistoryChanged {
            browser_handle: ::std::option::Option::None,
            index: ::std::option::Option::None,
            entries: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHistoryChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHistoryChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHistoryChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHistoryChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLoadError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadError {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadError.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadError.error_code)
    pub error_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgLoadError.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadError.error_description)
    pub error_description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadError.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadError {
    fn default() -> &'a CMsgLoadError {
        <CMsgLoadError as crate::Message>::default_instance()
    }
}

impl CMsgLoadError {
    pub fn new() -> CMsgLoadError {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 error_code = 2;

    pub fn error_code(&self) -> i32 {
        self.error_code.unwrap_or(0)
    }

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: i32) {
        self.error_code = ::std::option::Option::Some(v);
    }

    // optional string url = 3;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_description = 4;

    pub fn error_description(&self) -> &str {
        match self.error_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_description(&mut self) {
        self.error_description = ::std::option::Option::None;
    }

    pub fn has_error_description(&self) -> bool {
        self.error_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_description(&mut self, v: ::std::string::String) {
        self.error_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_description(&mut self) -> &mut ::std::string::String {
        if self.error_description.is_none() {
            self.error_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_description(&mut self) -> ::std::string::String {
        self.error_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLoadError| { &m.browser_handle },
            |m: &mut CMsgLoadError| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_code",
            |m: &CMsgLoadError| { &m.error_code },
            |m: &mut CMsgLoadError| { &mut m.error_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgLoadError| { &m.url },
            |m: &mut CMsgLoadError| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_description",
            |m: &CMsgLoadError| { &m.error_description },
            |m: &mut CMsgLoadError| { &mut m.error_description },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLoadError>(
            "CMsgLoadError",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgLoadError {
    const NAME: &'static str = "CMsgLoadError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.error_code = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.error_description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.error_code {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.error_description.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.error_description.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadError {
        CMsgLoadError::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.error_code = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.error_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadError {
        static instance: CMsgLoadError = CMsgLoadError {
            browser_handle: ::std::option::Option::None,
            error_code: ::std::option::Option::None,
            url: ::std::option::Option::None,
            error_description: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgLoadError {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLoadError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLoadError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgLoadError {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHTMLHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHTMLHeader {
    // message fields
    // @@protoc_insertion_point(field:CHTMLHeader.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLHeader.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CHTMLHeader.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHTMLHeader {
    fn default() -> &'a CHTMLHeader {
        <CHTMLHeader as crate::Message>::default_instance()
    }
}

impl CHTMLHeader {
    pub fn new() -> CHTMLHeader {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CHTMLHeader| { &m.key },
            |m: &mut CHTMLHeader| { &mut m.key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CHTMLHeader| { &m.value },
            |m: &mut CHTMLHeader| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHTMLHeader>(
            "CHTMLHeader",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHTMLHeader {
    const NAME: &'static str = "CHTMLHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHTMLHeader {
        CHTMLHeader::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHTMLHeader {
        static instance: CHTMLHeader = CHTMLHeader {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHTMLHeader {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHTMLHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHTMLHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHTMLHeader {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHTMLPageSecurityInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHTMLPageSecurityInfo {
    // message fields
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bIsSecure)
    pub bIsSecure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bHasCertError)
    pub bHasCertError: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.issuerName)
    pub issuerName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.certName)
    pub certName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.certExpiry)
    pub certExpiry: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.nCertBits)
    pub nCertBits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bIsEVCert)
    pub bIsEVCert: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CHTMLPageSecurityInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHTMLPageSecurityInfo {
    fn default() -> &'a CHTMLPageSecurityInfo {
        <CHTMLPageSecurityInfo as crate::Message>::default_instance()
    }
}

impl CHTMLPageSecurityInfo {
    pub fn new() -> CHTMLPageSecurityInfo {
        ::std::default::Default::default()
    }

    // optional bool bIsSecure = 1;

    pub fn bIsSecure(&self) -> bool {
        self.bIsSecure.unwrap_or(false)
    }

    pub fn clear_bIsSecure(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
    }

    pub fn has_bIsSecure(&self) -> bool {
        self.bIsSecure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsSecure(&mut self, v: bool) {
        self.bIsSecure = ::std::option::Option::Some(v);
    }

    // optional bool bHasCertError = 2;

    pub fn bHasCertError(&self) -> bool {
        self.bHasCertError.unwrap_or(false)
    }

    pub fn clear_bHasCertError(&mut self) {
        self.bHasCertError = ::std::option::Option::None;
    }

    pub fn has_bHasCertError(&self) -> bool {
        self.bHasCertError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasCertError(&mut self, v: bool) {
        self.bHasCertError = ::std::option::Option::Some(v);
    }

    // optional string issuerName = 3;

    pub fn issuerName(&self) -> &str {
        match self.issuerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuerName(&mut self) {
        self.issuerName = ::std::option::Option::None;
    }

    pub fn has_issuerName(&self) -> bool {
        self.issuerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuerName(&mut self, v: ::std::string::String) {
        self.issuerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerName(&mut self) -> &mut ::std::string::String {
        if self.issuerName.is_none() {
            self.issuerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuerName(&mut self) -> ::std::string::String {
        self.issuerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string certName = 4;

    pub fn certName(&self) -> &str {
        match self.certName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_certName(&mut self) {
        self.certName = ::std::option::Option::None;
    }

    pub fn has_certName(&self) -> bool {
        self.certName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certName(&mut self, v: ::std::string::String) {
        self.certName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certName(&mut self) -> &mut ::std::string::String {
        if self.certName.is_none() {
            self.certName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.certName.as_mut().unwrap()
    }

    // Take field
    pub fn take_certName(&mut self) -> ::std::string::String {
        self.certName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 certExpiry = 5;

    pub fn certExpiry(&self) -> i32 {
        self.certExpiry.unwrap_or(0i32)
    }

    pub fn clear_certExpiry(&mut self) {
        self.certExpiry = ::std::option::Option::None;
    }

    pub fn has_certExpiry(&self) -> bool {
        self.certExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certExpiry(&mut self, v: i32) {
        self.certExpiry = ::std::option::Option::Some(v);
    }

    // optional int32 nCertBits = 6;

    pub fn nCertBits(&self) -> i32 {
        self.nCertBits.unwrap_or(0i32)
    }

    pub fn clear_nCertBits(&mut self) {
        self.nCertBits = ::std::option::Option::None;
    }

    pub fn has_nCertBits(&self) -> bool {
        self.nCertBits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nCertBits(&mut self, v: i32) {
        self.nCertBits = ::std::option::Option::Some(v);
    }

    // optional bool bIsEVCert = 7;

    pub fn bIsEVCert(&self) -> bool {
        self.bIsEVCert.unwrap_or(false)
    }

    pub fn clear_bIsEVCert(&mut self) {
        self.bIsEVCert = ::std::option::Option::None;
    }

    pub fn has_bIsEVCert(&self) -> bool {
        self.bIsEVCert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsEVCert(&mut self, v: bool) {
        self.bIsEVCert = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsSecure",
            |m: &CHTMLPageSecurityInfo| { &m.bIsSecure },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.bIsSecure },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bHasCertError",
            |m: &CHTMLPageSecurityInfo| { &m.bHasCertError },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.bHasCertError },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuerName",
            |m: &CHTMLPageSecurityInfo| { &m.issuerName },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.issuerName },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "certName",
            |m: &CHTMLPageSecurityInfo| { &m.certName },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.certName },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "certExpiry",
            |m: &CHTMLPageSecurityInfo| { &m.certExpiry },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.certExpiry },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nCertBits",
            |m: &CHTMLPageSecurityInfo| { &m.nCertBits },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.nCertBits },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsEVCert",
            |m: &CHTMLPageSecurityInfo| { &m.bIsEVCert },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.bIsEVCert },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHTMLPageSecurityInfo>(
            "CHTMLPageSecurityInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHTMLPageSecurityInfo {
    const NAME: &'static str = "CHTMLPageSecurityInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bIsSecure = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bHasCertError = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.issuerName = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.certName = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.certExpiry = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.nCertBits = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.bIsEVCert = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bIsSecure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bHasCertError {
            my_size += 1 + 1;
        }
        if let Some(v) = self.issuerName.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.certName.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.certExpiry {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.nCertBits {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.bIsEVCert {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.bIsSecure {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bHasCertError {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.issuerName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.certName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.certExpiry {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.nCertBits {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bIsEVCert {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHTMLPageSecurityInfo {
        CHTMLPageSecurityInfo::new()
    }

    fn clear(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
        self.bHasCertError = ::std::option::Option::None;
        self.issuerName = ::std::option::Option::None;
        self.certName = ::std::option::Option::None;
        self.certExpiry = ::std::option::Option::None;
        self.nCertBits = ::std::option::Option::None;
        self.bIsEVCert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHTMLPageSecurityInfo {
        static instance: CHTMLPageSecurityInfo = CHTMLPageSecurityInfo {
            bIsSecure: ::std::option::Option::None,
            bHasCertError: ::std::option::Option::None,
            issuerName: ::std::option::Option::None,
            certName: ::std::option::Option::None,
            certExpiry: ::std::option::Option::None,
            nCertBits: ::std::option::Option::None,
            bIsEVCert: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHTMLPageSecurityInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHTMLPageSecurityInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHTMLPageSecurityInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHTMLPageSecurityInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFinishedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFinishedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgFinishedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFinishedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFinishedRequest.pageTitle)
    pub pageTitle: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFinishedRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFinishedRequest {
    fn default() -> &'a CMsgFinishedRequest {
        <CMsgFinishedRequest as crate::Message>::default_instance()
    }
}

impl CMsgFinishedRequest {
    pub fn new() -> CMsgFinishedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;

    pub fn pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pageTitle(&mut self) {
        self.pageTitle = ::std::option::Option::None;
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFinishedRequest| { &m.browser_handle },
            |m: &mut CMsgFinishedRequest| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgFinishedRequest| { &m.url },
            |m: &mut CMsgFinishedRequest| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageTitle",
            |m: &CMsgFinishedRequest| { &m.pageTitle },
            |m: &mut CMsgFinishedRequest| { &mut m.pageTitle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFinishedRequest>(
            "CMsgFinishedRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFinishedRequest {
    const NAME: &'static str = "CMsgFinishedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pageTitle = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.pageTitle.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pageTitle.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFinishedRequest {
        CMsgFinishedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.pageTitle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFinishedRequest {
        static instance: CMsgFinishedRequest = CMsgFinishedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            pageTitle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFinishedRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFinishedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFinishedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFinishedRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLoadedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.pageTitle)
    pub pageTitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.headers)
    pub headers: ::std::vec::Vec<CHTMLHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadedRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadedRequest {
    fn default() -> &'a CMsgLoadedRequest {
        <CMsgLoadedRequest as crate::Message>::default_instance()
    }
}

impl CMsgLoadedRequest {
    pub fn new() -> CMsgLoadedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;

    pub fn pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pageTitle(&mut self) {
        self.pageTitle = ::std::option::Option::None;
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CHTMLHeader headers = 5;

    pub fn headers(&self) -> &[CHTMLHeader] {
        &self.headers
    }

    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::std::vec::Vec<CHTMLHeader>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::std::vec::Vec<CHTMLHeader> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::std::vec::Vec<CHTMLHeader> {
        ::std::mem::replace(&mut self.headers, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLoadedRequest| { &m.browser_handle },
            |m: &mut CMsgLoadedRequest| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgLoadedRequest| { &m.url },
            |m: &mut CMsgLoadedRequest| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageTitle",
            |m: &CMsgLoadedRequest| { &m.pageTitle },
            |m: &mut CMsgLoadedRequest| { &mut m.pageTitle },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "headers",
            |m: &CMsgLoadedRequest| { &m.headers },
            |m: &mut CMsgLoadedRequest| { &mut m.headers },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLoadedRequest>(
            "CMsgLoadedRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgLoadedRequest {
    const NAME: &'static str = "CMsgLoadedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pageTitle = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.headers.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.pageTitle.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pageTitle.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.headers {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadedRequest {
        CMsgLoadedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.pageTitle = ::std::option::Option::None;
        self.headers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadedRequest {
        static instance: CMsgLoadedRequest = CMsgLoadedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            pageTitle: ::std::option::Option::None,
            headers: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgLoadedRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLoadedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLoadedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgLoadedRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFavIconURLChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFavIconURLChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgFavIconURLChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFavIconURLChanged.urls)
    pub urls: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFavIconURLChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFavIconURLChanged {
    fn default() -> &'a CMsgFavIconURLChanged {
        <CMsgFavIconURLChanged as crate::Message>::default_instance()
    }
}

impl CMsgFavIconURLChanged {
    pub fn new() -> CMsgFavIconURLChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated string urls = 2;

    pub fn urls(&self) -> &[::std::string::String] {
        &self.urls
    }

    pub fn clear_urls(&mut self) {
        self.urls.clear();
    }

    // Param is passed by value, moved
    pub fn set_urls(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.urls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_urls(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.urls
    }

    // Take field
    pub fn take_urls(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.urls, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFavIconURLChanged| { &m.browser_handle },
            |m: &mut CMsgFavIconURLChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "urls",
            |m: &CMsgFavIconURLChanged| { &m.urls },
            |m: &mut CMsgFavIconURLChanged| { &mut m.urls },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFavIconURLChanged>(
            "CMsgFavIconURLChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFavIconURLChanged {
    const NAME: &'static str = "CMsgFavIconURLChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.urls.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.urls {
            my_size += crate::rt::string_size(2, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.urls {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFavIconURLChanged {
        CMsgFavIconURLChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.urls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFavIconURLChanged {
        static instance: CMsgFavIconURLChanged = CMsgFavIconURLChanged {
            browser_handle: ::std::option::Option::None,
            urls: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFavIconURLChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFavIconURLChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFavIconURLChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFavIconURLChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPageSecurity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPageSecurity {
    // message fields
    // @@protoc_insertion_point(field:CMsgPageSecurity.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPageSecurity.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPageSecurity.security_info)
    pub security_info: crate::MessageField<CHTMLPageSecurityInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPageSecurity.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPageSecurity {
    fn default() -> &'a CMsgPageSecurity {
        <CMsgPageSecurity as crate::Message>::default_instance()
    }
}

impl CMsgPageSecurity {
    pub fn new() -> CMsgPageSecurity {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CHTMLPageSecurityInfo security_info = 3;

    pub fn security_info(&self) -> &CHTMLPageSecurityInfo {
        self.security_info.as_ref().unwrap_or_else(|| <CHTMLPageSecurityInfo as crate::Message>::default_instance())
    }

    pub fn clear_security_info(&mut self) {
        self.security_info.clear();
    }

    pub fn has_security_info(&self) -> bool {
        self.security_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_info(&mut self, v: CHTMLPageSecurityInfo) {
        self.security_info = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_info(&mut self) -> &mut CHTMLPageSecurityInfo {
        self.security_info.mut_or_insert_default()
    }

    // Take field
    pub fn take_security_info(&mut self) -> CHTMLPageSecurityInfo {
        self.security_info.take().unwrap_or_else(|| CHTMLPageSecurityInfo::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPageSecurity| { &m.browser_handle },
            |m: &mut CMsgPageSecurity| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgPageSecurity| { &m.url },
            |m: &mut CMsgPageSecurity| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CHTMLPageSecurityInfo>(
            "security_info",
            |m: &CMsgPageSecurity| { &m.security_info },
            |m: &mut CMsgPageSecurity| { &mut m.security_info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPageSecurity>(
            "CMsgPageSecurity",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPageSecurity {
    const NAME: &'static str = "CMsgPageSecurity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.security_info)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.security_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.security_info.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPageSecurity {
        CMsgPageSecurity::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.security_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPageSecurity {
        static instance: CMsgPageSecurity = CMsgPageSecurity {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            security_info: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPageSecurity {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPageSecurity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPageSecurity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPageSecurity {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStartRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.target)
    pub target: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.postData)
    pub postData: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.bIsRedirect)
    pub bIsRedirect: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequest {
    fn default() -> &'a CMsgStartRequest {
        <CMsgStartRequest as crate::Message>::default_instance()
    }
}

impl CMsgStartRequest {
    pub fn new() -> CMsgStartRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 3;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 4;

    pub fn postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postData(&mut self) {
        self.postData = ::std::option::Option::None;
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 5;

    pub fn bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }

    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStartRequest| { &m.browser_handle },
            |m: &mut CMsgStartRequest| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgStartRequest| { &m.url },
            |m: &mut CMsgStartRequest| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &CMsgStartRequest| { &m.target },
            |m: &mut CMsgStartRequest| { &mut m.target },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "postData",
            |m: &CMsgStartRequest| { &m.postData },
            |m: &mut CMsgStartRequest| { &mut m.postData },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsRedirect",
            |m: &CMsgStartRequest| { &m.bIsRedirect },
            |m: &mut CMsgStartRequest| { &mut m.bIsRedirect },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartRequest>(
            "CMsgStartRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgStartRequest {
    const NAME: &'static str = "CMsgStartRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.postData = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.bIsRedirect = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.target.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.postData.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.postData.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartRequest {
        CMsgStartRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.postData = ::std::option::Option::None;
        self.bIsRedirect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartRequest {
        static instance: CMsgStartRequest = CMsgStartRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            target: ::std::option::Option::None,
            postData: ::std::option::Option::None,
            bIsRedirect: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgStartRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgStartRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStartRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartRequestResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartRequestResponse.bAllow)
    pub bAllow: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartRequestResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequestResponse {
    fn default() -> &'a CMsgStartRequestResponse {
        <CMsgStartRequestResponse as crate::Message>::default_instance()
    }
}

impl CMsgStartRequestResponse {
    pub fn new() -> CMsgStartRequestResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;

    pub fn bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }

    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStartRequestResponse| { &m.browser_handle },
            |m: &mut CMsgStartRequestResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bAllow",
            |m: &CMsgStartRequestResponse| { &m.bAllow },
            |m: &mut CMsgStartRequestResponse| { &mut m.bAllow },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartRequestResponse>(
            "CMsgStartRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgStartRequestResponse {
    const NAME: &'static str = "CMsgStartRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bAllow = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bAllow {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartRequestResponse {
        CMsgStartRequestResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartRequestResponse {
        static instance: CMsgStartRequestResponse = CMsgStartRequestResponse {
            browser_handle: ::std::option::Option::None,
            bAllow: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgStartRequestResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgStartRequestResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowPopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowPopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowPopup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowPopup {
    fn default() -> &'a CMsgShowPopup {
        <CMsgShowPopup as crate::Message>::default_instance()
    }
}

impl CMsgShowPopup {
    pub fn new() -> CMsgShowPopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowPopup| { &m.browser_handle },
            |m: &mut CMsgShowPopup| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowPopup>(
            "CMsgShowPopup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgShowPopup {
    const NAME: &'static str = "CMsgShowPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowPopup {
        CMsgShowPopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowPopup {
        static instance: CMsgShowPopup = CMsgShowPopup {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgShowPopup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowPopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgShowPopup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHidePopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHidePopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgHidePopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHidePopup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHidePopup {
    fn default() -> &'a CMsgHidePopup {
        <CMsgHidePopup as crate::Message>::default_instance()
    }
}

impl CMsgHidePopup {
    pub fn new() -> CMsgHidePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHidePopup| { &m.browser_handle },
            |m: &mut CMsgHidePopup| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHidePopup>(
            "CMsgHidePopup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHidePopup {
    const NAME: &'static str = "CMsgHidePopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHidePopup {
        CMsgHidePopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHidePopup {
        static instance: CMsgHidePopup = CMsgHidePopup {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHidePopup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHidePopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHidePopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHidePopup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSizePopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSizePopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgSizePopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.tall)
    pub tall: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSizePopup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSizePopup {
    fn default() -> &'a CMsgSizePopup {
        <CMsgSizePopup as crate::Message>::default_instance()
    }
}

impl CMsgSizePopup {
    pub fn new() -> CMsgSizePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 4;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSizePopup| { &m.browser_handle },
            |m: &mut CMsgSizePopup| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgSizePopup| { &m.x },
            |m: &mut CMsgSizePopup| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgSizePopup| { &m.y },
            |m: &mut CMsgSizePopup| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgSizePopup| { &m.wide },
            |m: &mut CMsgSizePopup| { &mut m.wide },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgSizePopup| { &m.tall },
            |m: &mut CMsgSizePopup| { &mut m.tall },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSizePopup>(
            "CMsgSizePopup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSizePopup {
    const NAME: &'static str = "CMsgSizePopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.wide {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tall {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSizePopup {
        CMsgSizePopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSizePopup {
        static instance: CMsgSizePopup = CMsgSizePopup {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSizePopup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSizePopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSizePopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSizePopup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgOpenNewTab)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenNewTab {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenNewTab.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpenNewTab.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgOpenNewTab.bForeground)
    pub bForeground: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenNewTab.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenNewTab {
    fn default() -> &'a CMsgOpenNewTab {
        <CMsgOpenNewTab as crate::Message>::default_instance()
    }
}

impl CMsgOpenNewTab {
    pub fn new() -> CMsgOpenNewTab {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bForeground = 3;

    pub fn bForeground(&self) -> bool {
        self.bForeground.unwrap_or(false)
    }

    pub fn clear_bForeground(&mut self) {
        self.bForeground = ::std::option::Option::None;
    }

    pub fn has_bForeground(&self) -> bool {
        self.bForeground.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bForeground(&mut self, v: bool) {
        self.bForeground = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgOpenNewTab| { &m.browser_handle },
            |m: &mut CMsgOpenNewTab| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgOpenNewTab| { &m.url },
            |m: &mut CMsgOpenNewTab| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bForeground",
            |m: &CMsgOpenNewTab| { &m.bForeground },
            |m: &mut CMsgOpenNewTab| { &mut m.bForeground },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpenNewTab>(
            "CMsgOpenNewTab",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgOpenNewTab {
    const NAME: &'static str = "CMsgOpenNewTab";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.bForeground = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.bForeground {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.bForeground {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenNewTab {
        CMsgOpenNewTab::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.bForeground = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenNewTab {
        static instance: CMsgOpenNewTab = CMsgOpenNewTab {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            bForeground: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgOpenNewTab {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpenNewTab").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpenNewTab {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgOpenNewTab {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopupHTMLWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupHTMLWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.popup_index)
    pub popup_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.trusted_creator)
    pub trusted_creator: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.hwnd)
    pub hwnd: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.parent_popup_index)
    pub parent_popup_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupHTMLWindow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindow {
    fn default() -> &'a CMsgPopupHTMLWindow {
        <CMsgPopupHTMLWindow as crate::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindow {
    pub fn new() -> CMsgPopupHTMLWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 x = 3;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(-2147483648i32)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 4;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(-2147483648i32)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 5;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 6;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 popup_index = 7;

    pub fn popup_index(&self) -> u32 {
        self.popup_index.unwrap_or(0)
    }

    pub fn clear_popup_index(&mut self) {
        self.popup_index = ::std::option::Option::None;
    }

    pub fn has_popup_index(&self) -> bool {
        self.popup_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popup_index(&mut self, v: u32) {
        self.popup_index = ::std::option::Option::Some(v);
    }

    // optional bool trusted_creator = 8;

    pub fn trusted_creator(&self) -> bool {
        self.trusted_creator.unwrap_or(false)
    }

    pub fn clear_trusted_creator(&mut self) {
        self.trusted_creator = ::std::option::Option::None;
    }

    pub fn has_trusted_creator(&self) -> bool {
        self.trusted_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted_creator(&mut self, v: bool) {
        self.trusted_creator = ::std::option::Option::Some(v);
    }

    // optional string name = 9;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 hwnd = 10;

    pub fn hwnd(&self) -> u64 {
        self.hwnd.unwrap_or(0)
    }

    pub fn clear_hwnd(&mut self) {
        self.hwnd = ::std::option::Option::None;
    }

    pub fn has_hwnd(&self) -> bool {
        self.hwnd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd(&mut self, v: u64) {
        self.hwnd = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_popup_index = 11;

    pub fn parent_popup_index(&self) -> u32 {
        self.parent_popup_index.unwrap_or(0)
    }

    pub fn clear_parent_popup_index(&mut self) {
        self.parent_popup_index = ::std::option::Option::None;
    }

    pub fn has_parent_popup_index(&self) -> bool {
        self.parent_popup_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_popup_index(&mut self, v: u32) {
        self.parent_popup_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPopupHTMLWindow| { &m.browser_handle },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgPopupHTMLWindow| { &m.url },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgPopupHTMLWindow| { &m.x },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgPopupHTMLWindow| { &m.y },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgPopupHTMLWindow| { &m.wide },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.wide },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgPopupHTMLWindow| { &m.tall },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.tall },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "popup_index",
            |m: &CMsgPopupHTMLWindow| { &m.popup_index },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.popup_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "trusted_creator",
            |m: &CMsgPopupHTMLWindow| { &m.trusted_creator },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.trusted_creator },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgPopupHTMLWindow| { &m.name },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hwnd",
            |m: &CMsgPopupHTMLWindow| { &m.hwnd },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.hwnd },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_popup_index",
            |m: &CMsgPopupHTMLWindow| { &m.parent_popup_index },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.parent_popup_index },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopupHTMLWindow>(
            "CMsgPopupHTMLWindow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPopupHTMLWindow {
    const NAME: &'static str = "CMsgPopupHTMLWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.popup_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.trusted_creator = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.hwnd = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.parent_popup_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.wide {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tall {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.popup_index {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.trusted_creator {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        if let Some(v) = self.hwnd {
            my_size += crate::rt::uint64_size(10, v);
        }
        if let Some(v) = self.parent_popup_index {
            my_size += crate::rt::uint32_size(11, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.popup_index {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.trusted_creator {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.hwnd {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.parent_popup_index {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupHTMLWindow {
        CMsgPopupHTMLWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.popup_index = ::std::option::Option::None;
        self.trusted_creator = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.hwnd = ::std::option::Option::None;
        self.parent_popup_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindow {
        static instance: CMsgPopupHTMLWindow = CMsgPopupHTMLWindow {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            popup_index: ::std::option::Option::None,
            trusted_creator: ::std::option::Option::None,
            name: ::std::option::Option::None,
            hwnd: ::std::option::Option::None,
            parent_popup_index: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPopupHTMLWindow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopupHTMLWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopupHTMLWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPopupHTMLWindow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopupHTMLWindowResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupHTMLWindowResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindowResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindowResponse.bAllow)
    pub bAllow: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupHTMLWindowResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindowResponse {
    fn default() -> &'a CMsgPopupHTMLWindowResponse {
        <CMsgPopupHTMLWindowResponse as crate::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindowResponse {
    pub fn new() -> CMsgPopupHTMLWindowResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;

    pub fn bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }

    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPopupHTMLWindowResponse| { &m.browser_handle },
            |m: &mut CMsgPopupHTMLWindowResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bAllow",
            |m: &CMsgPopupHTMLWindowResponse| { &m.bAllow },
            |m: &mut CMsgPopupHTMLWindowResponse| { &mut m.bAllow },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopupHTMLWindowResponse>(
            "CMsgPopupHTMLWindowResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPopupHTMLWindowResponse {
    const NAME: &'static str = "CMsgPopupHTMLWindowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bAllow = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bAllow {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupHTMLWindowResponse {
        CMsgPopupHTMLWindowResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindowResponse {
        static instance: CMsgPopupHTMLWindowResponse = CMsgPopupHTMLWindowResponse {
            browser_handle: ::std::option::Option::None,
            bAllow: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPopupHTMLWindowResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopupHTMLWindowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopupHTMLWindowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPopupHTMLWindowResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetHTMLTitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetHTMLTitle {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHTMLTitle.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetHTMLTitle.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHTMLTitle.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHTMLTitle {
    fn default() -> &'a CMsgSetHTMLTitle {
        <CMsgSetHTMLTitle as crate::Message>::default_instance()
    }
}

impl CMsgSetHTMLTitle {
    pub fn new() -> CMsgSetHTMLTitle {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetHTMLTitle| { &m.browser_handle },
            |m: &mut CMsgSetHTMLTitle| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgSetHTMLTitle| { &m.title },
            |m: &mut CMsgSetHTMLTitle| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetHTMLTitle>(
            "CMsgSetHTMLTitle",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetHTMLTitle {
    const NAME: &'static str = "CMsgSetHTMLTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHTMLTitle {
        CMsgSetHTMLTitle::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHTMLTitle {
        static instance: CMsgSetHTMLTitle = CMsgSetHTMLTitle {
            browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetHTMLTitle {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetHTMLTitle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetHTMLTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetHTMLTitle {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLoadingResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadingResource {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadingResource.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadingResource.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadingResource.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadingResource {
    fn default() -> &'a CMsgLoadingResource {
        <CMsgLoadingResource as crate::Message>::default_instance()
    }
}

impl CMsgLoadingResource {
    pub fn new() -> CMsgLoadingResource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLoadingResource| { &m.browser_handle },
            |m: &mut CMsgLoadingResource| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgLoadingResource| { &m.url },
            |m: &mut CMsgLoadingResource| { &mut m.url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLoadingResource>(
            "CMsgLoadingResource",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgLoadingResource {
    const NAME: &'static str = "CMsgLoadingResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadingResource {
        CMsgLoadingResource::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadingResource {
        static instance: CMsgLoadingResource = CMsgLoadingResource {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgLoadingResource {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLoadingResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLoadingResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgLoadingResource {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStatusText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStatusText {
    // message fields
    // @@protoc_insertion_point(field:CMsgStatusText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStatusText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStatusText.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStatusText {
    fn default() -> &'a CMsgStatusText {
        <CMsgStatusText as crate::Message>::default_instance()
    }
}

impl CMsgStatusText {
    pub fn new() -> CMsgStatusText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStatusText| { &m.browser_handle },
            |m: &mut CMsgStatusText| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgStatusText| { &m.text },
            |m: &mut CMsgStatusText| { &mut m.text },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStatusText>(
            "CMsgStatusText",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgStatusText {
    const NAME: &'static str = "CMsgStatusText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStatusText {
        CMsgStatusText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStatusText {
        static instance: CMsgStatusText = CMsgStatusText {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgStatusText {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStatusText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStatusText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgStatusText {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetCursor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetCursor {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetCursor.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.cursor)
    pub cursor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.custom_data)
    pub custom_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgSetCursor.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.xhotspot)
    pub xhotspot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.yhotspot)
    pub yhotspot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetCursor.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetCursor {
    fn default() -> &'a CMsgSetCursor {
        <CMsgSetCursor as crate::Message>::default_instance()
    }
}

impl CMsgSetCursor {
    pub fn new() -> CMsgSetCursor {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 cursor = 2;

    pub fn cursor(&self) -> u32 {
        self.cursor.unwrap_or(0)
    }

    pub fn clear_cursor(&mut self) {
        self.cursor = ::std::option::Option::None;
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: u32) {
        self.cursor = ::std::option::Option::Some(v);
    }

    // optional bytes custom_data = 3;

    pub fn custom_data(&self) -> &[u8] {
        match self.custom_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_custom_data(&mut self) {
        self.custom_data = ::std::option::Option::None;
    }

    pub fn has_custom_data(&self) -> bool {
        self.custom_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_data(&mut self, v: ::bytes::Bytes) {
        self.custom_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_data(&mut self) -> &mut ::bytes::Bytes {
        if self.custom_data.is_none() {
            self.custom_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.custom_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_data(&mut self) -> ::bytes::Bytes {
        self.custom_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 wide = 4;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 xhotspot = 6;

    pub fn xhotspot(&self) -> u32 {
        self.xhotspot.unwrap_or(0)
    }

    pub fn clear_xhotspot(&mut self) {
        self.xhotspot = ::std::option::Option::None;
    }

    pub fn has_xhotspot(&self) -> bool {
        self.xhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xhotspot(&mut self, v: u32) {
        self.xhotspot = ::std::option::Option::Some(v);
    }

    // optional uint32 yhotspot = 7;

    pub fn yhotspot(&self) -> u32 {
        self.yhotspot.unwrap_or(0)
    }

    pub fn clear_yhotspot(&mut self) {
        self.yhotspot = ::std::option::Option::None;
    }

    pub fn has_yhotspot(&self) -> bool {
        self.yhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yhotspot(&mut self, v: u32) {
        self.yhotspot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetCursor| { &m.browser_handle },
            |m: &mut CMsgSetCursor| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor",
            |m: &CMsgSetCursor| { &m.cursor },
            |m: &mut CMsgSetCursor| { &mut m.cursor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_data",
            |m: &CMsgSetCursor| { &m.custom_data },
            |m: &mut CMsgSetCursor| { &mut m.custom_data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgSetCursor| { &m.wide },
            |m: &mut CMsgSetCursor| { &mut m.wide },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgSetCursor| { &m.tall },
            |m: &mut CMsgSetCursor| { &mut m.tall },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "xhotspot",
            |m: &CMsgSetCursor| { &m.xhotspot },
            |m: &mut CMsgSetCursor| { &mut m.xhotspot },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "yhotspot",
            |m: &CMsgSetCursor| { &m.yhotspot },
            |m: &mut CMsgSetCursor| { &mut m.yhotspot },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetCursor>(
            "CMsgSetCursor",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetCursor {
    const NAME: &'static str = "CMsgSetCursor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cursor = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.custom_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                32 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.xhotspot = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.yhotspot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cursor {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.custom_data.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.wide {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tall {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.xhotspot {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.yhotspot {
            my_size += crate::rt::uint32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cursor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.custom_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.xhotspot {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.yhotspot {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetCursor {
        CMsgSetCursor::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.cursor = ::std::option::Option::None;
        self.custom_data = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.xhotspot = ::std::option::Option::None;
        self.yhotspot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetCursor {
        static instance: CMsgSetCursor = CMsgSetCursor {
            browser_handle: ::std::option::Option::None,
            cursor: ::std::option::Option::None,
            custom_data: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            xhotspot: ::std::option::Option::None,
            yhotspot: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetCursor {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetCursor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetCursor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetCursor {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFileLoadDialog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFileLoadDialog {
    // message fields
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.initialFile)
    pub initialFile: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.accept_types)
    pub accept_types: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.is_save)
    pub is_save: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.choose_directory)
    pub choose_directory: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.filters)
    pub filters: ::std::vec::Vec<cmsg_file_load_dialog::Filter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFileLoadDialog.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialog {
    fn default() -> &'a CMsgFileLoadDialog {
        <CMsgFileLoadDialog as crate::Message>::default_instance()
    }
}

impl CMsgFileLoadDialog {
    pub fn new() -> CMsgFileLoadDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string initialFile = 4;

    pub fn initialFile(&self) -> &str {
        match self.initialFile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initialFile(&mut self) {
        self.initialFile = ::std::option::Option::None;
    }

    pub fn has_initialFile(&self) -> bool {
        self.initialFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialFile(&mut self, v: ::std::string::String) {
        self.initialFile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initialFile(&mut self) -> &mut ::std::string::String {
        if self.initialFile.is_none() {
            self.initialFile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initialFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_initialFile(&mut self) -> ::std::string::String {
        self.initialFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string accept_types = 5;

    pub fn accept_types(&self) -> &[::std::string::String] {
        &self.accept_types
    }

    pub fn clear_accept_types(&mut self) {
        self.accept_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_accept_types(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.accept_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accept_types(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.accept_types
    }

    // Take field
    pub fn take_accept_types(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.accept_types, ::std::vec::Vec::new())
    }

    // optional bool is_save = 6;

    pub fn is_save(&self) -> bool {
        self.is_save.unwrap_or(false)
    }

    pub fn clear_is_save(&mut self) {
        self.is_save = ::std::option::Option::None;
    }

    pub fn has_is_save(&self) -> bool {
        self.is_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_save(&mut self, v: bool) {
        self.is_save = ::std::option::Option::Some(v);
    }

    // optional bool choose_directory = 7;

    pub fn choose_directory(&self) -> bool {
        self.choose_directory.unwrap_or(false)
    }

    pub fn clear_choose_directory(&mut self) {
        self.choose_directory = ::std::option::Option::None;
    }

    pub fn has_choose_directory(&self) -> bool {
        self.choose_directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choose_directory(&mut self, v: bool) {
        self.choose_directory = ::std::option::Option::Some(v);
    }

    // repeated .CMsgFileLoadDialog.Filter filters = 8;

    pub fn filters(&self) -> &[cmsg_file_load_dialog::Filter] {
        &self.filters
    }

    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::std::vec::Vec<cmsg_file_load_dialog::Filter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::std::vec::Vec<cmsg_file_load_dialog::Filter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::std::vec::Vec<cmsg_file_load_dialog::Filter> {
        ::std::mem::replace(&mut self.filters, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFileLoadDialog| { &m.browser_handle },
            |m: &mut CMsgFileLoadDialog| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_browser_handle",
            |m: &CMsgFileLoadDialog| { &m.owning_browser_handle },
            |m: &mut CMsgFileLoadDialog| { &mut m.owning_browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgFileLoadDialog| { &m.title },
            |m: &mut CMsgFileLoadDialog| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "initialFile",
            |m: &CMsgFileLoadDialog| { &m.initialFile },
            |m: &mut CMsgFileLoadDialog| { &mut m.initialFile },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accept_types",
            |m: &CMsgFileLoadDialog| { &m.accept_types },
            |m: &mut CMsgFileLoadDialog| { &mut m.accept_types },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_save",
            |m: &CMsgFileLoadDialog| { &m.is_save },
            |m: &mut CMsgFileLoadDialog| { &mut m.is_save },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "choose_directory",
            |m: &CMsgFileLoadDialog| { &m.choose_directory },
            |m: &mut CMsgFileLoadDialog| { &mut m.choose_directory },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &CMsgFileLoadDialog| { &m.filters },
            |m: &mut CMsgFileLoadDialog| { &mut m.filters },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFileLoadDialog>(
            "CMsgFileLoadDialog",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFileLoadDialog {
    const NAME: &'static str = "CMsgFileLoadDialog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.initialFile = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.accept_types.push(is.read_string()?);
                },
                48 => {
                    self.is_save = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.choose_directory = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.filters.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.initialFile.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        for value in &self.accept_types {
            my_size += crate::rt::string_size(5, &value);
        };
        if let Some(v) = self.is_save {
            my_size += 1 + 1;
        }
        if let Some(v) = self.choose_directory {
            my_size += 1 + 1;
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.initialFile.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.accept_types {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.is_save {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.choose_directory {
            os.write_bool(7, v)?;
        }
        for v in &self.filters {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFileLoadDialog {
        CMsgFileLoadDialog::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.initialFile = ::std::option::Option::None;
        self.accept_types.clear();
        self.is_save = ::std::option::Option::None;
        self.choose_directory = ::std::option::Option::None;
        self.filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFileLoadDialog {
        static instance: CMsgFileLoadDialog = CMsgFileLoadDialog {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            initialFile: ::std::option::Option::None,
            accept_types: ::std::vec::Vec::new(),
            is_save: ::std::option::Option::None,
            choose_directory: ::std::option::Option::None,
            filters: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFileLoadDialog {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFileLoadDialog").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFileLoadDialog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFileLoadDialog {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgFileLoadDialog`
pub mod cmsg_file_load_dialog {
    // @@protoc_insertion_point(message:CMsgFileLoadDialog.Filter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Filter {
        // message fields
        // @@protoc_insertion_point(field:CMsgFileLoadDialog.Filter.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgFileLoadDialog.Filter.patterns)
        pub patterns: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgFileLoadDialog.Filter.is_default)
        pub is_default: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFileLoadDialog.Filter.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as crate::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // repeated string patterns = 2;

        pub fn patterns(&self) -> &[::std::string::String] {
            &self.patterns
        }

        pub fn clear_patterns(&mut self) {
            self.patterns.clear();
        }

        // Param is passed by value, moved
        pub fn set_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.patterns = v;
        }

        // Mutable pointer to the field.
        pub fn mut_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.patterns
        }

        // Take field
        pub fn take_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.patterns, ::std::vec::Vec::new())
        }

        // optional bool is_default = 3;

        pub fn is_default(&self) -> bool {
            self.is_default.unwrap_or(false)
        }

        pub fn clear_is_default(&mut self) {
            self.is_default = ::std::option::Option::None;
        }

        pub fn has_is_default(&self) -> bool {
            self.is_default.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_default(&mut self, v: bool) {
            self.is_default = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Filter| { &m.name },
                |m: &mut Filter| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "patterns",
                |m: &Filter| { &m.patterns },
                |m: &mut Filter| { &mut m.patterns },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_default",
                |m: &Filter| { &m.is_default },
                |m: &mut Filter| { &mut m.is_default },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "CMsgFileLoadDialog.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.patterns.push(is.read_string()?);
                    },
                    24 => {
                        self.is_default = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            for value in &self.patterns {
                my_size += crate::rt::string_size(2, &value);
            };
            if let Some(v) = self.is_default {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.patterns {
                os.write_string(2, &v)?;
            };
            if let Some(v) = self.is_default {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.patterns.clear();
            self.is_default = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                name: ::std::option::Option::None,
                patterns: ::std::vec::Vec::new(),
                is_default: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Filter {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgFileLoadDialog.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Filter {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgFileLoadDialogResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFileLoadDialogResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.bsuccess)
    pub bsuccess: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFileLoadDialogResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialogResponse {
    fn default() -> &'a CMsgFileLoadDialogResponse {
        <CMsgFileLoadDialogResponse as crate::Message>::default_instance()
    }
}

impl CMsgFileLoadDialogResponse {
    pub fn new() -> CMsgFileLoadDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bsuccess = 3;

    pub fn bsuccess(&self) -> bool {
        self.bsuccess.unwrap_or(false)
    }

    pub fn clear_bsuccess(&mut self) {
        self.bsuccess = ::std::option::Option::None;
    }

    pub fn has_bsuccess(&self) -> bool {
        self.bsuccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsuccess(&mut self, v: bool) {
        self.bsuccess = ::std::option::Option::Some(v);
    }

    // repeated string files = 4;

    pub fn files(&self) -> &[::std::string::String] {
        &self.files
    }

    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.files, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFileLoadDialogResponse| { &m.browser_handle },
            |m: &mut CMsgFileLoadDialogResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_browser_handle",
            |m: &CMsgFileLoadDialogResponse| { &m.owning_browser_handle },
            |m: &mut CMsgFileLoadDialogResponse| { &mut m.owning_browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bsuccess",
            |m: &CMsgFileLoadDialogResponse| { &m.bsuccess },
            |m: &mut CMsgFileLoadDialogResponse| { &mut m.bsuccess },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &CMsgFileLoadDialogResponse| { &m.files },
            |m: &mut CMsgFileLoadDialogResponse| { &mut m.files },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFileLoadDialogResponse>(
            "CMsgFileLoadDialogResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFileLoadDialogResponse {
    const NAME: &'static str = "CMsgFileLoadDialogResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bsuccess = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bsuccess {
            my_size += 1 + 1;
        }
        for value in &self.files {
            my_size += crate::rt::string_size(4, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bsuccess {
            os.write_bool(3, v)?;
        }
        for v in &self.files {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFileLoadDialogResponse {
        CMsgFileLoadDialogResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.bsuccess = ::std::option::Option::None;
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFileLoadDialogResponse {
        static instance: CMsgFileLoadDialogResponse = CMsgFileLoadDialogResponse {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            bsuccess: ::std::option::Option::None,
            files: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFileLoadDialogResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFileLoadDialogResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFileLoadDialogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFileLoadDialogResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowToolTip.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowToolTip {
    fn default() -> &'a CMsgShowToolTip {
        <CMsgShowToolTip as crate::Message>::default_instance()
    }
}

impl CMsgShowToolTip {
    pub fn new() -> CMsgShowToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowToolTip| { &m.browser_handle },
            |m: &mut CMsgShowToolTip| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgShowToolTip| { &m.text },
            |m: &mut CMsgShowToolTip| { &mut m.text },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowToolTip>(
            "CMsgShowToolTip",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgShowToolTip {
    const NAME: &'static str = "CMsgShowToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowToolTip {
        CMsgShowToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowToolTip {
        static instance: CMsgShowToolTip = CMsgShowToolTip {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgShowToolTip {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowToolTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgShowToolTip {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgUpdateToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpdateToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdateToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateToolTip.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateToolTip {
    fn default() -> &'a CMsgUpdateToolTip {
        <CMsgUpdateToolTip as crate::Message>::default_instance()
    }
}

impl CMsgUpdateToolTip {
    pub fn new() -> CMsgUpdateToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgUpdateToolTip| { &m.browser_handle },
            |m: &mut CMsgUpdateToolTip| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgUpdateToolTip| { &m.text },
            |m: &mut CMsgUpdateToolTip| { &mut m.text },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdateToolTip>(
            "CMsgUpdateToolTip",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgUpdateToolTip {
    const NAME: &'static str = "CMsgUpdateToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateToolTip {
        CMsgUpdateToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateToolTip {
        static instance: CMsgUpdateToolTip = CMsgUpdateToolTip {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgUpdateToolTip {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUpdateToolTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUpdateToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgUpdateToolTip {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHideToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHideToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgHideToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHideToolTip.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHideToolTip {
    fn default() -> &'a CMsgHideToolTip {
        <CMsgHideToolTip as crate::Message>::default_instance()
    }
}

impl CMsgHideToolTip {
    pub fn new() -> CMsgHideToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHideToolTip| { &m.browser_handle },
            |m: &mut CMsgHideToolTip| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHideToolTip>(
            "CMsgHideToolTip",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHideToolTip {
    const NAME: &'static str = "CMsgHideToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHideToolTip {
        CMsgHideToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHideToolTip {
        static instance: CMsgHideToolTip = CMsgHideToolTip {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHideToolTip {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHideToolTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHideToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHideToolTip {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSearchResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSearchResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgSearchResults.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSearchResults.activeMatch)
    pub activeMatch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSearchResults.results)
    pub results: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSearchResults.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSearchResults {
    fn default() -> &'a CMsgSearchResults {
        <CMsgSearchResults as crate::Message>::default_instance()
    }
}

impl CMsgSearchResults {
    pub fn new() -> CMsgSearchResults {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 activeMatch = 2;

    pub fn activeMatch(&self) -> i32 {
        self.activeMatch.unwrap_or(0)
    }

    pub fn clear_activeMatch(&mut self) {
        self.activeMatch = ::std::option::Option::None;
    }

    pub fn has_activeMatch(&self) -> bool {
        self.activeMatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeMatch(&mut self, v: i32) {
        self.activeMatch = ::std::option::Option::Some(v);
    }

    // optional int32 results = 3;

    pub fn results(&self) -> i32 {
        self.results.unwrap_or(0)
    }

    pub fn clear_results(&mut self) {
        self.results = ::std::option::Option::None;
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: i32) {
        self.results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSearchResults| { &m.browser_handle },
            |m: &mut CMsgSearchResults| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "activeMatch",
            |m: &CMsgSearchResults| { &m.activeMatch },
            |m: &mut CMsgSearchResults| { &mut m.activeMatch },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "results",
            |m: &CMsgSearchResults| { &m.results },
            |m: &mut CMsgSearchResults| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSearchResults>(
            "CMsgSearchResults",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSearchResults {
    const NAME: &'static str = "CMsgSearchResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.activeMatch = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.results = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.activeMatch {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.results {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.activeMatch {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.results {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSearchResults {
        CMsgSearchResults::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.activeMatch = ::std::option::Option::None;
        self.results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSearchResults {
        static instance: CMsgSearchResults = CMsgSearchResults {
            browser_handle: ::std::option::Option::None,
            activeMatch: ::std::option::Option::None,
            results: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSearchResults {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSearchResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSearchResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSearchResults {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClose)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClose {
    // message fields
    // @@protoc_insertion_point(field:CMsgClose.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClose.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClose {
    fn default() -> &'a CMsgClose {
        <CMsgClose as crate::Message>::default_instance()
    }
}

impl CMsgClose {
    pub fn new() -> CMsgClose {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClose| { &m.browser_handle },
            |m: &mut CMsgClose| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClose>(
            "CMsgClose",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClose {
    const NAME: &'static str = "CMsgClose";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClose {
        CMsgClose::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClose {
        static instance: CMsgClose = CMsgClose {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClose {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClose").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClose {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetSharedPaintBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetSharedPaintBuffers {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.source_pid)
    pub source_pid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.source_handle)
    pub source_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.handle)
    pub handle: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetSharedPaintBuffers.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetSharedPaintBuffers {
    fn default() -> &'a CMsgSetSharedPaintBuffers {
        <CMsgSetSharedPaintBuffers as crate::Message>::default_instance()
    }
}

impl CMsgSetSharedPaintBuffers {
    pub fn new() -> CMsgSetSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 2;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 3;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint64 source_pid = 4;

    pub fn source_pid(&self) -> u64 {
        self.source_pid.unwrap_or(0)
    }

    pub fn clear_source_pid(&mut self) {
        self.source_pid = ::std::option::Option::None;
    }

    pub fn has_source_pid(&self) -> bool {
        self.source_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_pid(&mut self, v: u64) {
        self.source_pid = ::std::option::Option::Some(v);
    }

    // optional uint64 source_handle = 5;

    pub fn source_handle(&self) -> u64 {
        self.source_handle.unwrap_or(0)
    }

    pub fn clear_source_handle(&mut self) {
        self.source_handle = ::std::option::Option::None;
    }

    pub fn has_source_handle(&self) -> bool {
        self.source_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_handle(&mut self, v: u64) {
        self.source_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 handle = 6;

    pub fn handle(&self) -> u64 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: u64) {
        self.handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetSharedPaintBuffers| { &m.browser_handle },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgSetSharedPaintBuffers| { &m.wide },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.wide },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgSetSharedPaintBuffers| { &m.tall },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.tall },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_pid",
            |m: &CMsgSetSharedPaintBuffers| { &m.source_pid },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.source_pid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_handle",
            |m: &CMsgSetSharedPaintBuffers| { &m.source_handle },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.source_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CMsgSetSharedPaintBuffers| { &m.handle },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetSharedPaintBuffers>(
            "CMsgSetSharedPaintBuffers",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetSharedPaintBuffers {
    const NAME: &'static str = "CMsgSetSharedPaintBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.source_pid = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.source_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wide {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tall {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.source_pid {
            my_size += crate::rt::uint64_size(4, v);
        }
        if let Some(v) = self.source_handle {
            my_size += crate::rt::uint64_size(5, v);
        }
        if let Some(v) = self.handle {
            my_size += crate::rt::uint64_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.source_pid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.source_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.handle {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetSharedPaintBuffers {
        CMsgSetSharedPaintBuffers::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.source_pid = ::std::option::Option::None;
        self.source_handle = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetSharedPaintBuffers {
        static instance: CMsgSetSharedPaintBuffers = CMsgSetSharedPaintBuffers {
            browser_handle: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            source_pid: ::std::option::Option::None,
            source_handle: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetSharedPaintBuffers {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetSharedPaintBuffers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetSharedPaintBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetSharedPaintBuffers {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAckSharedPaintBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckSharedPaintBuffers {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckSharedPaintBuffers.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckSharedPaintBuffers.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckSharedPaintBuffers {
    fn default() -> &'a CMsgAckSharedPaintBuffers {
        <CMsgAckSharedPaintBuffers as crate::Message>::default_instance()
    }
}

impl CMsgAckSharedPaintBuffers {
    pub fn new() -> CMsgAckSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgAckSharedPaintBuffers| { &m.browser_handle },
            |m: &mut CMsgAckSharedPaintBuffers| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAckSharedPaintBuffers>(
            "CMsgAckSharedPaintBuffers",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAckSharedPaintBuffers {
    const NAME: &'static str = "CMsgAckSharedPaintBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckSharedPaintBuffers {
        CMsgAckSharedPaintBuffers::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckSharedPaintBuffers {
        static instance: CMsgAckSharedPaintBuffers = CMsgAckSharedPaintBuffers {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAckSharedPaintBuffers {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAckSharedPaintBuffers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAckSharedPaintBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAckSharedPaintBuffers {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNeedsPaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeedsPaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgNeedsPaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.avg_frame_ms)
    pub avg_frame_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.stddev_sum_frame_ms)
    pub stddev_sum_frame_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.long_frame_ms)
    pub long_frame_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNeedsPaint.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsPaint {
    fn default() -> &'a CMsgNeedsPaint {
        <CMsgNeedsPaint as crate::Message>::default_instance()
    }
}

impl CMsgNeedsPaint {
    pub fn new() -> CMsgNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 10;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 11;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 12;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 15;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_frame_ms = 20;

    pub fn avg_frame_ms(&self) -> u32 {
        self.avg_frame_ms.unwrap_or(0)
    }

    pub fn clear_avg_frame_ms(&mut self) {
        self.avg_frame_ms = ::std::option::Option::None;
    }

    pub fn has_avg_frame_ms(&self) -> bool {
        self.avg_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_frame_ms(&mut self, v: u32) {
        self.avg_frame_ms = ::std::option::Option::Some(v);
    }

    // optional float stddev_sum_frame_ms = 21;

    pub fn stddev_sum_frame_ms(&self) -> f32 {
        self.stddev_sum_frame_ms.unwrap_or(0.)
    }

    pub fn clear_stddev_sum_frame_ms(&mut self) {
        self.stddev_sum_frame_ms = ::std::option::Option::None;
    }

    pub fn has_stddev_sum_frame_ms(&self) -> bool {
        self.stddev_sum_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_sum_frame_ms(&mut self, v: f32) {
        self.stddev_sum_frame_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 long_frame_ms = 22;

    pub fn long_frame_ms(&self) -> u32 {
        self.long_frame_ms.unwrap_or(0)
    }

    pub fn clear_long_frame_ms(&mut self) {
        self.long_frame_ms = ::std::option::Option::None;
    }

    pub fn has_long_frame_ms(&self) -> bool {
        self.long_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_frame_ms(&mut self, v: u32) {
        self.long_frame_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgNeedsPaint| { &m.browser_handle },
            |m: &mut CMsgNeedsPaint| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrollx",
            |m: &CMsgNeedsPaint| { &m.scrollx },
            |m: &mut CMsgNeedsPaint| { &mut m.scrollx },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrolly",
            |m: &CMsgNeedsPaint| { &m.scrolly },
            |m: &mut CMsgNeedsPaint| { &mut m.scrolly },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagescale",
            |m: &CMsgNeedsPaint| { &m.pagescale },
            |m: &mut CMsgNeedsPaint| { &mut m.pagescale },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgNeedsPaint| { &m.pageserial },
            |m: &mut CMsgNeedsPaint| { &mut m.pageserial },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_frame_ms",
            |m: &CMsgNeedsPaint| { &m.avg_frame_ms },
            |m: &mut CMsgNeedsPaint| { &mut m.avg_frame_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stddev_sum_frame_ms",
            |m: &CMsgNeedsPaint| { &m.stddev_sum_frame_ms },
            |m: &mut CMsgNeedsPaint| { &mut m.stddev_sum_frame_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "long_frame_ms",
            |m: &CMsgNeedsPaint| { &m.long_frame_ms },
            |m: &mut CMsgNeedsPaint| { &mut m.long_frame_ms },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNeedsPaint>(
            "CMsgNeedsPaint",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNeedsPaint {
    const NAME: &'static str = "CMsgNeedsPaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                101 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                120 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.avg_frame_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.stddev_sum_frame_ms = ::std::option::Option::Some(is.read_float()?);
                },
                176 => {
                    self.long_frame_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scrollx {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.scrolly {
            my_size += crate::rt::uint32_size(11, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += crate::rt::uint32_size(15, v);
        }
        if let Some(v) = self.avg_frame_ms {
            my_size += crate::rt::uint32_size(20, v);
        }
        if let Some(v) = self.stddev_sum_frame_ms {
            my_size += 2 + 4;
        }
        if let Some(v) = self.long_frame_ms {
            my_size += crate::rt::uint32_size(22, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.avg_frame_ms {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.stddev_sum_frame_ms {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.long_frame_ms {
            os.write_uint32(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeedsPaint {
        CMsgNeedsPaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.avg_frame_ms = ::std::option::Option::None;
        self.stddev_sum_frame_ms = ::std::option::Option::None;
        self.long_frame_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeedsPaint {
        static instance: CMsgNeedsPaint = CMsgNeedsPaint {
            browser_handle: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            avg_frame_ms: ::std::option::Option::None,
            stddev_sum_frame_ms: ::std::option::Option::None,
            long_frame_ms: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNeedsPaint {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNeedsPaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNeedsPaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNeedsPaint {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgComboNeedsPaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgComboNeedsPaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.rgba)
    pub rgba: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.combobox_wide)
    pub combobox_wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.combobox_tall)
    pub combobox_tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.shared_memory_handle)
    pub shared_memory_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.shared_memory_size)
    pub shared_memory_size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgComboNeedsPaint.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgComboNeedsPaint {
    fn default() -> &'a CMsgComboNeedsPaint {
        <CMsgComboNeedsPaint as crate::Message>::default_instance()
    }
}

impl CMsgComboNeedsPaint {
    pub fn new() -> CMsgComboNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 rgba = 2;

    pub fn rgba(&self) -> u64 {
        self.rgba.unwrap_or(0)
    }

    pub fn clear_rgba(&mut self) {
        self.rgba = ::std::option::Option::None;
    }

    pub fn has_rgba(&self) -> bool {
        self.rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rgba(&mut self, v: u64) {
        self.rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_wide = 3;

    pub fn combobox_wide(&self) -> u32 {
        self.combobox_wide.unwrap_or(0u32)
    }

    pub fn clear_combobox_wide(&mut self) {
        self.combobox_wide = ::std::option::Option::None;
    }

    pub fn has_combobox_wide(&self) -> bool {
        self.combobox_wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_wide(&mut self, v: u32) {
        self.combobox_wide = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_tall = 4;

    pub fn combobox_tall(&self) -> u32 {
        self.combobox_tall.unwrap_or(0u32)
    }

    pub fn clear_combobox_tall(&mut self) {
        self.combobox_tall = ::std::option::Option::None;
    }

    pub fn has_combobox_tall(&self) -> bool {
        self.combobox_tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_tall(&mut self, v: u32) {
        self.combobox_tall = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_handle = 5;

    pub fn shared_memory_handle(&self) -> u64 {
        self.shared_memory_handle.unwrap_or(0u64)
    }

    pub fn clear_shared_memory_handle(&mut self) {
        self.shared_memory_handle = ::std::option::Option::None;
    }

    pub fn has_shared_memory_handle(&self) -> bool {
        self.shared_memory_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_handle(&mut self, v: u64) {
        self.shared_memory_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_size = 7;

    pub fn shared_memory_size(&self) -> u64 {
        self.shared_memory_size.unwrap_or(0u64)
    }

    pub fn clear_shared_memory_size(&mut self) {
        self.shared_memory_size = ::std::option::Option::None;
    }

    pub fn has_shared_memory_size(&self) -> bool {
        self.shared_memory_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_size(&mut self, v: u64) {
        self.shared_memory_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgComboNeedsPaint| { &m.browser_handle },
            |m: &mut CMsgComboNeedsPaint| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rgba",
            |m: &CMsgComboNeedsPaint| { &m.rgba },
            |m: &mut CMsgComboNeedsPaint| { &mut m.rgba },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "combobox_wide",
            |m: &CMsgComboNeedsPaint| { &m.combobox_wide },
            |m: &mut CMsgComboNeedsPaint| { &mut m.combobox_wide },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "combobox_tall",
            |m: &CMsgComboNeedsPaint| { &m.combobox_tall },
            |m: &mut CMsgComboNeedsPaint| { &mut m.combobox_tall },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shared_memory_handle",
            |m: &CMsgComboNeedsPaint| { &m.shared_memory_handle },
            |m: &mut CMsgComboNeedsPaint| { &mut m.shared_memory_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shared_memory_size",
            |m: &CMsgComboNeedsPaint| { &m.shared_memory_size },
            |m: &mut CMsgComboNeedsPaint| { &mut m.shared_memory_size },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgComboNeedsPaint>(
            "CMsgComboNeedsPaint",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgComboNeedsPaint {
    const NAME: &'static str = "CMsgComboNeedsPaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rgba = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.combobox_wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.combobox_tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.shared_memory_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.shared_memory_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rgba {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.combobox_wide {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.combobox_tall {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.shared_memory_handle {
            my_size += crate::rt::uint64_size(5, v);
        }
        if let Some(v) = self.shared_memory_size {
            my_size += crate::rt::uint64_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rgba {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.combobox_wide {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.combobox_tall {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.shared_memory_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.shared_memory_size {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgComboNeedsPaint {
        CMsgComboNeedsPaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rgba = ::std::option::Option::None;
        self.combobox_wide = ::std::option::Option::None;
        self.combobox_tall = ::std::option::Option::None;
        self.shared_memory_handle = ::std::option::Option::None;
        self.shared_memory_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgComboNeedsPaint {
        static instance: CMsgComboNeedsPaint = CMsgComboNeedsPaint {
            browser_handle: ::std::option::Option::None,
            rgba: ::std::option::Option::None,
            combobox_wide: ::std::option::Option::None,
            combobox_tall: ::std::option::Option::None,
            shared_memory_handle: ::std::option::Option::None,
            shared_memory_size: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgComboNeedsPaint {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgComboNeedsPaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgComboNeedsPaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgComboNeedsPaint {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNeedsSharedTexturePaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeedsSharedTexturePaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.share_handle)
    pub share_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNeedsSharedTexturePaint.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsSharedTexturePaint {
    fn default() -> &'a CMsgNeedsSharedTexturePaint {
        <CMsgNeedsSharedTexturePaint as crate::Message>::default_instance()
    }
}

impl CMsgNeedsSharedTexturePaint {
    pub fn new() -> CMsgNeedsSharedTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 share_handle = 2;

    pub fn share_handle(&self) -> u32 {
        self.share_handle.unwrap_or(0)
    }

    pub fn clear_share_handle(&mut self) {
        self.share_handle = ::std::option::Option::None;
    }

    pub fn has_share_handle(&self) -> bool {
        self.share_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_share_handle(&mut self, v: u32) {
        self.share_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgNeedsSharedTexturePaint| { &m.browser_handle },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "share_handle",
            |m: &CMsgNeedsSharedTexturePaint| { &m.share_handle },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.share_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgNeedsSharedTexturePaint| { &m.width },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgNeedsSharedTexturePaint| { &m.height },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrollx",
            |m: &CMsgNeedsSharedTexturePaint| { &m.scrollx },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.scrollx },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrolly",
            |m: &CMsgNeedsSharedTexturePaint| { &m.scrolly },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.scrolly },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagescale",
            |m: &CMsgNeedsSharedTexturePaint| { &m.pagescale },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.pagescale },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgNeedsSharedTexturePaint| { &m.pageserial },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.pageserial },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNeedsSharedTexturePaint>(
            "CMsgNeedsSharedTexturePaint",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNeedsSharedTexturePaint {
    const NAME: &'static str = "CMsgNeedsSharedTexturePaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.share_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.share_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.width {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.scrollx {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scrolly {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += crate::rt::uint32_size(8, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.share_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeedsSharedTexturePaint {
        CMsgNeedsSharedTexturePaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.share_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeedsSharedTexturePaint {
        static instance: CMsgNeedsSharedTexturePaint = CMsgNeedsSharedTexturePaint {
            browser_handle: ::std::option::Option::None,
            share_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNeedsSharedTexturePaint {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNeedsSharedTexturePaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNeedsSharedTexturePaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNeedsSharedTexturePaint {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameOverlayTexturePaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameOverlayTexturePaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameOverlayTexturePaint.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTexturePaint {
    fn default() -> &'a CMsgGameOverlayTexturePaint {
        <CMsgGameOverlayTexturePaint as crate::Message>::default_instance()
    }
}

impl CMsgGameOverlayTexturePaint {
    pub fn new() -> CMsgGameOverlayTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGameOverlayTexturePaint| { &m.browser_handle },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgGameOverlayTexturePaint| { &m.width },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgGameOverlayTexturePaint| { &m.height },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrollx",
            |m: &CMsgGameOverlayTexturePaint| { &m.scrollx },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.scrollx },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrolly",
            |m: &CMsgGameOverlayTexturePaint| { &m.scrolly },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.scrolly },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagescale",
            |m: &CMsgGameOverlayTexturePaint| { &m.pagescale },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.pagescale },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgGameOverlayTexturePaint| { &m.pageserial },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.pageserial },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameOverlayTexturePaint>(
            "CMsgGameOverlayTexturePaint",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGameOverlayTexturePaint {
    const NAME: &'static str = "CMsgGameOverlayTexturePaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.scrollx {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scrolly {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += crate::rt::uint32_size(8, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameOverlayTexturePaint {
        CMsgGameOverlayTexturePaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameOverlayTexturePaint {
        static instance: CMsgGameOverlayTexturePaint = CMsgGameOverlayTexturePaint {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGameOverlayTexturePaint {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameOverlayTexturePaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameOverlayTexturePaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGameOverlayTexturePaint {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetZoom)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetZoom {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetZoom.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetZoom.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoom {
    fn default() -> &'a CMsgGetZoom {
        <CMsgGetZoom as crate::Message>::default_instance()
    }
}

impl CMsgGetZoom {
    pub fn new() -> CMsgGetZoom {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetZoom| { &m.browser_handle },
            |m: &mut CMsgGetZoom| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetZoom>(
            "CMsgGetZoom",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGetZoom {
    const NAME: &'static str = "CMsgGetZoom";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetZoom {
        CMsgGetZoom::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetZoom {
        static instance: CMsgGetZoom = CMsgGetZoom {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGetZoom {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetZoom").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetZoom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGetZoom {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetZoomResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetZoomResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetZoomResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetZoomResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetZoomResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoomResponse {
    fn default() -> &'a CMsgGetZoomResponse {
        <CMsgGetZoomResponse as crate::Message>::default_instance()
    }
}

impl CMsgGetZoomResponse {
    pub fn new() -> CMsgGetZoomResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetZoomResponse| { &m.browser_handle },
            |m: &mut CMsgGetZoomResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgGetZoomResponse| { &m.zoom },
            |m: &mut CMsgGetZoomResponse| { &mut m.zoom },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetZoomResponse>(
            "CMsgGetZoomResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGetZoomResponse {
    const NAME: &'static str = "CMsgGetZoomResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetZoomResponse {
        CMsgGetZoomResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetZoomResponse {
        static instance: CMsgGetZoomResponse = CMsgGetZoomResponse {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGetZoomResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetZoomResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetZoomResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGetZoomResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLinkAtPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinkAtPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinkAtPosition.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPosition {
    fn default() -> &'a CMsgLinkAtPosition {
        <CMsgLinkAtPosition as crate::Message>::default_instance()
    }
}

impl CMsgLinkAtPosition {
    pub fn new() -> CMsgLinkAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLinkAtPosition| { &m.browser_handle },
            |m: &mut CMsgLinkAtPosition| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgLinkAtPosition| { &m.x },
            |m: &mut CMsgLinkAtPosition| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgLinkAtPosition| { &m.y },
            |m: &mut CMsgLinkAtPosition| { &mut m.y },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLinkAtPosition>(
            "CMsgLinkAtPosition",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgLinkAtPosition {
    const NAME: &'static str = "CMsgLinkAtPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinkAtPosition {
        CMsgLinkAtPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinkAtPosition {
        static instance: CMsgLinkAtPosition = CMsgLinkAtPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgLinkAtPosition {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLinkAtPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLinkAtPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgLinkAtPosition {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLinkAtPositionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinkAtPositionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.y)
    pub y: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.blivelink)
    pub blivelink: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.binput)
    pub binput: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinkAtPositionResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPositionResponse {
    fn default() -> &'a CMsgLinkAtPositionResponse {
        <CMsgLinkAtPositionResponse as crate::Message>::default_instance()
    }
}

impl CMsgLinkAtPositionResponse {
    pub fn new() -> CMsgLinkAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional string url = 4;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool blivelink = 5;

    pub fn blivelink(&self) -> bool {
        self.blivelink.unwrap_or(false)
    }

    pub fn clear_blivelink(&mut self) {
        self.blivelink = ::std::option::Option::None;
    }

    pub fn has_blivelink(&self) -> bool {
        self.blivelink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blivelink(&mut self, v: bool) {
        self.blivelink = ::std::option::Option::Some(v);
    }

    // optional bool binput = 6;

    pub fn binput(&self) -> bool {
        self.binput.unwrap_or(false)
    }

    pub fn clear_binput(&mut self) {
        self.binput = ::std::option::Option::None;
    }

    pub fn has_binput(&self) -> bool {
        self.binput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binput(&mut self, v: bool) {
        self.binput = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLinkAtPositionResponse| { &m.browser_handle },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgLinkAtPositionResponse| { &m.x },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgLinkAtPositionResponse| { &m.y },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgLinkAtPositionResponse| { &m.url },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "blivelink",
            |m: &CMsgLinkAtPositionResponse| { &m.blivelink },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.blivelink },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "binput",
            |m: &CMsgLinkAtPositionResponse| { &m.binput },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.binput },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLinkAtPositionResponse>(
            "CMsgLinkAtPositionResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgLinkAtPositionResponse {
    const NAME: &'static str = "CMsgLinkAtPositionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.blivelink = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.binput = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.blivelink {
            my_size += 1 + 1;
        }
        if let Some(v) = self.binput {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.blivelink {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.binput {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinkAtPositionResponse {
        CMsgLinkAtPositionResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.blivelink = ::std::option::Option::None;
        self.binput = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinkAtPositionResponse {
        static instance: CMsgLinkAtPositionResponse = CMsgLinkAtPositionResponse {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            url: ::std::option::Option::None,
            blivelink: ::std::option::Option::None,
            binput: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgLinkAtPositionResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLinkAtPositionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLinkAtPositionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgLinkAtPositionResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgZoomToElementAtPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToElementAtPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToElementAtPosition.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPosition {
    fn default() -> &'a CMsgZoomToElementAtPosition {
        <CMsgZoomToElementAtPosition as crate::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPosition {
    pub fn new() -> CMsgZoomToElementAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgZoomToElementAtPosition| { &m.browser_handle },
            |m: &mut CMsgZoomToElementAtPosition| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgZoomToElementAtPosition| { &m.x },
            |m: &mut CMsgZoomToElementAtPosition| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgZoomToElementAtPosition| { &m.y },
            |m: &mut CMsgZoomToElementAtPosition| { &mut m.y },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgZoomToElementAtPosition>(
            "CMsgZoomToElementAtPosition",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgZoomToElementAtPosition {
    const NAME: &'static str = "CMsgZoomToElementAtPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToElementAtPosition {
        CMsgZoomToElementAtPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPosition {
        static instance: CMsgZoomToElementAtPosition = CMsgZoomToElementAtPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgZoomToElementAtPosition {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgZoomToElementAtPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgZoomToElementAtPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgZoomToElementAtPosition {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgZoomToElementAtPositionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToElementAtPositionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToElementAtPositionResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPositionResponse {
    fn default() -> &'a CMsgZoomToElementAtPositionResponse {
        <CMsgZoomToElementAtPositionResponse as crate::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPositionResponse {
    pub fn new() -> CMsgZoomToElementAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgZoomToElementAtPositionResponse| { &m.browser_handle },
            |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgZoomToElementAtPositionResponse| { &m.scale },
            |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.scale },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgZoomToElementAtPositionResponse| { &m.duration },
            |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.duration },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgZoomToElementAtPositionResponse>(
            "CMsgZoomToElementAtPositionResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgZoomToElementAtPositionResponse {
    const NAME: &'static str = "CMsgZoomToElementAtPositionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToElementAtPositionResponse {
        CMsgZoomToElementAtPositionResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPositionResponse {
        static instance: CMsgZoomToElementAtPositionResponse = CMsgZoomToElementAtPositionResponse {
            browser_handle: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgZoomToElementAtPositionResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgZoomToElementAtPositionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgZoomToElementAtPositionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgZoomToElementAtPositionResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScalePageToValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScalePageToValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgScalePageToValue.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScalePageToValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValue {
    fn default() -> &'a CMsgScalePageToValue {
        <CMsgScalePageToValue as crate::Message>::default_instance()
    }
}

impl CMsgScalePageToValue {
    pub fn new() -> CMsgScalePageToValue {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float x = 3;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 4;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScalePageToValue| { &m.browser_handle },
            |m: &mut CMsgScalePageToValue| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgScalePageToValue| { &m.scale },
            |m: &mut CMsgScalePageToValue| { &mut m.scale },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgScalePageToValue| { &m.x },
            |m: &mut CMsgScalePageToValue| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgScalePageToValue| { &m.y },
            |m: &mut CMsgScalePageToValue| { &mut m.y },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScalePageToValue>(
            "CMsgScalePageToValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgScalePageToValue {
    const NAME: &'static str = "CMsgScalePageToValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScalePageToValue {
        CMsgScalePageToValue::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScalePageToValue {
        static instance: CMsgScalePageToValue = CMsgScalePageToValue {
            browser_handle: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgScalePageToValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScalePageToValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScalePageToValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgScalePageToValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgForcePopupsToDirectHWND)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgForcePopupsToDirectHWND {
    // message fields
    // @@protoc_insertion_point(field:CMsgForcePopupsToDirectHWND.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgForcePopupsToDirectHWND.force_direct_hwnd_popups)
    pub force_direct_hwnd_popups: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgForcePopupsToDirectHWND.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgForcePopupsToDirectHWND {
    fn default() -> &'a CMsgForcePopupsToDirectHWND {
        <CMsgForcePopupsToDirectHWND as crate::Message>::default_instance()
    }
}

impl CMsgForcePopupsToDirectHWND {
    pub fn new() -> CMsgForcePopupsToDirectHWND {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool force_direct_hwnd_popups = 2;

    pub fn force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.unwrap_or(false)
    }

    pub fn clear_force_direct_hwnd_popups(&mut self) {
        self.force_direct_hwnd_popups = ::std::option::Option::None;
    }

    pub fn has_force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_direct_hwnd_popups(&mut self, v: bool) {
        self.force_direct_hwnd_popups = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgForcePopupsToDirectHWND| { &m.browser_handle },
            |m: &mut CMsgForcePopupsToDirectHWND| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_direct_hwnd_popups",
            |m: &CMsgForcePopupsToDirectHWND| { &m.force_direct_hwnd_popups },
            |m: &mut CMsgForcePopupsToDirectHWND| { &mut m.force_direct_hwnd_popups },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgForcePopupsToDirectHWND>(
            "CMsgForcePopupsToDirectHWND",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgForcePopupsToDirectHWND {
    const NAME: &'static str = "CMsgForcePopupsToDirectHWND";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.force_direct_hwnd_popups = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgForcePopupsToDirectHWND {
        CMsgForcePopupsToDirectHWND::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.force_direct_hwnd_popups = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgForcePopupsToDirectHWND {
        static instance: CMsgForcePopupsToDirectHWND = CMsgForcePopupsToDirectHWND {
            browser_handle: ::std::option::Option::None,
            force_direct_hwnd_popups: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgForcePopupsToDirectHWND {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgForcePopupsToDirectHWND").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgForcePopupsToDirectHWND {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgForcePopupsToDirectHWND {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScalePageToValueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScalePageToValueResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgScalePageToValueResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValueResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScalePageToValueResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValueResponse {
    fn default() -> &'a CMsgScalePageToValueResponse {
        <CMsgScalePageToValueResponse as crate::Message>::default_instance()
    }
}

impl CMsgScalePageToValueResponse {
    pub fn new() -> CMsgScalePageToValueResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScalePageToValueResponse| { &m.browser_handle },
            |m: &mut CMsgScalePageToValueResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgScalePageToValueResponse| { &m.zoom },
            |m: &mut CMsgScalePageToValueResponse| { &mut m.zoom },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScalePageToValueResponse>(
            "CMsgScalePageToValueResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgScalePageToValueResponse {
    const NAME: &'static str = "CMsgScalePageToValueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScalePageToValueResponse {
        CMsgScalePageToValueResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScalePageToValueResponse {
        static instance: CMsgScalePageToValueResponse = CMsgScalePageToValueResponse {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgScalePageToValueResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScalePageToValueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScalePageToValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgScalePageToValueResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSavePageToJPEG)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSavePageToJPEG {
    // message fields
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSavePageToJPEG.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEG {
    fn default() -> &'a CMsgSavePageToJPEG {
        <CMsgSavePageToJPEG as crate::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEG {
    pub fn new() -> CMsgSavePageToJPEG {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 width = 4;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSavePageToJPEG| { &m.browser_handle },
            |m: &mut CMsgSavePageToJPEG| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgSavePageToJPEG| { &m.url },
            |m: &mut CMsgSavePageToJPEG| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgSavePageToJPEG| { &m.filename },
            |m: &mut CMsgSavePageToJPEG| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgSavePageToJPEG| { &m.width },
            |m: &mut CMsgSavePageToJPEG| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgSavePageToJPEG| { &m.height },
            |m: &mut CMsgSavePageToJPEG| { &mut m.height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSavePageToJPEG>(
            "CMsgSavePageToJPEG",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSavePageToJPEG {
    const NAME: &'static str = "CMsgSavePageToJPEG";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSavePageToJPEG {
        CMsgSavePageToJPEG::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSavePageToJPEG {
        static instance: CMsgSavePageToJPEG = CMsgSavePageToJPEG {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSavePageToJPEG {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSavePageToJPEG").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSavePageToJPEG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSavePageToJPEG {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSavePageToJPEGResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSavePageToJPEGResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSavePageToJPEGResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEGResponse {
    fn default() -> &'a CMsgSavePageToJPEGResponse {
        <CMsgSavePageToJPEGResponse as crate::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEGResponse {
    pub fn new() -> CMsgSavePageToJPEGResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSavePageToJPEGResponse| { &m.browser_handle },
            |m: &mut CMsgSavePageToJPEGResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgSavePageToJPEGResponse| { &m.url },
            |m: &mut CMsgSavePageToJPEGResponse| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgSavePageToJPEGResponse| { &m.filename },
            |m: &mut CMsgSavePageToJPEGResponse| { &mut m.filename },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSavePageToJPEGResponse>(
            "CMsgSavePageToJPEGResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSavePageToJPEGResponse {
    const NAME: &'static str = "CMsgSavePageToJPEGResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSavePageToJPEGResponse {
        CMsgSavePageToJPEGResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSavePageToJPEGResponse {
        static instance: CMsgSavePageToJPEGResponse = CMsgSavePageToJPEGResponse {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSavePageToJPEGResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSavePageToJPEGResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSavePageToJPEGResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSavePageToJPEGResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSAlert {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSAlert.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSAlert.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSAlert.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSAlert {
    fn default() -> &'a CMsgJSAlert {
        <CMsgJSAlert as crate::Message>::default_instance()
    }
}

impl CMsgJSAlert {
    pub fn new() -> CMsgJSAlert {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSAlert| { &m.browser_handle },
            |m: &mut CMsgJSAlert| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgJSAlert| { &m.message },
            |m: &mut CMsgJSAlert| { &mut m.message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSAlert>(
            "CMsgJSAlert",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSAlert {
    const NAME: &'static str = "CMsgJSAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSAlert {
        CMsgJSAlert::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSAlert {
        static instance: CMsgJSAlert = CMsgJSAlert {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSAlert {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSAlert {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSConfirm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSConfirm {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSConfirm.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSConfirm.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSConfirm.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSConfirm {
    fn default() -> &'a CMsgJSConfirm {
        <CMsgJSConfirm as crate::Message>::default_instance()
    }
}

impl CMsgJSConfirm {
    pub fn new() -> CMsgJSConfirm {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSConfirm| { &m.browser_handle },
            |m: &mut CMsgJSConfirm| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgJSConfirm| { &m.message },
            |m: &mut CMsgJSConfirm| { &mut m.message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSConfirm>(
            "CMsgJSConfirm",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSConfirm {
    const NAME: &'static str = "CMsgJSConfirm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSConfirm {
        CMsgJSConfirm::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSConfirm {
        static instance: CMsgJSConfirm = CMsgJSConfirm {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSConfirm {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSConfirm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSConfirm {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSDialogResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSDialogResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSDialogResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSDialogResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSDialogResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSDialogResponse {
    fn default() -> &'a CMsgJSDialogResponse {
        <CMsgJSDialogResponse as crate::Message>::default_instance()
    }
}

impl CMsgJSDialogResponse {
    pub fn new() -> CMsgJSDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool result = 2;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSDialogResponse| { &m.browser_handle },
            |m: &mut CMsgJSDialogResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgJSDialogResponse| { &m.result },
            |m: &mut CMsgJSDialogResponse| { &mut m.result },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSDialogResponse>(
            "CMsgJSDialogResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSDialogResponse {
    const NAME: &'static str = "CMsgJSDialogResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSDialogResponse {
        CMsgJSDialogResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSDialogResponse {
        static instance: CMsgJSDialogResponse = CMsgJSDialogResponse {
            browser_handle: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSDialogResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSDialogResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSDialogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSDialogResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCanGoBackAndForward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCanGoBackAndForward {
    // message fields
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.bgoback)
    pub bgoback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.bgoforward)
    pub bgoforward: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCanGoBackAndForward.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCanGoBackAndForward {
    fn default() -> &'a CMsgCanGoBackAndForward {
        <CMsgCanGoBackAndForward as crate::Message>::default_instance()
    }
}

impl CMsgCanGoBackAndForward {
    pub fn new() -> CMsgCanGoBackAndForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bgoback = 2;

    pub fn bgoback(&self) -> bool {
        self.bgoback.unwrap_or(false)
    }

    pub fn clear_bgoback(&mut self) {
        self.bgoback = ::std::option::Option::None;
    }

    pub fn has_bgoback(&self) -> bool {
        self.bgoback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoback(&mut self, v: bool) {
        self.bgoback = ::std::option::Option::Some(v);
    }

    // optional bool bgoforward = 3;

    pub fn bgoforward(&self) -> bool {
        self.bgoforward.unwrap_or(false)
    }

    pub fn clear_bgoforward(&mut self) {
        self.bgoforward = ::std::option::Option::None;
    }

    pub fn has_bgoforward(&self) -> bool {
        self.bgoforward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoforward(&mut self, v: bool) {
        self.bgoforward = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgCanGoBackAndForward| { &m.browser_handle },
            |m: &mut CMsgCanGoBackAndForward| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bgoback",
            |m: &CMsgCanGoBackAndForward| { &m.bgoback },
            |m: &mut CMsgCanGoBackAndForward| { &mut m.bgoback },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bgoforward",
            |m: &CMsgCanGoBackAndForward| { &m.bgoforward },
            |m: &mut CMsgCanGoBackAndForward| { &mut m.bgoforward },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCanGoBackAndForward>(
            "CMsgCanGoBackAndForward",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCanGoBackAndForward {
    const NAME: &'static str = "CMsgCanGoBackAndForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bgoback = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.bgoforward = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bgoback {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bgoforward {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bgoback {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bgoforward {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCanGoBackAndForward {
        CMsgCanGoBackAndForward::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bgoback = ::std::option::Option::None;
        self.bgoforward = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCanGoBackAndForward {
        static instance: CMsgCanGoBackAndForward = CMsgCanGoBackAndForward {
            browser_handle: ::std::option::Option::None,
            bgoback: ::std::option::Option::None,
            bgoforward: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCanGoBackAndForward {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCanGoBackAndForward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCanGoBackAndForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCanGoBackAndForward {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgOpenSteamURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenSteamURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.referrer)
    pub referrer: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenSteamURL.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenSteamURL {
    fn default() -> &'a CMsgOpenSteamURL {
        <CMsgOpenSteamURL as crate::Message>::default_instance()
    }
}

impl CMsgOpenSteamURL {
    pub fn new() -> CMsgOpenSteamURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string referrer = 3;

    pub fn referrer(&self) -> &str {
        match self.referrer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_referrer(&mut self) {
        self.referrer = ::std::option::Option::None;
    }

    pub fn has_referrer(&self) -> bool {
        self.referrer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_referrer(&mut self, v: ::std::string::String) {
        self.referrer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_referrer(&mut self) -> &mut ::std::string::String {
        if self.referrer.is_none() {
            self.referrer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.referrer.as_mut().unwrap()
    }

    // Take field
    pub fn take_referrer(&mut self) -> ::std::string::String {
        self.referrer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgOpenSteamURL| { &m.browser_handle },
            |m: &mut CMsgOpenSteamURL| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgOpenSteamURL| { &m.url },
            |m: &mut CMsgOpenSteamURL| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "referrer",
            |m: &CMsgOpenSteamURL| { &m.referrer },
            |m: &mut CMsgOpenSteamURL| { &mut m.referrer },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpenSteamURL>(
            "CMsgOpenSteamURL",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgOpenSteamURL {
    const NAME: &'static str = "CMsgOpenSteamURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.referrer = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.referrer.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.referrer.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenSteamURL {
        CMsgOpenSteamURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.referrer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenSteamURL {
        static instance: CMsgOpenSteamURL = CMsgOpenSteamURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            referrer: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgOpenSteamURL {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpenSteamURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpenSteamURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgOpenSteamURL {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetCookie)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetCookie {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetCookie.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.host)
    pub host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.expires)
    pub expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCookie.secure)
    pub secure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSetCookie.httponly)
    pub httponly: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetCookie.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetCookie {
    fn default() -> &'a CMsgSetCookie {
        <CMsgSetCookie as crate::Message>::default_instance()
    }
}

impl CMsgSetCookie {
    pub fn new() -> CMsgSetCookie {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 3;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 4;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expires = 5;

    pub fn expires(&self) -> u32 {
        self.expires.unwrap_or(0)
    }

    pub fn clear_expires(&mut self) {
        self.expires = ::std::option::Option::None;
    }

    pub fn has_expires(&self) -> bool {
        self.expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expires(&mut self, v: u32) {
        self.expires = ::std::option::Option::Some(v);
    }

    // optional bool secure = 6;

    pub fn secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }

    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool httponly = 7;

    pub fn httponly(&self) -> bool {
        self.httponly.unwrap_or(false)
    }

    pub fn clear_httponly(&mut self) {
        self.httponly = ::std::option::Option::None;
    }

    pub fn has_httponly(&self) -> bool {
        self.httponly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httponly(&mut self, v: bool) {
        self.httponly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CMsgSetCookie| { &m.key },
            |m: &mut CMsgSetCookie| { &mut m.key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgSetCookie| { &m.value },
            |m: &mut CMsgSetCookie| { &mut m.value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CMsgSetCookie| { &m.path },
            |m: &mut CMsgSetCookie| { &mut m.path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &CMsgSetCookie| { &m.host },
            |m: &mut CMsgSetCookie| { &mut m.host },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "expires",
            |m: &CMsgSetCookie| { &m.expires },
            |m: &mut CMsgSetCookie| { &mut m.expires },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "secure",
            |m: &CMsgSetCookie| { &m.secure },
            |m: &mut CMsgSetCookie| { &mut m.secure },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "httponly",
            |m: &CMsgSetCookie| { &m.httponly },
            |m: &mut CMsgSetCookie| { &mut m.httponly },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetCookie>(
            "CMsgSetCookie",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetCookie {
    const NAME: &'static str = "CMsgSetCookie";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.secure = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.httponly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.host.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.expires {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.secure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.httponly {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.expires {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.httponly {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetCookie {
        CMsgSetCookie::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.host = ::std::option::Option::None;
        self.expires = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.httponly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetCookie {
        static instance: CMsgSetCookie = CMsgSetCookie {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            path: ::std::option::Option::None,
            host: ::std::option::Option::None,
            expires: ::std::option::Option::None,
            secure: ::std::option::Option::None,
            httponly: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetCookie {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetCookie").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetCookie {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetTargetFrameRate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTargetFrameRate {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTargetFrameRate.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetTargetFrameRate.nTargetFrameRate)
    pub nTargetFrameRate: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTargetFrameRate.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTargetFrameRate {
    fn default() -> &'a CMsgSetTargetFrameRate {
        <CMsgSetTargetFrameRate as crate::Message>::default_instance()
    }
}

impl CMsgSetTargetFrameRate {
    pub fn new() -> CMsgSetTargetFrameRate {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 nTargetFrameRate = 2;

    pub fn nTargetFrameRate(&self) -> u32 {
        self.nTargetFrameRate.unwrap_or(0)
    }

    pub fn clear_nTargetFrameRate(&mut self) {
        self.nTargetFrameRate = ::std::option::Option::None;
    }

    pub fn has_nTargetFrameRate(&self) -> bool {
        self.nTargetFrameRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nTargetFrameRate(&mut self, v: u32) {
        self.nTargetFrameRate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetTargetFrameRate| { &m.browser_handle },
            |m: &mut CMsgSetTargetFrameRate| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nTargetFrameRate",
            |m: &CMsgSetTargetFrameRate| { &m.nTargetFrameRate },
            |m: &mut CMsgSetTargetFrameRate| { &mut m.nTargetFrameRate },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetTargetFrameRate>(
            "CMsgSetTargetFrameRate",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetTargetFrameRate {
    const NAME: &'static str = "CMsgSetTargetFrameRate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.nTargetFrameRate = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.nTargetFrameRate {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nTargetFrameRate {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTargetFrameRate {
        CMsgSetTargetFrameRate::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.nTargetFrameRate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTargetFrameRate {
        static instance: CMsgSetTargetFrameRate = CMsgSetTargetFrameRate {
            browser_handle: ::std::option::Option::None,
            nTargetFrameRate: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetTargetFrameRate {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetTargetFrameRate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetTargetFrameRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetTargetFrameRate {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPauseRepaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPauseRepaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgPauseRepaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPauseRepaint.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPauseRepaint {
    fn default() -> &'a CMsgPauseRepaint {
        <CMsgPauseRepaint as crate::Message>::default_instance()
    }
}

impl CMsgPauseRepaint {
    pub fn new() -> CMsgPauseRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPauseRepaint| { &m.browser_handle },
            |m: &mut CMsgPauseRepaint| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPauseRepaint>(
            "CMsgPauseRepaint",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPauseRepaint {
    const NAME: &'static str = "CMsgPauseRepaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPauseRepaint {
        CMsgPauseRepaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPauseRepaint {
        static instance: CMsgPauseRepaint = CMsgPauseRepaint {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPauseRepaint {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPauseRepaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPauseRepaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPauseRepaint {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFullRepaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFullRepaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgFullRepaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFullRepaint.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFullRepaint {
    fn default() -> &'a CMsgFullRepaint {
        <CMsgFullRepaint as crate::Message>::default_instance()
    }
}

impl CMsgFullRepaint {
    pub fn new() -> CMsgFullRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFullRepaint| { &m.browser_handle },
            |m: &mut CMsgFullRepaint| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFullRepaint>(
            "CMsgFullRepaint",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFullRepaint {
    const NAME: &'static str = "CMsgFullRepaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFullRepaint {
        CMsgFullRepaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFullRepaint {
        static instance: CMsgFullRepaint = CMsgFullRepaint {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFullRepaint {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFullRepaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFullRepaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFullRepaint {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRequestFullScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestFullScreen {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestFullScreen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestFullScreen.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestFullScreen {
    fn default() -> &'a CMsgRequestFullScreen {
        <CMsgRequestFullScreen as crate::Message>::default_instance()
    }
}

impl CMsgRequestFullScreen {
    pub fn new() -> CMsgRequestFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgRequestFullScreen| { &m.browser_handle },
            |m: &mut CMsgRequestFullScreen| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestFullScreen>(
            "CMsgRequestFullScreen",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRequestFullScreen {
    const NAME: &'static str = "CMsgRequestFullScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestFullScreen {
        CMsgRequestFullScreen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestFullScreen {
        static instance: CMsgRequestFullScreen = CMsgRequestFullScreen {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRequestFullScreen {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestFullScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestFullScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRequestFullScreen {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgExitFullScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExitFullScreen {
    // message fields
    // @@protoc_insertion_point(field:CMsgExitFullScreen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExitFullScreen.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExitFullScreen {
    fn default() -> &'a CMsgExitFullScreen {
        <CMsgExitFullScreen as crate::Message>::default_instance()
    }
}

impl CMsgExitFullScreen {
    pub fn new() -> CMsgExitFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgExitFullScreen| { &m.browser_handle },
            |m: &mut CMsgExitFullScreen| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgExitFullScreen>(
            "CMsgExitFullScreen",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgExitFullScreen {
    const NAME: &'static str = "CMsgExitFullScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExitFullScreen {
        CMsgExitFullScreen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExitFullScreen {
        static instance: CMsgExitFullScreen = CMsgExitFullScreen {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgExitFullScreen {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgExitFullScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgExitFullScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgExitFullScreen {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgToggleFindInPageDialog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgToggleFindInPageDialog {
    // message fields
    // @@protoc_insertion_point(field:CMsgToggleFindInPageDialog.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgToggleFindInPageDialog.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgToggleFindInPageDialog {
    fn default() -> &'a CMsgToggleFindInPageDialog {
        <CMsgToggleFindInPageDialog as crate::Message>::default_instance()
    }
}

impl CMsgToggleFindInPageDialog {
    pub fn new() -> CMsgToggleFindInPageDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgToggleFindInPageDialog| { &m.browser_handle },
            |m: &mut CMsgToggleFindInPageDialog| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgToggleFindInPageDialog>(
            "CMsgToggleFindInPageDialog",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgToggleFindInPageDialog {
    const NAME: &'static str = "CMsgToggleFindInPageDialog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgToggleFindInPageDialog {
        CMsgToggleFindInPageDialog::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgToggleFindInPageDialog {
        static instance: CMsgToggleFindInPageDialog = CMsgToggleFindInPageDialog {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgToggleFindInPageDialog {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgToggleFindInPageDialog").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgToggleFindInPageDialog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgToggleFindInPageDialog {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetPIDShuttingDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetPIDShuttingDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetPIDShuttingDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetPIDShuttingDown.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetPIDShuttingDown {
    fn default() -> &'a CMsgSetPIDShuttingDown {
        <CMsgSetPIDShuttingDown as crate::Message>::default_instance()
    }
}

impl CMsgSetPIDShuttingDown {
    pub fn new() -> CMsgSetPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetPIDShuttingDown| { &m.browser_handle },
            |m: &mut CMsgSetPIDShuttingDown| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetPIDShuttingDown>(
            "CMsgSetPIDShuttingDown",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetPIDShuttingDown {
    const NAME: &'static str = "CMsgSetPIDShuttingDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetPIDShuttingDown {
        CMsgSetPIDShuttingDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetPIDShuttingDown {
        static instance: CMsgSetPIDShuttingDown = CMsgSetPIDShuttingDown {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetPIDShuttingDown {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetPIDShuttingDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetPIDShuttingDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetPIDShuttingDown {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDisableBackgroundThrottling)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDisableBackgroundThrottling {
    // message fields
    // @@protoc_insertion_point(field:CMsgDisableBackgroundThrottling.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDisableBackgroundThrottling.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDisableBackgroundThrottling {
    fn default() -> &'a CMsgDisableBackgroundThrottling {
        <CMsgDisableBackgroundThrottling as crate::Message>::default_instance()
    }
}

impl CMsgDisableBackgroundThrottling {
    pub fn new() -> CMsgDisableBackgroundThrottling {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgDisableBackgroundThrottling| { &m.browser_handle },
            |m: &mut CMsgDisableBackgroundThrottling| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDisableBackgroundThrottling>(
            "CMsgDisableBackgroundThrottling",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDisableBackgroundThrottling {
    const NAME: &'static str = "CMsgDisableBackgroundThrottling";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDisableBackgroundThrottling {
        CMsgDisableBackgroundThrottling::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDisableBackgroundThrottling {
        static instance: CMsgDisableBackgroundThrottling = CMsgDisableBackgroundThrottling {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDisableBackgroundThrottling {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDisableBackgroundThrottling").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDisableBackgroundThrottling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDisableBackgroundThrottling {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAckPIDShuttingDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckPIDShuttingDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckPIDShuttingDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckPIDShuttingDown.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckPIDShuttingDown {
    fn default() -> &'a CMsgAckPIDShuttingDown {
        <CMsgAckPIDShuttingDown as crate::Message>::default_instance()
    }
}

impl CMsgAckPIDShuttingDown {
    pub fn new() -> CMsgAckPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgAckPIDShuttingDown| { &m.browser_handle },
            |m: &mut CMsgAckPIDShuttingDown| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAckPIDShuttingDown>(
            "CMsgAckPIDShuttingDown",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAckPIDShuttingDown {
    const NAME: &'static str = "CMsgAckPIDShuttingDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckPIDShuttingDown {
        CMsgAckPIDShuttingDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckPIDShuttingDown {
        static instance: CMsgAckPIDShuttingDown = CMsgAckPIDShuttingDown {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAckPIDShuttingDown {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAckPIDShuttingDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAckPIDShuttingDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAckPIDShuttingDown {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetCookiesForURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetCookiesForURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetCookiesForURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetCookiesForURL.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURL {
    fn default() -> &'a CMsgGetCookiesForURL {
        <CMsgGetCookiesForURL as crate::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURL {
    pub fn new() -> CMsgGetCookiesForURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetCookiesForURL| { &m.browser_handle },
            |m: &mut CMsgGetCookiesForURL| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgGetCookiesForURL| { &m.url },
            |m: &mut CMsgGetCookiesForURL| { &mut m.url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetCookiesForURL>(
            "CMsgGetCookiesForURL",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGetCookiesForURL {
    const NAME: &'static str = "CMsgGetCookiesForURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetCookiesForURL {
        CMsgGetCookiesForURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetCookiesForURL {
        static instance: CMsgGetCookiesForURL = CMsgGetCookiesForURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGetCookiesForURL {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetCookiesForURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetCookiesForURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGetCookiesForURL {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCookie)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCookie {
    // message fields
    // @@protoc_insertion_point(field:CCookie.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCookie.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCookie {
    fn default() -> &'a CCookie {
        <CCookie as crate::Message>::default_instance()
    }
}

impl CCookie {
    pub fn new() -> CCookie {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 3;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 4;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCookie| { &m.name },
            |m: &mut CCookie| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CCookie| { &m.value },
            |m: &mut CCookie| { &mut m.value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "domain",
            |m: &CCookie| { &m.domain },
            |m: &mut CCookie| { &mut m.domain },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CCookie| { &m.path },
            |m: &mut CCookie| { &mut m.path },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CCookie>(
            "CCookie",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CCookie {
    const NAME: &'static str = "CCookie";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.domain.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.domain.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCookie {
        CCookie::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCookie {
        static instance: CCookie = CCookie {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            domain: ::std::option::Option::None,
            path: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CCookie {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCookie").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CCookie {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetCookiesForURLResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetCookiesForURLResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.cookies)
    pub cookies: ::std::vec::Vec<CCookie>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetCookiesForURLResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURLResponse {
    fn default() -> &'a CMsgGetCookiesForURLResponse {
        <CMsgGetCookiesForURLResponse as crate::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURLResponse {
    pub fn new() -> CMsgGetCookiesForURLResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CCookie cookies = 3;

    pub fn cookies(&self) -> &[CCookie] {
        &self.cookies
    }

    pub fn clear_cookies(&mut self) {
        self.cookies.clear();
    }

    // Param is passed by value, moved
    pub fn set_cookies(&mut self, v: ::std::vec::Vec<CCookie>) {
        self.cookies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cookies(&mut self) -> &mut ::std::vec::Vec<CCookie> {
        &mut self.cookies
    }

    // Take field
    pub fn take_cookies(&mut self) -> ::std::vec::Vec<CCookie> {
        ::std::mem::replace(&mut self.cookies, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetCookiesForURLResponse| { &m.browser_handle },
            |m: &mut CMsgGetCookiesForURLResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgGetCookiesForURLResponse| { &m.url },
            |m: &mut CMsgGetCookiesForURLResponse| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cookies",
            |m: &CMsgGetCookiesForURLResponse| { &m.cookies },
            |m: &mut CMsgGetCookiesForURLResponse| { &mut m.cookies },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetCookiesForURLResponse>(
            "CMsgGetCookiesForURLResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGetCookiesForURLResponse {
    const NAME: &'static str = "CMsgGetCookiesForURLResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.cookies.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.cookies {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.cookies {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetCookiesForURLResponse {
        CMsgGetCookiesForURLResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.cookies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetCookiesForURLResponse {
        static instance: CMsgGetCookiesForURLResponse = CMsgGetCookiesForURLResponse {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            cookies: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGetCookiesForURLResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetCookiesForURLResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetCookiesForURLResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGetCookiesForURLResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNodeHasFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNodeHasFocus {
    // message fields
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bInput)
    pub bInput: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.elementtagname)
    pub elementtagname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.searchbuttontext)
    pub searchbuttontext: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bHasMultipleInputs)
    pub bHasMultipleInputs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.input_type)
    pub input_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bIsMainFrame)
    pub bIsMainFrame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNodeHasFocus.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNodeHasFocus {
    fn default() -> &'a CMsgNodeHasFocus {
        <CMsgNodeHasFocus as crate::Message>::default_instance()
    }
}

impl CMsgNodeHasFocus {
    pub fn new() -> CMsgNodeHasFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bInput = 2;

    pub fn bInput(&self) -> bool {
        self.bInput.unwrap_or(false)
    }

    pub fn clear_bInput(&mut self) {
        self.bInput = ::std::option::Option::None;
    }

    pub fn has_bInput(&self) -> bool {
        self.bInput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bInput(&mut self, v: bool) {
        self.bInput = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string elementtagname = 4;

    pub fn elementtagname(&self) -> &str {
        match self.elementtagname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_elementtagname(&mut self) {
        self.elementtagname = ::std::option::Option::None;
    }

    pub fn has_elementtagname(&self) -> bool {
        self.elementtagname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elementtagname(&mut self, v: ::std::string::String) {
        self.elementtagname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elementtagname(&mut self) -> &mut ::std::string::String {
        if self.elementtagname.is_none() {
            self.elementtagname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.elementtagname.as_mut().unwrap()
    }

    // Take field
    pub fn take_elementtagname(&mut self) -> ::std::string::String {
        self.elementtagname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string searchbuttontext = 5;

    pub fn searchbuttontext(&self) -> &str {
        match self.searchbuttontext.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_searchbuttontext(&mut self) {
        self.searchbuttontext = ::std::option::Option::None;
    }

    pub fn has_searchbuttontext(&self) -> bool {
        self.searchbuttontext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_searchbuttontext(&mut self, v: ::std::string::String) {
        self.searchbuttontext = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_searchbuttontext(&mut self) -> &mut ::std::string::String {
        if self.searchbuttontext.is_none() {
            self.searchbuttontext = ::std::option::Option::Some(::std::string::String::new());
        }
        self.searchbuttontext.as_mut().unwrap()
    }

    // Take field
    pub fn take_searchbuttontext(&mut self) -> ::std::string::String {
        self.searchbuttontext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bHasMultipleInputs = 6;

    pub fn bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.unwrap_or(false)
    }

    pub fn clear_bHasMultipleInputs(&mut self) {
        self.bHasMultipleInputs = ::std::option::Option::None;
    }

    pub fn has_bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasMultipleInputs(&mut self, v: bool) {
        self.bHasMultipleInputs = ::std::option::Option::Some(v);
    }

    // optional string input_type = 7;

    pub fn input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None;
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsMainFrame = 8;

    pub fn bIsMainFrame(&self) -> bool {
        self.bIsMainFrame.unwrap_or(false)
    }

    pub fn clear_bIsMainFrame(&mut self) {
        self.bIsMainFrame = ::std::option::Option::None;
    }

    pub fn has_bIsMainFrame(&self) -> bool {
        self.bIsMainFrame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsMainFrame(&mut self, v: bool) {
        self.bIsMainFrame = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgNodeHasFocus| { &m.browser_handle },
            |m: &mut CMsgNodeHasFocus| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bInput",
            |m: &CMsgNodeHasFocus| { &m.bInput },
            |m: &mut CMsgNodeHasFocus| { &mut m.bInput },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgNodeHasFocus| { &m.name },
            |m: &mut CMsgNodeHasFocus| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "elementtagname",
            |m: &CMsgNodeHasFocus| { &m.elementtagname },
            |m: &mut CMsgNodeHasFocus| { &mut m.elementtagname },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "searchbuttontext",
            |m: &CMsgNodeHasFocus| { &m.searchbuttontext },
            |m: &mut CMsgNodeHasFocus| { &mut m.searchbuttontext },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bHasMultipleInputs",
            |m: &CMsgNodeHasFocus| { &m.bHasMultipleInputs },
            |m: &mut CMsgNodeHasFocus| { &mut m.bHasMultipleInputs },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_type",
            |m: &CMsgNodeHasFocus| { &m.input_type },
            |m: &mut CMsgNodeHasFocus| { &mut m.input_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsMainFrame",
            |m: &CMsgNodeHasFocus| { &m.bIsMainFrame },
            |m: &mut CMsgNodeHasFocus| { &mut m.bIsMainFrame },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNodeHasFocus>(
            "CMsgNodeHasFocus",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNodeHasFocus {
    const NAME: &'static str = "CMsgNodeHasFocus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bInput = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.elementtagname = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.searchbuttontext = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.bHasMultipleInputs = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.input_type = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.bIsMainFrame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bInput {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.elementtagname.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.searchbuttontext.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.bHasMultipleInputs {
            my_size += 1 + 1;
        }
        if let Some(v) = self.input_type.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.bIsMainFrame {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bInput {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.elementtagname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.searchbuttontext.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bHasMultipleInputs {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.bIsMainFrame {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNodeHasFocus {
        CMsgNodeHasFocus::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bInput = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.elementtagname = ::std::option::Option::None;
        self.searchbuttontext = ::std::option::Option::None;
        self.bHasMultipleInputs = ::std::option::Option::None;
        self.input_type = ::std::option::Option::None;
        self.bIsMainFrame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNodeHasFocus {
        static instance: CMsgNodeHasFocus = CMsgNodeHasFocus {
            browser_handle: ::std::option::Option::None,
            bInput: ::std::option::Option::None,
            name: ::std::option::Option::None,
            elementtagname: ::std::option::Option::None,
            searchbuttontext: ::std::option::Option::None,
            bHasMultipleInputs: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            bIsMainFrame: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNodeHasFocus {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNodeHasFocus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNodeHasFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNodeHasFocus {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgZoomToFocusedElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToFocusedElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToFocusedElement.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToFocusedElement.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToFocusedElement {
    fn default() -> &'a CMsgZoomToFocusedElement {
        <CMsgZoomToFocusedElement as crate::Message>::default_instance()
    }
}

impl CMsgZoomToFocusedElement {
    pub fn new() -> CMsgZoomToFocusedElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgZoomToFocusedElement| { &m.browser_handle },
            |m: &mut CMsgZoomToFocusedElement| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgZoomToFocusedElement>(
            "CMsgZoomToFocusedElement",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgZoomToFocusedElement {
    const NAME: &'static str = "CMsgZoomToFocusedElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToFocusedElement {
        CMsgZoomToFocusedElement::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToFocusedElement {
        static instance: CMsgZoomToFocusedElement = CMsgZoomToFocusedElement {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgZoomToFocusedElement {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgZoomToFocusedElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgZoomToFocusedElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgZoomToFocusedElement {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFocusedNodeText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFocusedNodeText {
    // message fields
    // @@protoc_insertion_point(field:CMsgFocusedNodeText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFocusedNodeText.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeText {
    fn default() -> &'a CMsgFocusedNodeText {
        <CMsgFocusedNodeText as crate::Message>::default_instance()
    }
}

impl CMsgFocusedNodeText {
    pub fn new() -> CMsgFocusedNodeText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFocusedNodeText| { &m.browser_handle },
            |m: &mut CMsgFocusedNodeText| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFocusedNodeText>(
            "CMsgFocusedNodeText",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFocusedNodeText {
    const NAME: &'static str = "CMsgFocusedNodeText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFocusedNodeText {
        CMsgFocusedNodeText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFocusedNodeText {
        static instance: CMsgFocusedNodeText = CMsgFocusedNodeText {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFocusedNodeText {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFocusedNodeText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFocusedNodeText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFocusedNodeText {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFocusedNodeTextResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFocusedNodeTextResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFocusedNodeTextResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFocusedNodeTextResponse.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFocusedNodeTextResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeTextResponse {
    fn default() -> &'a CMsgFocusedNodeTextResponse {
        <CMsgFocusedNodeTextResponse as crate::Message>::default_instance()
    }
}

impl CMsgFocusedNodeTextResponse {
    pub fn new() -> CMsgFocusedNodeTextResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFocusedNodeTextResponse| { &m.browser_handle },
            |m: &mut CMsgFocusedNodeTextResponse| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgFocusedNodeTextResponse| { &m.value },
            |m: &mut CMsgFocusedNodeTextResponse| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFocusedNodeTextResponse>(
            "CMsgFocusedNodeTextResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgFocusedNodeTextResponse {
    const NAME: &'static str = "CMsgFocusedNodeTextResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFocusedNodeTextResponse {
        CMsgFocusedNodeTextResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFocusedNodeTextResponse {
        static instance: CMsgFocusedNodeTextResponse = CMsgFocusedNodeTextResponse {
            browser_handle: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgFocusedNodeTextResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFocusedNodeTextResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFocusedNodeTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgFocusedNodeTextResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBuildID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBuildID {
    // message fields
    // @@protoc_insertion_point(field:CMsgBuildID.build_id)
    pub build_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBuildID.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBuildID {
    fn default() -> &'a CMsgBuildID {
        <CMsgBuildID as crate::Message>::default_instance()
    }
}

impl CMsgBuildID {
    pub fn new() -> CMsgBuildID {
        ::std::default::Default::default()
    }

    // optional uint64 build_id = 1;

    pub fn build_id(&self) -> u64 {
        self.build_id.unwrap_or(0)
    }

    pub fn clear_build_id(&mut self) {
        self.build_id = ::std::option::Option::None;
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: u64) {
        self.build_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_id",
            |m: &CMsgBuildID| { &m.build_id },
            |m: &mut CMsgBuildID| { &mut m.build_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBuildID>(
            "CMsgBuildID",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBuildID {
    const NAME: &'static str = "CMsgBuildID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.build_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.build_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.build_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBuildID {
        CMsgBuildID::new()
    }

    fn clear(&mut self) {
        self.build_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBuildID {
        static instance: CMsgBuildID = CMsgBuildID {
            build_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBuildID {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBuildID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBuildID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBuildID {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgOpenDevTools)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenDevTools {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenDevTools.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenDevTools.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenDevTools {
    fn default() -> &'a CMsgOpenDevTools {
        <CMsgOpenDevTools as crate::Message>::default_instance()
    }
}

impl CMsgOpenDevTools {
    pub fn new() -> CMsgOpenDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgOpenDevTools| { &m.browser_handle },
            |m: &mut CMsgOpenDevTools| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpenDevTools>(
            "CMsgOpenDevTools",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgOpenDevTools {
    const NAME: &'static str = "CMsgOpenDevTools";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenDevTools {
        CMsgOpenDevTools::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenDevTools {
        static instance: CMsgOpenDevTools = CMsgOpenDevTools {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgOpenDevTools {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpenDevTools").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpenDevTools {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgOpenDevTools {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCloseDevTools)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCloseDevTools {
    // message fields
    // @@protoc_insertion_point(field:CMsgCloseDevTools.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCloseDevTools.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCloseDevTools {
    fn default() -> &'a CMsgCloseDevTools {
        <CMsgCloseDevTools as crate::Message>::default_instance()
    }
}

impl CMsgCloseDevTools {
    pub fn new() -> CMsgCloseDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgCloseDevTools| { &m.browser_handle },
            |m: &mut CMsgCloseDevTools| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCloseDevTools>(
            "CMsgCloseDevTools",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCloseDevTools {
    const NAME: &'static str = "CMsgCloseDevTools";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCloseDevTools {
        CMsgCloseDevTools::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCloseDevTools {
        static instance: CMsgCloseDevTools = CMsgCloseDevTools {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCloseDevTools {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCloseDevTools").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCloseDevTools {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCloseDevTools {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgUnlockH264)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUnlockH264 {
    // message fields
    // @@protoc_insertion_point(field:CMsgUnlockH264.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUnlockH264.unlock_code)
    pub unlock_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUnlockH264.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUnlockH264 {
    fn default() -> &'a CMsgUnlockH264 {
        <CMsgUnlockH264 as crate::Message>::default_instance()
    }
}

impl CMsgUnlockH264 {
    pub fn new() -> CMsgUnlockH264 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string unlock_code = 2;

    pub fn unlock_code(&self) -> &str {
        match self.unlock_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unlock_code(&mut self) {
        self.unlock_code = ::std::option::Option::None;
    }

    pub fn has_unlock_code(&self) -> bool {
        self.unlock_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlock_code(&mut self, v: ::std::string::String) {
        self.unlock_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlock_code(&mut self) -> &mut ::std::string::String {
        if self.unlock_code.is_none() {
            self.unlock_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unlock_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlock_code(&mut self) -> ::std::string::String {
        self.unlock_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgUnlockH264| { &m.browser_handle },
            |m: &mut CMsgUnlockH264| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unlock_code",
            |m: &CMsgUnlockH264| { &m.unlock_code },
            |m: &mut CMsgUnlockH264| { &mut m.unlock_code },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUnlockH264>(
            "CMsgUnlockH264",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgUnlockH264 {
    const NAME: &'static str = "CMsgUnlockH264";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.unlock_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.unlock_code.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unlock_code.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUnlockH264 {
        CMsgUnlockH264::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unlock_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUnlockH264 {
        static instance: CMsgUnlockH264 = CMsgUnlockH264 {
            browser_handle: ::std::option::Option::None,
            unlock_code: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgUnlockH264 {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUnlockH264").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUnlockH264 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgUnlockH264 {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScreenInformationChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScreenInformationChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.override_width)
    pub override_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.override_height)
    pub override_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_left)
    pub monitor_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_top)
    pub monitor_top: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_right)
    pub monitor_right: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_bottom)
    pub monitor_bottom: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_left)
    pub usable_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_top)
    pub usable_top: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_right)
    pub usable_right: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_bottom)
    pub usable_bottom: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScreenInformationChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScreenInformationChanged {
    fn default() -> &'a CMsgScreenInformationChanged {
        <CMsgScreenInformationChanged as crate::Message>::default_instance()
    }
}

impl CMsgScreenInformationChanged {
    pub fn new() -> CMsgScreenInformationChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 override_width = 2;

    pub fn override_width(&self) -> u32 {
        self.override_width.unwrap_or(0)
    }

    pub fn clear_override_width(&mut self) {
        self.override_width = ::std::option::Option::None;
    }

    pub fn has_override_width(&self) -> bool {
        self.override_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_width(&mut self, v: u32) {
        self.override_width = ::std::option::Option::Some(v);
    }

    // optional uint32 override_height = 3;

    pub fn override_height(&self) -> u32 {
        self.override_height.unwrap_or(0)
    }

    pub fn clear_override_height(&mut self) {
        self.override_height = ::std::option::Option::None;
    }

    pub fn has_override_height(&self) -> bool {
        self.override_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_height(&mut self, v: u32) {
        self.override_height = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_left = 4;

    pub fn monitor_left(&self) -> u32 {
        self.monitor_left.unwrap_or(0)
    }

    pub fn clear_monitor_left(&mut self) {
        self.monitor_left = ::std::option::Option::None;
    }

    pub fn has_monitor_left(&self) -> bool {
        self.monitor_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_left(&mut self, v: u32) {
        self.monitor_left = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_top = 5;

    pub fn monitor_top(&self) -> u32 {
        self.monitor_top.unwrap_or(0)
    }

    pub fn clear_monitor_top(&mut self) {
        self.monitor_top = ::std::option::Option::None;
    }

    pub fn has_monitor_top(&self) -> bool {
        self.monitor_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_top(&mut self, v: u32) {
        self.monitor_top = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_right = 6;

    pub fn monitor_right(&self) -> u32 {
        self.monitor_right.unwrap_or(0)
    }

    pub fn clear_monitor_right(&mut self) {
        self.monitor_right = ::std::option::Option::None;
    }

    pub fn has_monitor_right(&self) -> bool {
        self.monitor_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_right(&mut self, v: u32) {
        self.monitor_right = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_bottom = 7;

    pub fn monitor_bottom(&self) -> u32 {
        self.monitor_bottom.unwrap_or(0)
    }

    pub fn clear_monitor_bottom(&mut self) {
        self.monitor_bottom = ::std::option::Option::None;
    }

    pub fn has_monitor_bottom(&self) -> bool {
        self.monitor_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_bottom(&mut self, v: u32) {
        self.monitor_bottom = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_left = 8;

    pub fn usable_left(&self) -> u32 {
        self.usable_left.unwrap_or(0)
    }

    pub fn clear_usable_left(&mut self) {
        self.usable_left = ::std::option::Option::None;
    }

    pub fn has_usable_left(&self) -> bool {
        self.usable_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_left(&mut self, v: u32) {
        self.usable_left = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_top = 9;

    pub fn usable_top(&self) -> u32 {
        self.usable_top.unwrap_or(0)
    }

    pub fn clear_usable_top(&mut self) {
        self.usable_top = ::std::option::Option::None;
    }

    pub fn has_usable_top(&self) -> bool {
        self.usable_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_top(&mut self, v: u32) {
        self.usable_top = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_right = 10;

    pub fn usable_right(&self) -> u32 {
        self.usable_right.unwrap_or(0)
    }

    pub fn clear_usable_right(&mut self) {
        self.usable_right = ::std::option::Option::None;
    }

    pub fn has_usable_right(&self) -> bool {
        self.usable_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_right(&mut self, v: u32) {
        self.usable_right = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_bottom = 11;

    pub fn usable_bottom(&self) -> u32 {
        self.usable_bottom.unwrap_or(0)
    }

    pub fn clear_usable_bottom(&mut self) {
        self.usable_bottom = ::std::option::Option::None;
    }

    pub fn has_usable_bottom(&self) -> bool {
        self.usable_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_bottom(&mut self, v: u32) {
        self.usable_bottom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScreenInformationChanged| { &m.browser_handle },
            |m: &mut CMsgScreenInformationChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_width",
            |m: &CMsgScreenInformationChanged| { &m.override_width },
            |m: &mut CMsgScreenInformationChanged| { &mut m.override_width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_height",
            |m: &CMsgScreenInformationChanged| { &m.override_height },
            |m: &mut CMsgScreenInformationChanged| { &mut m.override_height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_left",
            |m: &CMsgScreenInformationChanged| { &m.monitor_left },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_left },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_top",
            |m: &CMsgScreenInformationChanged| { &m.monitor_top },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_top },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_right",
            |m: &CMsgScreenInformationChanged| { &m.monitor_right },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_right },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_bottom",
            |m: &CMsgScreenInformationChanged| { &m.monitor_bottom },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_bottom },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_left",
            |m: &CMsgScreenInformationChanged| { &m.usable_left },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_left },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_top",
            |m: &CMsgScreenInformationChanged| { &m.usable_top },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_top },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_right",
            |m: &CMsgScreenInformationChanged| { &m.usable_right },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_right },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_bottom",
            |m: &CMsgScreenInformationChanged| { &m.usable_bottom },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_bottom },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScreenInformationChanged>(
            "CMsgScreenInformationChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgScreenInformationChanged {
    const NAME: &'static str = "CMsgScreenInformationChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.override_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.override_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.monitor_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.monitor_top = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.monitor_right = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.monitor_bottom = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.usable_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.usable_top = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.usable_right = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.usable_bottom = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.override_width {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.override_height {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.monitor_left {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.monitor_top {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.monitor_right {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.monitor_bottom {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.usable_left {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.usable_top {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.usable_right {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.usable_bottom {
            my_size += crate::rt::uint32_size(11, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.override_width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.override_height {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.monitor_left {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.monitor_top {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.monitor_right {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.monitor_bottom {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.usable_left {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.usable_top {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.usable_right {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.usable_bottom {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScreenInformationChanged {
        CMsgScreenInformationChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.override_width = ::std::option::Option::None;
        self.override_height = ::std::option::Option::None;
        self.monitor_left = ::std::option::Option::None;
        self.monitor_top = ::std::option::Option::None;
        self.monitor_right = ::std::option::Option::None;
        self.monitor_bottom = ::std::option::Option::None;
        self.usable_left = ::std::option::Option::None;
        self.usable_top = ::std::option::Option::None;
        self.usable_right = ::std::option::Option::None;
        self.usable_bottom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScreenInformationChanged {
        static instance: CMsgScreenInformationChanged = CMsgScreenInformationChanged {
            browser_handle: ::std::option::Option::None,
            override_width: ::std::option::Option::None,
            override_height: ::std::option::Option::None,
            monitor_left: ::std::option::Option::None,
            monitor_top: ::std::option::Option::None,
            monitor_right: ::std::option::Option::None,
            monitor_bottom: ::std::option::Option::None,
            usable_left: ::std::option::Option::None,
            usable_top: ::std::option::Option::None,
            usable_right: ::std::option::Option::None,
            usable_bottom: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgScreenInformationChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScreenInformationChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScreenInformationChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgScreenInformationChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearAllCookies)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearAllCookies {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearAllCookies.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearAllCookies.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllCookies {
    fn default() -> &'a CMsgClearAllCookies {
        <CMsgClearAllCookies as crate::Message>::default_instance()
    }
}

impl CMsgClearAllCookies {
    pub fn new() -> CMsgClearAllCookies {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClearAllCookies| { &m.browser_handle },
            |m: &mut CMsgClearAllCookies| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearAllCookies>(
            "CMsgClearAllCookies",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClearAllCookies {
    const NAME: &'static str = "CMsgClearAllCookies";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearAllCookies {
        CMsgClearAllCookies::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearAllCookies {
        static instance: CMsgClearAllCookies = CMsgClearAllCookies {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClearAllCookies {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearAllCookies").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearAllCookies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClearAllCookies {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScreenDPI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScreenDPI {
    // message fields
    // @@protoc_insertion_point(field:CMsgScreenDPI.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenDPI.dpi_scaling)
    pub dpi_scaling: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScreenDPI.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScreenDPI {
    fn default() -> &'a CMsgScreenDPI {
        <CMsgScreenDPI as crate::Message>::default_instance()
    }
}

impl CMsgScreenDPI {
    pub fn new() -> CMsgScreenDPI {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 2;

    pub fn dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }

    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScreenDPI| { &m.browser_handle },
            |m: &mut CMsgScreenDPI| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dpi_scaling",
            |m: &CMsgScreenDPI| { &m.dpi_scaling },
            |m: &mut CMsgScreenDPI| { &mut m.dpi_scaling },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScreenDPI>(
            "CMsgScreenDPI",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgScreenDPI {
    const NAME: &'static str = "CMsgScreenDPI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.dpi_scaling = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScreenDPI {
        CMsgScreenDPI::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScreenDPI {
        static instance: CMsgScreenDPI = CMsgScreenDPI {
            browser_handle: ::std::option::Option::None,
            dpi_scaling: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgScreenDPI {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScreenDPI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScreenDPI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgScreenDPI {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAckScreenDPI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckScreenDPI {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckScreenDPI.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckScreenDPI.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckScreenDPI {
    fn default() -> &'a CMsgAckScreenDPI {
        <CMsgAckScreenDPI as crate::Message>::default_instance()
    }
}

impl CMsgAckScreenDPI {
    pub fn new() -> CMsgAckScreenDPI {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgAckScreenDPI| { &m.browser_handle },
            |m: &mut CMsgAckScreenDPI| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAckScreenDPI>(
            "CMsgAckScreenDPI",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAckScreenDPI {
    const NAME: &'static str = "CMsgAckScreenDPI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckScreenDPI {
        CMsgAckScreenDPI::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckScreenDPI {
        static instance: CMsgAckScreenDPI = CMsgAckScreenDPI {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAckScreenDPI {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAckScreenDPI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAckScreenDPI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAckScreenDPI {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAuthedSteamDomains)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAuthedSteamDomains {
    // message fields
    // @@protoc_insertion_point(field:CMsgAuthedSteamDomains.domains)
    pub domains: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAuthedSteamDomains.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAuthedSteamDomains {
    fn default() -> &'a CMsgAuthedSteamDomains {
        <CMsgAuthedSteamDomains as crate::Message>::default_instance()
    }
}

impl CMsgAuthedSteamDomains {
    pub fn new() -> CMsgAuthedSteamDomains {
        ::std::default::Default::default()
    }

    // repeated string domains = 1;

    pub fn domains(&self) -> &[::std::string::String] {
        &self.domains
    }

    pub fn clear_domains(&mut self) {
        self.domains.clear();
    }

    // Param is passed by value, moved
    pub fn set_domains(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.domains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_domains(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.domains
    }

    // Take field
    pub fn take_domains(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.domains, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "domains",
            |m: &CMsgAuthedSteamDomains| { &m.domains },
            |m: &mut CMsgAuthedSteamDomains| { &mut m.domains },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAuthedSteamDomains>(
            "CMsgAuthedSteamDomains",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAuthedSteamDomains {
    const NAME: &'static str = "CMsgAuthedSteamDomains";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domains.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.domains {
            my_size += crate::rt::string_size(1, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.domains {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAuthedSteamDomains {
        CMsgAuthedSteamDomains::new()
    }

    fn clear(&mut self) {
        self.domains.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAuthedSteamDomains {
        static instance: CMsgAuthedSteamDomains = CMsgAuthedSteamDomains {
            domains: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAuthedSteamDomains {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAuthedSteamDomains").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAuthedSteamDomains {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAuthedSteamDomains {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamAuthNeeded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamAuthNeeded {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamAuthNeeded.filler)
    pub filler: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamAuthNeeded.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthNeeded {
    fn default() -> &'a CMsgSteamAuthNeeded {
        <CMsgSteamAuthNeeded as crate::Message>::default_instance()
    }
}

impl CMsgSteamAuthNeeded {
    pub fn new() -> CMsgSteamAuthNeeded {
        ::std::default::Default::default()
    }

    // optional bool filler = 1;

    pub fn filler(&self) -> bool {
        self.filler.unwrap_or(false)
    }

    pub fn clear_filler(&mut self) {
        self.filler = ::std::option::Option::None;
    }

    pub fn has_filler(&self) -> bool {
        self.filler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filler(&mut self, v: bool) {
        self.filler = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filler",
            |m: &CMsgSteamAuthNeeded| { &m.filler },
            |m: &mut CMsgSteamAuthNeeded| { &mut m.filler },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamAuthNeeded>(
            "CMsgSteamAuthNeeded",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSteamAuthNeeded {
    const NAME: &'static str = "CMsgSteamAuthNeeded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.filler = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filler {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.filler {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamAuthNeeded {
        CMsgSteamAuthNeeded::new()
    }

    fn clear(&mut self) {
        self.filler = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamAuthNeeded {
        static instance: CMsgSteamAuthNeeded = CMsgSteamAuthNeeded {
            filler: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSteamAuthNeeded {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamAuthNeeded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamAuthNeeded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSteamAuthNeeded {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamAuthCookiesSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamAuthCookiesSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamAuthCookiesSet.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamAuthCookiesSet.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthCookiesSet {
    fn default() -> &'a CMsgSteamAuthCookiesSet {
        <CMsgSteamAuthCookiesSet as crate::Message>::default_instance()
    }
}

impl CMsgSteamAuthCookiesSet {
    pub fn new() -> CMsgSteamAuthCookiesSet {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgSteamAuthCookiesSet| { &m.success },
            |m: &mut CMsgSteamAuthCookiesSet| { &mut m.success },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamAuthCookiesSet>(
            "CMsgSteamAuthCookiesSet",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSteamAuthCookiesSet {
    const NAME: &'static str = "CMsgSteamAuthCookiesSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamAuthCookiesSet {
        CMsgSteamAuthCookiesSet::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamAuthCookiesSet {
        static instance: CMsgSteamAuthCookiesSet = CMsgSteamAuthCookiesSet {
            success: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSteamAuthCookiesSet {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamAuthCookiesSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamAuthCookiesSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSteamAuthCookiesSet {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSRegisterMethod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSRegisterMethod {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.method_type)
    pub method_type: ::std::option::Option<crate::EnumOrUnknown<EJSRegisterMethodType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSRegisterMethod.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSRegisterMethod {
    fn default() -> &'a CMsgJSRegisterMethod {
        <CMsgJSRegisterMethod as crate::Message>::default_instance()
    }
}

impl CMsgJSRegisterMethod {
    pub fn new() -> CMsgJSRegisterMethod {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EJSRegisterMethodType method_type = 3;

    pub fn method_type(&self) -> EJSRegisterMethodType {
        match self.method_type {
            Some(e) => e.enum_value_or(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            None => EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid,
        }
    }

    pub fn clear_method_type(&mut self) {
        self.method_type = ::std::option::Option::None;
    }

    pub fn has_method_type(&self) -> bool {
        self.method_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_type(&mut self, v: EJSRegisterMethodType) {
        self.method_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSRegisterMethod| { &m.browser_handle },
            |m: &mut CMsgJSRegisterMethod| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgJSRegisterMethod| { &m.name },
            |m: &mut CMsgJSRegisterMethod| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_type",
            |m: &CMsgJSRegisterMethod| { &m.method_type },
            |m: &mut CMsgJSRegisterMethod| { &mut m.method_type },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSRegisterMethod>(
            "CMsgJSRegisterMethod",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSRegisterMethod {
    const NAME: &'static str = "CMsgJSRegisterMethod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.method_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.method_type {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.method_type {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSRegisterMethod {
        CMsgJSRegisterMethod::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.method_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSRegisterMethod {
        static instance: CMsgJSRegisterMethod = CMsgJSRegisterMethod {
            browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            method_type: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSRegisterMethod {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSRegisterMethod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSRegisterMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSRegisterMethod {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSValue.bool_value)
    pub bool_value: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.int_value)
    pub int_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgJSValue.uint_value)
    pub uint_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSValue.double_value)
    pub double_value: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgJSValue.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSValue.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJSValue.bytes_value)
    pub bytes_value: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgJSValue.is_array)
    pub is_array: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.array_values)
    pub array_values: ::std::vec::Vec<CMsgJSValue>,
    // @@protoc_insertion_point(field:CMsgJSValue.is_object)
    pub is_object: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.object_properties)
    pub object_properties: ::std::vec::Vec<cmsg_jsvalue::JSObjectProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSValue {
    fn default() -> &'a CMsgJSValue {
        <CMsgJSValue as crate::Message>::default_instance()
    }
}

impl CMsgJSValue {
    pub fn new() -> CMsgJSValue {
        ::std::default::Default::default()
    }

    // optional bool bool_value = 1;

    pub fn bool_value(&self) -> bool {
        self.bool_value.unwrap_or(false)
    }

    pub fn clear_bool_value(&mut self) {
        self.bool_value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        self.bool_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.bool_value = ::std::option::Option::Some(v);
    }

    // optional int32 int_value = 2;

    pub fn int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    // optional uint32 uint_value = 3;

    pub fn uint_value(&self) -> u32 {
        self.uint_value.unwrap_or(0)
    }

    pub fn clear_uint_value(&mut self) {
        self.uint_value = ::std::option::Option::None;
    }

    pub fn has_uint_value(&self) -> bool {
        self.uint_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint_value(&mut self, v: u32) {
        self.uint_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 4;

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }

    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 function_handle = 6;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    // optional bytes bytes_value = 12;

    pub fn bytes_value(&self) -> &[u8] {
        match self.bytes_value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_value(&mut self) {
        self.bytes_value = ::std::option::Option::None;
    }

    pub fn has_bytes_value(&self) -> bool {
        self.bytes_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_value(&mut self, v: ::bytes::Bytes) {
        self.bytes_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_value(&mut self) -> &mut ::bytes::Bytes {
        if self.bytes_value.is_none() {
            self.bytes_value = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.bytes_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_value(&mut self) -> ::bytes::Bytes {
        self.bytes_value.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool is_array = 8;

    pub fn is_array(&self) -> bool {
        self.is_array.unwrap_or(false)
    }

    pub fn clear_is_array(&mut self) {
        self.is_array = ::std::option::Option::None;
    }

    pub fn has_is_array(&self) -> bool {
        self.is_array.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_array(&mut self, v: bool) {
        self.is_array = ::std::option::Option::Some(v);
    }

    // repeated .CMsgJSValue array_values = 9;

    pub fn array_values(&self) -> &[CMsgJSValue] {
        &self.array_values
    }

    pub fn clear_array_values(&mut self) {
        self.array_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_array_values(&mut self, v: ::std::vec::Vec<CMsgJSValue>) {
        self.array_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_array_values(&mut self) -> &mut ::std::vec::Vec<CMsgJSValue> {
        &mut self.array_values
    }

    // Take field
    pub fn take_array_values(&mut self) -> ::std::vec::Vec<CMsgJSValue> {
        ::std::mem::replace(&mut self.array_values, ::std::vec::Vec::new())
    }

    // optional bool is_object = 10;

    pub fn is_object(&self) -> bool {
        self.is_object.unwrap_or(false)
    }

    pub fn clear_is_object(&mut self) {
        self.is_object = ::std::option::Option::None;
    }

    pub fn has_is_object(&self) -> bool {
        self.is_object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_object(&mut self, v: bool) {
        self.is_object = ::std::option::Option::Some(v);
    }

    // repeated .CMsgJSValue.JSObjectProperty object_properties = 11;

    pub fn object_properties(&self) -> &[cmsg_jsvalue::JSObjectProperty] {
        &self.object_properties
    }

    pub fn clear_object_properties(&mut self) {
        self.object_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_properties(&mut self, v: ::std::vec::Vec<cmsg_jsvalue::JSObjectProperty>) {
        self.object_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_properties(&mut self) -> &mut ::std::vec::Vec<cmsg_jsvalue::JSObjectProperty> {
        &mut self.object_properties
    }

    // Take field
    pub fn take_object_properties(&mut self) -> ::std::vec::Vec<cmsg_jsvalue::JSObjectProperty> {
        ::std::mem::replace(&mut self.object_properties, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bool_value",
            |m: &CMsgJSValue| { &m.bool_value },
            |m: &mut CMsgJSValue| { &mut m.bool_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_value",
            |m: &CMsgJSValue| { &m.int_value },
            |m: &mut CMsgJSValue| { &mut m.int_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint_value",
            |m: &CMsgJSValue| { &m.uint_value },
            |m: &mut CMsgJSValue| { &mut m.uint_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_value",
            |m: &CMsgJSValue| { &m.double_value },
            |m: &mut CMsgJSValue| { &mut m.double_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &CMsgJSValue| { &m.string_value },
            |m: &mut CMsgJSValue| { &mut m.string_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_handle",
            |m: &CMsgJSValue| { &m.function_handle },
            |m: &mut CMsgJSValue| { &mut m.function_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_value",
            |m: &CMsgJSValue| { &m.bytes_value },
            |m: &mut CMsgJSValue| { &mut m.bytes_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_array",
            |m: &CMsgJSValue| { &m.is_array },
            |m: &mut CMsgJSValue| { &mut m.is_array },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "array_values",
            |m: &CMsgJSValue| { &m.array_values },
            |m: &mut CMsgJSValue| { &mut m.array_values },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_object",
            |m: &CMsgJSValue| { &m.is_object },
            |m: &mut CMsgJSValue| { &mut m.is_object },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "object_properties",
            |m: &CMsgJSValue| { &m.object_properties },
            |m: &mut CMsgJSValue| { &mut m.object_properties },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSValue>(
            "CMsgJSValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSValue {
    const NAME: &'static str = "CMsgJSValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bool_value = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.int_value = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.uint_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.double_value = ::std::option::Option::Some(is.read_double()?);
                },
                42 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                98 => {
                    self.bytes_value = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                64 => {
                    self.is_array = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.array_values.push(is.read_message()?);
                },
                80 => {
                    self.is_object = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.object_properties.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bool_value {
            my_size += 1 + 1;
        }
        if let Some(v) = self.int_value {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.uint_value {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.double_value {
            my_size += 1 + 8;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.function_handle {
            my_size += crate::rt::uint64_size(6, v);
        }
        if let Some(v) = self.bytes_value.as_ref() {
            my_size += crate::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.is_array {
            my_size += 1 + 1;
        }
        for value in &self.array_values {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_object {
            my_size += 1 + 1;
        }
        for value in &self.object_properties {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.bool_value {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.uint_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.bytes_value.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.is_array {
            os.write_bool(8, v)?;
        }
        for v in &self.array_values {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.is_object {
            os.write_bool(10, v)?;
        }
        for v in &self.object_properties {
            crate::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSValue {
        CMsgJSValue::new()
    }

    fn clear(&mut self) {
        self.bool_value = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.uint_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.bytes_value = ::std::option::Option::None;
        self.is_array = ::std::option::Option::None;
        self.array_values.clear();
        self.is_object = ::std::option::Option::None;
        self.object_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSValue {
        static instance: CMsgJSValue = CMsgJSValue {
            bool_value: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            uint_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            bytes_value: ::std::option::Option::None,
            is_array: ::std::option::Option::None,
            array_values: ::std::vec::Vec::new(),
            is_object: ::std::option::Option::None,
            object_properties: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgJSValue`
pub mod cmsg_jsvalue {
    // @@protoc_insertion_point(message:CMsgJSValue.JSObjectProperty)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct JSObjectProperty {
        // message fields
        // @@protoc_insertion_point(field:CMsgJSValue.JSObjectProperty.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgJSValue.JSObjectProperty.value)
        pub value: crate::MessageField<super::CMsgJSValue>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgJSValue.JSObjectProperty.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a JSObjectProperty {
        fn default() -> &'a JSObjectProperty {
            <JSObjectProperty as crate::Message>::default_instance()
        }
    }

    impl JSObjectProperty {
        pub fn new() -> JSObjectProperty {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .CMsgJSValue value = 2;

        pub fn value(&self) -> &super::CMsgJSValue {
            self.value.as_ref().unwrap_or_else(|| <super::CMsgJSValue as crate::Message>::default_instance())
        }

        pub fn clear_value(&mut self) {
            self.value.clear();
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: super::CMsgJSValue) {
            self.value = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut super::CMsgJSValue {
            self.value.mut_or_insert_default()
        }

        // Take field
        pub fn take_value(&mut self) -> super::CMsgJSValue {
            self.value.take().unwrap_or_else(|| super::CMsgJSValue::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &JSObjectProperty| { &m.name },
                |m: &mut JSObjectProperty| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgJSValue>(
                "value",
                |m: &JSObjectProperty| { &m.value },
                |m: &mut JSObjectProperty| { &mut m.value },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<JSObjectProperty>(
                "CMsgJSValue.JSObjectProperty",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for JSObjectProperty {
        const NAME: &'static str = "JSObjectProperty";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.value)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> JSObjectProperty {
            JSObjectProperty::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static JSObjectProperty {
            static instance: JSObjectProperty = JSObjectProperty {
                name: ::std::option::Option::None,
                value: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for JSObjectProperty {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgJSValue.JSObjectProperty").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for JSObjectProperty {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for JSObjectProperty {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgJSMethodCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSMethodCall {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSMethodCall.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.arguments)
    pub arguments: ::std::vec::Vec<CMsgJSValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSMethodCall.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSMethodCall {
    fn default() -> &'a CMsgJSMethodCall {
        <CMsgJSMethodCall as crate::Message>::default_instance()
    }
}

impl CMsgJSMethodCall {
    pub fn new() -> CMsgJSMethodCall {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgJSValue arguments = 4;

    pub fn arguments(&self) -> &[CMsgJSValue] {
        &self.arguments
    }

    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::std::vec::Vec<CMsgJSValue>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::std::vec::Vec<CMsgJSValue> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::std::vec::Vec<CMsgJSValue> {
        ::std::mem::replace(&mut self.arguments, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSMethodCall| { &m.browser_handle },
            |m: &mut CMsgJSMethodCall| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_browser_handle",
            |m: &CMsgJSMethodCall| { &m.owning_browser_handle },
            |m: &mut CMsgJSMethodCall| { &mut m.owning_browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgJSMethodCall| { &m.name },
            |m: &mut CMsgJSMethodCall| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &CMsgJSMethodCall| { &m.arguments },
            |m: &mut CMsgJSMethodCall| { &mut m.arguments },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSMethodCall>(
            "CMsgJSMethodCall",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSMethodCall {
    const NAME: &'static str = "CMsgJSMethodCall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.arguments {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSMethodCall {
        CMsgJSMethodCall::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSMethodCall {
        static instance: CMsgJSMethodCall = CMsgJSMethodCall {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSMethodCall {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSMethodCall").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSMethodCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSMethodCall {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSExecuteCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSExecuteCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.arguments)
    pub arguments: ::std::vec::Vec<CMsgJSValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSExecuteCallback.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSExecuteCallback {
    fn default() -> &'a CMsgJSExecuteCallback {
        <CMsgJSExecuteCallback as crate::Message>::default_instance()
    }
}

impl CMsgJSExecuteCallback {
    pub fn new() -> CMsgJSExecuteCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 3;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    // repeated .CMsgJSValue arguments = 4;

    pub fn arguments(&self) -> &[CMsgJSValue] {
        &self.arguments
    }

    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::std::vec::Vec<CMsgJSValue>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::std::vec::Vec<CMsgJSValue> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::std::vec::Vec<CMsgJSValue> {
        ::std::mem::replace(&mut self.arguments, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSExecuteCallback| { &m.browser_handle },
            |m: &mut CMsgJSExecuteCallback| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_browser_handle",
            |m: &CMsgJSExecuteCallback| { &m.owning_browser_handle },
            |m: &mut CMsgJSExecuteCallback| { &mut m.owning_browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_handle",
            |m: &CMsgJSExecuteCallback| { &m.function_handle },
            |m: &mut CMsgJSExecuteCallback| { &mut m.function_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &CMsgJSExecuteCallback| { &m.arguments },
            |m: &mut CMsgJSExecuteCallback| { &mut m.arguments },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSExecuteCallback>(
            "CMsgJSExecuteCallback",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSExecuteCallback {
    const NAME: &'static str = "CMsgJSExecuteCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.function_handle {
            my_size += crate::rt::uint64_size(3, v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(3, v)?;
        }
        for v in &self.arguments {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSExecuteCallback {
        CMsgJSExecuteCallback::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSExecuteCallback {
        static instance: CMsgJSExecuteCallback = CMsgJSExecuteCallback {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSExecuteCallback {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSExecuteCallback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSExecuteCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSExecuteCallback {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSReleaseCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSReleaseCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSReleaseCallback.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSReleaseCallback {
    fn default() -> &'a CMsgJSReleaseCallback {
        <CMsgJSReleaseCallback as crate::Message>::default_instance()
    }
}

impl CMsgJSReleaseCallback {
    pub fn new() -> CMsgJSReleaseCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 3;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSReleaseCallback| { &m.browser_handle },
            |m: &mut CMsgJSReleaseCallback| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_browser_handle",
            |m: &CMsgJSReleaseCallback| { &m.owning_browser_handle },
            |m: &mut CMsgJSReleaseCallback| { &mut m.owning_browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_handle",
            |m: &CMsgJSReleaseCallback| { &m.function_handle },
            |m: &mut CMsgJSReleaseCallback| { &mut m.function_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSReleaseCallback>(
            "CMsgJSReleaseCallback",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSReleaseCallback {
    const NAME: &'static str = "CMsgJSReleaseCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.function_handle {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSReleaseCallback {
        CMsgJSReleaseCallback::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSReleaseCallback {
        static instance: CMsgJSReleaseCallback = CMsgJSReleaseCallback {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSReleaseCallback {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSReleaseCallback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSReleaseCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSReleaseCallback {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSRaiseException)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSRaiseException {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSRaiseException.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRaiseException.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRaiseException.exception)
    pub exception: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSRaiseException.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSRaiseException {
    fn default() -> &'a CMsgJSRaiseException {
        <CMsgJSRaiseException as crate::Message>::default_instance()
    }
}

impl CMsgJSRaiseException {
    pub fn new() -> CMsgJSRaiseException {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional string exception = 3;

    pub fn exception(&self) -> &str {
        match self.exception.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_exception(&mut self) {
        self.exception = ::std::option::Option::None;
    }

    pub fn has_exception(&self) -> bool {
        self.exception.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: ::std::string::String) {
        self.exception = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception(&mut self) -> &mut ::std::string::String {
        if self.exception.is_none() {
            self.exception = ::std::option::Option::Some(::std::string::String::new());
        }
        self.exception.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception(&mut self) -> ::std::string::String {
        self.exception.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSRaiseException| { &m.browser_handle },
            |m: &mut CMsgJSRaiseException| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owning_browser_handle",
            |m: &CMsgJSRaiseException| { &m.owning_browser_handle },
            |m: &mut CMsgJSRaiseException| { &mut m.owning_browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exception",
            |m: &CMsgJSRaiseException| { &m.exception },
            |m: &mut CMsgJSRaiseException| { &mut m.exception },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSRaiseException>(
            "CMsgJSRaiseException",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgJSRaiseException {
    const NAME: &'static str = "CMsgJSRaiseException";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.exception = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.exception.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.exception.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSRaiseException {
        CMsgJSRaiseException::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.exception = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSRaiseException {
        static instance: CMsgJSRaiseException = CMsgJSRaiseException {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            exception: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgJSRaiseException {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSRaiseException").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSRaiseException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgJSRaiseException {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLoadLocalization)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadLocalization {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadLocalization.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadLocalization.localization_path)
    pub localization_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadLocalization.language)
    pub language: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadLocalization.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadLocalization {
    fn default() -> &'a CMsgLoadLocalization {
        <CMsgLoadLocalization as crate::Message>::default_instance()
    }
}

impl CMsgLoadLocalization {
    pub fn new() -> CMsgLoadLocalization {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string localization_path = 2;

    pub fn localization_path(&self) -> &str {
        match self.localization_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localization_path(&mut self) {
        self.localization_path = ::std::option::Option::None;
    }

    pub fn has_localization_path(&self) -> bool {
        self.localization_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localization_path(&mut self, v: ::std::string::String) {
        self.localization_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localization_path(&mut self) -> &mut ::std::string::String {
        if self.localization_path.is_none() {
            self.localization_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localization_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_localization_path(&mut self) -> ::std::string::String {
        self.localization_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 3;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLoadLocalization| { &m.browser_handle },
            |m: &mut CMsgLoadLocalization| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "localization_path",
            |m: &CMsgLoadLocalization| { &m.localization_path },
            |m: &mut CMsgLoadLocalization| { &mut m.localization_path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgLoadLocalization| { &m.language },
            |m: &mut CMsgLoadLocalization| { &mut m.language },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLoadLocalization>(
            "CMsgLoadLocalization",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgLoadLocalization {
    const NAME: &'static str = "CMsgLoadLocalization";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.localization_path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.localization_path.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.localization_path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadLocalization {
        CMsgLoadLocalization::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.localization_path = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadLocalization {
        static instance: CMsgLoadLocalization = CMsgLoadLocalization {
            browser_handle: ::std::option::Option::None,
            localization_path: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgLoadLocalization {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLoadLocalization").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLoadLocalization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgLoadLocalization {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNotifyUserActivation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNotifyUserActivation {
    // message fields
    // @@protoc_insertion_point(field:CMsgNotifyUserActivation.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNotifyUserActivation.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNotifyUserActivation {
    fn default() -> &'a CMsgNotifyUserActivation {
        <CMsgNotifyUserActivation as crate::Message>::default_instance()
    }
}

impl CMsgNotifyUserActivation {
    pub fn new() -> CMsgNotifyUserActivation {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgNotifyUserActivation| { &m.browser_handle },
            |m: &mut CMsgNotifyUserActivation| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNotifyUserActivation>(
            "CMsgNotifyUserActivation",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNotifyUserActivation {
    const NAME: &'static str = "CMsgNotifyUserActivation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNotifyUserActivation {
        CMsgNotifyUserActivation::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNotifyUserActivation {
        static instance: CMsgNotifyUserActivation = CMsgNotifyUserActivation {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNotifyUserActivation {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNotifyUserActivation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNotifyUserActivation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNotifyUserActivation {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetNetFakeLocalSystemState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetNetFakeLocalSystemState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetNetFakeLocalSystemState.state)
    pub state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetNetFakeLocalSystemState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetNetFakeLocalSystemState {
    fn default() -> &'a CMsgSetNetFakeLocalSystemState {
        <CMsgSetNetFakeLocalSystemState as crate::Message>::default_instance()
    }
}

impl CMsgSetNetFakeLocalSystemState {
    pub fn new() -> CMsgSetNetFakeLocalSystemState {
        ::std::default::Default::default()
    }

    // optional uint32 state = 1;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CMsgSetNetFakeLocalSystemState| { &m.state },
            |m: &mut CMsgSetNetFakeLocalSystemState| { &mut m.state },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetNetFakeLocalSystemState>(
            "CMsgSetNetFakeLocalSystemState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetNetFakeLocalSystemState {
    const NAME: &'static str = "CMsgSetNetFakeLocalSystemState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.state {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetNetFakeLocalSystemState {
        CMsgSetNetFakeLocalSystemState::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetNetFakeLocalSystemState {
        static instance: CMsgSetNetFakeLocalSystemState = CMsgSetNetFakeLocalSystemState {
            state: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetNetFakeLocalSystemState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetNetFakeLocalSystemState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetNetFakeLocalSystemState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetNetFakeLocalSystemState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetGameOverlayTargetPIDs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetGameOverlayTargetPIDs {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetGameOverlayTargetPIDs.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetGameOverlayTargetPIDs.target_pid)
    pub target_pid: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetGameOverlayTargetPIDs.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetGameOverlayTargetPIDs {
    fn default() -> &'a CMsgSetGameOverlayTargetPIDs {
        <CMsgSetGameOverlayTargetPIDs as crate::Message>::default_instance()
    }
}

impl CMsgSetGameOverlayTargetPIDs {
    pub fn new() -> CMsgSetGameOverlayTargetPIDs {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated uint32 target_pid = 2;

    pub fn target_pid(&self) -> &[u32] {
        &self.target_pid
    }

    pub fn clear_target_pid(&mut self) {
        self.target_pid.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_pid(&mut self, v: ::std::vec::Vec<u32>) {
        self.target_pid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_pid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.target_pid
    }

    // Take field
    pub fn take_target_pid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.target_pid, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetGameOverlayTargetPIDs| { &m.browser_handle },
            |m: &mut CMsgSetGameOverlayTargetPIDs| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "target_pid",
            |m: &CMsgSetGameOverlayTargetPIDs| { &m.target_pid },
            |m: &mut CMsgSetGameOverlayTargetPIDs| { &mut m.target_pid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetGameOverlayTargetPIDs>(
            "CMsgSetGameOverlayTargetPIDs",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetGameOverlayTargetPIDs {
    const NAME: &'static str = "CMsgSetGameOverlayTargetPIDs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.target_pid)?;
                },
                16 => {
                    self.target_pid.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.target_pid {
            my_size += crate::rt::uint32_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.target_pid {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetGameOverlayTargetPIDs {
        CMsgSetGameOverlayTargetPIDs::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetGameOverlayTargetPIDs {
        static instance: CMsgSetGameOverlayTargetPIDs = CMsgSetGameOverlayTargetPIDs {
            browser_handle: ::std::option::Option::None,
            target_pid: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetGameOverlayTargetPIDs {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetGameOverlayTargetPIDs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetGameOverlayTargetPIDs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetGameOverlayTargetPIDs {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameOverlayTargetTextureID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameOverlayTargetTextureID {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.target_pid)
    pub target_pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.texture_handle)
    pub texture_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameOverlayTargetTextureID.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTargetTextureID {
    fn default() -> &'a CMsgGameOverlayTargetTextureID {
        <CMsgGameOverlayTargetTextureID as crate::Message>::default_instance()
    }
}

impl CMsgGameOverlayTargetTextureID {
    pub fn new() -> CMsgGameOverlayTargetTextureID {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_pid = 2;

    pub fn target_pid(&self) -> u32 {
        self.target_pid.unwrap_or(0)
    }

    pub fn clear_target_pid(&mut self) {
        self.target_pid = ::std::option::Option::None;
    }

    pub fn has_target_pid(&self) -> bool {
        self.target_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_pid(&mut self, v: u32) {
        self.target_pid = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_handle = 3;

    pub fn texture_handle(&self) -> u32 {
        self.texture_handle.unwrap_or(0)
    }

    pub fn clear_texture_handle(&mut self) {
        self.texture_handle = ::std::option::Option::None;
    }

    pub fn has_texture_handle(&self) -> bool {
        self.texture_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_handle(&mut self, v: u32) {
        self.texture_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGameOverlayTargetTextureID| { &m.browser_handle },
            |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_pid",
            |m: &CMsgGameOverlayTargetTextureID| { &m.target_pid },
            |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.target_pid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_handle",
            |m: &CMsgGameOverlayTargetTextureID| { &m.texture_handle },
            |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.texture_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameOverlayTargetTextureID>(
            "CMsgGameOverlayTargetTextureID",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGameOverlayTargetTextureID {
    const NAME: &'static str = "CMsgGameOverlayTargetTextureID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.texture_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_pid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.texture_handle {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.texture_handle {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameOverlayTargetTextureID {
        CMsgGameOverlayTargetTextureID::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid = ::std::option::Option::None;
        self.texture_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameOverlayTargetTextureID {
        static instance: CMsgGameOverlayTargetTextureID = CMsgGameOverlayTargetTextureID {
            browser_handle: ::std::option::Option::None,
            target_pid: ::std::option::Option::None,
            texture_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGameOverlayTargetTextureID {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameOverlayTargetTextureID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameOverlayTargetTextureID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGameOverlayTargetTextureID {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDraggableRegionsChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDraggableRegionsChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.rects)
    pub rects: ::std::vec::Vec<cmsg_draggable_regions_changed::DraggableRects>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDraggableRegionsChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDraggableRegionsChanged {
    fn default() -> &'a CMsgDraggableRegionsChanged {
        <CMsgDraggableRegionsChanged as crate::Message>::default_instance()
    }
}

impl CMsgDraggableRegionsChanged {
    pub fn new() -> CMsgDraggableRegionsChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated .CMsgDraggableRegionsChanged.DraggableRects rects = 2;

    pub fn rects(&self) -> &[cmsg_draggable_regions_changed::DraggableRects] {
        &self.rects
    }

    pub fn clear_rects(&mut self) {
        self.rects.clear();
    }

    // Param is passed by value, moved
    pub fn set_rects(&mut self, v: ::std::vec::Vec<cmsg_draggable_regions_changed::DraggableRects>) {
        self.rects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rects(&mut self) -> &mut ::std::vec::Vec<cmsg_draggable_regions_changed::DraggableRects> {
        &mut self.rects
    }

    // Take field
    pub fn take_rects(&mut self) -> ::std::vec::Vec<cmsg_draggable_regions_changed::DraggableRects> {
        ::std::mem::replace(&mut self.rects, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgDraggableRegionsChanged| { &m.browser_handle },
            |m: &mut CMsgDraggableRegionsChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rects",
            |m: &CMsgDraggableRegionsChanged| { &m.rects },
            |m: &mut CMsgDraggableRegionsChanged| { &mut m.rects },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDraggableRegionsChanged>(
            "CMsgDraggableRegionsChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDraggableRegionsChanged {
    const NAME: &'static str = "CMsgDraggableRegionsChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.rects.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.rects {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.rects {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDraggableRegionsChanged {
        CMsgDraggableRegionsChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDraggableRegionsChanged {
        static instance: CMsgDraggableRegionsChanged = CMsgDraggableRegionsChanged {
            browser_handle: ::std::option::Option::None,
            rects: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDraggableRegionsChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDraggableRegionsChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDraggableRegionsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDraggableRegionsChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDraggableRegionsChanged`
pub mod cmsg_draggable_regions_changed {
    // @@protoc_insertion_point(message:CMsgDraggableRegionsChanged.DraggableRects)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DraggableRects {
        // message fields
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.x)
        pub x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.y)
        pub y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.width)
        pub width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.height)
        pub height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.draggable)
        pub draggable: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDraggableRegionsChanged.DraggableRects.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DraggableRects {
        fn default() -> &'a DraggableRects {
            <DraggableRects as crate::Message>::default_instance()
        }
    }

    impl DraggableRects {
        pub fn new() -> DraggableRects {
            ::std::default::Default::default()
        }

        // optional int32 x = 1;

        pub fn x(&self) -> i32 {
            self.x.unwrap_or(0)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: i32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional int32 y = 2;

        pub fn y(&self) -> i32 {
            self.y.unwrap_or(0)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: i32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional int32 width = 3;

        pub fn width(&self) -> i32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: i32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional int32 height = 4;

        pub fn height(&self) -> i32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: i32) {
            self.height = ::std::option::Option::Some(v);
        }

        // optional bool draggable = 5;

        pub fn draggable(&self) -> bool {
            self.draggable.unwrap_or(false)
        }

        pub fn clear_draggable(&mut self) {
            self.draggable = ::std::option::Option::None;
        }

        pub fn has_draggable(&self) -> bool {
            self.draggable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_draggable(&mut self, v: bool) {
            self.draggable = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &DraggableRects| { &m.x },
                |m: &mut DraggableRects| { &mut m.x },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &DraggableRects| { &m.y },
                |m: &mut DraggableRects| { &mut m.y },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &DraggableRects| { &m.width },
                |m: &mut DraggableRects| { &mut m.width },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &DraggableRects| { &m.height },
                |m: &mut DraggableRects| { &mut m.height },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "draggable",
                |m: &DraggableRects| { &m.draggable },
                |m: &mut DraggableRects| { &mut m.draggable },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DraggableRects>(
                "CMsgDraggableRegionsChanged.DraggableRects",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DraggableRects {
        const NAME: &'static str = "DraggableRects";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.x = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.draggable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.y {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.width {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.height {
                my_size += crate::rt::int32_size(4, v);
            }
            if let Some(v) = self.draggable {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.x {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.width {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.height {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.draggable {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DraggableRects {
            DraggableRects::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.draggable = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DraggableRects {
            static instance: DraggableRects = DraggableRects {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                draggable: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DraggableRects {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDraggableRegionsChanged.DraggableRects").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DraggableRects {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DraggableRects {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgResizeGripChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResizeGripChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.height)
    pub height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgResizeGripChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResizeGripChanged {
    fn default() -> &'a CMsgResizeGripChanged {
        <CMsgResizeGripChanged as crate::Message>::default_instance()
    }
}

impl CMsgResizeGripChanged {
    pub fn new() -> CMsgResizeGripChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgResizeGripChanged| { &m.browser_handle },
            |m: &mut CMsgResizeGripChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgResizeGripChanged| { &m.width },
            |m: &mut CMsgResizeGripChanged| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgResizeGripChanged| { &m.height },
            |m: &mut CMsgResizeGripChanged| { &mut m.height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgResizeGripChanged>(
            "CMsgResizeGripChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgResizeGripChanged {
    const NAME: &'static str = "CMsgResizeGripChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResizeGripChanged {
        CMsgResizeGripChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResizeGripChanged {
        static instance: CMsgResizeGripChanged = CMsgResizeGripChanged {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgResizeGripChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgResizeGripChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgResizeGripChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgResizeGripChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetWindowPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetWindowPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.min_width)
    pub min_width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.min_height)
    pub min_height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.max_width)
    pub max_width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.max_height)
    pub max_height: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetWindowPosition.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetWindowPosition {
    fn default() -> &'a CMsgSetWindowPosition {
        <CMsgSetWindowPosition as crate::Message>::default_instance()
    }
}

impl CMsgSetWindowPosition {
    pub fn new() -> CMsgSetWindowPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double x = 2;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 3;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double width = 4;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 5;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double min_width = 6;

    pub fn min_width(&self) -> f64 {
        self.min_width.unwrap_or(0.)
    }

    pub fn clear_min_width(&mut self) {
        self.min_width = ::std::option::Option::None;
    }

    pub fn has_min_width(&self) -> bool {
        self.min_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_width(&mut self, v: f64) {
        self.min_width = ::std::option::Option::Some(v);
    }

    // optional double min_height = 7;

    pub fn min_height(&self) -> f64 {
        self.min_height.unwrap_or(0.)
    }

    pub fn clear_min_height(&mut self) {
        self.min_height = ::std::option::Option::None;
    }

    pub fn has_min_height(&self) -> bool {
        self.min_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_height(&mut self, v: f64) {
        self.min_height = ::std::option::Option::Some(v);
    }

    // optional double max_width = 8;

    pub fn max_width(&self) -> f64 {
        self.max_width.unwrap_or(0.)
    }

    pub fn clear_max_width(&mut self) {
        self.max_width = ::std::option::Option::None;
    }

    pub fn has_max_width(&self) -> bool {
        self.max_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_width(&mut self, v: f64) {
        self.max_width = ::std::option::Option::Some(v);
    }

    // optional double max_height = 9;

    pub fn max_height(&self) -> f64 {
        self.max_height.unwrap_or(0.)
    }

    pub fn clear_max_height(&mut self) {
        self.max_height = ::std::option::Option::None;
    }

    pub fn has_max_height(&self) -> bool {
        self.max_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_height(&mut self, v: f64) {
        self.max_height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetWindowPosition| { &m.browser_handle },
            |m: &mut CMsgSetWindowPosition| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgSetWindowPosition| { &m.x },
            |m: &mut CMsgSetWindowPosition| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgSetWindowPosition| { &m.y },
            |m: &mut CMsgSetWindowPosition| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgSetWindowPosition| { &m.width },
            |m: &mut CMsgSetWindowPosition| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgSetWindowPosition| { &m.height },
            |m: &mut CMsgSetWindowPosition| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_width",
            |m: &CMsgSetWindowPosition| { &m.min_width },
            |m: &mut CMsgSetWindowPosition| { &mut m.min_width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_height",
            |m: &CMsgSetWindowPosition| { &m.min_height },
            |m: &mut CMsgSetWindowPosition| { &mut m.min_height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_width",
            |m: &CMsgSetWindowPosition| { &m.max_width },
            |m: &mut CMsgSetWindowPosition| { &mut m.max_width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_height",
            |m: &CMsgSetWindowPosition| { &m.max_height },
            |m: &mut CMsgSetWindowPosition| { &mut m.max_height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetWindowPosition>(
            "CMsgSetWindowPosition",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetWindowPosition {
    const NAME: &'static str = "CMsgSetWindowPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.min_width = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.min_height = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.max_width = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.max_height = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.min_width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.min_height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max_width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max_height {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.min_width {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.min_height {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.max_width {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.max_height {
            os.write_double(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetWindowPosition {
        CMsgSetWindowPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.min_width = ::std::option::Option::None;
        self.min_height = ::std::option::Option::None;
        self.max_width = ::std::option::Option::None;
        self.max_height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetWindowPosition {
        static instance: CMsgSetWindowPosition = CMsgSetWindowPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            min_width: ::std::option::Option::None,
            min_height: ::std::option::Option::None,
            max_width: ::std::option::Option::None,
            max_height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetWindowPosition {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetWindowPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetWindowPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetWindowPosition {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowWindow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowWindow {
    fn default() -> &'a CMsgShowWindow {
        <CMsgShowWindow as crate::Message>::default_instance()
    }
}

impl CMsgShowWindow {
    pub fn new() -> CMsgShowWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowWindow| { &m.browser_handle },
            |m: &mut CMsgShowWindow| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowWindow>(
            "CMsgShowWindow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgShowWindow {
    const NAME: &'static str = "CMsgShowWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowWindow {
        CMsgShowWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowWindow {
        static instance: CMsgShowWindow = CMsgShowWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgShowWindow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgShowWindow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHideWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHideWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgHideWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHideWindow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHideWindow {
    fn default() -> &'a CMsgHideWindow {
        <CMsgHideWindow as crate::Message>::default_instance()
    }
}

impl CMsgHideWindow {
    pub fn new() -> CMsgHideWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHideWindow| { &m.browser_handle },
            |m: &mut CMsgHideWindow| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHideWindow>(
            "CMsgHideWindow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHideWindow {
    const NAME: &'static str = "CMsgHideWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHideWindow {
        CMsgHideWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHideWindow {
        static instance: CMsgHideWindow = CMsgHideWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHideWindow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHideWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHideWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHideWindow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBringWindowToFront)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBringWindowToFront {
    // message fields
    // @@protoc_insertion_point(field:CMsgBringWindowToFront.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBringWindowToFront.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBringWindowToFront {
    fn default() -> &'a CMsgBringWindowToFront {
        <CMsgBringWindowToFront as crate::Message>::default_instance()
    }
}

impl CMsgBringWindowToFront {
    pub fn new() -> CMsgBringWindowToFront {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBringWindowToFront| { &m.browser_handle },
            |m: &mut CMsgBringWindowToFront| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBringWindowToFront>(
            "CMsgBringWindowToFront",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBringWindowToFront {
    const NAME: &'static str = "CMsgBringWindowToFront";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBringWindowToFront {
        CMsgBringWindowToFront::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBringWindowToFront {
        static instance: CMsgBringWindowToFront = CMsgBringWindowToFront {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBringWindowToFront {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBringWindowToFront").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBringWindowToFront {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBringWindowToFront {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetForegroundWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetForegroundWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetForegroundWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetForegroundWindow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetForegroundWindow {
    fn default() -> &'a CMsgSetForegroundWindow {
        <CMsgSetForegroundWindow as crate::Message>::default_instance()
    }
}

impl CMsgSetForegroundWindow {
    pub fn new() -> CMsgSetForegroundWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetForegroundWindow| { &m.browser_handle },
            |m: &mut CMsgSetForegroundWindow| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetForegroundWindow>(
            "CMsgSetForegroundWindow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetForegroundWindow {
    const NAME: &'static str = "CMsgSetForegroundWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetForegroundWindow {
        CMsgSetForegroundWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetForegroundWindow {
        static instance: CMsgSetForegroundWindow = CMsgSetForegroundWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetForegroundWindow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetForegroundWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetForegroundWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetForegroundWindow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMaximizeRestoreWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMaximizeRestoreWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgMaximizeRestoreWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMaximizeRestoreWindow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMaximizeRestoreWindow {
    fn default() -> &'a CMsgMaximizeRestoreWindow {
        <CMsgMaximizeRestoreWindow as crate::Message>::default_instance()
    }
}

impl CMsgMaximizeRestoreWindow {
    pub fn new() -> CMsgMaximizeRestoreWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMaximizeRestoreWindow| { &m.browser_handle },
            |m: &mut CMsgMaximizeRestoreWindow| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMaximizeRestoreWindow>(
            "CMsgMaximizeRestoreWindow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMaximizeRestoreWindow {
    const NAME: &'static str = "CMsgMaximizeRestoreWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMaximizeRestoreWindow {
        CMsgMaximizeRestoreWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMaximizeRestoreWindow {
        static instance: CMsgMaximizeRestoreWindow = CMsgMaximizeRestoreWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMaximizeRestoreWindow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMaximizeRestoreWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMaximizeRestoreWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMaximizeRestoreWindow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMinimizeWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMinimizeWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgMinimizeWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMinimizeWindow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMinimizeWindow {
    fn default() -> &'a CMsgMinimizeWindow {
        <CMsgMinimizeWindow as crate::Message>::default_instance()
    }
}

impl CMsgMinimizeWindow {
    pub fn new() -> CMsgMinimizeWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMinimizeWindow| { &m.browser_handle },
            |m: &mut CMsgMinimizeWindow| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMinimizeWindow>(
            "CMsgMinimizeWindow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMinimizeWindow {
    const NAME: &'static str = "CMsgMinimizeWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMinimizeWindow {
        CMsgMinimizeWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMinimizeWindow {
        static instance: CMsgMinimizeWindow = CMsgMinimizeWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMinimizeWindow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMinimizeWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMinimizeWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMinimizeWindow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowBrowserContextMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowBrowserContextMenu {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.custom_commands)
    pub custom_commands: ::std::vec::Vec<cmsg_show_browser_context_menu::ContextCommand>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.type_flags)
    pub type_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.page_url)
    pub page_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.coord_x)
    pub coord_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.coord_y)
    pub coord_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.link_url)
    pub link_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.unfiltered_link_url)
    pub unfiltered_link_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.selection_text)
    pub selection_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.misspelled_word)
    pub misspelled_word: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.edit_state_flags)
    pub edit_state_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowBrowserContextMenu.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowBrowserContextMenu {
    fn default() -> &'a CMsgShowBrowserContextMenu {
        <CMsgShowBrowserContextMenu as crate::Message>::default_instance()
    }
}

impl CMsgShowBrowserContextMenu {
    pub fn new() -> CMsgShowBrowserContextMenu {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated .CMsgShowBrowserContextMenu.ContextCommand custom_commands = 2;

    pub fn custom_commands(&self) -> &[cmsg_show_browser_context_menu::ContextCommand] {
        &self.custom_commands
    }

    pub fn clear_custom_commands(&mut self) {
        self.custom_commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_commands(&mut self, v: ::std::vec::Vec<cmsg_show_browser_context_menu::ContextCommand>) {
        self.custom_commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_commands(&mut self) -> &mut ::std::vec::Vec<cmsg_show_browser_context_menu::ContextCommand> {
        &mut self.custom_commands
    }

    // Take field
    pub fn take_custom_commands(&mut self) -> ::std::vec::Vec<cmsg_show_browser_context_menu::ContextCommand> {
        ::std::mem::replace(&mut self.custom_commands, ::std::vec::Vec::new())
    }

    // optional uint32 type_flags = 3;

    pub fn type_flags(&self) -> u32 {
        self.type_flags.unwrap_or(0)
    }

    pub fn clear_type_flags(&mut self) {
        self.type_flags = ::std::option::Option::None;
    }

    pub fn has_type_flags(&self) -> bool {
        self.type_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_flags(&mut self, v: u32) {
        self.type_flags = ::std::option::Option::Some(v);
    }

    // optional string page_url = 4;

    pub fn page_url(&self) -> &str {
        match self.page_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_page_url(&mut self) {
        self.page_url = ::std::option::Option::None;
    }

    pub fn has_page_url(&self) -> bool {
        self.page_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_url(&mut self, v: ::std::string::String) {
        self.page_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_url(&mut self) -> &mut ::std::string::String {
        if self.page_url.is_none() {
            self.page_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.page_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_page_url(&mut self) -> ::std::string::String {
        self.page_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 coord_x = 5;

    pub fn coord_x(&self) -> i32 {
        self.coord_x.unwrap_or(0)
    }

    pub fn clear_coord_x(&mut self) {
        self.coord_x = ::std::option::Option::None;
    }

    pub fn has_coord_x(&self) -> bool {
        self.coord_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coord_x(&mut self, v: i32) {
        self.coord_x = ::std::option::Option::Some(v);
    }

    // optional int32 coord_y = 6;

    pub fn coord_y(&self) -> i32 {
        self.coord_y.unwrap_or(0)
    }

    pub fn clear_coord_y(&mut self) {
        self.coord_y = ::std::option::Option::None;
    }

    pub fn has_coord_y(&self) -> bool {
        self.coord_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coord_y(&mut self, v: i32) {
        self.coord_y = ::std::option::Option::Some(v);
    }

    // optional string link_url = 7;

    pub fn link_url(&self) -> &str {
        match self.link_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_link_url(&mut self) {
        self.link_url = ::std::option::Option::None;
    }

    pub fn has_link_url(&self) -> bool {
        self.link_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_url(&mut self, v: ::std::string::String) {
        self.link_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_url(&mut self) -> &mut ::std::string::String {
        if self.link_url.is_none() {
            self.link_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.link_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_link_url(&mut self) -> ::std::string::String {
        self.link_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unfiltered_link_url = 8;

    pub fn unfiltered_link_url(&self) -> &str {
        match self.unfiltered_link_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unfiltered_link_url(&mut self) {
        self.unfiltered_link_url = ::std::option::Option::None;
    }

    pub fn has_unfiltered_link_url(&self) -> bool {
        self.unfiltered_link_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unfiltered_link_url(&mut self, v: ::std::string::String) {
        self.unfiltered_link_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unfiltered_link_url(&mut self) -> &mut ::std::string::String {
        if self.unfiltered_link_url.is_none() {
            self.unfiltered_link_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unfiltered_link_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_unfiltered_link_url(&mut self) -> ::std::string::String {
        self.unfiltered_link_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string selection_text = 9;

    pub fn selection_text(&self) -> &str {
        match self.selection_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selection_text(&mut self) {
        self.selection_text = ::std::option::Option::None;
    }

    pub fn has_selection_text(&self) -> bool {
        self.selection_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_text(&mut self, v: ::std::string::String) {
        self.selection_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selection_text(&mut self) -> &mut ::std::string::String {
        if self.selection_text.is_none() {
            self.selection_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selection_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_selection_text(&mut self) -> ::std::string::String {
        self.selection_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string misspelled_word = 10;

    pub fn misspelled_word(&self) -> &str {
        match self.misspelled_word.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_misspelled_word(&mut self) {
        self.misspelled_word = ::std::option::Option::None;
    }

    pub fn has_misspelled_word(&self) -> bool {
        self.misspelled_word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_misspelled_word(&mut self, v: ::std::string::String) {
        self.misspelled_word = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_misspelled_word(&mut self) -> &mut ::std::string::String {
        if self.misspelled_word.is_none() {
            self.misspelled_word = ::std::option::Option::Some(::std::string::String::new());
        }
        self.misspelled_word.as_mut().unwrap()
    }

    // Take field
    pub fn take_misspelled_word(&mut self) -> ::std::string::String {
        self.misspelled_word.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 edit_state_flags = 11;

    pub fn edit_state_flags(&self) -> u32 {
        self.edit_state_flags.unwrap_or(0)
    }

    pub fn clear_edit_state_flags(&mut self) {
        self.edit_state_flags = ::std::option::Option::None;
    }

    pub fn has_edit_state_flags(&self) -> bool {
        self.edit_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_state_flags(&mut self, v: u32) {
        self.edit_state_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowBrowserContextMenu| { &m.browser_handle },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_commands",
            |m: &CMsgShowBrowserContextMenu| { &m.custom_commands },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.custom_commands },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_flags",
            |m: &CMsgShowBrowserContextMenu| { &m.type_flags },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.type_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_url",
            |m: &CMsgShowBrowserContextMenu| { &m.page_url },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.page_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "coord_x",
            |m: &CMsgShowBrowserContextMenu| { &m.coord_x },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.coord_x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "coord_y",
            |m: &CMsgShowBrowserContextMenu| { &m.coord_y },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.coord_y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "link_url",
            |m: &CMsgShowBrowserContextMenu| { &m.link_url },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.link_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unfiltered_link_url",
            |m: &CMsgShowBrowserContextMenu| { &m.unfiltered_link_url },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.unfiltered_link_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "selection_text",
            |m: &CMsgShowBrowserContextMenu| { &m.selection_text },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.selection_text },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "misspelled_word",
            |m: &CMsgShowBrowserContextMenu| { &m.misspelled_word },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.misspelled_word },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edit_state_flags",
            |m: &CMsgShowBrowserContextMenu| { &m.edit_state_flags },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.edit_state_flags },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowBrowserContextMenu>(
            "CMsgShowBrowserContextMenu",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgShowBrowserContextMenu {
    const NAME: &'static str = "CMsgShowBrowserContextMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.custom_commands.push(is.read_message()?);
                },
                24 => {
                    self.type_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.page_url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.coord_x = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.coord_y = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.link_url = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.unfiltered_link_url = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.selection_text = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.misspelled_word = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.edit_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.custom_commands {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.type_flags {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.page_url.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.coord_x {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.coord_y {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.link_url.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.unfiltered_link_url.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.selection_text.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        if let Some(v) = self.misspelled_word.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        if let Some(v) = self.edit_state_flags {
            my_size += crate::rt::uint32_size(11, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.custom_commands {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.type_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.coord_x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.coord_y {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.link_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.unfiltered_link_url.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.selection_text.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.misspelled_word.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.edit_state_flags {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowBrowserContextMenu {
        CMsgShowBrowserContextMenu::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.custom_commands.clear();
        self.type_flags = ::std::option::Option::None;
        self.page_url = ::std::option::Option::None;
        self.coord_x = ::std::option::Option::None;
        self.coord_y = ::std::option::Option::None;
        self.link_url = ::std::option::Option::None;
        self.unfiltered_link_url = ::std::option::Option::None;
        self.selection_text = ::std::option::Option::None;
        self.misspelled_word = ::std::option::Option::None;
        self.edit_state_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowBrowserContextMenu {
        static instance: CMsgShowBrowserContextMenu = CMsgShowBrowserContextMenu {
            browser_handle: ::std::option::Option::None,
            custom_commands: ::std::vec::Vec::new(),
            type_flags: ::std::option::Option::None,
            page_url: ::std::option::Option::None,
            coord_x: ::std::option::Option::None,
            coord_y: ::std::option::Option::None,
            link_url: ::std::option::Option::None,
            unfiltered_link_url: ::std::option::Option::None,
            selection_text: ::std::option::Option::None,
            misspelled_word: ::std::option::Option::None,
            edit_state_flags: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgShowBrowserContextMenu {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowBrowserContextMenu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowBrowserContextMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgShowBrowserContextMenu {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgShowBrowserContextMenu`
pub mod cmsg_show_browser_context_menu {
    // @@protoc_insertion_point(message:CMsgShowBrowserContextMenu.ContextCommand)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ContextCommand {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.ContextCommand.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.ContextCommand.label)
        pub label: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowBrowserContextMenu.ContextCommand.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContextCommand {
        fn default() -> &'a ContextCommand {
            <ContextCommand as crate::Message>::default_instance()
        }
    }

    impl ContextCommand {
        pub fn new() -> ContextCommand {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string label = 2;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &ContextCommand| { &m.id },
                |m: &mut ContextCommand| { &mut m.id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "label",
                |m: &ContextCommand| { &m.label },
                |m: &mut ContextCommand| { &mut m.label },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ContextCommand>(
                "CMsgShowBrowserContextMenu.ContextCommand",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ContextCommand {
        const NAME: &'static str = "ContextCommand";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.label.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.label.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContextCommand {
            ContextCommand::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.label = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContextCommand {
            static instance: ContextCommand = ContextCommand {
                id: ::std::option::Option::None,
                label: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ContextCommand {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgShowBrowserContextMenu.ContextCommand").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ContextCommand {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ContextCommand {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgHandleContextMenuCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHandleContextMenuCommand {
    // message fields
    // @@protoc_insertion_point(field:CMsgHandleContextMenuCommand.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHandleContextMenuCommand.command_id)
    pub command_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHandleContextMenuCommand.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHandleContextMenuCommand {
    fn default() -> &'a CMsgHandleContextMenuCommand {
        <CMsgHandleContextMenuCommand as crate::Message>::default_instance()
    }
}

impl CMsgHandleContextMenuCommand {
    pub fn new() -> CMsgHandleContextMenuCommand {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 command_id = 2;

    pub fn command_id(&self) -> i32 {
        self.command_id.unwrap_or(0)
    }

    pub fn clear_command_id(&mut self) {
        self.command_id = ::std::option::Option::None;
    }

    pub fn has_command_id(&self) -> bool {
        self.command_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_id(&mut self, v: i32) {
        self.command_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHandleContextMenuCommand| { &m.browser_handle },
            |m: &mut CMsgHandleContextMenuCommand| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "command_id",
            |m: &CMsgHandleContextMenuCommand| { &m.command_id },
            |m: &mut CMsgHandleContextMenuCommand| { &mut m.command_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHandleContextMenuCommand>(
            "CMsgHandleContextMenuCommand",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgHandleContextMenuCommand {
    const NAME: &'static str = "CMsgHandleContextMenuCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.command_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.command_id {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.command_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHandleContextMenuCommand {
        CMsgHandleContextMenuCommand::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.command_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHandleContextMenuCommand {
        static instance: CMsgHandleContextMenuCommand = CMsgHandleContextMenuCommand {
            browser_handle: ::std::option::Option::None,
            command_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgHandleContextMenuCommand {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHandleContextMenuCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHandleContextMenuCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgHandleContextMenuCommand {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTouchGesture)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTouchGesture {
    // message fields
    // @@protoc_insertion_point(field:CMsgTouchGesture.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.gesture)
    pub gesture: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.tap_count)
    pub tap_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.pinch_scale)
    pub pinch_scale: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTouchGesture.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTouchGesture {
    fn default() -> &'a CMsgTouchGesture {
        <CMsgTouchGesture as crate::Message>::default_instance()
    }
}

impl CMsgTouchGesture {
    pub fn new() -> CMsgTouchGesture {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 id = 2;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 gesture = 3;

    pub fn gesture(&self) -> u32 {
        self.gesture.unwrap_or(0)
    }

    pub fn clear_gesture(&mut self) {
        self.gesture = ::std::option::Option::None;
    }

    pub fn has_gesture(&self) -> bool {
        self.gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gesture(&mut self, v: u32) {
        self.gesture = ::std::option::Option::Some(v);
    }

    // optional double x = 4;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 5;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double width = 6;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 7;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 tap_count = 8;

    pub fn tap_count(&self) -> u32 {
        self.tap_count.unwrap_or(0)
    }

    pub fn clear_tap_count(&mut self) {
        self.tap_count = ::std::option::Option::None;
    }

    pub fn has_tap_count(&self) -> bool {
        self.tap_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tap_count(&mut self, v: u32) {
        self.tap_count = ::std::option::Option::Some(v);
    }

    // optional double pinch_scale = 9;

    pub fn pinch_scale(&self) -> f64 {
        self.pinch_scale.unwrap_or(0.)
    }

    pub fn clear_pinch_scale(&mut self) {
        self.pinch_scale = ::std::option::Option::None;
    }

    pub fn has_pinch_scale(&self) -> bool {
        self.pinch_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinch_scale(&mut self, v: f64) {
        self.pinch_scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgTouchGesture| { &m.browser_handle },
            |m: &mut CMsgTouchGesture| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgTouchGesture| { &m.id },
            |m: &mut CMsgTouchGesture| { &mut m.id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gesture",
            |m: &CMsgTouchGesture| { &m.gesture },
            |m: &mut CMsgTouchGesture| { &mut m.gesture },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgTouchGesture| { &m.x },
            |m: &mut CMsgTouchGesture| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgTouchGesture| { &m.y },
            |m: &mut CMsgTouchGesture| { &mut m.y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgTouchGesture| { &m.width },
            |m: &mut CMsgTouchGesture| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgTouchGesture| { &m.height },
            |m: &mut CMsgTouchGesture| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tap_count",
            |m: &CMsgTouchGesture| { &m.tap_count },
            |m: &mut CMsgTouchGesture| { &mut m.tap_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pinch_scale",
            |m: &CMsgTouchGesture| { &m.pinch_scale },
            |m: &mut CMsgTouchGesture| { &mut m.pinch_scale },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTouchGesture>(
            "CMsgTouchGesture",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgTouchGesture {
    const NAME: &'static str = "CMsgTouchGesture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.gesture = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                64 => {
                    self.tap_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                73 => {
                    self.pinch_scale = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.gesture {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tap_count {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.pinch_scale {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gesture {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.tap_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pinch_scale {
            os.write_double(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTouchGesture {
        CMsgTouchGesture::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.gesture = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.tap_count = ::std::option::Option::None;
        self.pinch_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTouchGesture {
        static instance: CMsgTouchGesture = CMsgTouchGesture {
            browser_handle: ::std::option::Option::None,
            id: ::std::option::Option::None,
            gesture: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            tap_count: ::std::option::Option::None,
            pinch_scale: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgTouchGesture {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTouchGesture").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTouchGesture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgTouchGesture {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetTouchGesturesToCancel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTouchGesturesToCancel {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTouchGesturesToCancel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetTouchGesturesToCancel.gestures)
    pub gestures: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTouchGesturesToCancel.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTouchGesturesToCancel {
    fn default() -> &'a CMsgSetTouchGesturesToCancel {
        <CMsgSetTouchGesturesToCancel as crate::Message>::default_instance()
    }
}

impl CMsgSetTouchGesturesToCancel {
    pub fn new() -> CMsgSetTouchGesturesToCancel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated uint32 gestures = 2;

    pub fn gestures(&self) -> &[u32] {
        &self.gestures
    }

    pub fn clear_gestures(&mut self) {
        self.gestures.clear();
    }

    // Param is passed by value, moved
    pub fn set_gestures(&mut self, v: ::std::vec::Vec<u32>) {
        self.gestures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gestures(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.gestures
    }

    // Take field
    pub fn take_gestures(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.gestures, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetTouchGesturesToCancel| { &m.browser_handle },
            |m: &mut CMsgSetTouchGesturesToCancel| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gestures",
            |m: &CMsgSetTouchGesturesToCancel| { &m.gestures },
            |m: &mut CMsgSetTouchGesturesToCancel| { &mut m.gestures },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetTouchGesturesToCancel>(
            "CMsgSetTouchGesturesToCancel",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetTouchGesturesToCancel {
    const NAME: &'static str = "CMsgSetTouchGesturesToCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.gestures)?;
                },
                16 => {
                    self.gestures.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.gestures {
            my_size += crate::rt::uint32_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.gestures {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTouchGesturesToCancel {
        CMsgSetTouchGesturesToCancel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.gestures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTouchGesturesToCancel {
        static instance: CMsgSetTouchGesturesToCancel = CMsgSetTouchGesturesToCancel {
            browser_handle: ::std::option::Option::None,
            gestures: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetTouchGesturesToCancel {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetTouchGesturesToCancel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetTouchGesturesToCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetTouchGesturesToCancel {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeSetComposition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeSetComposition {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeSetComposition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeSetComposition.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeSetComposition.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeSetComposition {
    fn default() -> &'a CMsgImeSetComposition {
        <CMsgImeSetComposition as crate::Message>::default_instance()
    }
}

impl CMsgImeSetComposition {
    pub fn new() -> CMsgImeSetComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeSetComposition| { &m.browser_handle },
            |m: &mut CMsgImeSetComposition| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgImeSetComposition| { &m.text },
            |m: &mut CMsgImeSetComposition| { &mut m.text },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeSetComposition>(
            "CMsgImeSetComposition",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgImeSetComposition {
    const NAME: &'static str = "CMsgImeSetComposition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeSetComposition {
        CMsgImeSetComposition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeSetComposition {
        static instance: CMsgImeSetComposition = CMsgImeSetComposition {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgImeSetComposition {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeSetComposition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeSetComposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgImeSetComposition {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeCommitText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCommitText {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCommitText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCommitText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCommitText.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCommitText {
    fn default() -> &'a CMsgImeCommitText {
        <CMsgImeCommitText as crate::Message>::default_instance()
    }
}

impl CMsgImeCommitText {
    pub fn new() -> CMsgImeCommitText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeCommitText| { &m.browser_handle },
            |m: &mut CMsgImeCommitText| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgImeCommitText| { &m.text },
            |m: &mut CMsgImeCommitText| { &mut m.text },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeCommitText>(
            "CMsgImeCommitText",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgImeCommitText {
    const NAME: &'static str = "CMsgImeCommitText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCommitText {
        CMsgImeCommitText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCommitText {
        static instance: CMsgImeCommitText = CMsgImeCommitText {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgImeCommitText {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeCommitText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeCommitText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgImeCommitText {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeCancelComposition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCancelComposition {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCancelComposition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCancelComposition.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCancelComposition {
    fn default() -> &'a CMsgImeCancelComposition {
        <CMsgImeCancelComposition as crate::Message>::default_instance()
    }
}

impl CMsgImeCancelComposition {
    pub fn new() -> CMsgImeCancelComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeCancelComposition| { &m.browser_handle },
            |m: &mut CMsgImeCancelComposition| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeCancelComposition>(
            "CMsgImeCancelComposition",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgImeCancelComposition {
    const NAME: &'static str = "CMsgImeCancelComposition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCancelComposition {
        CMsgImeCancelComposition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCancelComposition {
        static instance: CMsgImeCancelComposition = CMsgImeCancelComposition {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgImeCancelComposition {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeCancelComposition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeCancelComposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgImeCancelComposition {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeCompositionRangeChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCompositionRangeChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCompositionRangeChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCompositionRangeChanged {
    fn default() -> &'a CMsgImeCompositionRangeChanged {
        <CMsgImeCompositionRangeChanged as crate::Message>::default_instance()
    }
}

impl CMsgImeCompositionRangeChanged {
    pub fn new() -> CMsgImeCompositionRangeChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeCompositionRangeChanged| { &m.browser_handle },
            |m: &mut CMsgImeCompositionRangeChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgImeCompositionRangeChanged| { &m.x },
            |m: &mut CMsgImeCompositionRangeChanged| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgImeCompositionRangeChanged| { &m.y },
            |m: &mut CMsgImeCompositionRangeChanged| { &mut m.y },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeCompositionRangeChanged>(
            "CMsgImeCompositionRangeChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgImeCompositionRangeChanged {
    const NAME: &'static str = "CMsgImeCompositionRangeChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCompositionRangeChanged {
        CMsgImeCompositionRangeChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCompositionRangeChanged {
        static instance: CMsgImeCompositionRangeChanged = CMsgImeCompositionRangeChanged {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgImeCompositionRangeChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeCompositionRangeChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeCompositionRangeChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgImeCompositionRangeChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgInspectElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInspectElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgInspectElement.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInspectElement.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInspectElement.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInspectElement.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInspectElement {
    fn default() -> &'a CMsgInspectElement {
        <CMsgInspectElement as crate::Message>::default_instance()
    }
}

impl CMsgInspectElement {
    pub fn new() -> CMsgInspectElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgInspectElement| { &m.browser_handle },
            |m: &mut CMsgInspectElement| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgInspectElement| { &m.x },
            |m: &mut CMsgInspectElement| { &mut m.x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgInspectElement| { &m.y },
            |m: &mut CMsgInspectElement| { &mut m.y },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInspectElement>(
            "CMsgInspectElement",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgInspectElement {
    const NAME: &'static str = "CMsgInspectElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInspectElement {
        CMsgInspectElement::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInspectElement {
        static instance: CMsgInspectElement = CMsgInspectElement {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgInspectElement {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInspectElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInspectElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgInspectElement {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDisableF5)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDisableF5 {
    // message fields
    // @@protoc_insertion_point(field:CMsgDisableF5.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDisableF5.disable)
    pub disable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDisableF5.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDisableF5 {
    fn default() -> &'a CMsgDisableF5 {
        <CMsgDisableF5 as crate::Message>::default_instance()
    }
}

impl CMsgDisableF5 {
    pub fn new() -> CMsgDisableF5 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool disable = 2;

    pub fn disable(&self) -> bool {
        self.disable.unwrap_or(false)
    }

    pub fn clear_disable(&mut self) {
        self.disable = ::std::option::Option::None;
    }

    pub fn has_disable(&self) -> bool {
        self.disable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable(&mut self, v: bool) {
        self.disable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgDisableF5| { &m.browser_handle },
            |m: &mut CMsgDisableF5| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable",
            |m: &CMsgDisableF5| { &m.disable },
            |m: &mut CMsgDisableF5| { &mut m.disable },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDisableF5>(
            "CMsgDisableF5",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgDisableF5 {
    const NAME: &'static str = "CMsgDisableF5";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.disable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.disable {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.disable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDisableF5 {
        CMsgDisableF5::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.disable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDisableF5 {
        static instance: CMsgDisableF5 = CMsgDisableF5 {
            browser_handle: ::std::option::Option::None,
            disable: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgDisableF5 {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDisableF5").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDisableF5 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgDisableF5 {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStartDownload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartDownload {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartDownload.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartDownload.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartDownload.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartDownload {
    fn default() -> &'a CMsgStartDownload {
        <CMsgStartDownload as crate::Message>::default_instance()
    }
}

impl CMsgStartDownload {
    pub fn new() -> CMsgStartDownload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStartDownload| { &m.browser_handle },
            |m: &mut CMsgStartDownload| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgStartDownload| { &m.url },
            |m: &mut CMsgStartDownload| { &mut m.url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartDownload>(
            "CMsgStartDownload",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgStartDownload {
    const NAME: &'static str = "CMsgStartDownload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartDownload {
        CMsgStartDownload::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartDownload {
        static instance: CMsgStartDownload = CMsgStartDownload {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgStartDownload {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartDownload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartDownload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgStartDownload {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetTopWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTopWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTopWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTopWindow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTopWindow {
    fn default() -> &'a CMsgSetTopWindow {
        <CMsgSetTopWindow as crate::Message>::default_instance()
    }
}

impl CMsgSetTopWindow {
    pub fn new() -> CMsgSetTopWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetTopWindow| { &m.browser_handle },
            |m: &mut CMsgSetTopWindow| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetTopWindow>(
            "CMsgSetTopWindow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetTopWindow {
    const NAME: &'static str = "CMsgSetTopWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTopWindow {
        CMsgSetTopWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTopWindow {
        static instance: CMsgSetTopWindow = CMsgSetTopWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetTopWindow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetTopWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetTopWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetTopWindow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserViewPostMessageToParentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserViewPostMessageToParentRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.args)
    pub args: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.requesting_url)
    pub requesting_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserViewPostMessageToParentRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserViewPostMessageToParentRequest {
    fn default() -> &'a CMsgBrowserViewPostMessageToParentRequest {
        <CMsgBrowserViewPostMessageToParentRequest as crate::Message>::default_instance()
    }
}

impl CMsgBrowserViewPostMessageToParentRequest {
    pub fn new() -> CMsgBrowserViewPostMessageToParentRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string args = 3;

    pub fn args(&self) -> &str {
        match self.args.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_args(&mut self) {
        self.args = ::std::option::Option::None;
    }

    pub fn has_args(&self) -> bool {
        self.args.is_some()
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::string::String) {
        self.args = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_args(&mut self) -> &mut ::std::string::String {
        if self.args.is_none() {
            self.args = ::std::option::Option::Some(::std::string::String::new());
        }
        self.args.as_mut().unwrap()
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::string::String {
        self.args.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requesting_url = 4;

    pub fn requesting_url(&self) -> &str {
        match self.requesting_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requesting_url(&mut self) {
        self.requesting_url = ::std::option::Option::None;
    }

    pub fn has_requesting_url(&self) -> bool {
        self.requesting_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_url(&mut self, v: ::std::string::String) {
        self.requesting_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requesting_url(&mut self) -> &mut ::std::string::String {
        if self.requesting_url.is_none() {
            self.requesting_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.requesting_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_requesting_url(&mut self) -> ::std::string::String {
        self.requesting_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserViewPostMessageToParentRequest| { &m.browser_handle },
            |m: &mut CMsgBrowserViewPostMessageToParentRequest| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgBrowserViewPostMessageToParentRequest| { &m.message },
            |m: &mut CMsgBrowserViewPostMessageToParentRequest| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "args",
            |m: &CMsgBrowserViewPostMessageToParentRequest| { &m.args },
            |m: &mut CMsgBrowserViewPostMessageToParentRequest| { &mut m.args },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requesting_url",
            |m: &CMsgBrowserViewPostMessageToParentRequest| { &m.requesting_url },
            |m: &mut CMsgBrowserViewPostMessageToParentRequest| { &mut m.requesting_url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserViewPostMessageToParentRequest>(
            "CMsgBrowserViewPostMessageToParentRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserViewPostMessageToParentRequest {
    const NAME: &'static str = "CMsgBrowserViewPostMessageToParentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.args = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.requesting_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.args.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.requesting_url.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.args.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.requesting_url.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserViewPostMessageToParentRequest {
        CMsgBrowserViewPostMessageToParentRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.args = ::std::option::Option::None;
        self.requesting_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserViewPostMessageToParentRequest {
        static instance: CMsgBrowserViewPostMessageToParentRequest = CMsgBrowserViewPostMessageToParentRequest {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            args: ::std::option::Option::None,
            requesting_url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserViewPostMessageToParentRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserViewPostMessageToParentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserViewPostMessageToParentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserViewPostMessageToParentRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBlockedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBlockedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgBlockedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBlockedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBlockedRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBlockedRequest {
    fn default() -> &'a CMsgBlockedRequest {
        <CMsgBlockedRequest as crate::Message>::default_instance()
    }
}

impl CMsgBlockedRequest {
    pub fn new() -> CMsgBlockedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBlockedRequest| { &m.browser_handle },
            |m: &mut CMsgBlockedRequest| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgBlockedRequest| { &m.url },
            |m: &mut CMsgBlockedRequest| { &mut m.url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBlockedRequest>(
            "CMsgBlockedRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBlockedRequest {
    const NAME: &'static str = "CMsgBlockedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBlockedRequest {
        CMsgBlockedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBlockedRequest {
        static instance: CMsgBlockedRequest = CMsgBlockedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBlockedRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBlockedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBlockedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBlockedRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserFocusChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserFocusChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserFocusChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserFocusChanged.focused)
    pub focused: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserFocusChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserFocusChanged {
    fn default() -> &'a CMsgBrowserFocusChanged {
        <CMsgBrowserFocusChanged as crate::Message>::default_instance()
    }
}

impl CMsgBrowserFocusChanged {
    pub fn new() -> CMsgBrowserFocusChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool focused = 2;

    pub fn focused(&self) -> bool {
        self.focused.unwrap_or(false)
    }

    pub fn clear_focused(&mut self) {
        self.focused = ::std::option::Option::None;
    }

    pub fn has_focused(&self) -> bool {
        self.focused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focused(&mut self, v: bool) {
        self.focused = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserFocusChanged| { &m.browser_handle },
            |m: &mut CMsgBrowserFocusChanged| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "focused",
            |m: &CMsgBrowserFocusChanged| { &m.focused },
            |m: &mut CMsgBrowserFocusChanged| { &mut m.focused },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserFocusChanged>(
            "CMsgBrowserFocusChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBrowserFocusChanged {
    const NAME: &'static str = "CMsgBrowserFocusChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.focused = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.focused {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.focused {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserFocusChanged {
        CMsgBrowserFocusChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.focused = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserFocusChanged {
        static instance: CMsgBrowserFocusChanged = CMsgBrowserFocusChanged {
            browser_handle: ::std::option::Option::None,
            focused: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBrowserFocusChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserFocusChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserFocusChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBrowserFocusChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetProtocolBlockList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetProtocolBlockList {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetProtocolBlockList.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetProtocolBlockList.list)
    pub list: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetProtocolBlockList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetProtocolBlockList {
    fn default() -> &'a CMsgSetProtocolBlockList {
        <CMsgSetProtocolBlockList as crate::Message>::default_instance()
    }
}

impl CMsgSetProtocolBlockList {
    pub fn new() -> CMsgSetProtocolBlockList {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string list = 2;

    pub fn list(&self) -> &str {
        match self.list.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_list(&mut self) {
        self.list = ::std::option::Option::None;
    }

    pub fn has_list(&self) -> bool {
        self.list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list(&mut self, v: ::std::string::String) {
        self.list = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_list(&mut self) -> &mut ::std::string::String {
        if self.list.is_none() {
            self.list = ::std::option::Option::Some(::std::string::String::new());
        }
        self.list.as_mut().unwrap()
    }

    // Take field
    pub fn take_list(&mut self) -> ::std::string::String {
        self.list.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetProtocolBlockList| { &m.browser_handle },
            |m: &mut CMsgSetProtocolBlockList| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "list",
            |m: &CMsgSetProtocolBlockList| { &m.list },
            |m: &mut CMsgSetProtocolBlockList| { &mut m.list },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetProtocolBlockList>(
            "CMsgSetProtocolBlockList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetProtocolBlockList {
    const NAME: &'static str = "CMsgSetProtocolBlockList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.list = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.list.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.list.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetProtocolBlockList {
        CMsgSetProtocolBlockList::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.list = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetProtocolBlockList {
        static instance: CMsgSetProtocolBlockList = CMsgSetProtocolBlockList {
            browser_handle: ::std::option::Option::None,
            list: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetProtocolBlockList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetProtocolBlockList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetProtocolBlockList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetProtocolBlockList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetForceDeviceScaleFactors)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetForceDeviceScaleFactors {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetForceDeviceScaleFactors.dpi_scale)
    pub dpi_scale: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetForceDeviceScaleFactors.browser_scale)
    pub browser_scale: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetForceDeviceScaleFactors.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetForceDeviceScaleFactors {
    fn default() -> &'a CMsgSetForceDeviceScaleFactors {
        <CMsgSetForceDeviceScaleFactors as crate::Message>::default_instance()
    }
}

impl CMsgSetForceDeviceScaleFactors {
    pub fn new() -> CMsgSetForceDeviceScaleFactors {
        ::std::default::Default::default()
    }

    // optional double dpi_scale = 1;

    pub fn dpi_scale(&self) -> f64 {
        self.dpi_scale.unwrap_or(0.)
    }

    pub fn clear_dpi_scale(&mut self) {
        self.dpi_scale = ::std::option::Option::None;
    }

    pub fn has_dpi_scale(&self) -> bool {
        self.dpi_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scale(&mut self, v: f64) {
        self.dpi_scale = ::std::option::Option::Some(v);
    }

    // optional double browser_scale = 2;

    pub fn browser_scale(&self) -> f64 {
        self.browser_scale.unwrap_or(0.)
    }

    pub fn clear_browser_scale(&mut self) {
        self.browser_scale = ::std::option::Option::None;
    }

    pub fn has_browser_scale(&self) -> bool {
        self.browser_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_scale(&mut self, v: f64) {
        self.browser_scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dpi_scale",
            |m: &CMsgSetForceDeviceScaleFactors| { &m.dpi_scale },
            |m: &mut CMsgSetForceDeviceScaleFactors| { &mut m.dpi_scale },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_scale",
            |m: &CMsgSetForceDeviceScaleFactors| { &m.browser_scale },
            |m: &mut CMsgSetForceDeviceScaleFactors| { &mut m.browser_scale },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetForceDeviceScaleFactors>(
            "CMsgSetForceDeviceScaleFactors",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetForceDeviceScaleFactors {
    const NAME: &'static str = "CMsgSetForceDeviceScaleFactors";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.dpi_scale = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.browser_scale = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dpi_scale {
            my_size += 1 + 8;
        }
        if let Some(v) = self.browser_scale {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.dpi_scale {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.browser_scale {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetForceDeviceScaleFactors {
        CMsgSetForceDeviceScaleFactors::new()
    }

    fn clear(&mut self) {
        self.dpi_scale = ::std::option::Option::None;
        self.browser_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetForceDeviceScaleFactors {
        static instance: CMsgSetForceDeviceScaleFactors = CMsgSetForceDeviceScaleFactors {
            dpi_scale: ::std::option::Option::None,
            browser_scale: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetForceDeviceScaleFactors {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetForceDeviceScaleFactors").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetForceDeviceScaleFactors {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetForceDeviceScaleFactors {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetUIMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetUIMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetUIMode.ui_mode)
    pub ui_mode: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetUIMode.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetUIMode {
    fn default() -> &'a CMsgSetUIMode {
        <CMsgSetUIMode as crate::Message>::default_instance()
    }
}

impl CMsgSetUIMode {
    pub fn new() -> CMsgSetUIMode {
        ::std::default::Default::default()
    }

    // optional int32 ui_mode = 1;

    pub fn ui_mode(&self) -> i32 {
        self.ui_mode.unwrap_or(0)
    }

    pub fn clear_ui_mode(&mut self) {
        self.ui_mode = ::std::option::Option::None;
    }

    pub fn has_ui_mode(&self) -> bool {
        self.ui_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_mode(&mut self, v: i32) {
        self.ui_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ui_mode",
            |m: &CMsgSetUIMode| { &m.ui_mode },
            |m: &mut CMsgSetUIMode| { &mut m.ui_mode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetUIMode>(
            "CMsgSetUIMode",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetUIMode {
    const NAME: &'static str = "CMsgSetUIMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ui_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ui_mode {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.ui_mode {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetUIMode {
        CMsgSetUIMode::new()
    }

    fn clear(&mut self) {
        self.ui_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetUIMode {
        static instance: CMsgSetUIMode = CMsgSetUIMode {
            ui_mode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetUIMode {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetUIMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetUIMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetUIMode {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopupCreated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupCreated {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupCreated.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupCreated.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupCreated {
    fn default() -> &'a CMsgPopupCreated {
        <CMsgPopupCreated as crate::Message>::default_instance()
    }
}

impl CMsgPopupCreated {
    pub fn new() -> CMsgPopupCreated {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPopupCreated| { &m.browser_handle },
            |m: &mut CMsgPopupCreated| { &mut m.browser_handle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopupCreated>(
            "CMsgPopupCreated",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPopupCreated {
    const NAME: &'static str = "CMsgPopupCreated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupCreated {
        CMsgPopupCreated::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupCreated {
        static instance: CMsgPopupCreated = CMsgPopupCreated {
            browser_handle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPopupCreated {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopupCreated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopupCreated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPopupCreated {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetVRKeyboardVisibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetVRKeyboardVisibility {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetVRKeyboardVisibility.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetVRKeyboardVisibility.visible)
    pub visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetVRKeyboardVisibility.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetVRKeyboardVisibility {
    fn default() -> &'a CMsgSetVRKeyboardVisibility {
        <CMsgSetVRKeyboardVisibility as crate::Message>::default_instance()
    }
}

impl CMsgSetVRKeyboardVisibility {
    pub fn new() -> CMsgSetVRKeyboardVisibility {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool visible = 2;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetVRKeyboardVisibility| { &m.browser_handle },
            |m: &mut CMsgSetVRKeyboardVisibility| { &mut m.browser_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &CMsgSetVRKeyboardVisibility| { &m.visible },
            |m: &mut CMsgSetVRKeyboardVisibility| { &mut m.visible },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetVRKeyboardVisibility>(
            "CMsgSetVRKeyboardVisibility",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSetVRKeyboardVisibility {
    const NAME: &'static str = "CMsgSetVRKeyboardVisibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetVRKeyboardVisibility {
        CMsgSetVRKeyboardVisibility::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetVRKeyboardVisibility {
        static instance: CMsgSetVRKeyboardVisibility = CMsgSetVRKeyboardVisibility {
            browser_handle: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSetVRKeyboardVisibility {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetVRKeyboardVisibility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetVRKeyboardVisibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSetVRKeyboardVisibility {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRestartJSContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRestartJSContext {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRestartJSContext.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRestartJSContext {
    fn default() -> &'a CMsgRestartJSContext {
        <CMsgRestartJSContext as crate::Message>::default_instance()
    }
}

impl CMsgRestartJSContext {
    pub fn new() -> CMsgRestartJSContext {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRestartJSContext>(
            "CMsgRestartJSContext",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRestartJSContext {
    const NAME: &'static str = "CMsgRestartJSContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRestartJSContext {
        CMsgRestartJSContext::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRestartJSContext {
        static instance: CMsgRestartJSContext = CMsgRestartJSContext {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRestartJSContext {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRestartJSContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRestartJSContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRestartJSContext {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EJSRegisterMethodType)
pub enum EJSRegisterMethodType {
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Invalid)
    k_EJSRegisterMethodType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Function)
    k_EJSRegisterMethodType_Function = 1,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Callback)
    k_EJSRegisterMethodType_Callback = 2,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Promise)
    k_EJSRegisterMethodType_Promise = 3,
}

impl crate::Enum for EJSRegisterMethodType {
    const NAME: &'static str = "EJSRegisterMethodType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EJSRegisterMethodType> {
        match value {
            0 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            1 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Function),
            2 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Callback),
            3 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Promise),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EJSRegisterMethodType> {
        match str {
            "k_EJSRegisterMethodType_Invalid" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            "k_EJSRegisterMethodType_Function" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Function),
            "k_EJSRegisterMethodType_Callback" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Callback),
            "k_EJSRegisterMethodType_Promise" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Promise),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EJSRegisterMethodType] = &[
        EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Function,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Callback,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Promise,
    ];
}

impl crate::EnumFull for EJSRegisterMethodType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EJSRegisterMethodType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EJSRegisterMethodType {
    fn default() -> Self {
        EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid
    }
}

impl EJSRegisterMethodType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EJSRegisterMethodType>("EJSRegisterMethodType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12htmlmessages.proto\"\x90\x01\n\tCMsgKeyUp\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07keyCode\x18\x02\x20\x01\
    (\rR\x07keyCode\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12$\
    \n\rnativeKeyCode\x18\x04\x20\x01(\rR\rnativeKeyCode\"\xb6\x01\n\x0bCMsg\
    KeyDown\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x18\n\x07keyCode\x18\x02\x20\x01(\rR\x07keyCode\x12\x1c\n\tmodifiers\
    \x18\x03\x20\x01(\rR\tmodifiers\x12\"\n\ris_system_key\x18\x04\x20\x01(\
    \x08R\x0bisSystemKey\x12$\n\rnativeKeyCode\x18\x05\x20\x01(\rR\rnativeKe\
    yCode\"\xac\x01\n\x0bCMsgKeyChar\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x18\n\x07unichar\x18\x02\x20\x01(\rR\x07unic\
    har\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12\x18\n\x07key\
    Code\x18\x04\x20\x01(\rR\x07keyCode\x12$\n\rnativeKeyCode\x18\x05\x20\
    \x01(\rR\rnativeKeyCode\"w\n\rCMsgMouseDown\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12!\n\x0cmouse_button\x18\x02\x20\x01(\
    \rR\x0bmouseButton\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\"\
    \xb3\x01\n\x0bCMsgMouseUp\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\x12!\n\x0cmouse_button\x18\x02\x20\x01(\rR\x0bmouseButton\
    \x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12\x20\n\x0cis_off\
    _panel\x18\x04\x20\x01(\x08R\nisOffPanel\x12\x0c\n\x01x\x18\x05\x20\x01(\
    \x05R\x01x\x12\x0c\n\x01y\x18\x06\x20\x01(\x05R\x01y\"{\n\x11CMsgMouseDb\
    lClick\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12!\
    \n\x0cmouse_button\x18\x02\x20\x01(\rR\x0bmouseButton\x12\x1c\n\tmodifie\
    rs\x18\x03\x20\x01(\rR\tmodifiers\"\x85\x01\n\x0eCMsgMouseWheel\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06delta\
    x\x18\x02\x20\x01(\x05R\x06deltax\x12\x16\n\x06deltay\x18\x03\x20\x01(\
    \x05R\x06deltay\x12\x1c\n\tmodifiers\x18\x04\x20\x01(\rR\tmodifiers\"p\n\
    \rCMsgMouseMove\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHan\
    dle\x12\x0c\n\x01x\x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\
    \x01(\x05R\x01y\x12\x1c\n\tmodifiers\x18\x04\x20\x01(\rR\tmodifiers\"7\n\
    \x0eCMsgMouseLeave\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\"\xcc\x05\n\x11CMsgBrowserCreate\x12\x1d\n\nrequest_id\x18\x01\
    \x20\x01(\rR\trequestId\x12\x1c\n\tuseragent\x18\x03\x20\x01(\tR\tuserag\
    ent\x12\x19\n\x08user_css\x18\x05\x20\x01(\tR\x07userCss\x12)\n\x10nativ\
    e_dropdowns\x18\x06\x20\x01(\x08R\x0fnativeDropdowns\x12\x1f\n\x0bdpi_sc\
    aling\x18\x07\x20\x01(\x02R\ndpiScaling\x12\"\n\toffscreen\x18\x08\x20\
    \x01(\x08:\x04trueR\toffscreen\x12&\n\rinitial_width\x18\t\x20\x01(\r:\
    \x010R\x0cinitialWidth\x12(\n\x0einitial_height\x18\n\x20\x01(\r:\x010R\
    \rinitialHeight\x12\x1f\n\x0bwindow_icon\x18\x0b\x20\x01(\tR\nwindowIcon\
    \x12%\n\nborderless\x18\x0c\x20\x01(\x08:\x05falseR\nborderless\x12#\n\r\
    vroverlay_key\x18\r\x20\x01(\tR\x0cvroverlayKey\x12$\n\x0cbrowser_type\
    \x18\x0e\x20\x01(\r:\x010R\x0bbrowserType\x12,\n\x0binitial_top\x18\x0f\
    \x20\x01(\x05:\x0b-2147483648R\ninitialTop\x12.\n\x0cinitial_left\x18\
    \x10\x20\x01(\x05:\x0b-2147483648R\x0binitialLeft\x12@\n\x19only_allow_t\
    rusted_popups\x18\x11\x20\x01(\x08:\x05falseR\x16onlyAllowTrustedPopups\
    \x12\x1f\n\x0binitial_url\x18\x12\x20\x01(\tR\ninitialUrl\x12\x1f\n\x0bh\
    wnd_parent\x18\x13\x20\x01(\x06R\nhwndParent\x12(\n\x0ecreation_flags\
    \x18\x14\x20\x01(\r:\x010R\rcreationFlags\"a\n\x19CMsgBrowserCreateRespo\
    nse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\
    \n\nrequest_id\x18\x02\x20\x01(\rR\trequestId\":\n\x11CMsgBrowserRemove\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\x85\x03\n\
    \x1eCMsgSetLocalFileRequestMapping\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x1f\n\x0brequest_url\x18\x02\x20\x01(\tR\nre\
    questUrl\x12,\n\x12default_local_path\x18\x03\x20\x01(\tR\x10defaultLoca\
    lPath\x12G\n\x06routes\x18\x04\x20\x03(\x0b2/.CMsgSetLocalFileRequestMap\
    ping.AdditionalRouteR\x06routes\x1a\xa3\x01\n\x0fAdditionalRoute\x12!\n\
    \x0crelative_url\x18\x01\x20\x01(\tR\x0brelativeUrl\x12\x1d\n\nlocal_pat\
    h\x18\x02\x20\x01(\tR\tlocalPath\x12-\n\x12allowed_extensions\x18\x03\
    \x20\x01(\tR\x11allowedExtensions\x12\x1f\n\x0burl_rewrite\x18\x04\x20\
    \x01(\x08R\nurlRewrite\"\x94\x02\n\x17CMsgBrowserErrorStrings\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05title\x18\
    \x02\x20\x01(\tR\x05title\x12\x16\n\x06header\x18\x03\x20\x01(\tR\x06hea\
    der\x12\x1d\n\ncache_miss\x18\x04\x20\x01(\tR\tcacheMiss\x12\x17\n\x07ba\
    d_url\x18\x05\x20\x01(\tR\x06badUrl\x12-\n\x12connection_problem\x18\x06\
    \x20\x01(\tR\x11connectionProblem\x12#\n\rproxy_problem\x18\x07\x20\x01(\
    \tR\x0cproxyProblem\x12\x18\n\x07unknown\x18\x08\x20\x01(\tR\x07unknown\
    \"O\n\x12CMsgBrowserSetName\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"f\n\x0fCM\
    sgBrowserSize\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandl\
    e\x12\x14\n\x05width\x18\x02\x20\x01(\x01R\x05width\x12\x16\n\x06height\
    \x18\x03\x20\x01(\x01R\x06height\"l\n\x15CMsgBrowserSetMinSize\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\
    \x18\x02\x20\x01(\x01R\x05width\x12\x16\n\x06height\x18\x03\x20\x01(\x01\
    R\x06height\"\x8a\x01\n\x13CMsgBrowserPosition\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\x01R\
    \x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x01R\x01y\x12\x17\n\x07x_local\x18\
    \x04\x20\x01(\x01R\x06xLocal\x12\x17\n\x07y_local\x18\x05\x20\x01(\x01R\
    \x06yLocal\"\xf2\x01\n\x12CMsgBrowserResized\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\x01R\
    \x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x01R\x01y\x12\x14\n\x05width\x18\
    \x04\x20\x01(\x01R\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\x01R\
    \x06height\x12%\n\x0edpi_horizontal\x18\x06\x20\x01(\x01R\rdpiHorizontal\
    \x12!\n\x0cdpi_vertical\x18\x07\x20\x01(\x01R\x0bdpiVertical\x12!\n\x0cd\
    isplay_name\x18\x08\x20\x01(\tR\x0bdisplayName\"\x9f\x01\n\x0bCMsgPostUR\
    L\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\x12\x12\n\x04post\x18\x03\x20\x01(\tR\
    \x04post\x12\x1e\n\npageserial\x18\x04\x20\x01(\rR\npageserial\x12#\n\rr\
    eplace_entry\x18\x05\x20\x01(\x08R\x0creplaceEntry\"^\n\rCMsgAddHeader\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\
    \x03key\x18\x02\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x03\x20\x01(\t\
    R\x05value\"5\n\x0cCMsgStopLoad\x12%\n\x0ebrowser_handle\x18\x01\x20\x01\
    (\rR\rbrowserHandle\"3\n\nCMsgReload\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\"6\n\rCMsgGoForward\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\"3\n\nCMsgGoBack\x12%\n\x0ebrowser_h\
    andle\x18\x01\x20\x01(\rR\rbrowserHandle\"N\n\rCMsgWasHidden\x12%\n\x0eb\
    rowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06hidden\x18\
    \x02\x20\x01(\x08R\x06hidden\"Z\n\x17CMsgSetWindowVisibility\x12%\n\x0eb\
    rowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07visible\
    \x18\x02\x20\x01(\x08R\x07visible\"9\n\x10CMsgClearHistory\x12%\n\x0ebro\
    wser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"A\n\x18CMsgClearAllBrows\
    ingData\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"1\n\
    \x08CMsgCopy\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \"2\n\tCMsgPaste\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHa\
    ndle\"V\n\x15CMsgExecuteJavaScript\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x16\n\x06script\x18\x02\x20\x01(\tR\x06scrip\
    t\"K\n\x0cCMsgSetFocus\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbro\
    wserHandle\x12\x14\n\x05focus\x18\x02\x20\x01(\x08R\x05focus\"D\n\x1bCMs\
    gHorizontalScrollBarSize\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rb\
    rowserHandle\"\xce\x01\n#CMsgHorizontalScrollBarSizeResponse\x12%\n\x0eb\
    rowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\nscroll_max\
    \x18\x06\x20\x01(\rR\tscrollMax\x12\x16\n\x06scroll\x18\x07\x20\x01(\rR\
    \x06scroll\x12\x12\n\x04zoom\x18\x08\x20\x01(\x02R\x04zoom\x12\x18\n\x07\
    visible\x18\t\x20\x01(\x08R\x07visible\x12\x1b\n\tpage_size\x18\n\x20\
    \x01(\rR\x08pageSize\"B\n\x19CMsgVerticalScrollBarSize\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\xcc\x01\n!CMsgVerticalScrol\
    lBarSizeResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHa\
    ndle\x12\x1d\n\nscroll_max\x18\x06\x20\x01(\rR\tscrollMax\x12\x16\n\x06s\
    croll\x18\x07\x20\x01(\rR\x06scroll\x12\x12\n\x04zoom\x18\x08\x20\x01(\
    \x02R\x04zoom\x12\x18\n\x07visible\x18\t\x20\x01(\x08R\x07visible\x12\
    \x1b\n\tpage_size\x18\n\x20\x01(\rR\x08pageSize\"~\n\x08CMsgFind\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04find\
    \x18\x02\x20\x01(\tR\x04find\x12\x16\n\x06infind\x18\x03\x20\x01(\x08R\
    \x06infind\x12\x1f\n\x07reverse\x18\x04\x20\x01(\x08:\x05falseR\x07rever\
    se\"5\n\x0cCMsgStopFind\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbr\
    owserHandle\"X\n\x17CMsgSetHorizontalScroll\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06scroll\x18\x02\x20\x01(\rR\
    \x06scroll\"V\n\x15CMsgSetVerticalScroll\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06scroll\x18\x02\x20\x01(\rR\
    \x06scroll\"M\n\x10CMsgSetZoomLevel\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x01R\x04zoom\
    \"7\n\x0eCMsgViewSource\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbr\
    owserHandle\"\x82\x01\n\x10CMsgBrowserReady\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12$\n\x0evr_overlay_key\x18\x02\x20\x01\
    (\tR\x0cvrOverlayKey\x12!\n\x0chwnd_browser\x18\x03\x20\x01(\x06R\x0bhwn\
    dBrowser\"\xcd\x01\n\x0eCMsgURLChanged\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\
    \x12\x1a\n\x08postData\x18\x03\x20\x01(\tR\x08postData\x12\x20\n\x0bbIsR\
    edirect\x18\x04\x20\x01(\x08R\x0bbIsRedirect\x12\x1c\n\tpagetitle\x18\
    \x05\x20\x01(\tR\tpagetitle\x12&\n\x0ebNewNavigation\x18\x06\x20\x01(\
    \x08R\x0ebNewNavigation\"!\n\rCHistoryEntry\x12\x10\n\x03url\x18\x01\x20\
    \x01(\tR\x03url\"{\n\x12CMsgHistoryChanged\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05index\x18\x02\x20\x01(\rR\
    \x05index\x12(\n\x07entries\x18\x03\x20\x03(\x0b2\x0e.CHistoryEntryR\x07\
    entries\"\x94\x01\n\rCMsgLoadError\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x1d\n\nerror_code\x18\x02\x20\x01(\x05R\terr\
    orCode\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12+\n\x11error_descr\
    iption\x18\x04\x20\x01(\tR\x10errorDescription\"5\n\x0bCHTMLHeader\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value\"\x8e\x02\n\x15CHTMLPageSecurityInfo\x12#\n\tbIsSecure\
    \x18\x01\x20\x01(\x08:\x05falseR\tbIsSecure\x12+\n\rbHasCertError\x18\
    \x02\x20\x01(\x08:\x05falseR\rbHasCertError\x12\x1e\n\nissuerName\x18\
    \x03\x20\x01(\tR\nissuerName\x12\x1a\n\x08certName\x18\x04\x20\x01(\tR\
    \x08certName\x12!\n\ncertExpiry\x18\x05\x20\x01(\x05:\x010R\ncertExpiry\
    \x12\x1f\n\tnCertBits\x18\x06\x20\x01(\x05:\x010R\tnCertBits\x12#\n\tbIs\
    EVCert\x18\x07\x20\x01(\x08:\x05falseR\tbIsEVCert\"l\n\x13CMsgFinishedRe\
    quest\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x1c\n\tpageTitle\x18\x03\
    \x20\x01(\tR\tpageTitle\"\x92\x01\n\x11CMsgLoadedRequest\x12%\n\x0ebrows\
    er_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\
    \x20\x01(\tR\x03url\x12\x1c\n\tpageTitle\x18\x03\x20\x01(\tR\tpageTitle\
    \x12&\n\x07headers\x18\x05\x20\x03(\x0b2\x0c.CHTMLHeaderR\x07headers\"R\
    \n\x15CMsgFavIconURLChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x12\n\x04urls\x18\x02\x20\x03(\tR\x04urls\"\x88\x01\
    \n\x10CMsgPageSecurity\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbro\
    wserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12;\n\rsecurity_\
    info\x18\x03\x20\x01(\x0b2\x16.CHTMLPageSecurityInfoR\x0csecurityInfo\"\
    \xa1\x01\n\x10CMsgStartRequest\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\
    \rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x16\n\
    \x06target\x18\x03\x20\x01(\tR\x06target\x12\x1a\n\x08postData\x18\x04\
    \x20\x01(\tR\x08postData\x12\x20\n\x0bbIsRedirect\x18\x05\x20\x01(\x08R\
    \x0bbIsRedirect\"Y\n\x18CMsgStartRequestResponse\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06bAllow\x18\x02\x20\x01\
    (\x08R\x06bAllow\"6\n\rCMsgShowPopup\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\"6\n\rCMsgHidePopup\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\"z\n\rCMsgSizePopup\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\
    \x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x05R\x01y\x12\x12\n\x04w\
    ide\x18\x04\x20\x01(\rR\x04wide\x12\x12\n\x04tall\x18\x05\x20\x01(\rR\
    \x04tall\"k\n\x0eCMsgOpenNewTab\x12%\n\x0ebrowser_handle\x18\x01\x20\x01\
    (\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x20\
    \n\x0bbForeground\x18\x03\x20\x01(\x08R\x0bbForeground\"\xcc\x02\n\x13CM\
    sgPopupHTMLWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x19\n\x01x\x18\x03\
    \x20\x01(\x05:\x0b-2147483648R\x01x\x12\x19\n\x01y\x18\x04\x20\x01(\x05:\
    \x0b-2147483648R\x01y\x12\x12\n\x04wide\x18\x05\x20\x01(\rR\x04wide\x12\
    \x12\n\x04tall\x18\x06\x20\x01(\rR\x04tall\x12\x1f\n\x0bpopup_index\x18\
    \x07\x20\x01(\rR\npopupIndex\x12'\n\x0ftrusted_creator\x18\x08\x20\x01(\
    \x08R\x0etrustedCreator\x12\x12\n\x04name\x18\t\x20\x01(\tR\x04name\x12\
    \x12\n\x04hwnd\x18\n\x20\x01(\x04R\x04hwnd\x12,\n\x12parent_popup_index\
    \x18\x0b\x20\x01(\rR\x10parentPopupIndex\"\\\n\x1bCMsgPopupHTMLWindowRes\
    ponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x16\n\x06bAllow\x18\x02\x20\x01(\x08R\x06bAllow\"O\n\x10CMsgSetHTMLTitl\
    e\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\
    \x05title\x18\x02\x20\x01(\tR\x05title\"N\n\x13CMsgLoadingResource\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\
    \x18\x02\x20\x01(\tR\x03url\"K\n\x0eCMsgStatusText\x12%\n\x0ebrowser_han\
    dle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\x01\
    (\tR\x04text\"\xcf\x01\n\rCMsgSetCursor\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\x12\x16\n\x06cursor\x18\x02\x20\x01(\rR\x06c\
    ursor\x12\x1f\n\x0bcustom_data\x18\x03\x20\x01(\x0cR\ncustomData\x12\x12\
    \n\x04wide\x18\x04\x20\x01(\rR\x04wide\x12\x12\n\x04tall\x18\x05\x20\x01\
    (\rR\x04tall\x12\x1a\n\x08xhotspot\x18\x06\x20\x01(\rR\x08xhotspot\x12\
    \x1a\n\x08yhotspot\x18\x07\x20\x01(\rR\x08yhotspot\"\x9d\x03\n\x12CMsgFi\
    leLoadDialog\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x122\n\x15owning_browser_handle\x18\x02\x20\x01(\rR\x13owningBrowserHan\
    dle\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x20\n\x0binitial\
    File\x18\x04\x20\x01(\tR\x0binitialFile\x12!\n\x0caccept_types\x18\x05\
    \x20\x03(\tR\x0bacceptTypes\x12\x17\n\x07is_save\x18\x06\x20\x01(\x08R\
    \x06isSave\x12)\n\x10choose_directory\x18\x07\x20\x01(\x08R\x0fchooseDir\
    ectory\x124\n\x07filters\x18\x08\x20\x03(\x0b2\x1a.CMsgFileLoadDialog.Fi\
    lterR\x07filters\x1aW\n\x06Filter\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x1a\n\x08patterns\x18\x02\x20\x03(\tR\x08patterns\x12\x1d\n\
    \nis_default\x18\x03\x20\x01(\x08R\tisDefault\"\xa9\x01\n\x1aCMsgFileLoa\
    dDialogResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHan\
    dle\x122\n\x15owning_browser_handle\x18\x02\x20\x01(\rR\x13owningBrowser\
    Handle\x12\x1a\n\x08bsuccess\x18\x03\x20\x01(\x08R\x08bsuccess\x12\x14\n\
    \x05files\x18\x04\x20\x03(\tR\x05files\"L\n\x0fCMsgShowToolTip\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\
    \x18\x02\x20\x01(\tR\x04text\"N\n\x11CMsgUpdateToolTip\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\
    \x01(\tR\x04text\"8\n\x0fCMsgHideToolTip\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\"v\n\x11CMsgSearchResults\x12%\n\x0ebrow\
    ser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x20\n\x0bactiveMatch\
    \x18\x02\x20\x01(\x05R\x0bactiveMatch\x12\x18\n\x07results\x18\x03\x20\
    \x01(\x05R\x07results\"2\n\tCMsgClose\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\"\xc6\x01\n\x19CMsgSetSharedPaintBuffers\x12\
    %\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04wi\
    de\x18\x02\x20\x01(\rR\x04wide\x12\x12\n\x04tall\x18\x03\x20\x01(\rR\x04\
    tall\x12\x1d\n\nsource_pid\x18\x04\x20\x01(\x04R\tsourcePid\x12#\n\rsour\
    ce_handle\x18\x05\x20\x01(\x04R\x0csourceHandle\x12\x16\n\x06handle\x18\
    \x06\x20\x01(\x04R\x06handle\"B\n\x19CMsgAckSharedPaintBuffers\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\x9e\x02\n\x0eCMs\
    gNeedsPaint\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x18\n\x07scrollx\x18\n\x20\x01(\rR\x07scrollx\x12\x18\n\x07scrolly\
    \x18\x0b\x20\x01(\rR\x07scrolly\x12\x1c\n\tpagescale\x18\x0c\x20\x01(\
    \x02R\tpagescale\x12\x1e\n\npageserial\x18\x0f\x20\x01(\rR\npageserial\
    \x12\x20\n\x0cavg_frame_ms\x18\x14\x20\x01(\rR\navgFrameMs\x12-\n\x13std\
    dev_sum_frame_ms\x18\x15\x20\x01(\x02R\x10stddevSumFrameMs\x12\"\n\rlong\
    _frame_ms\x18\x16\x20\x01(\rR\x0blongFrameMs\"\x86\x02\n\x13CMsgComboNee\
    dsPaint\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x12\n\x04rgba\x18\x02\x20\x01(\x04R\x04rgba\x12&\n\rcombobox_wide\x18\
    \x03\x20\x01(\r:\x010R\x0ccomboboxWide\x12&\n\rcombobox_tall\x18\x04\x20\
    \x01(\r:\x010R\x0ccomboboxTall\x123\n\x14shared_memory_handle\x18\x05\
    \x20\x01(\x04:\x010R\x12sharedMemoryHandle\x12/\n\x12shared_memory_size\
    \x18\x07\x20\x01(\x04:\x010R\x10sharedMemorySize\"\x87\x02\n\x1bCMsgNeed\
    sSharedTexturePaint\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowse\
    rHandle\x12!\n\x0cshare_handle\x18\x02\x20\x01(\rR\x0bshareHandle\x12\
    \x14\n\x05width\x18\x03\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x04\
    \x20\x01(\rR\x06height\x12\x18\n\x07scrollx\x18\x05\x20\x01(\rR\x07scrol\
    lx\x12\x18\n\x07scrolly\x18\x06\x20\x01(\rR\x07scrolly\x12\x1c\n\tpagesc\
    ale\x18\x07\x20\x01(\x02R\tpagescale\x12\x1e\n\npageserial\x18\x08\x20\
    \x01(\rR\npageserial\"\xe4\x01\n\x1bCMsgGameOverlayTexturePaint\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\
    \x18\x03\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x04\x20\x01(\rR\
    \x06height\x12\x18\n\x07scrollx\x18\x05\x20\x01(\rR\x07scrollx\x12\x18\n\
    \x07scrolly\x18\x06\x20\x01(\rR\x07scrolly\x12\x1c\n\tpagescale\x18\x07\
    \x20\x01(\x02R\tpagescale\x12\x1e\n\npageserial\x18\x08\x20\x01(\rR\npag\
    eserial\"4\n\x0bCMsgGetZoom\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\"P\n\x13CMsgGetZoomResponse\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x02R\
    \x04zoom\"W\n\x12CMsgLinkAtPosition\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\
    \n\x01y\x18\x03\x20\x01(\rR\x01y\"\xa7\x01\n\x1aCMsgLinkAtPositionRespon\
    se\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\
    \x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\
    \x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12\x1c\n\tblivelink\x18\
    \x05\x20\x01(\x08R\tblivelink\x12\x16\n\x06binput\x18\x06\x20\x01(\x08R\
    \x06binput\"`\n\x1bCMsgZoomToElementAtPosition\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\
    \x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\"~\n#CMsgZoomToElementAtPo\
    sitionResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHand\
    le\x12\x14\n\x05scale\x18\x02\x20\x01(\x02R\x05scale\x12\x1a\n\x08durati\
    on\x18\x03\x20\x01(\x02R\x08duration\"o\n\x14CMsgScalePageToValue\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05scale\
    \x18\x02\x20\x01(\x02R\x05scale\x12\x0c\n\x01x\x18\x03\x20\x01(\x02R\x01\
    x\x12\x0c\n\x01y\x18\x04\x20\x01(\x02R\x01y\"}\n\x1bCMsgForcePopupsToDir\
    ectHWND\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x127\
    \n\x18force_direct_hwnd_popups\x18\x02\x20\x01(\x08R\x15forceDirectHwndP\
    opups\"Y\n\x1cCMsgScalePageToValueResponse\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x02R\
    \x04zoom\"\x97\x01\n\x12CMsgSavePageToJPEG\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03\
    url\x12\x1a\n\x08filename\x18\x03\x20\x01(\tR\x08filename\x12\x14\n\x05w\
    idth\x18\x04\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\r\
    R\x06height\"q\n\x1aCMsgSavePageToJPEGResponse\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12\x1a\n\x08filename\x18\x03\x20\x01(\tR\x08filename\"N\n\x0bCM\
    sgJSAlert\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"P\n\rCMsgJSConfirm\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\"U\n\x14CMsgJSDialogResponse\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\
    \x06result\x18\x02\x20\x01(\x08R\x06result\"z\n\x17CMsgCanGoBackAndForwa\
    rd\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\
    \x07bgoback\x18\x02\x20\x01(\x08R\x07bgoback\x12\x1e\n\nbgoforward\x18\
    \x03\x20\x01(\x08R\nbgoforward\"g\n\x10CMsgOpenSteamURL\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\
    \x01(\tR\x03url\x12\x1a\n\x08referrer\x18\x03\x20\x01(\tR\x08referrer\"\
    \xad\x01\n\rCMsgSetCookie\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12\x12\n\x04path\x18\
    \x03\x20\x01(\tR\x04path\x12\x12\n\x04host\x18\x04\x20\x01(\tR\x04host\
    \x12\x18\n\x07expires\x18\x05\x20\x01(\rR\x07expires\x12\x16\n\x06secure\
    \x18\x06\x20\x01(\x08R\x06secure\x12\x1a\n\x08httponly\x18\x07\x20\x01(\
    \x08R\x08httponly\"k\n\x16CMsgSetTargetFrameRate\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12*\n\x10nTargetFrameRate\x18\x02\
    \x20\x01(\rR\x10nTargetFrameRate\"9\n\x10CMsgPauseRepaint\x12%\n\x0ebrow\
    ser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"8\n\x0fCMsgFullRepaint\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\">\n\x15CMs\
    gRequestFullScreen\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\";\n\x12CMsgExitFullScreen\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"C\n\x1aCMsgToggleFindInPageDialog\x12%\n\x0ebro\
    wser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"?\n\x16CMsgSetPIDShuttin\
    gDown\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"H\n\
    \x1fCMsgDisableBackgroundThrottling\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"?\n\x16CMsgAckPIDShuttingDown\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\"O\n\x14CMsgGetCookiesForURL\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\"_\n\x07CCookie\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \x12\x16\n\x06domain\x18\x03\x20\x01(\tR\x06domain\x12\x12\n\x04path\x18\
    \x04\x20\x01(\tR\x04path\"{\n\x1cCMsgGetCookiesForURLResponse\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\
    \x02\x20\x01(\tR\x03url\x12\"\n\x07cookies\x18\x03\x20\x03(\x0b2\x08.CCo\
    okieR\x07cookies\"\xac\x02\n\x10CMsgNodeHasFocus\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06bInput\x18\x02\x20\x01\
    (\x08R\x06bInput\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12&\n\
    \x0eelementtagname\x18\x04\x20\x01(\tR\x0eelementtagname\x12*\n\x10searc\
    hbuttontext\x18\x05\x20\x01(\tR\x10searchbuttontext\x12.\n\x12bHasMultip\
    leInputs\x18\x06\x20\x01(\x08R\x12bHasMultipleInputs\x12\x1d\n\ninput_ty\
    pe\x18\x07\x20\x01(\tR\tinputType\x12\"\n\x0cbIsMainFrame\x18\x08\x20\
    \x01(\x08R\x0cbIsMainFrame\"A\n\x18CMsgZoomToFocusedElement\x12%\n\x0ebr\
    owser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"<\n\x13CMsgFocusedNodeT\
    ext\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"Z\n\x1b\
    CMsgFocusedNodeTextResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"(\n\x0b\
    CMsgBuildID\x12\x19\n\x08build_id\x18\x01\x20\x01(\x04R\x07buildId\"9\n\
    \x10CMsgOpenDevTools\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrows\
    erHandle\":\n\x11CMsgCloseDevTools\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"X\n\x0eCMsgUnlockH264\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1f\n\x0bunlock_code\x18\x02\x20\
    \x01(\tR\nunlockCode\"\xad\x03\n\x1cCMsgScreenInformationChanged\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12%\n\x0eoverride\
    _width\x18\x02\x20\x01(\rR\roverrideWidth\x12'\n\x0foverride_height\x18\
    \x03\x20\x01(\rR\x0eoverrideHeight\x12!\n\x0cmonitor_left\x18\x04\x20\
    \x01(\rR\x0bmonitorLeft\x12\x1f\n\x0bmonitor_top\x18\x05\x20\x01(\rR\nmo\
    nitorTop\x12#\n\rmonitor_right\x18\x06\x20\x01(\rR\x0cmonitorRight\x12%\
    \n\x0emonitor_bottom\x18\x07\x20\x01(\rR\rmonitorBottom\x12\x1f\n\x0busa\
    ble_left\x18\x08\x20\x01(\rR\nusableLeft\x12\x1d\n\nusable_top\x18\t\x20\
    \x01(\rR\tusableTop\x12!\n\x0cusable_right\x18\n\x20\x01(\rR\x0busableRi\
    ght\x12#\n\rusable_bottom\x18\x0b\x20\x01(\rR\x0cusableBottom\"<\n\x13CM\
    sgClearAllCookies\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\"W\n\rCMsgScreenDPI\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\x12\x1f\n\x0bdpi_scaling\x18\x02\x20\x01(\x02R\ndpiScaling\
    \"9\n\x10CMsgAckScreenDPI\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\"2\n\x16CMsgAuthedSteamDomains\x12\x18\n\x07domains\x18\
    \x01\x20\x03(\tR\x07domains\"-\n\x13CMsgSteamAuthNeeded\x12\x16\n\x06fil\
    ler\x18\x01\x20\x01(\x08R\x06filler\"3\n\x17CMsgSteamAuthCookiesSet\x12\
    \x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"\xab\x01\n\x14CMsgJS\
    RegisterMethod\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHand\
    le\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12X\n\x0bmethod_type\
    \x18\x03\x20\x01(\x0e2\x16.EJSRegisterMethodType:\x1fk_EJSRegisterMethod\
    Type_InvalidR\nmethodType\"\xf9\x03\n\x0bCMsgJSValue\x12\x1d\n\nbool_val\
    ue\x18\x01\x20\x01(\x08R\tboolValue\x12\x1b\n\tint_value\x18\x02\x20\x01\
    (\x05R\x08intValue\x12\x1d\n\nuint_value\x18\x03\x20\x01(\rR\tuintValue\
    \x12!\n\x0cdouble_value\x18\x04\x20\x01(\x01R\x0bdoubleValue\x12!\n\x0cs\
    tring_value\x18\x05\x20\x01(\tR\x0bstringValue\x12'\n\x0ffunction_handle\
    \x18\x06\x20\x01(\x04R\x0efunctionHandle\x12\x1f\n\x0bbytes_value\x18\
    \x0c\x20\x01(\x0cR\nbytesValue\x12\x19\n\x08is_array\x18\x08\x20\x01(\
    \x08R\x07isArray\x12/\n\x0carray_values\x18\t\x20\x03(\x0b2\x0c.CMsgJSVa\
    lueR\x0barrayValues\x12\x1b\n\tis_object\x18\n\x20\x01(\x08R\x08isObject\
    \x12J\n\x11object_properties\x18\x0b\x20\x03(\x0b2\x1d.CMsgJSValue.JSObj\
    ectPropertyR\x10objectProperties\x1aJ\n\x10JSObjectProperty\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\"\n\x05value\x18\x02\x20\x01(\
    \x0b2\x0c.CMsgJSValueR\x05value\"\xad\x01\n\x10CMsgJSMethodCall\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x122\n\x15owning_b\
    rowser_handle\x18\x02\x20\x01(\rR\x13owningBrowserHandle\x12\x12\n\x04na\
    me\x18\x03\x20\x01(\tR\x04name\x12*\n\targuments\x18\x04\x20\x03(\x0b2\
    \x0c.CMsgJSValueR\targuments\"\xc7\x01\n\x15CMsgJSExecuteCallback\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x122\n\x15owning_b\
    rowser_handle\x18\x02\x20\x01(\rR\x13owningBrowserHandle\x12'\n\x0ffunct\
    ion_handle\x18\x03\x20\x01(\x04R\x0efunctionHandle\x12*\n\targuments\x18\
    \x04\x20\x03(\x0b2\x0c.CMsgJSValueR\targuments\"\x9b\x01\n\x15CMsgJSRele\
    aseCallback\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x122\n\x15owning_browser_handle\x18\x02\x20\x01(\rR\x13owningBrowserHan\
    dle\x12'\n\x0ffunction_handle\x18\x03\x20\x01(\x04R\x0efunctionHandle\"\
    \x8f\x01\n\x14CMsgJSRaiseException\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x122\n\x15owning_browser_handle\x18\x02\x20\x01(\
    \rR\x13owningBrowserHandle\x12\x1c\n\texception\x18\x03\x20\x01(\tR\texc\
    eption\"\x86\x01\n\x14CMsgLoadLocalization\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12+\n\x11localization_path\x18\x02\x20\
    \x01(\tR\x10localizationPath\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\
    \x08language\"A\n\x18CMsgNotifyUserActivation\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\"6\n\x1eCMsgSetNetFakeLocalSystemSta\
    te\x12\x14\n\x05state\x18\x01\x20\x01(\rR\x05state\"d\n\x1cCMsgSetGameOv\
    erlayTargetPIDs\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHan\
    dle\x12\x1d\n\ntarget_pid\x18\x02\x20\x03(\rR\ttargetPid\"\x8d\x01\n\x1e\
    CMsgGameOverlayTargetTextureID\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\
    \rR\rbrowserHandle\x12\x1d\n\ntarget_pid\x18\x02\x20\x01(\rR\ttargetPid\
    \x12%\n\x0etexture_handle\x18\x03\x20\x01(\rR\rtextureHandle\"\x81\x02\n\
    \x1bCMsgDraggableRegionsChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01\
    (\rR\rbrowserHandle\x12A\n\x05rects\x18\x02\x20\x03(\x0b2+.CMsgDraggable\
    RegionsChanged.DraggableRectsR\x05rects\x1ax\n\x0eDraggableRects\x12\x0c\
    \n\x01x\x18\x01\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\
    \x01y\x12\x14\n\x05width\x18\x03\x20\x01(\x05R\x05width\x12\x16\n\x06hei\
    ght\x18\x04\x20\x01(\x05R\x06height\x12\x1c\n\tdraggable\x18\x05\x20\x01\
    (\x08R\tdraggable\"l\n\x15CMsgResizeGripChanged\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\x18\x02\x20\x01(\
    \x05R\x05width\x12\x16\n\x06height\x18\x03\x20\x01(\x05R\x06height\"\x80\
    \x02\n\x15CMsgSetWindowPosition\x12%\n\x0ebrowser_handle\x18\x01\x20\x01\
    (\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\x01R\x01x\x12\x0c\n\
    \x01y\x18\x03\x20\x01(\x01R\x01y\x12\x14\n\x05width\x18\x04\x20\x01(\x01\
    R\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\x01R\x06height\x12\x1b\n\
    \tmin_width\x18\x06\x20\x01(\x01R\x08minWidth\x12\x1d\n\nmin_height\x18\
    \x07\x20\x01(\x01R\tminHeight\x12\x1b\n\tmax_width\x18\x08\x20\x01(\x01R\
    \x08maxWidth\x12\x1d\n\nmax_height\x18\t\x20\x01(\x01R\tmaxHeight\"7\n\
    \x0eCMsgShowWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\"7\n\x0eCMsgHideWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\
    \rR\rbrowserHandle\"?\n\x16CMsgBringWindowToFront\x12%\n\x0ebrowser_hand\
    le\x18\x01\x20\x01(\rR\rbrowserHandle\"@\n\x17CMsgSetForegroundWindow\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"B\n\x19CMs\
    gMaximizeRestoreWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbro\
    wserHandle\";\n\x12CMsgMinimizeWindow\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\"\x81\x04\n\x1aCMsgShowBrowserContextMenu\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12S\n\x0fc\
    ustom_commands\x18\x02\x20\x03(\x0b2*.CMsgShowBrowserContextMenu.Context\
    CommandR\x0ecustomCommands\x12\x1d\n\ntype_flags\x18\x03\x20\x01(\rR\tty\
    peFlags\x12\x19\n\x08page_url\x18\x04\x20\x01(\tR\x07pageUrl\x12\x17\n\
    \x07coord_x\x18\x05\x20\x01(\x05R\x06coordX\x12\x17\n\x07coord_y\x18\x06\
    \x20\x01(\x05R\x06coordY\x12\x19\n\x08link_url\x18\x07\x20\x01(\tR\x07li\
    nkUrl\x12.\n\x13unfiltered_link_url\x18\x08\x20\x01(\tR\x11unfilteredLin\
    kUrl\x12%\n\x0eselection_text\x18\t\x20\x01(\tR\rselectionText\x12'\n\
    \x0fmisspelled_word\x18\n\x20\x01(\tR\x0emisspelledWord\x12(\n\x10edit_s\
    tate_flags\x18\x0b\x20\x01(\rR\x0eeditStateFlags\x1a6\n\x0eContextComman\
    d\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x14\n\x05label\x18\x02\
    \x20\x01(\tR\x05label\"d\n\x1cCMsgHandleContextMenuCommand\x12%\n\x0ebro\
    wser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\ncommand_id\x18\
    \x02\x20\x01(\x05R\tcommandId\"\xeb\x01\n\x10CMsgTouchGesture\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\x05R\x02id\x12\x18\n\x07gesture\x18\x03\x20\x01(\rR\x07ges\
    ture\x12\x0c\n\x01x\x18\x04\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x05\
    \x20\x01(\x01R\x01y\x12\x14\n\x05width\x18\x06\x20\x01(\x01R\x05width\
    \x12\x16\n\x06height\x18\x07\x20\x01(\x01R\x06height\x12\x1b\n\ttap_coun\
    t\x18\x08\x20\x01(\rR\x08tapCount\x12\x1f\n\x0bpinch_scale\x18\t\x20\x01\
    (\x01R\npinchScale\"a\n\x1cCMsgSetTouchGesturesToCancel\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1a\n\x08gestures\x18\
    \x02\x20\x03(\rR\x08gestures\"R\n\x15CMsgImeSetComposition\x12%\n\x0ebro\
    wser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\
    \x20\x01(\tR\x04text\"N\n\x11CMsgImeCommitText\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\x01(\t\
    R\x04text\"A\n\x18CMsgImeCancelComposition\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\"c\n\x1eCMsgImeCompositionRangeChanged\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\
    \x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\"\
    W\n\x12CMsgInspectElement\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\x18\
    \x03\x20\x01(\rR\x01y\"P\n\rCMsgDisableF5\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07disable\x18\x02\x20\x01(\
    \x08R\x07disable\"L\n\x11CMsgStartDownload\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03\
    url\"9\n\x10CMsgSetTopWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\r\
    R\rbrowserHandle\"\xa7\x01\n)CMsgBrowserViewPostMessageToParentRequest\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\x12\x12\n\x04args\x18\x03\x20\
    \x01(\tR\x04args\x12%\n\x0erequesting_url\x18\x04\x20\x01(\tR\rrequestin\
    gUrl\"M\n\x12CMsgBlockedRequest\x12%\n\x0ebrowser_handle\x18\x01\x20\x01\
    (\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\"Z\n\x17\
    CMsgBrowserFocusChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbr\
    owserHandle\x12\x18\n\x07focused\x18\x02\x20\x01(\x08R\x07focused\"U\n\
    \x18CMsgSetProtocolBlockList\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\r\
    R\rbrowserHandle\x12\x12\n\x04list\x18\x02\x20\x01(\tR\x04list\"b\n\x1eC\
    MsgSetForceDeviceScaleFactors\x12\x1b\n\tdpi_scale\x18\x01\x20\x01(\x01R\
    \x08dpiScale\x12#\n\rbrowser_scale\x18\x02\x20\x01(\x01R\x0cbrowserScale\
    \"(\n\rCMsgSetUIMode\x12\x17\n\x07ui_mode\x18\x01\x20\x01(\x05R\x06uiMod\
    e\"9\n\x10CMsgPopupCreated\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\"^\n\x1bCMsgSetVRKeyboardVisibility\x12%\n\x0ebrowser_ha\
    ndle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07visible\x18\x02\x20\
    \x01(\x08R\x07visible\"\x16\n\x14CMsgRestartJSContext*\xad\x01\n\x15EJSR\
    egisterMethodType\x12#\n\x1fk_EJSRegisterMethodType_Invalid\x10\0\x12$\n\
    \x20k_EJSRegisterMethodType_Function\x10\x01\x12$\n\x20k_EJSRegisterMeth\
    odType_Callback\x10\x02\x12#\n\x1fk_EJSRegisterMethodType_Promise\x10\
    \x03B\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(169);
            messages.push(CMsgKeyUp::generated_message_descriptor_data());
            messages.push(CMsgKeyDown::generated_message_descriptor_data());
            messages.push(CMsgKeyChar::generated_message_descriptor_data());
            messages.push(CMsgMouseDown::generated_message_descriptor_data());
            messages.push(CMsgMouseUp::generated_message_descriptor_data());
            messages.push(CMsgMouseDblClick::generated_message_descriptor_data());
            messages.push(CMsgMouseWheel::generated_message_descriptor_data());
            messages.push(CMsgMouseMove::generated_message_descriptor_data());
            messages.push(CMsgMouseLeave::generated_message_descriptor_data());
            messages.push(CMsgBrowserCreate::generated_message_descriptor_data());
            messages.push(CMsgBrowserCreateResponse::generated_message_descriptor_data());
            messages.push(CMsgBrowserRemove::generated_message_descriptor_data());
            messages.push(CMsgSetLocalFileRequestMapping::generated_message_descriptor_data());
            messages.push(CMsgBrowserErrorStrings::generated_message_descriptor_data());
            messages.push(CMsgBrowserSetName::generated_message_descriptor_data());
            messages.push(CMsgBrowserSize::generated_message_descriptor_data());
            messages.push(CMsgBrowserSetMinSize::generated_message_descriptor_data());
            messages.push(CMsgBrowserPosition::generated_message_descriptor_data());
            messages.push(CMsgBrowserResized::generated_message_descriptor_data());
            messages.push(CMsgPostURL::generated_message_descriptor_data());
            messages.push(CMsgAddHeader::generated_message_descriptor_data());
            messages.push(CMsgStopLoad::generated_message_descriptor_data());
            messages.push(CMsgReload::generated_message_descriptor_data());
            messages.push(CMsgGoForward::generated_message_descriptor_data());
            messages.push(CMsgGoBack::generated_message_descriptor_data());
            messages.push(CMsgWasHidden::generated_message_descriptor_data());
            messages.push(CMsgSetWindowVisibility::generated_message_descriptor_data());
            messages.push(CMsgClearHistory::generated_message_descriptor_data());
            messages.push(CMsgClearAllBrowsingData::generated_message_descriptor_data());
            messages.push(CMsgCopy::generated_message_descriptor_data());
            messages.push(CMsgPaste::generated_message_descriptor_data());
            messages.push(CMsgExecuteJavaScript::generated_message_descriptor_data());
            messages.push(CMsgSetFocus::generated_message_descriptor_data());
            messages.push(CMsgHorizontalScrollBarSize::generated_message_descriptor_data());
            messages.push(CMsgHorizontalScrollBarSizeResponse::generated_message_descriptor_data());
            messages.push(CMsgVerticalScrollBarSize::generated_message_descriptor_data());
            messages.push(CMsgVerticalScrollBarSizeResponse::generated_message_descriptor_data());
            messages.push(CMsgFind::generated_message_descriptor_data());
            messages.push(CMsgStopFind::generated_message_descriptor_data());
            messages.push(CMsgSetHorizontalScroll::generated_message_descriptor_data());
            messages.push(CMsgSetVerticalScroll::generated_message_descriptor_data());
            messages.push(CMsgSetZoomLevel::generated_message_descriptor_data());
            messages.push(CMsgViewSource::generated_message_descriptor_data());
            messages.push(CMsgBrowserReady::generated_message_descriptor_data());
            messages.push(CMsgURLChanged::generated_message_descriptor_data());
            messages.push(CHistoryEntry::generated_message_descriptor_data());
            messages.push(CMsgHistoryChanged::generated_message_descriptor_data());
            messages.push(CMsgLoadError::generated_message_descriptor_data());
            messages.push(CHTMLHeader::generated_message_descriptor_data());
            messages.push(CHTMLPageSecurityInfo::generated_message_descriptor_data());
            messages.push(CMsgFinishedRequest::generated_message_descriptor_data());
            messages.push(CMsgLoadedRequest::generated_message_descriptor_data());
            messages.push(CMsgFavIconURLChanged::generated_message_descriptor_data());
            messages.push(CMsgPageSecurity::generated_message_descriptor_data());
            messages.push(CMsgStartRequest::generated_message_descriptor_data());
            messages.push(CMsgStartRequestResponse::generated_message_descriptor_data());
            messages.push(CMsgShowPopup::generated_message_descriptor_data());
            messages.push(CMsgHidePopup::generated_message_descriptor_data());
            messages.push(CMsgSizePopup::generated_message_descriptor_data());
            messages.push(CMsgOpenNewTab::generated_message_descriptor_data());
            messages.push(CMsgPopupHTMLWindow::generated_message_descriptor_data());
            messages.push(CMsgPopupHTMLWindowResponse::generated_message_descriptor_data());
            messages.push(CMsgSetHTMLTitle::generated_message_descriptor_data());
            messages.push(CMsgLoadingResource::generated_message_descriptor_data());
            messages.push(CMsgStatusText::generated_message_descriptor_data());
            messages.push(CMsgSetCursor::generated_message_descriptor_data());
            messages.push(CMsgFileLoadDialog::generated_message_descriptor_data());
            messages.push(CMsgFileLoadDialogResponse::generated_message_descriptor_data());
            messages.push(CMsgShowToolTip::generated_message_descriptor_data());
            messages.push(CMsgUpdateToolTip::generated_message_descriptor_data());
            messages.push(CMsgHideToolTip::generated_message_descriptor_data());
            messages.push(CMsgSearchResults::generated_message_descriptor_data());
            messages.push(CMsgClose::generated_message_descriptor_data());
            messages.push(CMsgSetSharedPaintBuffers::generated_message_descriptor_data());
            messages.push(CMsgAckSharedPaintBuffers::generated_message_descriptor_data());
            messages.push(CMsgNeedsPaint::generated_message_descriptor_data());
            messages.push(CMsgComboNeedsPaint::generated_message_descriptor_data());
            messages.push(CMsgNeedsSharedTexturePaint::generated_message_descriptor_data());
            messages.push(CMsgGameOverlayTexturePaint::generated_message_descriptor_data());
            messages.push(CMsgGetZoom::generated_message_descriptor_data());
            messages.push(CMsgGetZoomResponse::generated_message_descriptor_data());
            messages.push(CMsgLinkAtPosition::generated_message_descriptor_data());
            messages.push(CMsgLinkAtPositionResponse::generated_message_descriptor_data());
            messages.push(CMsgZoomToElementAtPosition::generated_message_descriptor_data());
            messages.push(CMsgZoomToElementAtPositionResponse::generated_message_descriptor_data());
            messages.push(CMsgScalePageToValue::generated_message_descriptor_data());
            messages.push(CMsgForcePopupsToDirectHWND::generated_message_descriptor_data());
            messages.push(CMsgScalePageToValueResponse::generated_message_descriptor_data());
            messages.push(CMsgSavePageToJPEG::generated_message_descriptor_data());
            messages.push(CMsgSavePageToJPEGResponse::generated_message_descriptor_data());
            messages.push(CMsgJSAlert::generated_message_descriptor_data());
            messages.push(CMsgJSConfirm::generated_message_descriptor_data());
            messages.push(CMsgJSDialogResponse::generated_message_descriptor_data());
            messages.push(CMsgCanGoBackAndForward::generated_message_descriptor_data());
            messages.push(CMsgOpenSteamURL::generated_message_descriptor_data());
            messages.push(CMsgSetCookie::generated_message_descriptor_data());
            messages.push(CMsgSetTargetFrameRate::generated_message_descriptor_data());
            messages.push(CMsgPauseRepaint::generated_message_descriptor_data());
            messages.push(CMsgFullRepaint::generated_message_descriptor_data());
            messages.push(CMsgRequestFullScreen::generated_message_descriptor_data());
            messages.push(CMsgExitFullScreen::generated_message_descriptor_data());
            messages.push(CMsgToggleFindInPageDialog::generated_message_descriptor_data());
            messages.push(CMsgSetPIDShuttingDown::generated_message_descriptor_data());
            messages.push(CMsgDisableBackgroundThrottling::generated_message_descriptor_data());
            messages.push(CMsgAckPIDShuttingDown::generated_message_descriptor_data());
            messages.push(CMsgGetCookiesForURL::generated_message_descriptor_data());
            messages.push(CCookie::generated_message_descriptor_data());
            messages.push(CMsgGetCookiesForURLResponse::generated_message_descriptor_data());
            messages.push(CMsgNodeHasFocus::generated_message_descriptor_data());
            messages.push(CMsgZoomToFocusedElement::generated_message_descriptor_data());
            messages.push(CMsgFocusedNodeText::generated_message_descriptor_data());
            messages.push(CMsgFocusedNodeTextResponse::generated_message_descriptor_data());
            messages.push(CMsgBuildID::generated_message_descriptor_data());
            messages.push(CMsgOpenDevTools::generated_message_descriptor_data());
            messages.push(CMsgCloseDevTools::generated_message_descriptor_data());
            messages.push(CMsgUnlockH264::generated_message_descriptor_data());
            messages.push(CMsgScreenInformationChanged::generated_message_descriptor_data());
            messages.push(CMsgClearAllCookies::generated_message_descriptor_data());
            messages.push(CMsgScreenDPI::generated_message_descriptor_data());
            messages.push(CMsgAckScreenDPI::generated_message_descriptor_data());
            messages.push(CMsgAuthedSteamDomains::generated_message_descriptor_data());
            messages.push(CMsgSteamAuthNeeded::generated_message_descriptor_data());
            messages.push(CMsgSteamAuthCookiesSet::generated_message_descriptor_data());
            messages.push(CMsgJSRegisterMethod::generated_message_descriptor_data());
            messages.push(CMsgJSValue::generated_message_descriptor_data());
            messages.push(CMsgJSMethodCall::generated_message_descriptor_data());
            messages.push(CMsgJSExecuteCallback::generated_message_descriptor_data());
            messages.push(CMsgJSReleaseCallback::generated_message_descriptor_data());
            messages.push(CMsgJSRaiseException::generated_message_descriptor_data());
            messages.push(CMsgLoadLocalization::generated_message_descriptor_data());
            messages.push(CMsgNotifyUserActivation::generated_message_descriptor_data());
            messages.push(CMsgSetNetFakeLocalSystemState::generated_message_descriptor_data());
            messages.push(CMsgSetGameOverlayTargetPIDs::generated_message_descriptor_data());
            messages.push(CMsgGameOverlayTargetTextureID::generated_message_descriptor_data());
            messages.push(CMsgDraggableRegionsChanged::generated_message_descriptor_data());
            messages.push(CMsgResizeGripChanged::generated_message_descriptor_data());
            messages.push(CMsgSetWindowPosition::generated_message_descriptor_data());
            messages.push(CMsgShowWindow::generated_message_descriptor_data());
            messages.push(CMsgHideWindow::generated_message_descriptor_data());
            messages.push(CMsgBringWindowToFront::generated_message_descriptor_data());
            messages.push(CMsgSetForegroundWindow::generated_message_descriptor_data());
            messages.push(CMsgMaximizeRestoreWindow::generated_message_descriptor_data());
            messages.push(CMsgMinimizeWindow::generated_message_descriptor_data());
            messages.push(CMsgShowBrowserContextMenu::generated_message_descriptor_data());
            messages.push(CMsgHandleContextMenuCommand::generated_message_descriptor_data());
            messages.push(CMsgTouchGesture::generated_message_descriptor_data());
            messages.push(CMsgSetTouchGesturesToCancel::generated_message_descriptor_data());
            messages.push(CMsgImeSetComposition::generated_message_descriptor_data());
            messages.push(CMsgImeCommitText::generated_message_descriptor_data());
            messages.push(CMsgImeCancelComposition::generated_message_descriptor_data());
            messages.push(CMsgImeCompositionRangeChanged::generated_message_descriptor_data());
            messages.push(CMsgInspectElement::generated_message_descriptor_data());
            messages.push(CMsgDisableF5::generated_message_descriptor_data());
            messages.push(CMsgStartDownload::generated_message_descriptor_data());
            messages.push(CMsgSetTopWindow::generated_message_descriptor_data());
            messages.push(CMsgBrowserViewPostMessageToParentRequest::generated_message_descriptor_data());
            messages.push(CMsgBlockedRequest::generated_message_descriptor_data());
            messages.push(CMsgBrowserFocusChanged::generated_message_descriptor_data());
            messages.push(CMsgSetProtocolBlockList::generated_message_descriptor_data());
            messages.push(CMsgSetForceDeviceScaleFactors::generated_message_descriptor_data());
            messages.push(CMsgSetUIMode::generated_message_descriptor_data());
            messages.push(CMsgPopupCreated::generated_message_descriptor_data());
            messages.push(CMsgSetVRKeyboardVisibility::generated_message_descriptor_data());
            messages.push(CMsgRestartJSContext::generated_message_descriptor_data());
            messages.push(cmsg_set_local_file_request_mapping::AdditionalRoute::generated_message_descriptor_data());
            messages.push(cmsg_file_load_dialog::Filter::generated_message_descriptor_data());
            messages.push(cmsg_jsvalue::JSObjectProperty::generated_message_descriptor_data());
            messages.push(cmsg_draggable_regions_changed::DraggableRects::generated_message_descriptor_data());
            messages.push(cmsg_show_browser_context_menu::ContextCommand::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(EJSRegisterMethodType::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
