// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_uds.proto`

// @@protoc_insertion_point(message:CMsgClientUDSP2PSessionStarted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUDSP2PSessionStarted {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionStarted.steamid_remote)
    pub steamid_remote: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionStarted.appid)
    pub appid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUDSP2PSessionStarted.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionStarted {
    fn default() -> &'a CMsgClientUDSP2PSessionStarted {
        <CMsgClientUDSP2PSessionStarted as crate::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionStarted {
    pub fn new() -> CMsgClientUDSP2PSessionStarted {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_remote",
            |m: &CMsgClientUDSP2PSessionStarted| { &m.steamid_remote },
            |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.steamid_remote },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUDSP2PSessionStarted| { &m.appid },
            |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUDSP2PSessionStarted>(
            "CMsgClientUDSP2PSessionStarted",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUDSP2PSessionStarted {
    const NAME: &'static str = "CMsgClientUDSP2PSessionStarted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUDSP2PSessionStarted {
        CMsgClientUDSP2PSessionStarted::new()
    }

    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionStarted {
        static instance: CMsgClientUDSP2PSessionStarted = CMsgClientUDSP2PSessionStarted {
            steamid_remote: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUDSP2PSessionStarted {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUDSP2PSessionStarted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUDSP2PSessionStarted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUDSP2PSessionStarted {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUDSP2PSessionEnded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUDSP2PSessionEnded {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.steamid_remote)
    pub steamid_remote: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.appid)
    pub appid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.session_length_sec)
    pub session_length_sec: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.session_error)
    pub session_error: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.nattype)
    pub nattype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_recv)
    pub bytes_recv: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_sent)
    pub bytes_sent: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_sent_relay)
    pub bytes_sent_relay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_recv_relay)
    pub bytes_recv_relay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.time_to_connect_ms)
    pub time_to_connect_ms: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUDSP2PSessionEnded.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionEnded {
    fn default() -> &'a CMsgClientUDSP2PSessionEnded {
        <CMsgClientUDSP2PSessionEnded as crate::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionEnded {
    pub fn new() -> CMsgClientUDSP2PSessionEnded {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 session_length_sec = 3;

    pub fn session_length_sec(&self) -> i32 {
        self.session_length_sec.unwrap_or(0)
    }

    pub fn clear_session_length_sec(&mut self) {
        self.session_length_sec = ::std::option::Option::None;
    }

    pub fn has_session_length_sec(&self) -> bool {
        self.session_length_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_sec(&mut self, v: i32) {
        self.session_length_sec = ::std::option::Option::Some(v);
    }

    // optional int32 session_error = 4;

    pub fn session_error(&self) -> i32 {
        self.session_error.unwrap_or(0)
    }

    pub fn clear_session_error(&mut self) {
        self.session_error = ::std::option::Option::None;
    }

    pub fn has_session_error(&self) -> bool {
        self.session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_error(&mut self, v: i32) {
        self.session_error = ::std::option::Option::Some(v);
    }

    // optional int32 nattype = 5;

    pub fn nattype(&self) -> i32 {
        self.nattype.unwrap_or(0)
    }

    pub fn clear_nattype(&mut self) {
        self.nattype = ::std::option::Option::None;
    }

    pub fn has_nattype(&self) -> bool {
        self.nattype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nattype(&mut self, v: i32) {
        self.nattype = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv = 6;

    pub fn bytes_recv(&self) -> i32 {
        self.bytes_recv.unwrap_or(0)
    }

    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: i32) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent = 7;

    pub fn bytes_sent(&self) -> i32 {
        self.bytes_sent.unwrap_or(0)
    }

    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: i32) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent_relay = 8;

    pub fn bytes_sent_relay(&self) -> i32 {
        self.bytes_sent_relay.unwrap_or(0)
    }

    pub fn clear_bytes_sent_relay(&mut self) {
        self.bytes_sent_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_sent_relay(&self) -> bool {
        self.bytes_sent_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent_relay(&mut self, v: i32) {
        self.bytes_sent_relay = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv_relay = 9;

    pub fn bytes_recv_relay(&self) -> i32 {
        self.bytes_recv_relay.unwrap_or(0)
    }

    pub fn clear_bytes_recv_relay(&mut self) {
        self.bytes_recv_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_recv_relay(&self) -> bool {
        self.bytes_recv_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv_relay(&mut self, v: i32) {
        self.bytes_recv_relay = ::std::option::Option::Some(v);
    }

    // optional int32 time_to_connect_ms = 10;

    pub fn time_to_connect_ms(&self) -> i32 {
        self.time_to_connect_ms.unwrap_or(0)
    }

    pub fn clear_time_to_connect_ms(&mut self) {
        self.time_to_connect_ms = ::std::option::Option::None;
    }

    pub fn has_time_to_connect_ms(&self) -> bool {
        self.time_to_connect_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_connect_ms(&mut self, v: i32) {
        self.time_to_connect_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_remote",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.steamid_remote },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.steamid_remote },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.appid },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_length_sec",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.session_length_sec },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_length_sec },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_error",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.session_error },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_error },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nattype",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.nattype },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.nattype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_recv",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_sent",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_sent_relay",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent_relay },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent_relay },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_recv_relay",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv_relay },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv_relay },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_to_connect_ms",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.time_to_connect_ms },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.time_to_connect_ms },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUDSP2PSessionEnded>(
            "CMsgClientUDSP2PSessionEnded",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUDSP2PSessionEnded {
    const NAME: &'static str = "CMsgClientUDSP2PSessionEnded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.session_length_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.session_error = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.nattype = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.bytes_recv = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.bytes_sent = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.bytes_sent_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.bytes_recv_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.time_to_connect_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.session_length_sec {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.session_error {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.nattype {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.bytes_recv {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.bytes_sent {
            my_size += crate::rt::int32_size(7, v);
        }
        if let Some(v) = self.bytes_sent_relay {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.bytes_recv_relay {
            my_size += crate::rt::int32_size(9, v);
        }
        if let Some(v) = self.time_to_connect_ms {
            my_size += crate::rt::int32_size(10, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.session_length_sec {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.session_error {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.nattype {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.bytes_recv {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bytes_sent {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.bytes_sent_relay {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.bytes_recv_relay {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.time_to_connect_ms {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUDSP2PSessionEnded {
        CMsgClientUDSP2PSessionEnded::new()
    }

    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.session_length_sec = ::std::option::Option::None;
        self.session_error = ::std::option::Option::None;
        self.nattype = ::std::option::Option::None;
        self.bytes_recv = ::std::option::Option::None;
        self.bytes_sent = ::std::option::Option::None;
        self.bytes_sent_relay = ::std::option::Option::None;
        self.bytes_recv_relay = ::std::option::Option::None;
        self.time_to_connect_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionEnded {
        static instance: CMsgClientUDSP2PSessionEnded = CMsgClientUDSP2PSessionEnded {
            steamid_remote: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            session_length_sec: ::std::option::Option::None,
            session_error: ::std::option::Option::None,
            nattype: ::std::option::Option::None,
            bytes_recv: ::std::option::Option::None,
            bytes_sent: ::std::option::Option::None,
            bytes_sent_relay: ::std::option::Option::None,
            bytes_recv_relay: ::std::option::Option::None,
            time_to_connect_ms: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUDSP2PSessionEnded {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUDSP2PSessionEnded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUDSP2PSessionEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUDSP2PSessionEnded {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClientDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientDetails {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientDetails.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetails {
    fn default() -> &'a CMsgClientGetClientDetails {
        <CMsgClientGetClientDetails as crate::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetails {
    pub fn new() -> CMsgClientGetClientDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientDetails>(
            "CMsgClientGetClientDetails",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetClientDetails {
    const NAME: &'static str = "CMsgClientGetClientDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientDetails {
        CMsgClientGetClientDetails::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientDetails {
        static instance: CMsgClientGetClientDetails = CMsgClientGetClientDetails {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetClientDetails {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetClientDetails {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClientDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.package_version)
    pub package_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.ip_public)
    pub ip_public: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.ip_private)
    pub ip_private: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.games_running)
    pub games_running: ::std::vec::Vec<cmsg_client_get_client_details_response::Game>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.bytes_available)
    pub bytes_available: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.clientcomm_version)
    pub clientcomm_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.local_users)
    pub local_users: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientDetailsResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetailsResponse {
    fn default() -> &'a CMsgClientGetClientDetailsResponse {
        <CMsgClientGetClientDetailsResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetailsResponse {
    pub fn new() -> CMsgClientGetClientDetailsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 package_version = 1;

    pub fn package_version(&self) -> u32 {
        self.package_version.unwrap_or(0)
    }

    pub fn clear_package_version(&mut self) {
        self.package_version = ::std::option::Option::None;
    }

    pub fn has_package_version(&self) -> bool {
        self.package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_version(&mut self, v: u32) {
        self.package_version = ::std::option::Option::Some(v);
    }

    // optional string os = 2;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name = 3;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_public = 4;

    pub fn ip_public(&self) -> &str {
        match self.ip_public.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_public(&mut self) {
        self.ip_public = ::std::option::Option::None;
    }

    pub fn has_ip_public(&self) -> bool {
        self.ip_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_public(&mut self, v: ::std::string::String) {
        self.ip_public = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_public(&mut self) -> &mut ::std::string::String {
        if self.ip_public.is_none() {
            self.ip_public = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip_public.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_public(&mut self) -> ::std::string::String {
        self.ip_public.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_private = 5;

    pub fn ip_private(&self) -> &str {
        match self.ip_private.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_private(&mut self) {
        self.ip_private = ::std::option::Option::None;
    }

    pub fn has_ip_private(&self) -> bool {
        self.ip_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_private(&mut self, v: ::std::string::String) {
        self.ip_private = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_private(&mut self) -> &mut ::std::string::String {
        if self.ip_private.is_none() {
            self.ip_private = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip_private.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_private(&mut self) -> ::std::string::String {
        self.ip_private.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgClientGetClientDetailsResponse.Game games_running = 6;

    pub fn games_running(&self) -> &[cmsg_client_get_client_details_response::Game] {
        &self.games_running
    }

    pub fn clear_games_running(&mut self) {
        self.games_running.clear();
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: ::std::vec::Vec<cmsg_client_get_client_details_response::Game>) {
        self.games_running = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games_running(&mut self) -> &mut ::std::vec::Vec<cmsg_client_get_client_details_response::Game> {
        &mut self.games_running
    }

    // Take field
    pub fn take_games_running(&mut self) -> ::std::vec::Vec<cmsg_client_get_client_details_response::Game> {
        ::std::mem::replace(&mut self.games_running, ::std::vec::Vec::new())
    }

    // optional uint64 bytes_available = 7;

    pub fn bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 clientcomm_version = 9;

    pub fn clientcomm_version(&self) -> u32 {
        self.clientcomm_version.unwrap_or(0)
    }

    pub fn clear_clientcomm_version(&mut self) {
        self.clientcomm_version = ::std::option::Option::None;
    }

    pub fn has_clientcomm_version(&self) -> bool {
        self.clientcomm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientcomm_version(&mut self, v: u32) {
        self.clientcomm_version = ::std::option::Option::Some(v);
    }

    // repeated uint32 local_users = 10;

    pub fn local_users(&self) -> &[u32] {
        &self.local_users
    }

    pub fn clear_local_users(&mut self) {
        self.local_users.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_users(&mut self, v: ::std::vec::Vec<u32>) {
        self.local_users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_local_users(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.local_users
    }

    // Take field
    pub fn take_local_users(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.local_users, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_version",
            |m: &CMsgClientGetClientDetailsResponse| { &m.package_version },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.package_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &CMsgClientGetClientDetailsResponse| { &m.os },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.os },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name",
            |m: &CMsgClientGetClientDetailsResponse| { &m.machine_name },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.machine_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_public",
            |m: &CMsgClientGetClientDetailsResponse| { &m.ip_public },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_public },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_private",
            |m: &CMsgClientGetClientDetailsResponse| { &m.ip_private },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_private },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "games_running",
            |m: &CMsgClientGetClientDetailsResponse| { &m.games_running },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.games_running },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_available",
            |m: &CMsgClientGetClientDetailsResponse| { &m.bytes_available },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.bytes_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgClientGetClientDetailsResponse| { &m.protocol_version },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.protocol_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientcomm_version",
            |m: &CMsgClientGetClientDetailsResponse| { &m.clientcomm_version },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.clientcomm_version },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "local_users",
            |m: &CMsgClientGetClientDetailsResponse| { &m.local_users },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.local_users },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientDetailsResponse>(
            "CMsgClientGetClientDetailsResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetClientDetailsResponse {
    const NAME: &'static str = "CMsgClientGetClientDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.package_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ip_public = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.ip_private = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.games_running.push(is.read_message()?);
                },
                56 => {
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.clientcomm_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.local_users)?;
                },
                80 => {
                    self.local_users.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.package_version {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.os.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.ip_public.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.ip_private.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        for value in &self.games_running {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.bytes_available {
            my_size += crate::rt::uint64_size(7, v);
        }
        if let Some(v) = self.protocol_version {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.clientcomm_version {
            my_size += crate::rt::uint32_size(9, v);
        }
        for value in &self.local_users {
            my_size += crate::rt::uint32_size(10, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.package_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ip_public.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.ip_private.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.games_running {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.bytes_available {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.clientcomm_version {
            os.write_uint32(9, v)?;
        }
        for v in &self.local_users {
            os.write_uint32(10, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientDetailsResponse {
        CMsgClientGetClientDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.package_version = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.ip_public = ::std::option::Option::None;
        self.ip_private = ::std::option::Option::None;
        self.games_running.clear();
        self.bytes_available = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.clientcomm_version = ::std::option::Option::None;
        self.local_users.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientDetailsResponse {
        static instance: CMsgClientGetClientDetailsResponse = CMsgClientGetClientDetailsResponse {
            package_version: ::std::option::Option::None,
            os: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            ip_public: ::std::option::Option::None,
            ip_private: ::std::option::Option::None,
            games_running: ::std::vec::Vec::new(),
            bytes_available: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            clientcomm_version: ::std::option::Option::None,
            local_users: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetClientDetailsResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientDetailsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetClientDetailsResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGetClientDetailsResponse`
pub mod cmsg_client_get_client_details_response {
    // @@protoc_insertion_point(message:CMsgClientGetClientDetailsResponse.Game)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Game {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.extra_info)
        pub extra_info: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.time_running_sec)
        pub time_running_sec: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetClientDetailsResponse.Game.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Game {
        fn default() -> &'a Game {
            <Game as crate::Message>::default_instance()
        }
    }

    impl Game {
        pub fn new() -> Game {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string extra_info = 2;

        pub fn extra_info(&self) -> &str {
            match self.extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_extra_info(&mut self) {
            self.extra_info = ::std::option::Option::None;
        }

        pub fn has_extra_info(&self) -> bool {
            self.extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_info(&mut self, v: ::std::string::String) {
            self.extra_info = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_extra_info(&mut self) -> &mut ::std::string::String {
            if self.extra_info.is_none() {
                self.extra_info = ::std::option::Option::Some(::std::string::String::new());
            }
            self.extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_extra_info(&mut self) -> ::std::string::String {
            self.extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 time_running_sec = 3;

        pub fn time_running_sec(&self) -> u32 {
            self.time_running_sec.unwrap_or(0)
        }

        pub fn clear_time_running_sec(&mut self) {
            self.time_running_sec = ::std::option::Option::None;
        }

        pub fn has_time_running_sec(&self) -> bool {
            self.time_running_sec.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_running_sec(&mut self, v: u32) {
            self.time_running_sec = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &Game| { &m.appid },
                |m: &mut Game| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "extra_info",
                |m: &Game| { &m.extra_info },
                |m: &mut Game| { &mut m.extra_info },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_running_sec",
                |m: &Game| { &m.time_running_sec },
                |m: &mut Game| { &mut m.time_running_sec },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Game>(
                "CMsgClientGetClientDetailsResponse.Game",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Game {
        const NAME: &'static str = "Game";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.extra_info = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.time_running_sec = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.extra_info.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.time_running_sec {
                my_size += crate::rt::uint32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extra_info.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.time_running_sec {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Game {
            Game::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.extra_info = ::std::option::Option::None;
            self.time_running_sec = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Game {
            static instance: Game = Game {
                appid: ::std::option::Option::None,
                extra_info: ::std::option::Option::None,
                time_running_sec: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Game {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetClientDetailsResponse.Game").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Game {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Game {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClientAppList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientAppList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.media)
    pub media: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.tools)
    pub tools: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.games)
    pub games: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.only_installed)
    pub only_installed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.only_changing)
    pub only_changing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.comics)
    pub comics: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.include_client_info)
    pub include_client_info: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientAppList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppList {
    fn default() -> &'a CMsgClientGetClientAppList {
        <CMsgClientGetClientAppList as crate::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppList {
    pub fn new() -> CMsgClientGetClientAppList {
        ::std::default::Default::default()
    }

    // optional bool media = 1;

    pub fn media(&self) -> bool {
        self.media.unwrap_or(false)
    }

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool tools = 2;

    pub fn tools(&self) -> bool {
        self.tools.unwrap_or(false)
    }

    pub fn clear_tools(&mut self) {
        self.tools = ::std::option::Option::None;
    }

    pub fn has_tools(&self) -> bool {
        self.tools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tools(&mut self, v: bool) {
        self.tools = ::std::option::Option::Some(v);
    }

    // optional bool games = 3;

    pub fn games(&self) -> bool {
        self.games.unwrap_or(false)
    }

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: bool) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional bool only_installed = 4;

    pub fn only_installed(&self) -> bool {
        self.only_installed.unwrap_or(false)
    }

    pub fn clear_only_installed(&mut self) {
        self.only_installed = ::std::option::Option::None;
    }

    pub fn has_only_installed(&self) -> bool {
        self.only_installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_installed(&mut self, v: bool) {
        self.only_installed = ::std::option::Option::Some(v);
    }

    // optional bool only_changing = 5;

    pub fn only_changing(&self) -> bool {
        self.only_changing.unwrap_or(false)
    }

    pub fn clear_only_changing(&mut self) {
        self.only_changing = ::std::option::Option::None;
    }

    pub fn has_only_changing(&self) -> bool {
        self.only_changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_changing(&mut self, v: bool) {
        self.only_changing = ::std::option::Option::Some(v);
    }

    // optional bool comics = 6;

    pub fn comics(&self) -> bool {
        self.comics.unwrap_or(false)
    }

    pub fn clear_comics(&mut self) {
        self.comics = ::std::option::Option::None;
    }

    pub fn has_comics(&self) -> bool {
        self.comics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comics(&mut self, v: bool) {
        self.comics = ::std::option::Option::Some(v);
    }

    // optional bool include_client_info = 7;

    pub fn include_client_info(&self) -> bool {
        self.include_client_info.unwrap_or(false)
    }

    pub fn clear_include_client_info(&mut self) {
        self.include_client_info = ::std::option::Option::None;
    }

    pub fn has_include_client_info(&self) -> bool {
        self.include_client_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_client_info(&mut self, v: bool) {
        self.include_client_info = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "media",
            |m: &CMsgClientGetClientAppList| { &m.media },
            |m: &mut CMsgClientGetClientAppList| { &mut m.media },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tools",
            |m: &CMsgClientGetClientAppList| { &m.tools },
            |m: &mut CMsgClientGetClientAppList| { &mut m.tools },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "games",
            |m: &CMsgClientGetClientAppList| { &m.games },
            |m: &mut CMsgClientGetClientAppList| { &mut m.games },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_installed",
            |m: &CMsgClientGetClientAppList| { &m.only_installed },
            |m: &mut CMsgClientGetClientAppList| { &mut m.only_installed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_changing",
            |m: &CMsgClientGetClientAppList| { &m.only_changing },
            |m: &mut CMsgClientGetClientAppList| { &mut m.only_changing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "comics",
            |m: &CMsgClientGetClientAppList| { &m.comics },
            |m: &mut CMsgClientGetClientAppList| { &mut m.comics },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_client_info",
            |m: &CMsgClientGetClientAppList| { &m.include_client_info },
            |m: &mut CMsgClientGetClientAppList| { &mut m.include_client_info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientAppList>(
            "CMsgClientGetClientAppList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetClientAppList {
    const NAME: &'static str = "CMsgClientGetClientAppList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.media = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.tools = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.games = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.only_installed = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.only_changing = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.comics = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.include_client_info = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.media {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tools {
            my_size += 1 + 1;
        }
        if let Some(v) = self.games {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_installed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_changing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.comics {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_client_info {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.media {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tools {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.games {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.only_installed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.only_changing {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.comics {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.include_client_info {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientAppList {
        CMsgClientGetClientAppList::new()
    }

    fn clear(&mut self) {
        self.media = ::std::option::Option::None;
        self.tools = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.only_installed = ::std::option::Option::None;
        self.only_changing = ::std::option::Option::None;
        self.comics = ::std::option::Option::None;
        self.include_client_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientAppList {
        static instance: CMsgClientGetClientAppList = CMsgClientGetClientAppList {
            media: ::std::option::Option::None,
            tools: ::std::option::Option::None,
            games: ::std::option::Option::None,
            only_installed: ::std::option::Option::None,
            only_changing: ::std::option::Option::None,
            comics: ::std::option::Option::None,
            include_client_info: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetClientAppList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientAppList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetClientAppList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientAppListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.apps)
    pub apps: ::std::vec::Vec<cmsg_client_get_client_app_list_response::App>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.bytes_available)
    pub bytes_available: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.client_info)
    pub client_info: crate::MessageField<CMsgClientGetClientDetailsResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppListResponse {
    fn default() -> &'a CMsgClientGetClientAppListResponse {
        <CMsgClientGetClientAppListResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppListResponse {
    pub fn new() -> CMsgClientGetClientAppListResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientGetClientAppListResponse.App apps = 1;

    pub fn apps(&self) -> &[cmsg_client_get_client_app_list_response::App] {
        &self.apps
    }

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::std::vec::Vec<cmsg_client_get_client_app_list_response::App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::std::vec::Vec<cmsg_client_get_client_app_list_response::App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::std::vec::Vec<cmsg_client_get_client_app_list_response::App> {
        ::std::mem::replace(&mut self.apps, ::std::vec::Vec::new())
    }

    // optional uint64 bytes_available = 2;

    pub fn bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    // optional .CMsgClientGetClientDetailsResponse client_info = 3;

    pub fn client_info(&self) -> &CMsgClientGetClientDetailsResponse {
        self.client_info.as_ref().unwrap_or_else(|| <CMsgClientGetClientDetailsResponse as crate::Message>::default_instance())
    }

    pub fn clear_client_info(&mut self) {
        self.client_info.clear();
    }

    pub fn has_client_info(&self) -> bool {
        self.client_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_info(&mut self, v: CMsgClientGetClientDetailsResponse) {
        self.client_info = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_info(&mut self) -> &mut CMsgClientGetClientDetailsResponse {
        self.client_info.mut_or_insert_default()
    }

    // Take field
    pub fn take_client_info(&mut self) -> CMsgClientGetClientDetailsResponse {
        self.client_info.take().unwrap_or_else(|| CMsgClientGetClientDetailsResponse::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientGetClientAppListResponse| { &m.apps },
            |m: &mut CMsgClientGetClientAppListResponse| { &mut m.apps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_available",
            |m: &CMsgClientGetClientAppListResponse| { &m.bytes_available },
            |m: &mut CMsgClientGetClientAppListResponse| { &mut m.bytes_available },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgClientGetClientDetailsResponse>(
            "client_info",
            |m: &CMsgClientGetClientAppListResponse| { &m.client_info },
            |m: &mut CMsgClientGetClientAppListResponse| { &mut m.client_info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientAppListResponse>(
            "CMsgClientGetClientAppListResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetClientAppListResponse {
    const NAME: &'static str = "CMsgClientGetClientAppListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                16 => {
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.client_info)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.bytes_available {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.client_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.apps {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.bytes_available {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.client_info.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientAppListResponse {
        CMsgClientGetClientAppListResponse::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.bytes_available = ::std::option::Option::None;
        self.client_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientAppListResponse {
        static instance: CMsgClientGetClientAppListResponse = CMsgClientGetClientAppListResponse {
            apps: ::std::vec::Vec::new(),
            bytes_available: ::std::option::Option::None,
            client_info: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetClientAppListResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientAppListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetClientAppListResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGetClientAppListResponse`
pub mod cmsg_client_get_client_app_list_response {
    // @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.category)
        pub category: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.app_type)
        pub app_type: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.favorite)
        pub favorite: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.installed)
        pub installed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.auto_update)
        pub auto_update: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_downloaded)
        pub bytes_downloaded: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_to_download)
        pub bytes_to_download: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_download_rate)
        pub bytes_download_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.dlcs)
        pub dlcs: ::std::vec::Vec<app::DLC>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.download_paused)
        pub download_paused: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.num_downloading)
        pub num_downloading: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.num_paused)
        pub num_paused: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.changing)
        pub changing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.available_on_platform)
        pub available_on_platform: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_staged)
        pub bytes_staged: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_to_stage)
        pub bytes_to_stage: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_required)
        pub bytes_required: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.source_buildid)
        pub source_buildid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.target_buildid)
        pub target_buildid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.estimated_seconds_remaining)
        pub estimated_seconds_remaining: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.queue_position)
        pub queue_position: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.uninstalling)
        pub uninstalling: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.rt_time_scheduled)
        pub rt_time_scheduled: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.App.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as crate::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string category = 2;

        pub fn category(&self) -> &str {
            match self.category.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category(&mut self) {
            self.category = ::std::option::Option::None;
        }

        pub fn has_category(&self) -> bool {
            self.category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category(&mut self, v: ::std::string::String) {
            self.category = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category(&mut self) -> &mut ::std::string::String {
            if self.category.is_none() {
                self.category = ::std::option::Option::Some(::std::string::String::new());
            }
            self.category.as_mut().unwrap()
        }

        // Take field
        pub fn take_category(&mut self) -> ::std::string::String {
            self.category.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string app_type = 10;

        pub fn app_type(&self) -> &str {
            match self.app_type.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_app_type(&mut self) {
            self.app_type = ::std::option::Option::None;
        }

        pub fn has_app_type(&self) -> bool {
            self.app_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_type(&mut self, v: ::std::string::String) {
            self.app_type = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_app_type(&mut self) -> &mut ::std::string::String {
            if self.app_type.is_none() {
                self.app_type = ::std::option::Option::Some(::std::string::String::new());
            }
            self.app_type.as_mut().unwrap()
        }

        // Take field
        pub fn take_app_type(&mut self) -> ::std::string::String {
            self.app_type.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool favorite = 3;

        pub fn favorite(&self) -> bool {
            self.favorite.unwrap_or(false)
        }

        pub fn clear_favorite(&mut self) {
            self.favorite = ::std::option::Option::None;
        }

        pub fn has_favorite(&self) -> bool {
            self.favorite.is_some()
        }

        // Param is passed by value, moved
        pub fn set_favorite(&mut self, v: bool) {
            self.favorite = ::std::option::Option::Some(v);
        }

        // optional bool installed = 4;

        pub fn installed(&self) -> bool {
            self.installed.unwrap_or(false)
        }

        pub fn clear_installed(&mut self) {
            self.installed = ::std::option::Option::None;
        }

        pub fn has_installed(&self) -> bool {
            self.installed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_installed(&mut self, v: bool) {
            self.installed = ::std::option::Option::Some(v);
        }

        // optional bool auto_update = 5;

        pub fn auto_update(&self) -> bool {
            self.auto_update.unwrap_or(false)
        }

        pub fn clear_auto_update(&mut self) {
            self.auto_update = ::std::option::Option::None;
        }

        pub fn has_auto_update(&self) -> bool {
            self.auto_update.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auto_update(&mut self, v: bool) {
            self.auto_update = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_downloaded = 6;

        pub fn bytes_downloaded(&self) -> u64 {
            self.bytes_downloaded.unwrap_or(0)
        }

        pub fn clear_bytes_downloaded(&mut self) {
            self.bytes_downloaded = ::std::option::Option::None;
        }

        pub fn has_bytes_downloaded(&self) -> bool {
            self.bytes_downloaded.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_downloaded(&mut self, v: u64) {
            self.bytes_downloaded = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_to_download = 7;

        pub fn bytes_to_download(&self) -> u64 {
            self.bytes_to_download.unwrap_or(0)
        }

        pub fn clear_bytes_to_download(&mut self) {
            self.bytes_to_download = ::std::option::Option::None;
        }

        pub fn has_bytes_to_download(&self) -> bool {
            self.bytes_to_download.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_to_download(&mut self, v: u64) {
            self.bytes_to_download = ::std::option::Option::Some(v);
        }

        // optional uint32 bytes_download_rate = 8;

        pub fn bytes_download_rate(&self) -> u32 {
            self.bytes_download_rate.unwrap_or(0)
        }

        pub fn clear_bytes_download_rate(&mut self) {
            self.bytes_download_rate = ::std::option::Option::None;
        }

        pub fn has_bytes_download_rate(&self) -> bool {
            self.bytes_download_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_download_rate(&mut self, v: u32) {
            self.bytes_download_rate = ::std::option::Option::Some(v);
        }

        // repeated .CMsgClientGetClientAppListResponse.App.DLC dlcs = 9;

        pub fn dlcs(&self) -> &[app::DLC] {
            &self.dlcs
        }

        pub fn clear_dlcs(&mut self) {
            self.dlcs.clear();
        }

        // Param is passed by value, moved
        pub fn set_dlcs(&mut self, v: ::std::vec::Vec<app::DLC>) {
            self.dlcs = v;
        }

        // Mutable pointer to the field.
        pub fn mut_dlcs(&mut self) -> &mut ::std::vec::Vec<app::DLC> {
            &mut self.dlcs
        }

        // Take field
        pub fn take_dlcs(&mut self) -> ::std::vec::Vec<app::DLC> {
            ::std::mem::replace(&mut self.dlcs, ::std::vec::Vec::new())
        }

        // optional bool download_paused = 11;

        pub fn download_paused(&self) -> bool {
            self.download_paused.unwrap_or(false)
        }

        pub fn clear_download_paused(&mut self) {
            self.download_paused = ::std::option::Option::None;
        }

        pub fn has_download_paused(&self) -> bool {
            self.download_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_download_paused(&mut self, v: bool) {
            self.download_paused = ::std::option::Option::Some(v);
        }

        // optional uint32 num_downloading = 12;

        pub fn num_downloading(&self) -> u32 {
            self.num_downloading.unwrap_or(0)
        }

        pub fn clear_num_downloading(&mut self) {
            self.num_downloading = ::std::option::Option::None;
        }

        pub fn has_num_downloading(&self) -> bool {
            self.num_downloading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_downloading(&mut self, v: u32) {
            self.num_downloading = ::std::option::Option::Some(v);
        }

        // optional uint32 num_paused = 13;

        pub fn num_paused(&self) -> u32 {
            self.num_paused.unwrap_or(0)
        }

        pub fn clear_num_paused(&mut self) {
            self.num_paused = ::std::option::Option::None;
        }

        pub fn has_num_paused(&self) -> bool {
            self.num_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_paused(&mut self, v: u32) {
            self.num_paused = ::std::option::Option::Some(v);
        }

        // optional bool changing = 14;

        pub fn changing(&self) -> bool {
            self.changing.unwrap_or(false)
        }

        pub fn clear_changing(&mut self) {
            self.changing = ::std::option::Option::None;
        }

        pub fn has_changing(&self) -> bool {
            self.changing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changing(&mut self, v: bool) {
            self.changing = ::std::option::Option::Some(v);
        }

        // optional bool available_on_platform = 15;

        pub fn available_on_platform(&self) -> bool {
            self.available_on_platform.unwrap_or(false)
        }

        pub fn clear_available_on_platform(&mut self) {
            self.available_on_platform = ::std::option::Option::None;
        }

        pub fn has_available_on_platform(&self) -> bool {
            self.available_on_platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_available_on_platform(&mut self, v: bool) {
            self.available_on_platform = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_staged = 16;

        pub fn bytes_staged(&self) -> u64 {
            self.bytes_staged.unwrap_or(0)
        }

        pub fn clear_bytes_staged(&mut self) {
            self.bytes_staged = ::std::option::Option::None;
        }

        pub fn has_bytes_staged(&self) -> bool {
            self.bytes_staged.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_staged(&mut self, v: u64) {
            self.bytes_staged = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_to_stage = 17;

        pub fn bytes_to_stage(&self) -> u64 {
            self.bytes_to_stage.unwrap_or(0)
        }

        pub fn clear_bytes_to_stage(&mut self) {
            self.bytes_to_stage = ::std::option::Option::None;
        }

        pub fn has_bytes_to_stage(&self) -> bool {
            self.bytes_to_stage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_to_stage(&mut self, v: u64) {
            self.bytes_to_stage = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_required = 18;

        pub fn bytes_required(&self) -> u64 {
            self.bytes_required.unwrap_or(0)
        }

        pub fn clear_bytes_required(&mut self) {
            self.bytes_required = ::std::option::Option::None;
        }

        pub fn has_bytes_required(&self) -> bool {
            self.bytes_required.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_required(&mut self, v: u64) {
            self.bytes_required = ::std::option::Option::Some(v);
        }

        // optional uint32 source_buildid = 19;

        pub fn source_buildid(&self) -> u32 {
            self.source_buildid.unwrap_or(0)
        }

        pub fn clear_source_buildid(&mut self) {
            self.source_buildid = ::std::option::Option::None;
        }

        pub fn has_source_buildid(&self) -> bool {
            self.source_buildid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_buildid(&mut self, v: u32) {
            self.source_buildid = ::std::option::Option::Some(v);
        }

        // optional uint32 target_buildid = 20;

        pub fn target_buildid(&self) -> u32 {
            self.target_buildid.unwrap_or(0)
        }

        pub fn clear_target_buildid(&mut self) {
            self.target_buildid = ::std::option::Option::None;
        }

        pub fn has_target_buildid(&self) -> bool {
            self.target_buildid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_buildid(&mut self, v: u32) {
            self.target_buildid = ::std::option::Option::Some(v);
        }

        // optional uint32 estimated_seconds_remaining = 21;

        pub fn estimated_seconds_remaining(&self) -> u32 {
            self.estimated_seconds_remaining.unwrap_or(0)
        }

        pub fn clear_estimated_seconds_remaining(&mut self) {
            self.estimated_seconds_remaining = ::std::option::Option::None;
        }

        pub fn has_estimated_seconds_remaining(&self) -> bool {
            self.estimated_seconds_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_estimated_seconds_remaining(&mut self, v: u32) {
            self.estimated_seconds_remaining = ::std::option::Option::Some(v);
        }

        // optional int32 queue_position = 22;

        pub fn queue_position(&self) -> i32 {
            self.queue_position.unwrap_or(0)
        }

        pub fn clear_queue_position(&mut self) {
            self.queue_position = ::std::option::Option::None;
        }

        pub fn has_queue_position(&self) -> bool {
            self.queue_position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_queue_position(&mut self, v: i32) {
            self.queue_position = ::std::option::Option::Some(v);
        }

        // optional bool uninstalling = 23;

        pub fn uninstalling(&self) -> bool {
            self.uninstalling.unwrap_or(false)
        }

        pub fn clear_uninstalling(&mut self) {
            self.uninstalling = ::std::option::Option::None;
        }

        pub fn has_uninstalling(&self) -> bool {
            self.uninstalling.is_some()
        }

        // Param is passed by value, moved
        pub fn set_uninstalling(&mut self, v: bool) {
            self.uninstalling = ::std::option::Option::Some(v);
        }

        // optional uint32 rt_time_scheduled = 24;

        pub fn rt_time_scheduled(&self) -> u32 {
            self.rt_time_scheduled.unwrap_or(0)
        }

        pub fn clear_rt_time_scheduled(&mut self) {
            self.rt_time_scheduled = ::std::option::Option::None;
        }

        pub fn has_rt_time_scheduled(&self) -> bool {
            self.rt_time_scheduled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rt_time_scheduled(&mut self, v: u32) {
            self.rt_time_scheduled = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(24);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &App| { &m.appid },
                |m: &mut App| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "category",
                |m: &App| { &m.category },
                |m: &mut App| { &mut m.category },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_type",
                |m: &App| { &m.app_type },
                |m: &mut App| { &mut m.app_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "favorite",
                |m: &App| { &m.favorite },
                |m: &mut App| { &mut m.favorite },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "installed",
                |m: &App| { &m.installed },
                |m: &mut App| { &mut m.installed },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "auto_update",
                |m: &App| { &m.auto_update },
                |m: &mut App| { &mut m.auto_update },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_downloaded",
                |m: &App| { &m.bytes_downloaded },
                |m: &mut App| { &mut m.bytes_downloaded },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_to_download",
                |m: &App| { &m.bytes_to_download },
                |m: &mut App| { &mut m.bytes_to_download },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_download_rate",
                |m: &App| { &m.bytes_download_rate },
                |m: &mut App| { &mut m.bytes_download_rate },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dlcs",
                |m: &App| { &m.dlcs },
                |m: &mut App| { &mut m.dlcs },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "download_paused",
                |m: &App| { &m.download_paused },
                |m: &mut App| { &mut m.download_paused },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_downloading",
                |m: &App| { &m.num_downloading },
                |m: &mut App| { &mut m.num_downloading },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_paused",
                |m: &App| { &m.num_paused },
                |m: &mut App| { &mut m.num_paused },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "changing",
                |m: &App| { &m.changing },
                |m: &mut App| { &mut m.changing },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "available_on_platform",
                |m: &App| { &m.available_on_platform },
                |m: &mut App| { &mut m.available_on_platform },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_staged",
                |m: &App| { &m.bytes_staged },
                |m: &mut App| { &mut m.bytes_staged },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_to_stage",
                |m: &App| { &m.bytes_to_stage },
                |m: &mut App| { &mut m.bytes_to_stage },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_required",
                |m: &App| { &m.bytes_required },
                |m: &mut App| { &mut m.bytes_required },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_buildid",
                |m: &App| { &m.source_buildid },
                |m: &mut App| { &mut m.source_buildid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "target_buildid",
                |m: &App| { &m.target_buildid },
                |m: &mut App| { &mut m.target_buildid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "estimated_seconds_remaining",
                |m: &App| { &m.estimated_seconds_remaining },
                |m: &mut App| { &mut m.estimated_seconds_remaining },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "queue_position",
                |m: &App| { &m.queue_position },
                |m: &mut App| { &mut m.queue_position },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "uninstalling",
                |m: &App| { &m.uninstalling },
                |m: &mut App| { &mut m.uninstalling },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rt_time_scheduled",
                |m: &App| { &m.rt_time_scheduled },
                |m: &mut App| { &mut m.rt_time_scheduled },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<App>(
                "CMsgClientGetClientAppListResponse.App",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.category = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.app_type = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.favorite = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.installed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.auto_update = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.bytes_to_download = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.bytes_download_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    74 => {
                        self.dlcs.push(is.read_message()?);
                    },
                    88 => {
                        self.download_paused = ::std::option::Option::Some(is.read_bool()?);
                    },
                    96 => {
                        self.num_downloading = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.num_paused = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.changing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.available_on_platform = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.bytes_staged = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    136 => {
                        self.bytes_to_stage = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    144 => {
                        self.bytes_required = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    152 => {
                        self.source_buildid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.target_buildid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.estimated_seconds_remaining = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                    },
                    184 => {
                        self.uninstalling = ::std::option::Option::Some(is.read_bool()?);
                    },
                    192 => {
                        self.rt_time_scheduled = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.category.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.app_type.as_ref() {
                my_size += crate::rt::string_size(10, &v);
            }
            if let Some(v) = self.favorite {
                my_size += 1 + 1;
            }
            if let Some(v) = self.installed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.auto_update {
                my_size += 1 + 1;
            }
            if let Some(v) = self.bytes_downloaded {
                my_size += crate::rt::uint64_size(6, v);
            }
            if let Some(v) = self.bytes_to_download {
                my_size += crate::rt::uint64_size(7, v);
            }
            if let Some(v) = self.bytes_download_rate {
                my_size += crate::rt::uint32_size(8, v);
            }
            for value in &self.dlcs {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.download_paused {
                my_size += 1 + 1;
            }
            if let Some(v) = self.num_downloading {
                my_size += crate::rt::uint32_size(12, v);
            }
            if let Some(v) = self.num_paused {
                my_size += crate::rt::uint32_size(13, v);
            }
            if let Some(v) = self.changing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.available_on_platform {
                my_size += 1 + 1;
            }
            if let Some(v) = self.bytes_staged {
                my_size += crate::rt::uint64_size(16, v);
            }
            if let Some(v) = self.bytes_to_stage {
                my_size += crate::rt::uint64_size(17, v);
            }
            if let Some(v) = self.bytes_required {
                my_size += crate::rt::uint64_size(18, v);
            }
            if let Some(v) = self.source_buildid {
                my_size += crate::rt::uint32_size(19, v);
            }
            if let Some(v) = self.target_buildid {
                my_size += crate::rt::uint32_size(20, v);
            }
            if let Some(v) = self.estimated_seconds_remaining {
                my_size += crate::rt::uint32_size(21, v);
            }
            if let Some(v) = self.queue_position {
                my_size += crate::rt::int32_size(22, v);
            }
            if let Some(v) = self.uninstalling {
                my_size += 2 + 1;
            }
            if let Some(v) = self.rt_time_scheduled {
                my_size += crate::rt::uint32_size(24, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.category.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.app_type.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.favorite {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.installed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.auto_update {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.bytes_downloaded {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.bytes_to_download {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.bytes_download_rate {
                os.write_uint32(8, v)?;
            }
            for v in &self.dlcs {
                crate::rt::write_message_field_with_cached_size(9, v, os)?;
            };
            if let Some(v) = self.download_paused {
                os.write_bool(11, v)?;
            }
            if let Some(v) = self.num_downloading {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.num_paused {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.changing {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.available_on_platform {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.bytes_staged {
                os.write_uint64(16, v)?;
            }
            if let Some(v) = self.bytes_to_stage {
                os.write_uint64(17, v)?;
            }
            if let Some(v) = self.bytes_required {
                os.write_uint64(18, v)?;
            }
            if let Some(v) = self.source_buildid {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.target_buildid {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.estimated_seconds_remaining {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.queue_position {
                os.write_int32(22, v)?;
            }
            if let Some(v) = self.uninstalling {
                os.write_bool(23, v)?;
            }
            if let Some(v) = self.rt_time_scheduled {
                os.write_uint32(24, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.category = ::std::option::Option::None;
            self.app_type = ::std::option::Option::None;
            self.favorite = ::std::option::Option::None;
            self.installed = ::std::option::Option::None;
            self.auto_update = ::std::option::Option::None;
            self.bytes_downloaded = ::std::option::Option::None;
            self.bytes_to_download = ::std::option::Option::None;
            self.bytes_download_rate = ::std::option::Option::None;
            self.dlcs.clear();
            self.download_paused = ::std::option::Option::None;
            self.num_downloading = ::std::option::Option::None;
            self.num_paused = ::std::option::Option::None;
            self.changing = ::std::option::Option::None;
            self.available_on_platform = ::std::option::Option::None;
            self.bytes_staged = ::std::option::Option::None;
            self.bytes_to_stage = ::std::option::Option::None;
            self.bytes_required = ::std::option::Option::None;
            self.source_buildid = ::std::option::Option::None;
            self.target_buildid = ::std::option::Option::None;
            self.estimated_seconds_remaining = ::std::option::Option::None;
            self.queue_position = ::std::option::Option::None;
            self.uninstalling = ::std::option::Option::None;
            self.rt_time_scheduled = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                appid: ::std::option::Option::None,
                category: ::std::option::Option::None,
                app_type: ::std::option::Option::None,
                favorite: ::std::option::Option::None,
                installed: ::std::option::Option::None,
                auto_update: ::std::option::Option::None,
                bytes_downloaded: ::std::option::Option::None,
                bytes_to_download: ::std::option::Option::None,
                bytes_download_rate: ::std::option::Option::None,
                dlcs: ::std::vec::Vec::new(),
                download_paused: ::std::option::Option::None,
                num_downloading: ::std::option::Option::None,
                num_paused: ::std::option::Option::None,
                changing: ::std::option::Option::None,
                available_on_platform: ::std::option::Option::None,
                bytes_staged: ::std::option::Option::None,
                bytes_to_stage: ::std::option::Option::None,
                bytes_required: ::std::option::Option::None,
                source_buildid: ::std::option::Option::None,
                target_buildid: ::std::option::Option::None,
                estimated_seconds_remaining: ::std::option::Option::None,
                queue_position: ::std::option::Option::None,
                uninstalling: ::std::option::Option::None,
                rt_time_scheduled: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for App {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppListResponse.App").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for App {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `App`
    pub mod app {
        // @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse.App.DLC)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DLC {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.DLC.appid)
            pub appid: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.DLC.installed)
            pub installed: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.App.DLC.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DLC {
            fn default() -> &'a DLC {
                <DLC as crate::Message>::default_instance()
            }
        }

        impl DLC {
            pub fn new() -> DLC {
                ::std::default::Default::default()
            }

            // optional uint32 appid = 1;

            pub fn appid(&self) -> u32 {
                self.appid.unwrap_or(0)
            }

            pub fn clear_appid(&mut self) {
                self.appid = ::std::option::Option::None;
            }

            pub fn has_appid(&self) -> bool {
                self.appid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_appid(&mut self, v: u32) {
                self.appid = ::std::option::Option::Some(v);
            }

            // optional bool installed = 2;

            pub fn installed(&self) -> bool {
                self.installed.unwrap_or(false)
            }

            pub fn clear_installed(&mut self) {
                self.installed = ::std::option::Option::None;
            }

            pub fn has_installed(&self) -> bool {
                self.installed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_installed(&mut self, v: bool) {
                self.installed = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "appid",
                    |m: &DLC| { &m.appid },
                    |m: &mut DLC| { &mut m.appid },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "installed",
                    |m: &DLC| { &m.installed },
                    |m: &mut DLC| { &mut m.installed },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<DLC>(
                    "CMsgClientGetClientAppListResponse.App.DLC",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for DLC {
            const NAME: &'static str = "DLC";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.appid = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.installed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.appid {
                    my_size += crate::rt::uint32_size(1, v);
                }
                if let Some(v) = self.installed {
                    my_size += 1 + 1;
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.appid {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.installed {
                    os.write_bool(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DLC {
                DLC::new()
            }

            fn clear(&mut self) {
                self.appid = ::std::option::Option::None;
                self.installed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DLC {
                static instance: DLC = DLC {
                    appid: ::std::option::Option::None,
                    installed: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for DLC {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppListResponse.App.DLC").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DLC {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for DLC {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientInstallClientApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInstallClientApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInstallClientApp.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInstallClientApp.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientApp {
    fn default() -> &'a CMsgClientInstallClientApp {
        <CMsgClientInstallClientApp as crate::Message>::default_instance()
    }
}

impl CMsgClientInstallClientApp {
    pub fn new() -> CMsgClientInstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientInstallClientApp| { &m.appid },
            |m: &mut CMsgClientInstallClientApp| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientInstallClientApp>(
            "CMsgClientInstallClientApp",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientInstallClientApp {
    const NAME: &'static str = "CMsgClientInstallClientApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInstallClientApp {
        CMsgClientInstallClientApp::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInstallClientApp {
        static instance: CMsgClientInstallClientApp = CMsgClientInstallClientApp {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientInstallClientApp {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientInstallClientApp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientInstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientInstallClientApp {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientInstallClientAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInstallClientAppResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInstallClientAppResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInstallClientAppResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientAppResponse {
    fn default() -> &'a CMsgClientInstallClientAppResponse {
        <CMsgClientInstallClientAppResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientInstallClientAppResponse {
    pub fn new() -> CMsgClientInstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientInstallClientAppResponse| { &m.result },
            |m: &mut CMsgClientInstallClientAppResponse| { &mut m.result },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientInstallClientAppResponse>(
            "CMsgClientInstallClientAppResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientInstallClientAppResponse {
    const NAME: &'static str = "CMsgClientInstallClientAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInstallClientAppResponse {
        CMsgClientInstallClientAppResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInstallClientAppResponse {
        static instance: CMsgClientInstallClientAppResponse = CMsgClientInstallClientAppResponse {
            result: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientInstallClientAppResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientInstallClientAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientInstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientInstallClientAppResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUninstallClientApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUninstallClientApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUninstallClientApp.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUninstallClientApp.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientApp {
    fn default() -> &'a CMsgClientUninstallClientApp {
        <CMsgClientUninstallClientApp as crate::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientApp {
    pub fn new() -> CMsgClientUninstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUninstallClientApp| { &m.appid },
            |m: &mut CMsgClientUninstallClientApp| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUninstallClientApp>(
            "CMsgClientUninstallClientApp",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUninstallClientApp {
    const NAME: &'static str = "CMsgClientUninstallClientApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUninstallClientApp {
        CMsgClientUninstallClientApp::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUninstallClientApp {
        static instance: CMsgClientUninstallClientApp = CMsgClientUninstallClientApp {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUninstallClientApp {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUninstallClientApp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUninstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUninstallClientApp {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUninstallClientAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUninstallClientAppResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUninstallClientAppResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUninstallClientAppResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientAppResponse {
    fn default() -> &'a CMsgClientUninstallClientAppResponse {
        <CMsgClientUninstallClientAppResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientAppResponse {
    pub fn new() -> CMsgClientUninstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientUninstallClientAppResponse| { &m.result },
            |m: &mut CMsgClientUninstallClientAppResponse| { &mut m.result },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUninstallClientAppResponse>(
            "CMsgClientUninstallClientAppResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUninstallClientAppResponse {
    const NAME: &'static str = "CMsgClientUninstallClientAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUninstallClientAppResponse {
        CMsgClientUninstallClientAppResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUninstallClientAppResponse {
        static instance: CMsgClientUninstallClientAppResponse = CMsgClientUninstallClientAppResponse {
            result: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUninstallClientAppResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUninstallClientAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUninstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUninstallClientAppResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSetClientAppUpdateState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetClientAppUpdateState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateState.update)
    pub update: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetClientAppUpdateState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateState {
    fn default() -> &'a CMsgClientSetClientAppUpdateState {
        <CMsgClientSetClientAppUpdateState as crate::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateState {
    pub fn new() -> CMsgClientSetClientAppUpdateState {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool update = 2;

    pub fn update(&self) -> bool {
        self.update.unwrap_or(false)
    }

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientSetClientAppUpdateState| { &m.appid },
            |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update",
            |m: &CMsgClientSetClientAppUpdateState| { &m.update },
            |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.update },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSetClientAppUpdateState>(
            "CMsgClientSetClientAppUpdateState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSetClientAppUpdateState {
    const NAME: &'static str = "CMsgClientSetClientAppUpdateState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.update = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.update {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.update {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetClientAppUpdateState {
        CMsgClientSetClientAppUpdateState::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateState {
        static instance: CMsgClientSetClientAppUpdateState = CMsgClientSetClientAppUpdateState {
            appid: ::std::option::Option::None,
            update: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSetClientAppUpdateState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSetClientAppUpdateState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSetClientAppUpdateState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSetClientAppUpdateState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSetClientAppUpdateStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetClientAppUpdateStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateStateResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetClientAppUpdateStateResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateStateResponse {
    fn default() -> &'a CMsgClientSetClientAppUpdateStateResponse {
        <CMsgClientSetClientAppUpdateStateResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateStateResponse {
    pub fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientSetClientAppUpdateStateResponse| { &m.result },
            |m: &mut CMsgClientSetClientAppUpdateStateResponse| { &mut m.result },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSetClientAppUpdateStateResponse>(
            "CMsgClientSetClientAppUpdateStateResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSetClientAppUpdateStateResponse {
    const NAME: &'static str = "CMsgClientSetClientAppUpdateStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        CMsgClientSetClientAppUpdateStateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateStateResponse {
        static instance: CMsgClientSetClientAppUpdateStateResponse = CMsgClientSetClientAppUpdateStateResponse {
            result: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSetClientAppUpdateStateResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSetClientAppUpdateStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSetClientAppUpdateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSetClientAppUpdateStateResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientEnableOrDisableDownloads)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEnableOrDisableDownloads {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEnableOrDisableDownloads.enable)
    pub enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEnableOrDisableDownloads.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEnableOrDisableDownloads {
    fn default() -> &'a CMsgClientEnableOrDisableDownloads {
        <CMsgClientEnableOrDisableDownloads as crate::Message>::default_instance()
    }
}

impl CMsgClientEnableOrDisableDownloads {
    pub fn new() -> CMsgClientEnableOrDisableDownloads {
        ::std::default::Default::default()
    }

    // optional bool enable = 1;

    pub fn enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable",
            |m: &CMsgClientEnableOrDisableDownloads| { &m.enable },
            |m: &mut CMsgClientEnableOrDisableDownloads| { &mut m.enable },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientEnableOrDisableDownloads>(
            "CMsgClientEnableOrDisableDownloads",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientEnableOrDisableDownloads {
    const NAME: &'static str = "CMsgClientEnableOrDisableDownloads";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEnableOrDisableDownloads {
        CMsgClientEnableOrDisableDownloads::new()
    }

    fn clear(&mut self) {
        self.enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEnableOrDisableDownloads {
        static instance: CMsgClientEnableOrDisableDownloads = CMsgClientEnableOrDisableDownloads {
            enable: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientEnableOrDisableDownloads {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientEnableOrDisableDownloads").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientEnableOrDisableDownloads {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientEnableOrDisableDownloads {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientEnableOrDisableDownloadsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEnableOrDisableDownloadsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEnableOrDisableDownloadsResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEnableOrDisableDownloadsResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEnableOrDisableDownloadsResponse {
    fn default() -> &'a CMsgClientEnableOrDisableDownloadsResponse {
        <CMsgClientEnableOrDisableDownloadsResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientEnableOrDisableDownloadsResponse {
    pub fn new() -> CMsgClientEnableOrDisableDownloadsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientEnableOrDisableDownloadsResponse| { &m.result },
            |m: &mut CMsgClientEnableOrDisableDownloadsResponse| { &mut m.result },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientEnableOrDisableDownloadsResponse>(
            "CMsgClientEnableOrDisableDownloadsResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientEnableOrDisableDownloadsResponse {
    const NAME: &'static str = "CMsgClientEnableOrDisableDownloadsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEnableOrDisableDownloadsResponse {
        CMsgClientEnableOrDisableDownloadsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEnableOrDisableDownloadsResponse {
        static instance: CMsgClientEnableOrDisableDownloadsResponse = CMsgClientEnableOrDisableDownloadsResponse {
            result: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientEnableOrDisableDownloadsResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientEnableOrDisableDownloadsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientEnableOrDisableDownloadsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientEnableOrDisableDownloadsResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_clientserver_uds.proto\x1a\x18steammessages_base.proto\
    \"]\n\x1eCMsgClientUDSP2PSessionStarted\x12%\n\x0esteamid_remote\x18\x01\
    \x20\x01(\x06R\rsteamidRemote\x12\x14\n\x05appid\x18\x02\x20\x01(\x05R\
    \x05appid\"\x87\x03\n\x1cCMsgClientUDSP2PSessionEnded\x12%\n\x0esteamid_\
    remote\x18\x01\x20\x01(\x06R\rsteamidRemote\x12\x14\n\x05appid\x18\x02\
    \x20\x01(\x05R\x05appid\x12,\n\x12session_length_sec\x18\x03\x20\x01(\
    \x05R\x10sessionLengthSec\x12#\n\rsession_error\x18\x04\x20\x01(\x05R\
    \x0csessionError\x12\x18\n\x07nattype\x18\x05\x20\x01(\x05R\x07nattype\
    \x12\x1d\n\nbytes_recv\x18\x06\x20\x01(\x05R\tbytesRecv\x12\x1d\n\nbytes\
    _sent\x18\x07\x20\x01(\x05R\tbytesSent\x12(\n\x10bytes_sent_relay\x18\
    \x08\x20\x01(\x05R\x0ebytesSentRelay\x12(\n\x10bytes_recv_relay\x18\t\
    \x20\x01(\x05R\x0ebytesRecvRelay\x12+\n\x12time_to_connect_ms\x18\n\x20\
    \x01(\x05R\x0ftimeToConnectMs\"\x1c\n\x1aCMsgClientGetClientDetails\"\
    \x96\x04\n\"CMsgClientGetClientDetailsResponse\x12'\n\x0fpackage_version\
    \x18\x01\x20\x01(\rR\x0epackageVersion\x12\x0e\n\x02os\x18\x02\x20\x01(\
    \tR\x02os\x12!\n\x0cmachine_name\x18\x03\x20\x01(\tR\x0bmachineName\x12\
    \x1b\n\tip_public\x18\x04\x20\x01(\tR\x08ipPublic\x12\x1d\n\nip_private\
    \x18\x05\x20\x01(\tR\tipPrivate\x12M\n\rgames_running\x18\x06\x20\x03(\
    \x0b2(.CMsgClientGetClientDetailsResponse.GameR\x0cgamesRunning\x12'\n\
    \x0fbytes_available\x18\x07\x20\x01(\x04R\x0ebytesAvailable\x12)\n\x10pr\
    otocol_version\x18\x08\x20\x01(\rR\x0fprotocolVersion\x12-\n\x12clientco\
    mm_version\x18\t\x20\x01(\rR\x11clientcommVersion\x12\x1f\n\x0blocal_use\
    rs\x18\n\x20\x03(\rR\nlocalUsers\x1ae\n\x04Game\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x1d\n\nextra_info\x18\x02\x20\x01(\tR\text\
    raInfo\x12(\n\x10time_running_sec\x18\x03\x20\x01(\rR\x0etimeRunningSec\
    \"\xf2\x01\n\x1aCMsgClientGetClientAppList\x12\x14\n\x05media\x18\x01\
    \x20\x01(\x08R\x05media\x12\x14\n\x05tools\x18\x02\x20\x01(\x08R\x05tool\
    s\x12\x14\n\x05games\x18\x03\x20\x01(\x08R\x05games\x12%\n\x0eonly_insta\
    lled\x18\x04\x20\x01(\x08R\ronlyInstalled\x12#\n\ronly_changing\x18\x05\
    \x20\x01(\x08R\x0conlyChanging\x12\x16\n\x06comics\x18\x06\x20\x01(\x08R\
    \x06comics\x12.\n\x13include_client_info\x18\x07\x20\x01(\x08R\x11includ\
    eClientInfo\"\xb9\t\n\"CMsgClientGetClientAppListResponse\x12;\n\x04apps\
    \x18\x01\x20\x03(\x0b2'.CMsgClientGetClientAppListResponse.AppR\x04apps\
    \x12'\n\x0fbytes_available\x18\x02\x20\x01(\x04R\x0ebytesAvailable\x12D\
    \n\x0bclient_info\x18\x03\x20\x01(\x0b2#.CMsgClientGetClientDetailsRespo\
    nseR\nclientInfo\x1a\xe6\x07\n\x03App\x12\x14\n\x05appid\x18\x01\x20\x01\
    (\rR\x05appid\x12\x1a\n\x08category\x18\x02\x20\x01(\tR\x08category\x12\
    \x19\n\x08app_type\x18\n\x20\x01(\tR\x07appType\x12\x1a\n\x08favorite\
    \x18\x03\x20\x01(\x08R\x08favorite\x12\x1c\n\tinstalled\x18\x04\x20\x01(\
    \x08R\tinstalled\x12\x1f\n\x0bauto_update\x18\x05\x20\x01(\x08R\nautoUpd\
    ate\x12)\n\x10bytes_downloaded\x18\x06\x20\x01(\x04R\x0fbytesDownloaded\
    \x12*\n\x11bytes_to_download\x18\x07\x20\x01(\x04R\x0fbytesToDownload\
    \x12.\n\x13bytes_download_rate\x18\x08\x20\x01(\rR\x11bytesDownloadRate\
    \x12?\n\x04dlcs\x18\t\x20\x03(\x0b2+.CMsgClientGetClientAppListResponse.\
    App.DLCR\x04dlcs\x12'\n\x0fdownload_paused\x18\x0b\x20\x01(\x08R\x0edown\
    loadPaused\x12'\n\x0fnum_downloading\x18\x0c\x20\x01(\rR\x0enumDownloadi\
    ng\x12\x1d\n\nnum_paused\x18\r\x20\x01(\rR\tnumPaused\x12\x1a\n\x08chang\
    ing\x18\x0e\x20\x01(\x08R\x08changing\x122\n\x15available_on_platform\
    \x18\x0f\x20\x01(\x08R\x13availableOnPlatform\x12!\n\x0cbytes_staged\x18\
    \x10\x20\x01(\x04R\x0bbytesStaged\x12$\n\x0ebytes_to_stage\x18\x11\x20\
    \x01(\x04R\x0cbytesToStage\x12%\n\x0ebytes_required\x18\x12\x20\x01(\x04\
    R\rbytesRequired\x12%\n\x0esource_buildid\x18\x13\x20\x01(\rR\rsourceBui\
    ldid\x12%\n\x0etarget_buildid\x18\x14\x20\x01(\rR\rtargetBuildid\x12>\n\
    \x1bestimated_seconds_remaining\x18\x15\x20\x01(\rR\x19estimatedSecondsR\
    emaining\x12%\n\x0equeue_position\x18\x16\x20\x01(\x05R\rqueuePosition\
    \x12\"\n\x0cuninstalling\x18\x17\x20\x01(\x08R\x0cuninstalling\x12*\n\
    \x11rt_time_scheduled\x18\x18\x20\x01(\rR\x0frtTimeScheduled\x1a9\n\x03D\
    LC\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1c\n\tinstalled\
    \x18\x02\x20\x01(\x08R\tinstalled\"2\n\x1aCMsgClientInstallClientApp\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"<\n\"CMsgClientInstallClie\
    ntAppResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"4\n\x1c\
    CMsgClientUninstallClientApp\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05a\
    ppid\">\n$CMsgClientUninstallClientAppResponse\x12\x16\n\x06result\x18\
    \x01\x20\x01(\rR\x06result\"Q\n!CMsgClientSetClientAppUpdateState\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x16\n\x06update\x18\x02\
    \x20\x01(\x08R\x06update\"C\n)CMsgClientSetClientAppUpdateStateResponse\
    \x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"<\n\"CMsgClientEnabl\
    eOrDisableDownloads\x12\x16\n\x06enable\x18\x01\x20\x01(\x08R\x06enable\
    \"D\n*CMsgClientEnableOrDisableDownloadsResponse\x12\x16\n\x06result\x18\
    \x01\x20\x01(\rR\x06resultB\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(CMsgClientUDSP2PSessionStarted::generated_message_descriptor_data());
            messages.push(CMsgClientUDSP2PSessionEnded::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientDetails::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientDetailsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientAppList::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientAppListResponse::generated_message_descriptor_data());
            messages.push(CMsgClientInstallClientApp::generated_message_descriptor_data());
            messages.push(CMsgClientInstallClientAppResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUninstallClientApp::generated_message_descriptor_data());
            messages.push(CMsgClientUninstallClientAppResponse::generated_message_descriptor_data());
            messages.push(CMsgClientSetClientAppUpdateState::generated_message_descriptor_data());
            messages.push(CMsgClientSetClientAppUpdateStateResponse::generated_message_descriptor_data());
            messages.push(CMsgClientEnableOrDisableDownloads::generated_message_descriptor_data());
            messages.push(CMsgClientEnableOrDisableDownloadsResponse::generated_message_descriptor_data());
            messages.push(cmsg_client_get_client_details_response::Game::generated_message_descriptor_data());
            messages.push(cmsg_client_get_client_app_list_response::App::generated_message_descriptor_data());
            messages.push(cmsg_client_get_client_app_list_response::app::DLC::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
