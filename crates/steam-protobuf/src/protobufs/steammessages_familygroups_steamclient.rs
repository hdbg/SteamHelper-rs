// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_familygroups.steamclient.proto`

// @@protoc_insertion_point(message:CFamilyGroups_CreateFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CreateFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_CreateFamilyGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_CreateFamilyGroup_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CreateFamilyGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CreateFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_CreateFamilyGroup_Request {
        <CFamilyGroups_CreateFamilyGroup_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_CreateFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_CreateFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CFamilyGroups_CreateFamilyGroup_Request| { &m.name },
            |m: &mut CFamilyGroups_CreateFamilyGroup_Request| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CFamilyGroups_CreateFamilyGroup_Request| { &m.steamid },
            |m: &mut CFamilyGroups_CreateFamilyGroup_Request| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_CreateFamilyGroup_Request>(
            "CFamilyGroups_CreateFamilyGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_CreateFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_CreateFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CreateFamilyGroup_Request {
        CFamilyGroups_CreateFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CreateFamilyGroup_Request {
        static instance: CFamilyGroups_CreateFamilyGroup_Request = CFamilyGroups_CreateFamilyGroup_Request {
            name: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_CreateFamilyGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_CreateFamilyGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_CreateFamilyGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_CreateFamilyGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_CreateFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CreateFamilyGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_CreateFamilyGroup_Response.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CreateFamilyGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CreateFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_CreateFamilyGroup_Response {
        <CFamilyGroups_CreateFamilyGroup_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_CreateFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_CreateFamilyGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_CreateFamilyGroup_Response| { &m.family_groupid },
            |m: &mut CFamilyGroups_CreateFamilyGroup_Response| { &mut m.family_groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_CreateFamilyGroup_Response>(
            "CFamilyGroups_CreateFamilyGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_CreateFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_CreateFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CreateFamilyGroup_Response {
        CFamilyGroups_CreateFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CreateFamilyGroup_Response {
        static instance: CFamilyGroups_CreateFamilyGroup_Response = CFamilyGroups_CreateFamilyGroup_Response {
            family_groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_CreateFamilyGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_CreateFamilyGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_CreateFamilyGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_CreateFamilyGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Request.send_running_apps)
    pub send_running_apps: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_GetFamilyGroup_Request {
        <CFamilyGroups_GetFamilyGroup_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_GetFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool send_running_apps = 2;

    pub fn send_running_apps(&self) -> bool {
        self.send_running_apps.unwrap_or(false)
    }

    pub fn clear_send_running_apps(&mut self) {
        self.send_running_apps = ::std::option::Option::None;
    }

    pub fn has_send_running_apps(&self) -> bool {
        self.send_running_apps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_running_apps(&mut self, v: bool) {
        self.send_running_apps = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_GetFamilyGroup_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_GetFamilyGroup_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_running_apps",
            |m: &CFamilyGroups_GetFamilyGroup_Request| { &m.send_running_apps },
            |m: &mut CFamilyGroups_GetFamilyGroup_Request| { &mut m.send_running_apps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetFamilyGroup_Request>(
            "CFamilyGroups_GetFamilyGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.send_running_apps = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.send_running_apps {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.send_running_apps {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroup_Request {
        CFamilyGroups_GetFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.send_running_apps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroup_Request {
        static instance: CFamilyGroups_GetFamilyGroup_Request = CFamilyGroups_GetFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            send_running_apps: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetFamilyGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetFamilyGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetFamilyGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetFamilyGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FamilyGroupMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupMember {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupMember.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FamilyGroupMember.role)
    pub role: ::std::option::Option<crate::EnumOrUnknown<EFamilyGroupRole>>,
    // @@protoc_insertion_point(field:FamilyGroupMember.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupMember.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupMember {
    fn default() -> &'a FamilyGroupMember {
        <FamilyGroupMember as crate::Message>::default_instance()
    }
}

impl FamilyGroupMember {
    pub fn new() -> FamilyGroupMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole role = 2;

    pub fn role(&self) -> EFamilyGroupRole {
        match self.role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: EFamilyGroupRole) {
        self.role = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 time_joined = 3;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &FamilyGroupMember| { &m.steamid },
            |m: &mut FamilyGroupMember| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &FamilyGroupMember| { &m.role },
            |m: &mut FamilyGroupMember| { &mut m.role },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_joined",
            |m: &FamilyGroupMember| { &m.time_joined },
            |m: &mut FamilyGroupMember| { &mut m.time_joined },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FamilyGroupMember>(
            "FamilyGroupMember",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FamilyGroupMember {
    const NAME: &'static str = "FamilyGroupMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.role {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.time_joined {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupMember {
        FamilyGroupMember::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupMember {
        static instance: FamilyGroupMember = FamilyGroupMember {
            steamid: ::std::option::Option::None,
            role: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FamilyGroupMember {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FamilyGroupMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FamilyGroupMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FamilyGroupMember {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FamilyGroupPendingInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupPendingInvite {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupPendingInvite.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FamilyGroupPendingInvite.role)
    pub role: ::std::option::Option<crate::EnumOrUnknown<EFamilyGroupRole>>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupPendingInvite.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupPendingInvite {
    fn default() -> &'a FamilyGroupPendingInvite {
        <FamilyGroupPendingInvite as crate::Message>::default_instance()
    }
}

impl FamilyGroupPendingInvite {
    pub fn new() -> FamilyGroupPendingInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole role = 2;

    pub fn role(&self) -> EFamilyGroupRole {
        match self.role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: EFamilyGroupRole) {
        self.role = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &FamilyGroupPendingInvite| { &m.steamid },
            |m: &mut FamilyGroupPendingInvite| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &FamilyGroupPendingInvite| { &m.role },
            |m: &mut FamilyGroupPendingInvite| { &mut m.role },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FamilyGroupPendingInvite>(
            "FamilyGroupPendingInvite",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FamilyGroupPendingInvite {
    const NAME: &'static str = "FamilyGroupPendingInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.role {
            my_size += crate::rt::int32_size(2, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupPendingInvite {
        FamilyGroupPendingInvite::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupPendingInvite {
        static instance: FamilyGroupPendingInvite = FamilyGroupPendingInvite {
            steamid: ::std::option::Option::None,
            role: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FamilyGroupPendingInvite {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FamilyGroupPendingInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FamilyGroupPendingInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FamilyGroupPendingInvite {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FamilyGroupFormerMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupFormerMember {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupFormerMember.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupFormerMember.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupFormerMember {
    fn default() -> &'a FamilyGroupFormerMember {
        <FamilyGroupFormerMember as crate::Message>::default_instance()
    }
}

impl FamilyGroupFormerMember {
    pub fn new() -> FamilyGroupFormerMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &FamilyGroupFormerMember| { &m.steamid },
            |m: &mut FamilyGroupFormerMember| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FamilyGroupFormerMember>(
            "FamilyGroupFormerMember",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FamilyGroupFormerMember {
    const NAME: &'static str = "FamilyGroupFormerMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupFormerMember {
        FamilyGroupFormerMember::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupFormerMember {
        static instance: FamilyGroupFormerMember = FamilyGroupFormerMember {
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FamilyGroupFormerMember {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FamilyGroupFormerMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FamilyGroupFormerMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FamilyGroupFormerMember {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.members)
    pub members: ::std::vec::Vec<FamilyGroupMember>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.pending_invites)
    pub pending_invites: ::std::vec::Vec<FamilyGroupPendingInvite>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.free_spots)
    pub free_spots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.slot_cooldown_remaining_seconds)
    pub slot_cooldown_remaining_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.former_members)
    pub former_members: ::std::vec::Vec<FamilyGroupFormerMember>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.slot_cooldown_overrides)
    pub slot_cooldown_overrides: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_GetFamilyGroup_Response {
        <CFamilyGroups_GetFamilyGroup_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_GetFamilyGroup_Response {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .FamilyGroupMember members = 2;

    pub fn members(&self) -> &[FamilyGroupMember] {
        &self.members
    }

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::std::vec::Vec<FamilyGroupMember>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::std::vec::Vec<FamilyGroupMember> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::std::vec::Vec<FamilyGroupMember> {
        ::std::mem::replace(&mut self.members, ::std::vec::Vec::new())
    }

    // repeated .FamilyGroupPendingInvite pending_invites = 3;

    pub fn pending_invites(&self) -> &[FamilyGroupPendingInvite] {
        &self.pending_invites
    }

    pub fn clear_pending_invites(&mut self) {
        self.pending_invites.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_invites(&mut self, v: ::std::vec::Vec<FamilyGroupPendingInvite>) {
        self.pending_invites = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_invites(&mut self) -> &mut ::std::vec::Vec<FamilyGroupPendingInvite> {
        &mut self.pending_invites
    }

    // Take field
    pub fn take_pending_invites(&mut self) -> ::std::vec::Vec<FamilyGroupPendingInvite> {
        ::std::mem::replace(&mut self.pending_invites, ::std::vec::Vec::new())
    }

    // optional uint32 free_spots = 4;

    pub fn free_spots(&self) -> u32 {
        self.free_spots.unwrap_or(0)
    }

    pub fn clear_free_spots(&mut self) {
        self.free_spots = ::std::option::Option::None;
    }

    pub fn has_free_spots(&self) -> bool {
        self.free_spots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_free_spots(&mut self, v: u32) {
        self.free_spots = ::std::option::Option::Some(v);
    }

    // optional string country = 5;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 slot_cooldown_remaining_seconds = 6;

    pub fn slot_cooldown_remaining_seconds(&self) -> u32 {
        self.slot_cooldown_remaining_seconds.unwrap_or(0)
    }

    pub fn clear_slot_cooldown_remaining_seconds(&mut self) {
        self.slot_cooldown_remaining_seconds = ::std::option::Option::None;
    }

    pub fn has_slot_cooldown_remaining_seconds(&self) -> bool {
        self.slot_cooldown_remaining_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_cooldown_remaining_seconds(&mut self, v: u32) {
        self.slot_cooldown_remaining_seconds = ::std::option::Option::Some(v);
    }

    // repeated .FamilyGroupFormerMember former_members = 7;

    pub fn former_members(&self) -> &[FamilyGroupFormerMember] {
        &self.former_members
    }

    pub fn clear_former_members(&mut self) {
        self.former_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_former_members(&mut self, v: ::std::vec::Vec<FamilyGroupFormerMember>) {
        self.former_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_former_members(&mut self) -> &mut ::std::vec::Vec<FamilyGroupFormerMember> {
        &mut self.former_members
    }

    // Take field
    pub fn take_former_members(&mut self) -> ::std::vec::Vec<FamilyGroupFormerMember> {
        ::std::mem::replace(&mut self.former_members, ::std::vec::Vec::new())
    }

    // optional uint32 slot_cooldown_overrides = 8;

    pub fn slot_cooldown_overrides(&self) -> u32 {
        self.slot_cooldown_overrides.unwrap_or(0)
    }

    pub fn clear_slot_cooldown_overrides(&mut self) {
        self.slot_cooldown_overrides = ::std::option::Option::None;
    }

    pub fn has_slot_cooldown_overrides(&self) -> bool {
        self.slot_cooldown_overrides.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_cooldown_overrides(&mut self, v: u32) {
        self.slot_cooldown_overrides = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.name },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.members },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.members },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_invites",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.pending_invites },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.pending_invites },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "free_spots",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.free_spots },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.free_spots },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.country },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.country },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_cooldown_remaining_seconds",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.slot_cooldown_remaining_seconds },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.slot_cooldown_remaining_seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "former_members",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.former_members },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.former_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_cooldown_overrides",
            |m: &CFamilyGroups_GetFamilyGroup_Response| { &m.slot_cooldown_overrides },
            |m: &mut CFamilyGroups_GetFamilyGroup_Response| { &mut m.slot_cooldown_overrides },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetFamilyGroup_Response>(
            "CFamilyGroups_GetFamilyGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                26 => {
                    self.pending_invites.push(is.read_message()?);
                },
                32 => {
                    self.free_spots = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.slot_cooldown_remaining_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.former_members.push(is.read_message()?);
                },
                64 => {
                    self.slot_cooldown_overrides = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pending_invites {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.free_spots {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.slot_cooldown_remaining_seconds {
            my_size += crate::rt::uint32_size(6, v);
        }
        for value in &self.former_members {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.slot_cooldown_overrides {
            my_size += crate::rt::uint32_size(8, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.members {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.pending_invites {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.free_spots {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.slot_cooldown_remaining_seconds {
            os.write_uint32(6, v)?;
        }
        for v in &self.former_members {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.slot_cooldown_overrides {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroup_Response {
        CFamilyGroups_GetFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.members.clear();
        self.pending_invites.clear();
        self.free_spots = ::std::option::Option::None;
        self.country = ::std::option::Option::None;
        self.slot_cooldown_remaining_seconds = ::std::option::Option::None;
        self.former_members.clear();
        self.slot_cooldown_overrides = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroup_Response {
        static instance: CFamilyGroups_GetFamilyGroup_Response = CFamilyGroups_GetFamilyGroup_Response {
            name: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            pending_invites: ::std::vec::Vec::new(),
            free_spots: ::std::option::Option::None,
            country: ::std::option::Option::None,
            slot_cooldown_remaining_seconds: ::std::option::Option::None,
            former_members: ::std::vec::Vec::new(),
            slot_cooldown_overrides: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetFamilyGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetFamilyGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetFamilyGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetFamilyGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroupForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroupForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroupForUser_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroupForUser_Request {
    fn default() -> &'a CFamilyGroups_GetFamilyGroupForUser_Request {
        <CFamilyGroups_GetFamilyGroupForUser_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroupForUser_Request {
    pub fn new() -> CFamilyGroups_GetFamilyGroupForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Request| { &m.steamid },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Request| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetFamilyGroupForUser_Request>(
            "CFamilyGroups_GetFamilyGroupForUser_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetFamilyGroupForUser_Request {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroupForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroupForUser_Request {
        CFamilyGroups_GetFamilyGroupForUser_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroupForUser_Request {
        static instance: CFamilyGroups_GetFamilyGroupForUser_Request = CFamilyGroups_GetFamilyGroupForUser_Request {
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetFamilyGroupForUser_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetFamilyGroupForUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetFamilyGroupForUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetFamilyGroupForUser_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FamilyGroupPendingInviteForUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupPendingInviteForUser {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupPendingInviteForUser.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FamilyGroupPendingInviteForUser.role)
    pub role: ::std::option::Option<crate::EnumOrUnknown<EFamilyGroupRole>>,
    // @@protoc_insertion_point(field:FamilyGroupPendingInviteForUser.inviter_steamid)
    pub inviter_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupPendingInviteForUser.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupPendingInviteForUser {
    fn default() -> &'a FamilyGroupPendingInviteForUser {
        <FamilyGroupPendingInviteForUser as crate::Message>::default_instance()
    }
}

impl FamilyGroupPendingInviteForUser {
    pub fn new() -> FamilyGroupPendingInviteForUser {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole role = 2;

    pub fn role(&self) -> EFamilyGroupRole {
        match self.role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: EFamilyGroupRole) {
        self.role = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional fixed64 inviter_steamid = 3;

    pub fn inviter_steamid(&self) -> u64 {
        self.inviter_steamid.unwrap_or(0)
    }

    pub fn clear_inviter_steamid(&mut self) {
        self.inviter_steamid = ::std::option::Option::None;
    }

    pub fn has_inviter_steamid(&self) -> bool {
        self.inviter_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter_steamid(&mut self, v: u64) {
        self.inviter_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &FamilyGroupPendingInviteForUser| { &m.family_groupid },
            |m: &mut FamilyGroupPendingInviteForUser| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &FamilyGroupPendingInviteForUser| { &m.role },
            |m: &mut FamilyGroupPendingInviteForUser| { &mut m.role },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviter_steamid",
            |m: &FamilyGroupPendingInviteForUser| { &m.inviter_steamid },
            |m: &mut FamilyGroupPendingInviteForUser| { &mut m.inviter_steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FamilyGroupPendingInviteForUser>(
            "FamilyGroupPendingInviteForUser",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FamilyGroupPendingInviteForUser {
    const NAME: &'static str = "FamilyGroupPendingInviteForUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                25 => {
                    self.inviter_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.inviter_steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.inviter_steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupPendingInviteForUser {
        FamilyGroupPendingInviteForUser::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.inviter_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupPendingInviteForUser {
        static instance: FamilyGroupPendingInviteForUser = FamilyGroupPendingInviteForUser {
            family_groupid: ::std::option::Option::None,
            role: ::std::option::Option::None,
            inviter_steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FamilyGroupPendingInviteForUser {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FamilyGroupPendingInviteForUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FamilyGroupPendingInviteForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FamilyGroupPendingInviteForUser {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroupForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroupForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.is_not_member_of_any_group)
    pub is_not_member_of_any_group: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.latest_time_joined)
    pub latest_time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.latest_joined_family_groupid)
    pub latest_joined_family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.pending_group_invites)
    pub pending_group_invites: ::std::vec::Vec<FamilyGroupPendingInviteForUser>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.role)
    pub role: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.cooldown_seconds_remaining)
    pub cooldown_seconds_remaining: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroupForUser_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroupForUser_Response {
    fn default() -> &'a CFamilyGroups_GetFamilyGroupForUser_Response {
        <CFamilyGroups_GetFamilyGroupForUser_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroupForUser_Response {
    pub fn new() -> CFamilyGroups_GetFamilyGroupForUser_Response {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool is_not_member_of_any_group = 2;

    pub fn is_not_member_of_any_group(&self) -> bool {
        self.is_not_member_of_any_group.unwrap_or(false)
    }

    pub fn clear_is_not_member_of_any_group(&mut self) {
        self.is_not_member_of_any_group = ::std::option::Option::None;
    }

    pub fn has_is_not_member_of_any_group(&self) -> bool {
        self.is_not_member_of_any_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_not_member_of_any_group(&mut self, v: bool) {
        self.is_not_member_of_any_group = ::std::option::Option::Some(v);
    }

    // optional uint32 latest_time_joined = 3;

    pub fn latest_time_joined(&self) -> u32 {
        self.latest_time_joined.unwrap_or(0)
    }

    pub fn clear_latest_time_joined(&mut self) {
        self.latest_time_joined = ::std::option::Option::None;
    }

    pub fn has_latest_time_joined(&self) -> bool {
        self.latest_time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_time_joined(&mut self, v: u32) {
        self.latest_time_joined = ::std::option::Option::Some(v);
    }

    // optional uint64 latest_joined_family_groupid = 4;

    pub fn latest_joined_family_groupid(&self) -> u64 {
        self.latest_joined_family_groupid.unwrap_or(0)
    }

    pub fn clear_latest_joined_family_groupid(&mut self) {
        self.latest_joined_family_groupid = ::std::option::Option::None;
    }

    pub fn has_latest_joined_family_groupid(&self) -> bool {
        self.latest_joined_family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_joined_family_groupid(&mut self, v: u64) {
        self.latest_joined_family_groupid = ::std::option::Option::Some(v);
    }

    // repeated .FamilyGroupPendingInviteForUser pending_group_invites = 5;

    pub fn pending_group_invites(&self) -> &[FamilyGroupPendingInviteForUser] {
        &self.pending_group_invites
    }

    pub fn clear_pending_group_invites(&mut self) {
        self.pending_group_invites.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_group_invites(&mut self, v: ::std::vec::Vec<FamilyGroupPendingInviteForUser>) {
        self.pending_group_invites = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_group_invites(&mut self) -> &mut ::std::vec::Vec<FamilyGroupPendingInviteForUser> {
        &mut self.pending_group_invites
    }

    // Take field
    pub fn take_pending_group_invites(&mut self) -> ::std::vec::Vec<FamilyGroupPendingInviteForUser> {
        ::std::mem::replace(&mut self.pending_group_invites, ::std::vec::Vec::new())
    }

    // optional uint32 role = 6;

    pub fn role(&self) -> u32 {
        self.role.unwrap_or(0)
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: u32) {
        self.role = ::std::option::Option::Some(v);
    }

    // optional uint32 cooldown_seconds_remaining = 7;

    pub fn cooldown_seconds_remaining(&self) -> u32 {
        self.cooldown_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds_remaining(&mut self) {
        self.cooldown_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds_remaining(&self) -> bool {
        self.cooldown_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds_remaining(&mut self, v: u32) {
        self.cooldown_seconds_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Response| { &m.family_groupid },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Response| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_not_member_of_any_group",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Response| { &m.is_not_member_of_any_group },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Response| { &mut m.is_not_member_of_any_group },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "latest_time_joined",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Response| { &m.latest_time_joined },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Response| { &mut m.latest_time_joined },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "latest_joined_family_groupid",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Response| { &m.latest_joined_family_groupid },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Response| { &mut m.latest_joined_family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_group_invites",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Response| { &m.pending_group_invites },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Response| { &mut m.pending_group_invites },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Response| { &m.role },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Response| { &mut m.role },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown_seconds_remaining",
            |m: &CFamilyGroups_GetFamilyGroupForUser_Response| { &m.cooldown_seconds_remaining },
            |m: &mut CFamilyGroups_GetFamilyGroupForUser_Response| { &mut m.cooldown_seconds_remaining },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetFamilyGroupForUser_Response>(
            "CFamilyGroups_GetFamilyGroupForUser_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetFamilyGroupForUser_Response {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroupForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.is_not_member_of_any_group = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.latest_time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.latest_joined_family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.pending_group_invites.push(is.read_message()?);
                },
                48 => {
                    self.role = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cooldown_seconds_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.is_not_member_of_any_group {
            my_size += 1 + 1;
        }
        if let Some(v) = self.latest_time_joined {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.latest_joined_family_groupid {
            my_size += crate::rt::uint64_size(4, v);
        }
        for value in &self.pending_group_invites {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.role {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cooldown_seconds_remaining {
            my_size += crate::rt::uint32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_not_member_of_any_group {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.latest_time_joined {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.latest_joined_family_groupid {
            os.write_uint64(4, v)?;
        }
        for v in &self.pending_group_invites {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.role {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cooldown_seconds_remaining {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroupForUser_Response {
        CFamilyGroups_GetFamilyGroupForUser_Response::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.is_not_member_of_any_group = ::std::option::Option::None;
        self.latest_time_joined = ::std::option::Option::None;
        self.latest_joined_family_groupid = ::std::option::Option::None;
        self.pending_group_invites.clear();
        self.role = ::std::option::Option::None;
        self.cooldown_seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroupForUser_Response {
        static instance: CFamilyGroups_GetFamilyGroupForUser_Response = CFamilyGroups_GetFamilyGroupForUser_Response {
            family_groupid: ::std::option::Option::None,
            is_not_member_of_any_group: ::std::option::Option::None,
            latest_time_joined: ::std::option::Option::None,
            latest_joined_family_groupid: ::std::option::Option::None,
            pending_group_invites: ::std::vec::Vec::new(),
            role: ::std::option::Option::None,
            cooldown_seconds_remaining: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetFamilyGroupForUser_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetFamilyGroupForUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetFamilyGroupForUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetFamilyGroupForUser_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_ModifyFamilyGroupDetails_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ModifyFamilyGroupDetails_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_ModifyFamilyGroupDetails_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ModifyFamilyGroupDetails_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ModifyFamilyGroupDetails_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ModifyFamilyGroupDetails_Request {
    fn default() -> &'a CFamilyGroups_ModifyFamilyGroupDetails_Request {
        <CFamilyGroups_ModifyFamilyGroupDetails_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_ModifyFamilyGroupDetails_Request {
    pub fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_ModifyFamilyGroupDetails_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_ModifyFamilyGroupDetails_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CFamilyGroups_ModifyFamilyGroupDetails_Request| { &m.name },
            |m: &mut CFamilyGroups_ModifyFamilyGroupDetails_Request| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_ModifyFamilyGroupDetails_Request>(
            "CFamilyGroups_ModifyFamilyGroupDetails_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_ModifyFamilyGroupDetails_Request {
    const NAME: &'static str = "CFamilyGroups_ModifyFamilyGroupDetails_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Request {
        CFamilyGroups_ModifyFamilyGroupDetails_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ModifyFamilyGroupDetails_Request {
        static instance: CFamilyGroups_ModifyFamilyGroupDetails_Request = CFamilyGroups_ModifyFamilyGroupDetails_Request {
            family_groupid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_ModifyFamilyGroupDetails_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_ModifyFamilyGroupDetails_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_ModifyFamilyGroupDetails_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_ModifyFamilyGroupDetails_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_ModifyFamilyGroupDetails_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ModifyFamilyGroupDetails_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ModifyFamilyGroupDetails_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ModifyFamilyGroupDetails_Response {
    fn default() -> &'a CFamilyGroups_ModifyFamilyGroupDetails_Response {
        <CFamilyGroups_ModifyFamilyGroupDetails_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_ModifyFamilyGroupDetails_Response {
    pub fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_ModifyFamilyGroupDetails_Response>(
            "CFamilyGroups_ModifyFamilyGroupDetails_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_ModifyFamilyGroupDetails_Response {
    const NAME: &'static str = "CFamilyGroups_ModifyFamilyGroupDetails_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Response {
        CFamilyGroups_ModifyFamilyGroupDetails_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ModifyFamilyGroupDetails_Response {
        static instance: CFamilyGroups_ModifyFamilyGroupDetails_Response = CFamilyGroups_ModifyFamilyGroupDetails_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_ModifyFamilyGroupDetails_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_ModifyFamilyGroupDetails_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_ModifyFamilyGroupDetails_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_ModifyFamilyGroupDetails_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_InviteToFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_InviteToFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Request.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Request.receiver_role)
    pub receiver_role: ::std::option::Option<crate::EnumOrUnknown<EFamilyGroupRole>>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_InviteToFamilyGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_InviteToFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_InviteToFamilyGroup_Request {
        <CFamilyGroups_InviteToFamilyGroup_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_InviteToFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_InviteToFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole receiver_role = 3;

    pub fn receiver_role(&self) -> EFamilyGroupRole {
        match self.receiver_role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_receiver_role(&mut self) {
        self.receiver_role = ::std::option::Option::None;
    }

    pub fn has_receiver_role(&self) -> bool {
        self.receiver_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_role(&mut self, v: EFamilyGroupRole) {
        self.receiver_role = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_InviteToFamilyGroup_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_InviteToFamilyGroup_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_steamid",
            |m: &CFamilyGroups_InviteToFamilyGroup_Request| { &m.receiver_steamid },
            |m: &mut CFamilyGroups_InviteToFamilyGroup_Request| { &mut m.receiver_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_role",
            |m: &CFamilyGroups_InviteToFamilyGroup_Request| { &m.receiver_role },
            |m: &mut CFamilyGroups_InviteToFamilyGroup_Request| { &mut m.receiver_role },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_InviteToFamilyGroup_Request>(
            "CFamilyGroups_InviteToFamilyGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_InviteToFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_InviteToFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.receiver_role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_role {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.receiver_role {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_InviteToFamilyGroup_Request {
        CFamilyGroups_InviteToFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.receiver_role = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_InviteToFamilyGroup_Request {
        static instance: CFamilyGroups_InviteToFamilyGroup_Request = CFamilyGroups_InviteToFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            receiver_role: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_InviteToFamilyGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_InviteToFamilyGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_InviteToFamilyGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_InviteToFamilyGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_InviteToFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_InviteToFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_InviteToFamilyGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_InviteToFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_InviteToFamilyGroup_Response {
        <CFamilyGroups_InviteToFamilyGroup_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_InviteToFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_InviteToFamilyGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_InviteToFamilyGroup_Response>(
            "CFamilyGroups_InviteToFamilyGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_InviteToFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_InviteToFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_InviteToFamilyGroup_Response {
        CFamilyGroups_InviteToFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_InviteToFamilyGroup_Response {
        static instance: CFamilyGroups_InviteToFamilyGroup_Response = CFamilyGroups_InviteToFamilyGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_InviteToFamilyGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_InviteToFamilyGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_InviteToFamilyGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_InviteToFamilyGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_JoinFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_JoinFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_JoinFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_JoinFamilyGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_JoinFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_JoinFamilyGroup_Request {
        <CFamilyGroups_JoinFamilyGroup_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_JoinFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_JoinFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_JoinFamilyGroup_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_JoinFamilyGroup_Request| { &mut m.family_groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_JoinFamilyGroup_Request>(
            "CFamilyGroups_JoinFamilyGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_JoinFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_JoinFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_JoinFamilyGroup_Request {
        CFamilyGroups_JoinFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_JoinFamilyGroup_Request {
        static instance: CFamilyGroups_JoinFamilyGroup_Request = CFamilyGroups_JoinFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_JoinFamilyGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_JoinFamilyGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_JoinFamilyGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_JoinFamilyGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_JoinFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_JoinFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_JoinFamilyGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_JoinFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_JoinFamilyGroup_Response {
        <CFamilyGroups_JoinFamilyGroup_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_JoinFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_JoinFamilyGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_JoinFamilyGroup_Response>(
            "CFamilyGroups_JoinFamilyGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_JoinFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_JoinFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_JoinFamilyGroup_Response {
        CFamilyGroups_JoinFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_JoinFamilyGroup_Response {
        static instance: CFamilyGroups_JoinFamilyGroup_Response = CFamilyGroups_JoinFamilyGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_JoinFamilyGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_JoinFamilyGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_JoinFamilyGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_JoinFamilyGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_RemoveFromFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RemoveFromFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RemoveFromFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RemoveFromFamilyGroup_Request.steamid_to_remove)
    pub steamid_to_remove: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RemoveFromFamilyGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RemoveFromFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_RemoveFromFamilyGroup_Request {
        <CFamilyGroups_RemoveFromFamilyGroup_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_RemoveFromFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_to_remove = 2;

    pub fn steamid_to_remove(&self) -> u64 {
        self.steamid_to_remove.unwrap_or(0)
    }

    pub fn clear_steamid_to_remove(&mut self) {
        self.steamid_to_remove = ::std::option::Option::None;
    }

    pub fn has_steamid_to_remove(&self) -> bool {
        self.steamid_to_remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_remove(&mut self, v: u64) {
        self.steamid_to_remove = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_RemoveFromFamilyGroup_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_RemoveFromFamilyGroup_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_to_remove",
            |m: &CFamilyGroups_RemoveFromFamilyGroup_Request| { &m.steamid_to_remove },
            |m: &mut CFamilyGroups_RemoveFromFamilyGroup_Request| { &mut m.steamid_to_remove },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_RemoveFromFamilyGroup_Request>(
            "CFamilyGroups_RemoveFromFamilyGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_RemoveFromFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_RemoveFromFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid_to_remove = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid_to_remove {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid_to_remove {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Request {
        CFamilyGroups_RemoveFromFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.steamid_to_remove = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RemoveFromFamilyGroup_Request {
        static instance: CFamilyGroups_RemoveFromFamilyGroup_Request = CFamilyGroups_RemoveFromFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            steamid_to_remove: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_RemoveFromFamilyGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_RemoveFromFamilyGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_RemoveFromFamilyGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_RemoveFromFamilyGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_RemoveFromFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RemoveFromFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RemoveFromFamilyGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RemoveFromFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_RemoveFromFamilyGroup_Response {
        <CFamilyGroups_RemoveFromFamilyGroup_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_RemoveFromFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_RemoveFromFamilyGroup_Response>(
            "CFamilyGroups_RemoveFromFamilyGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_RemoveFromFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_RemoveFromFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Response {
        CFamilyGroups_RemoveFromFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RemoveFromFamilyGroup_Response {
        static instance: CFamilyGroups_RemoveFromFamilyGroup_Response = CFamilyGroups_RemoveFromFamilyGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_RemoveFromFamilyGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_RemoveFromFamilyGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_RemoveFromFamilyGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_RemoveFromFamilyGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_CancelFamilyGroupInvite_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CancelFamilyGroupInvite_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_CancelFamilyGroupInvite_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_CancelFamilyGroupInvite_Request.steamid_to_cancel)
    pub steamid_to_cancel: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CancelFamilyGroupInvite_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CancelFamilyGroupInvite_Request {
    fn default() -> &'a CFamilyGroups_CancelFamilyGroupInvite_Request {
        <CFamilyGroups_CancelFamilyGroupInvite_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_CancelFamilyGroupInvite_Request {
    pub fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_to_cancel = 2;

    pub fn steamid_to_cancel(&self) -> u64 {
        self.steamid_to_cancel.unwrap_or(0)
    }

    pub fn clear_steamid_to_cancel(&mut self) {
        self.steamid_to_cancel = ::std::option::Option::None;
    }

    pub fn has_steamid_to_cancel(&self) -> bool {
        self.steamid_to_cancel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_cancel(&mut self, v: u64) {
        self.steamid_to_cancel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_CancelFamilyGroupInvite_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_CancelFamilyGroupInvite_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_to_cancel",
            |m: &CFamilyGroups_CancelFamilyGroupInvite_Request| { &m.steamid_to_cancel },
            |m: &mut CFamilyGroups_CancelFamilyGroupInvite_Request| { &mut m.steamid_to_cancel },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_CancelFamilyGroupInvite_Request>(
            "CFamilyGroups_CancelFamilyGroupInvite_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_CancelFamilyGroupInvite_Request {
    const NAME: &'static str = "CFamilyGroups_CancelFamilyGroupInvite_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid_to_cancel = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid_to_cancel {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid_to_cancel {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Request {
        CFamilyGroups_CancelFamilyGroupInvite_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.steamid_to_cancel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CancelFamilyGroupInvite_Request {
        static instance: CFamilyGroups_CancelFamilyGroupInvite_Request = CFamilyGroups_CancelFamilyGroupInvite_Request {
            family_groupid: ::std::option::Option::None,
            steamid_to_cancel: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_CancelFamilyGroupInvite_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_CancelFamilyGroupInvite_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_CancelFamilyGroupInvite_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_CancelFamilyGroupInvite_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_CancelFamilyGroupInvite_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CancelFamilyGroupInvite_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CancelFamilyGroupInvite_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CancelFamilyGroupInvite_Response {
    fn default() -> &'a CFamilyGroups_CancelFamilyGroupInvite_Response {
        <CFamilyGroups_CancelFamilyGroupInvite_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_CancelFamilyGroupInvite_Response {
    pub fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_CancelFamilyGroupInvite_Response>(
            "CFamilyGroups_CancelFamilyGroupInvite_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_CancelFamilyGroupInvite_Response {
    const NAME: &'static str = "CFamilyGroups_CancelFamilyGroupInvite_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Response {
        CFamilyGroups_CancelFamilyGroupInvite_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CancelFamilyGroupInvite_Response {
        static instance: CFamilyGroups_CancelFamilyGroupInvite_Response = CFamilyGroups_CancelFamilyGroupInvite_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_CancelFamilyGroupInvite_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_CancelFamilyGroupInvite_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_CancelFamilyGroupInvite_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_CancelFamilyGroupInvite_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetUsersSharingDevice_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetUsersSharingDevice_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetUsersSharingDevice_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetUsersSharingDevice_Request.client_instance_id)
    pub client_instance_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetUsersSharingDevice_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetUsersSharingDevice_Request {
    fn default() -> &'a CFamilyGroups_GetUsersSharingDevice_Request {
        <CFamilyGroups_GetUsersSharingDevice_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetUsersSharingDevice_Request {
    pub fn new() -> CFamilyGroups_GetUsersSharingDevice_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 client_instance_id = 2;

    pub fn client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_GetUsersSharingDevice_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_GetUsersSharingDevice_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_instance_id",
            |m: &CFamilyGroups_GetUsersSharingDevice_Request| { &m.client_instance_id },
            |m: &mut CFamilyGroups_GetUsersSharingDevice_Request| { &mut m.client_instance_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetUsersSharingDevice_Request>(
            "CFamilyGroups_GetUsersSharingDevice_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetUsersSharingDevice_Request {
    const NAME: &'static str = "CFamilyGroups_GetUsersSharingDevice_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.client_instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetUsersSharingDevice_Request {
        CFamilyGroups_GetUsersSharingDevice_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.client_instance_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetUsersSharingDevice_Request {
        static instance: CFamilyGroups_GetUsersSharingDevice_Request = CFamilyGroups_GetUsersSharingDevice_Request {
            family_groupid: ::std::option::Option::None,
            client_instance_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetUsersSharingDevice_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetUsersSharingDevice_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetUsersSharingDevice_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetUsersSharingDevice_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetUsersSharingDevice_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetUsersSharingDevice_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetUsersSharingDevice_Response.users)
    pub users: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetUsersSharingDevice_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetUsersSharingDevice_Response {
    fn default() -> &'a CFamilyGroups_GetUsersSharingDevice_Response {
        <CFamilyGroups_GetUsersSharingDevice_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetUsersSharingDevice_Response {
    pub fn new() -> CFamilyGroups_GetUsersSharingDevice_Response {
        ::std::default::Default::default()
    }

    // repeated fixed64 users = 1;

    pub fn users(&self) -> &[u64] {
        &self.users
    }

    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::std::vec::Vec<u64>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.users, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "users",
            |m: &CFamilyGroups_GetUsersSharingDevice_Response| { &m.users },
            |m: &mut CFamilyGroups_GetUsersSharingDevice_Response| { &mut m.users },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetUsersSharingDevice_Response>(
            "CFamilyGroups_GetUsersSharingDevice_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetUsersSharingDevice_Response {
    const NAME: &'static str = "CFamilyGroups_GetUsersSharingDevice_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.users)?;
                },
                9 => {
                    self.users.push(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.users.len() as u64;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.users {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetUsersSharingDevice_Response {
        CFamilyGroups_GetUsersSharingDevice_Response::new()
    }

    fn clear(&mut self) {
        self.users.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetUsersSharingDevice_Response {
        static instance: CFamilyGroups_GetUsersSharingDevice_Response = CFamilyGroups_GetUsersSharingDevice_Response {
            users: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetUsersSharingDevice_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetUsersSharingDevice_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetUsersSharingDevice_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetUsersSharingDevice_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_DeleteFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_DeleteFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_DeleteFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_DeleteFamilyGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_DeleteFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_DeleteFamilyGroup_Request {
        <CFamilyGroups_DeleteFamilyGroup_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_DeleteFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_DeleteFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_DeleteFamilyGroup_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_DeleteFamilyGroup_Request| { &mut m.family_groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_DeleteFamilyGroup_Request>(
            "CFamilyGroups_DeleteFamilyGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_DeleteFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_DeleteFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_DeleteFamilyGroup_Request {
        CFamilyGroups_DeleteFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_DeleteFamilyGroup_Request {
        static instance: CFamilyGroups_DeleteFamilyGroup_Request = CFamilyGroups_DeleteFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_DeleteFamilyGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_DeleteFamilyGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_DeleteFamilyGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_DeleteFamilyGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_DeleteFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_DeleteFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_DeleteFamilyGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_DeleteFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_DeleteFamilyGroup_Response {
        <CFamilyGroups_DeleteFamilyGroup_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_DeleteFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_DeleteFamilyGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_DeleteFamilyGroup_Response>(
            "CFamilyGroups_DeleteFamilyGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_DeleteFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_DeleteFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_DeleteFamilyGroup_Response {
        CFamilyGroups_DeleteFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_DeleteFamilyGroup_Response {
        static instance: CFamilyGroups_DeleteFamilyGroup_Response = CFamilyGroups_DeleteFamilyGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_DeleteFamilyGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_DeleteFamilyGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_DeleteFamilyGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_DeleteFamilyGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPlaytimeSummary_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPlaytimeSummary_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPlaytimeSummary_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPlaytimeSummary_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPlaytimeSummary_Request {
    fn default() -> &'a CFamilyGroups_GetPlaytimeSummary_Request {
        <CFamilyGroups_GetPlaytimeSummary_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPlaytimeSummary_Request {
    pub fn new() -> CFamilyGroups_GetPlaytimeSummary_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_GetPlaytimeSummary_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_GetPlaytimeSummary_Request| { &mut m.family_groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetPlaytimeSummary_Request>(
            "CFamilyGroups_GetPlaytimeSummary_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetPlaytimeSummary_Request {
    const NAME: &'static str = "CFamilyGroups_GetPlaytimeSummary_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPlaytimeSummary_Request {
        CFamilyGroups_GetPlaytimeSummary_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPlaytimeSummary_Request {
        static instance: CFamilyGroups_GetPlaytimeSummary_Request = CFamilyGroups_GetPlaytimeSummary_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetPlaytimeSummary_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetPlaytimeSummary_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetPlaytimeSummary_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetPlaytimeSummary_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_PlaytimeEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_PlaytimeEntry {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.first_played)
    pub first_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.latest_played)
    pub latest_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.seconds_played)
    pub seconds_played: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_PlaytimeEntry.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_PlaytimeEntry {
    fn default() -> &'a CFamilyGroups_PlaytimeEntry {
        <CFamilyGroups_PlaytimeEntry as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_PlaytimeEntry {
    pub fn new() -> CFamilyGroups_PlaytimeEntry {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 first_played = 3;

    pub fn first_played(&self) -> u32 {
        self.first_played.unwrap_or(0)
    }

    pub fn clear_first_played(&mut self) {
        self.first_played = ::std::option::Option::None;
    }

    pub fn has_first_played(&self) -> bool {
        self.first_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_played(&mut self, v: u32) {
        self.first_played = ::std::option::Option::Some(v);
    }

    // optional uint32 latest_played = 4;

    pub fn latest_played(&self) -> u32 {
        self.latest_played.unwrap_or(0)
    }

    pub fn clear_latest_played(&mut self) {
        self.latest_played = ::std::option::Option::None;
    }

    pub fn has_latest_played(&self) -> bool {
        self.latest_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_played(&mut self, v: u32) {
        self.latest_played = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_played = 5;

    pub fn seconds_played(&self) -> u32 {
        self.seconds_played.unwrap_or(0)
    }

    pub fn clear_seconds_played(&mut self) {
        self.seconds_played = ::std::option::Option::None;
    }

    pub fn has_seconds_played(&self) -> bool {
        self.seconds_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_played(&mut self, v: u32) {
        self.seconds_played = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CFamilyGroups_PlaytimeEntry| { &m.steamid },
            |m: &mut CFamilyGroups_PlaytimeEntry| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CFamilyGroups_PlaytimeEntry| { &m.appid },
            |m: &mut CFamilyGroups_PlaytimeEntry| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_played",
            |m: &CFamilyGroups_PlaytimeEntry| { &m.first_played },
            |m: &mut CFamilyGroups_PlaytimeEntry| { &mut m.first_played },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "latest_played",
            |m: &CFamilyGroups_PlaytimeEntry| { &m.latest_played },
            |m: &mut CFamilyGroups_PlaytimeEntry| { &mut m.latest_played },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_played",
            |m: &CFamilyGroups_PlaytimeEntry| { &m.seconds_played },
            |m: &mut CFamilyGroups_PlaytimeEntry| { &mut m.seconds_played },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_PlaytimeEntry>(
            "CFamilyGroups_PlaytimeEntry",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_PlaytimeEntry {
    const NAME: &'static str = "CFamilyGroups_PlaytimeEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.first_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.latest_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.seconds_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.first_played {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.latest_played {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.seconds_played {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.first_played {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.latest_played {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seconds_played {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_PlaytimeEntry {
        CFamilyGroups_PlaytimeEntry::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.first_played = ::std::option::Option::None;
        self.latest_played = ::std::option::Option::None;
        self.seconds_played = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_PlaytimeEntry {
        static instance: CFamilyGroups_PlaytimeEntry = CFamilyGroups_PlaytimeEntry {
            steamid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            first_played: ::std::option::Option::None,
            latest_played: ::std::option::Option::None,
            seconds_played: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_PlaytimeEntry {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_PlaytimeEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_PlaytimeEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_PlaytimeEntry {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPlaytimeSummary_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPlaytimeSummary_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPlaytimeSummary_Response.entries)
    pub entries: ::std::vec::Vec<CFamilyGroups_PlaytimeEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPlaytimeSummary_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPlaytimeSummary_Response {
    fn default() -> &'a CFamilyGroups_GetPlaytimeSummary_Response {
        <CFamilyGroups_GetPlaytimeSummary_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPlaytimeSummary_Response {
    pub fn new() -> CFamilyGroups_GetPlaytimeSummary_Response {
        ::std::default::Default::default()
    }

    // repeated .CFamilyGroups_PlaytimeEntry entries = 1;

    pub fn entries(&self) -> &[CFamilyGroups_PlaytimeEntry] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<CFamilyGroups_PlaytimeEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<CFamilyGroups_PlaytimeEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<CFamilyGroups_PlaytimeEntry> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CFamilyGroups_GetPlaytimeSummary_Response| { &m.entries },
            |m: &mut CFamilyGroups_GetPlaytimeSummary_Response| { &mut m.entries },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetPlaytimeSummary_Response>(
            "CFamilyGroups_GetPlaytimeSummary_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetPlaytimeSummary_Response {
    const NAME: &'static str = "CFamilyGroups_GetPlaytimeSummary_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPlaytimeSummary_Response {
        CFamilyGroups_GetPlaytimeSummary_Response::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPlaytimeSummary_Response {
        static instance: CFamilyGroups_GetPlaytimeSummary_Response = CFamilyGroups_GetPlaytimeSummary_Response {
            entries: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetPlaytimeSummary_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetPlaytimeSummary_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetPlaytimeSummary_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetPlaytimeSummary_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_RequestPurchase_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RequestPurchase_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.gidshoppingcart)
    pub gidshoppingcart: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.store_country_code)
    pub store_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.use_account_cart)
    pub use_account_cart: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RequestPurchase_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RequestPurchase_Request {
    fn default() -> &'a CFamilyGroups_RequestPurchase_Request {
        <CFamilyGroups_RequestPurchase_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_RequestPurchase_Request {
    pub fn new() -> CFamilyGroups_RequestPurchase_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 gidshoppingcart = 2;

    pub fn gidshoppingcart(&self) -> u64 {
        self.gidshoppingcart.unwrap_or(0)
    }

    pub fn clear_gidshoppingcart(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
    }

    pub fn has_gidshoppingcart(&self) -> bool {
        self.gidshoppingcart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidshoppingcart(&mut self, v: u64) {
        self.gidshoppingcart = ::std::option::Option::Some(v);
    }

    // optional string store_country_code = 3;

    pub fn store_country_code(&self) -> &str {
        match self.store_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_store_country_code(&mut self) {
        self.store_country_code = ::std::option::Option::None;
    }

    pub fn has_store_country_code(&self) -> bool {
        self.store_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_country_code(&mut self, v: ::std::string::String) {
        self.store_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_country_code(&mut self) -> &mut ::std::string::String {
        if self.store_country_code.is_none() {
            self.store_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.store_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_store_country_code(&mut self) -> ::std::string::String {
        self.store_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool use_account_cart = 4;

    pub fn use_account_cart(&self) -> bool {
        self.use_account_cart.unwrap_or(false)
    }

    pub fn clear_use_account_cart(&mut self) {
        self.use_account_cart = ::std::option::Option::None;
    }

    pub fn has_use_account_cart(&self) -> bool {
        self.use_account_cart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_account_cart(&mut self, v: bool) {
        self.use_account_cart = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_RequestPurchase_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_RequestPurchase_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gidshoppingcart",
            |m: &CFamilyGroups_RequestPurchase_Request| { &m.gidshoppingcart },
            |m: &mut CFamilyGroups_RequestPurchase_Request| { &mut m.gidshoppingcart },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "store_country_code",
            |m: &CFamilyGroups_RequestPurchase_Request| { &m.store_country_code },
            |m: &mut CFamilyGroups_RequestPurchase_Request| { &mut m.store_country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_account_cart",
            |m: &CFamilyGroups_RequestPurchase_Request| { &m.use_account_cart },
            |m: &mut CFamilyGroups_RequestPurchase_Request| { &mut m.use_account_cart },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_RequestPurchase_Request>(
            "CFamilyGroups_RequestPurchase_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_RequestPurchase_Request {
    const NAME: &'static str = "CFamilyGroups_RequestPurchase_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.gidshoppingcart = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.store_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.use_account_cart = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.gidshoppingcart {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.store_country_code.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.use_account_cart {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.gidshoppingcart {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.store_country_code.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.use_account_cart {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RequestPurchase_Request {
        CFamilyGroups_RequestPurchase_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.gidshoppingcart = ::std::option::Option::None;
        self.store_country_code = ::std::option::Option::None;
        self.use_account_cart = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RequestPurchase_Request {
        static instance: CFamilyGroups_RequestPurchase_Request = CFamilyGroups_RequestPurchase_Request {
            family_groupid: ::std::option::Option::None,
            gidshoppingcart: ::std::option::Option::None,
            store_country_code: ::std::option::Option::None,
            use_account_cart: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_RequestPurchase_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_RequestPurchase_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_RequestPurchase_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_RequestPurchase_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_RequestPurchase_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RequestPurchase_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Response.gidshoppingcart)
    pub gidshoppingcart: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Response.request_id)
    pub request_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RequestPurchase_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RequestPurchase_Response {
    fn default() -> &'a CFamilyGroups_RequestPurchase_Response {
        <CFamilyGroups_RequestPurchase_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_RequestPurchase_Response {
    pub fn new() -> CFamilyGroups_RequestPurchase_Response {
        ::std::default::Default::default()
    }

    // optional uint64 gidshoppingcart = 1;

    pub fn gidshoppingcart(&self) -> u64 {
        self.gidshoppingcart.unwrap_or(0)
    }

    pub fn clear_gidshoppingcart(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
    }

    pub fn has_gidshoppingcart(&self) -> bool {
        self.gidshoppingcart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidshoppingcart(&mut self, v: u64) {
        self.gidshoppingcart = ::std::option::Option::Some(v);
    }

    // optional uint64 request_id = 2;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gidshoppingcart",
            |m: &CFamilyGroups_RequestPurchase_Response| { &m.gidshoppingcart },
            |m: &mut CFamilyGroups_RequestPurchase_Response| { &mut m.gidshoppingcart },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CFamilyGroups_RequestPurchase_Response| { &m.request_id },
            |m: &mut CFamilyGroups_RequestPurchase_Response| { &mut m.request_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_RequestPurchase_Response>(
            "CFamilyGroups_RequestPurchase_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_RequestPurchase_Response {
    const NAME: &'static str = "CFamilyGroups_RequestPurchase_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gidshoppingcart = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gidshoppingcart {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gidshoppingcart {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RequestPurchase_Response {
        CFamilyGroups_RequestPurchase_Response::new()
    }

    fn clear(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RequestPurchase_Response {
        static instance: CFamilyGroups_RequestPurchase_Response = CFamilyGroups_RequestPurchase_Response {
            gidshoppingcart: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_RequestPurchase_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_RequestPurchase_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_RequestPurchase_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_RequestPurchase_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPurchaseRequests_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPurchaseRequests_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPurchaseRequests_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetPurchaseRequests_Request.include_completed)
    pub include_completed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPurchaseRequests_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPurchaseRequests_Request {
    fn default() -> &'a CFamilyGroups_GetPurchaseRequests_Request {
        <CFamilyGroups_GetPurchaseRequests_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPurchaseRequests_Request {
    pub fn new() -> CFamilyGroups_GetPurchaseRequests_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool include_completed = 2;

    pub fn include_completed(&self) -> bool {
        self.include_completed.unwrap_or(false)
    }

    pub fn clear_include_completed(&mut self) {
        self.include_completed = ::std::option::Option::None;
    }

    pub fn has_include_completed(&self) -> bool {
        self.include_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_completed(&mut self, v: bool) {
        self.include_completed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_GetPurchaseRequests_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_GetPurchaseRequests_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_completed",
            |m: &CFamilyGroups_GetPurchaseRequests_Request| { &m.include_completed },
            |m: &mut CFamilyGroups_GetPurchaseRequests_Request| { &mut m.include_completed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetPurchaseRequests_Request>(
            "CFamilyGroups_GetPurchaseRequests_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetPurchaseRequests_Request {
    const NAME: &'static str = "CFamilyGroups_GetPurchaseRequests_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.include_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.include_completed {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.include_completed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPurchaseRequests_Request {
        CFamilyGroups_GetPurchaseRequests_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.include_completed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPurchaseRequests_Request {
        static instance: CFamilyGroups_GetPurchaseRequests_Request = CFamilyGroups_GetPurchaseRequests_Request {
            family_groupid: ::std::option::Option::None,
            include_completed: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetPurchaseRequests_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetPurchaseRequests_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetPurchaseRequests_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetPurchaseRequests_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PurchaseRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PurchaseRequest {
    // message fields
    // @@protoc_insertion_point(field:PurchaseRequest.requester_steamid)
    pub requester_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PurchaseRequest.gidshoppingcart)
    pub gidshoppingcart: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PurchaseRequest.time_requested)
    pub time_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PurchaseRequest.time_responded)
    pub time_responded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PurchaseRequest.responder_steamid)
    pub responder_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PurchaseRequest.response_action)
    pub response_action: ::std::option::Option<crate::EnumOrUnknown<EPurchaseRequestAction>>,
    // @@protoc_insertion_point(field:PurchaseRequest.is_completed)
    pub is_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:PurchaseRequest.request_id)
    pub request_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:PurchaseRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PurchaseRequest {
    fn default() -> &'a PurchaseRequest {
        <PurchaseRequest as crate::Message>::default_instance()
    }
}

impl PurchaseRequest {
    pub fn new() -> PurchaseRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 requester_steamid = 1;

    pub fn requester_steamid(&self) -> u64 {
        self.requester_steamid.unwrap_or(0)
    }

    pub fn clear_requester_steamid(&mut self) {
        self.requester_steamid = ::std::option::Option::None;
    }

    pub fn has_requester_steamid(&self) -> bool {
        self.requester_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_steamid(&mut self, v: u64) {
        self.requester_steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 gidshoppingcart = 2;

    pub fn gidshoppingcart(&self) -> u64 {
        self.gidshoppingcart.unwrap_or(0)
    }

    pub fn clear_gidshoppingcart(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
    }

    pub fn has_gidshoppingcart(&self) -> bool {
        self.gidshoppingcart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidshoppingcart(&mut self, v: u64) {
        self.gidshoppingcart = ::std::option::Option::Some(v);
    }

    // optional uint32 time_requested = 3;

    pub fn time_requested(&self) -> u32 {
        self.time_requested.unwrap_or(0)
    }

    pub fn clear_time_requested(&mut self) {
        self.time_requested = ::std::option::Option::None;
    }

    pub fn has_time_requested(&self) -> bool {
        self.time_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_requested(&mut self, v: u32) {
        self.time_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 time_responded = 4;

    pub fn time_responded(&self) -> u32 {
        self.time_responded.unwrap_or(0)
    }

    pub fn clear_time_responded(&mut self) {
        self.time_responded = ::std::option::Option::None;
    }

    pub fn has_time_responded(&self) -> bool {
        self.time_responded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_responded(&mut self, v: u32) {
        self.time_responded = ::std::option::Option::Some(v);
    }

    // optional fixed64 responder_steamid = 5;

    pub fn responder_steamid(&self) -> u64 {
        self.responder_steamid.unwrap_or(0)
    }

    pub fn clear_responder_steamid(&mut self) {
        self.responder_steamid = ::std::option::Option::None;
    }

    pub fn has_responder_steamid(&self) -> bool {
        self.responder_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_responder_steamid(&mut self, v: u64) {
        self.responder_steamid = ::std::option::Option::Some(v);
    }

    // optional .EPurchaseRequestAction response_action = 6;

    pub fn response_action(&self) -> EPurchaseRequestAction {
        match self.response_action {
            Some(e) => e.enum_value_or(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            None => EPurchaseRequestAction::k_EPurchaseRequestAction_None,
        }
    }

    pub fn clear_response_action(&mut self) {
        self.response_action = ::std::option::Option::None;
    }

    pub fn has_response_action(&self) -> bool {
        self.response_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_action(&mut self, v: EPurchaseRequestAction) {
        self.response_action = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool is_completed = 7;

    pub fn is_completed(&self) -> bool {
        self.is_completed.unwrap_or(false)
    }

    pub fn clear_is_completed(&mut self) {
        self.is_completed = ::std::option::Option::None;
    }

    pub fn has_is_completed(&self) -> bool {
        self.is_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_completed(&mut self, v: bool) {
        self.is_completed = ::std::option::Option::Some(v);
    }

    // optional uint64 request_id = 8;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requester_steamid",
            |m: &PurchaseRequest| { &m.requester_steamid },
            |m: &mut PurchaseRequest| { &mut m.requester_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gidshoppingcart",
            |m: &PurchaseRequest| { &m.gidshoppingcart },
            |m: &mut PurchaseRequest| { &mut m.gidshoppingcart },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_requested",
            |m: &PurchaseRequest| { &m.time_requested },
            |m: &mut PurchaseRequest| { &mut m.time_requested },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_responded",
            |m: &PurchaseRequest| { &m.time_responded },
            |m: &mut PurchaseRequest| { &mut m.time_responded },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "responder_steamid",
            |m: &PurchaseRequest| { &m.responder_steamid },
            |m: &mut PurchaseRequest| { &mut m.responder_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_action",
            |m: &PurchaseRequest| { &m.response_action },
            |m: &mut PurchaseRequest| { &mut m.response_action },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_completed",
            |m: &PurchaseRequest| { &m.is_completed },
            |m: &mut PurchaseRequest| { &mut m.is_completed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &PurchaseRequest| { &m.request_id },
            |m: &mut PurchaseRequest| { &mut m.request_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<PurchaseRequest>(
            "PurchaseRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for PurchaseRequest {
    const NAME: &'static str = "PurchaseRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.requester_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.gidshoppingcart = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.time_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.time_responded = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.responder_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.response_action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requester_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gidshoppingcart {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.time_requested {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.time_responded {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.responder_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.response_action {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.is_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint64_size(8, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.requester_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gidshoppingcart {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.time_requested {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.time_responded {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.responder_steamid {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.response_action {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_completed {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PurchaseRequest {
        PurchaseRequest::new()
    }

    fn clear(&mut self) {
        self.requester_steamid = ::std::option::Option::None;
        self.gidshoppingcart = ::std::option::Option::None;
        self.time_requested = ::std::option::Option::None;
        self.time_responded = ::std::option::Option::None;
        self.responder_steamid = ::std::option::Option::None;
        self.response_action = ::std::option::Option::None;
        self.is_completed = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PurchaseRequest {
        static instance: PurchaseRequest = PurchaseRequest {
            requester_steamid: ::std::option::Option::None,
            gidshoppingcart: ::std::option::Option::None,
            time_requested: ::std::option::Option::None,
            time_responded: ::std::option::Option::None,
            responder_steamid: ::std::option::Option::None,
            response_action: ::std::option::Option::None,
            is_completed: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for PurchaseRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PurchaseRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PurchaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for PurchaseRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPurchaseRequests_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPurchaseRequests_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPurchaseRequests_Response.requests)
    pub requests: ::std::vec::Vec<PurchaseRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPurchaseRequests_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPurchaseRequests_Response {
    fn default() -> &'a CFamilyGroups_GetPurchaseRequests_Response {
        <CFamilyGroups_GetPurchaseRequests_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPurchaseRequests_Response {
    pub fn new() -> CFamilyGroups_GetPurchaseRequests_Response {
        ::std::default::Default::default()
    }

    // repeated .PurchaseRequest requests = 1;

    pub fn requests(&self) -> &[PurchaseRequest] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<PurchaseRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<PurchaseRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<PurchaseRequest> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &CFamilyGroups_GetPurchaseRequests_Response| { &m.requests },
            |m: &mut CFamilyGroups_GetPurchaseRequests_Response| { &mut m.requests },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetPurchaseRequests_Response>(
            "CFamilyGroups_GetPurchaseRequests_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetPurchaseRequests_Response {
    const NAME: &'static str = "CFamilyGroups_GetPurchaseRequests_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.requests {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPurchaseRequests_Response {
        CFamilyGroups_GetPurchaseRequests_Response::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPurchaseRequests_Response {
        static instance: CFamilyGroups_GetPurchaseRequests_Response = CFamilyGroups_GetPurchaseRequests_Response {
            requests: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetPurchaseRequests_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetPurchaseRequests_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetPurchaseRequests_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetPurchaseRequests_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_RespondToRequestedPurchase_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RespondToRequestedPurchase_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RespondToRequestedPurchase_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RespondToRequestedPurchase_Request.purchase_requester_steamid)
    pub purchase_requester_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RespondToRequestedPurchase_Request.action)
    pub action: ::std::option::Option<crate::EnumOrUnknown<EPurchaseRequestAction>>,
    // @@protoc_insertion_point(field:CFamilyGroups_RespondToRequestedPurchase_Request.request_id)
    pub request_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RespondToRequestedPurchase_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RespondToRequestedPurchase_Request {
    fn default() -> &'a CFamilyGroups_RespondToRequestedPurchase_Request {
        <CFamilyGroups_RespondToRequestedPurchase_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_RespondToRequestedPurchase_Request {
    pub fn new() -> CFamilyGroups_RespondToRequestedPurchase_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 purchase_requester_steamid = 2;

    pub fn purchase_requester_steamid(&self) -> u64 {
        self.purchase_requester_steamid.unwrap_or(0)
    }

    pub fn clear_purchase_requester_steamid(&mut self) {
        self.purchase_requester_steamid = ::std::option::Option::None;
    }

    pub fn has_purchase_requester_steamid(&self) -> bool {
        self.purchase_requester_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_requester_steamid(&mut self, v: u64) {
        self.purchase_requester_steamid = ::std::option::Option::Some(v);
    }

    // optional .EPurchaseRequestAction action = 3;

    pub fn action(&self) -> EPurchaseRequestAction {
        match self.action {
            Some(e) => e.enum_value_or(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            None => EPurchaseRequestAction::k_EPurchaseRequestAction_None,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: EPurchaseRequestAction) {
        self.action = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint64 request_id = 4;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_RespondToRequestedPurchase_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_RespondToRequestedPurchase_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_requester_steamid",
            |m: &CFamilyGroups_RespondToRequestedPurchase_Request| { &m.purchase_requester_steamid },
            |m: &mut CFamilyGroups_RespondToRequestedPurchase_Request| { &mut m.purchase_requester_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CFamilyGroups_RespondToRequestedPurchase_Request| { &m.action },
            |m: &mut CFamilyGroups_RespondToRequestedPurchase_Request| { &mut m.action },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CFamilyGroups_RespondToRequestedPurchase_Request| { &m.request_id },
            |m: &mut CFamilyGroups_RespondToRequestedPurchase_Request| { &mut m.request_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_RespondToRequestedPurchase_Request>(
            "CFamilyGroups_RespondToRequestedPurchase_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_RespondToRequestedPurchase_Request {
    const NAME: &'static str = "CFamilyGroups_RespondToRequestedPurchase_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.purchase_requester_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.purchase_requester_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.action {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint64_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.purchase_requester_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RespondToRequestedPurchase_Request {
        CFamilyGroups_RespondToRequestedPurchase_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.purchase_requester_steamid = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RespondToRequestedPurchase_Request {
        static instance: CFamilyGroups_RespondToRequestedPurchase_Request = CFamilyGroups_RespondToRequestedPurchase_Request {
            family_groupid: ::std::option::Option::None,
            purchase_requester_steamid: ::std::option::Option::None,
            action: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_RespondToRequestedPurchase_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_RespondToRequestedPurchase_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_RespondToRequestedPurchase_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_RespondToRequestedPurchase_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_RespondToRequestedPurchase_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RespondToRequestedPurchase_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RespondToRequestedPurchase_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RespondToRequestedPurchase_Response {
    fn default() -> &'a CFamilyGroups_RespondToRequestedPurchase_Response {
        <CFamilyGroups_RespondToRequestedPurchase_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_RespondToRequestedPurchase_Response {
    pub fn new() -> CFamilyGroups_RespondToRequestedPurchase_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_RespondToRequestedPurchase_Response>(
            "CFamilyGroups_RespondToRequestedPurchase_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_RespondToRequestedPurchase_Response {
    const NAME: &'static str = "CFamilyGroups_RespondToRequestedPurchase_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RespondToRequestedPurchase_Response {
        CFamilyGroups_RespondToRequestedPurchase_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RespondToRequestedPurchase_Response {
        static instance: CFamilyGroups_RespondToRequestedPurchase_Response = CFamilyGroups_RespondToRequestedPurchase_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_RespondToRequestedPurchase_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_RespondToRequestedPurchase_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_RespondToRequestedPurchase_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_RespondToRequestedPurchase_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetChangeLog_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetChangeLog_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetChangeLog_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetChangeLog_Request {
    fn default() -> &'a CFamilyGroups_GetChangeLog_Request {
        <CFamilyGroups_GetChangeLog_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetChangeLog_Request {
    pub fn new() -> CFamilyGroups_GetChangeLog_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_GetChangeLog_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_GetChangeLog_Request| { &mut m.family_groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetChangeLog_Request>(
            "CFamilyGroups_GetChangeLog_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetChangeLog_Request {
    const NAME: &'static str = "CFamilyGroups_GetChangeLog_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetChangeLog_Request {
        CFamilyGroups_GetChangeLog_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetChangeLog_Request {
        static instance: CFamilyGroups_GetChangeLog_Request = CFamilyGroups_GetChangeLog_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetChangeLog_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetChangeLog_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetChangeLog_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetChangeLog_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetChangeLog_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetChangeLog_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.changes)
    pub changes: ::std::vec::Vec<cfamily_groups_get_change_log_response::Change>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetChangeLog_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetChangeLog_Response {
    fn default() -> &'a CFamilyGroups_GetChangeLog_Response {
        <CFamilyGroups_GetChangeLog_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetChangeLog_Response {
    pub fn new() -> CFamilyGroups_GetChangeLog_Response {
        ::std::default::Default::default()
    }

    // repeated .CFamilyGroups_GetChangeLog_Response.Change changes = 1;

    pub fn changes(&self) -> &[cfamily_groups_get_change_log_response::Change] {
        &self.changes
    }

    pub fn clear_changes(&mut self) {
        self.changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_changes(&mut self, v: ::std::vec::Vec<cfamily_groups_get_change_log_response::Change>) {
        self.changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changes(&mut self) -> &mut ::std::vec::Vec<cfamily_groups_get_change_log_response::Change> {
        &mut self.changes
    }

    // Take field
    pub fn take_changes(&mut self) -> ::std::vec::Vec<cfamily_groups_get_change_log_response::Change> {
        ::std::mem::replace(&mut self.changes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changes",
            |m: &CFamilyGroups_GetChangeLog_Response| { &m.changes },
            |m: &mut CFamilyGroups_GetChangeLog_Response| { &mut m.changes },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetChangeLog_Response>(
            "CFamilyGroups_GetChangeLog_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetChangeLog_Response {
    const NAME: &'static str = "CFamilyGroups_GetChangeLog_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.changes.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.changes {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetChangeLog_Response {
        CFamilyGroups_GetChangeLog_Response::new()
    }

    fn clear(&mut self) {
        self.changes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetChangeLog_Response {
        static instance: CFamilyGroups_GetChangeLog_Response = CFamilyGroups_GetChangeLog_Response {
            changes: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetChangeLog_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetChangeLog_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetChangeLog_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetChangeLog_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CFamilyGroups_GetChangeLog_Response`
pub mod cfamily_groups_get_change_log_response {
    // @@protoc_insertion_point(message:CFamilyGroups_GetChangeLog_Response.Change)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Change {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.timestamp)
        pub timestamp: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.actor_steamid)
        pub actor_steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.type)
        pub type_: ::std::option::Option<crate::EnumOrUnknown<super::EFamilyGroupChangeLogType>>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.body)
        pub body: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.by_support)
        pub by_support: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroups_GetChangeLog_Response.Change.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Change {
        fn default() -> &'a Change {
            <Change as crate::Message>::default_instance()
        }
    }

    impl Change {
        pub fn new() -> Change {
            ::std::default::Default::default()
        }

        // optional fixed64 timestamp = 1;

        pub fn timestamp(&self) -> u64 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u64) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional fixed64 actor_steamid = 2;

        pub fn actor_steamid(&self) -> u64 {
            self.actor_steamid.unwrap_or(0)
        }

        pub fn clear_actor_steamid(&mut self) {
            self.actor_steamid = ::std::option::Option::None;
        }

        pub fn has_actor_steamid(&self) -> bool {
            self.actor_steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_actor_steamid(&mut self, v: u64) {
            self.actor_steamid = ::std::option::Option::Some(v);
        }

        // optional .EFamilyGroupChangeLogType type = 3;

        pub fn type_(&self) -> super::EFamilyGroupChangeLogType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::EFamilyGroupChangeLogType::k_InvalidChangeType),
                None => super::EFamilyGroupChangeLogType::k_InvalidChangeType,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::EFamilyGroupChangeLogType) {
            self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional string body = 4;

        pub fn body(&self) -> &str {
            match self.body.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_body(&mut self) {
            self.body = ::std::option::Option::None;
        }

        pub fn has_body(&self) -> bool {
            self.body.is_some()
        }

        // Param is passed by value, moved
        pub fn set_body(&mut self, v: ::std::string::String) {
            self.body = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_body(&mut self) -> &mut ::std::string::String {
            if self.body.is_none() {
                self.body = ::std::option::Option::Some(::std::string::String::new());
            }
            self.body.as_mut().unwrap()
        }

        // Take field
        pub fn take_body(&mut self) -> ::std::string::String {
            self.body.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool by_support = 5;

        pub fn by_support(&self) -> bool {
            self.by_support.unwrap_or(false)
        }

        pub fn clear_by_support(&mut self) {
            self.by_support = ::std::option::Option::None;
        }

        pub fn has_by_support(&self) -> bool {
            self.by_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_by_support(&mut self, v: bool) {
            self.by_support = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &Change| { &m.timestamp },
                |m: &mut Change| { &mut m.timestamp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "actor_steamid",
                |m: &Change| { &m.actor_steamid },
                |m: &mut Change| { &mut m.actor_steamid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Change| { &m.type_ },
                |m: &mut Change| { &mut m.type_ },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "body",
                |m: &Change| { &m.body },
                |m: &mut Change| { &mut m.body },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "by_support",
                |m: &Change| { &m.by_support },
                |m: &mut Change| { &mut m.by_support },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Change>(
                "CFamilyGroups_GetChangeLog_Response.Change",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Change {
        const NAME: &'static str = "Change";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    17 => {
                        self.actor_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.body = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.by_support = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += 1 + 8;
            }
            if let Some(v) = self.actor_steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.type_ {
                my_size += crate::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.body.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.by_support {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.actor_steamid {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.body.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.by_support {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Change {
            Change::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.actor_steamid = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.body = ::std::option::Option::None;
            self.by_support = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Change {
            static instance: Change = Change {
                timestamp: ::std::option::Option::None,
                actor_steamid: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                body: ::std::option::Option::None,
                by_support: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Change {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CFamilyGroups_GetChangeLog_Response.Change").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Change {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Change {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_SetFamilyCooldownOverrides_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_SetFamilyCooldownOverrides_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_SetFamilyCooldownOverrides_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_SetFamilyCooldownOverrides_Request.cooldown_count)
    pub cooldown_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_SetFamilyCooldownOverrides_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_SetFamilyCooldownOverrides_Request {
    fn default() -> &'a CFamilyGroups_SetFamilyCooldownOverrides_Request {
        <CFamilyGroups_SetFamilyCooldownOverrides_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_SetFamilyCooldownOverrides_Request {
    pub fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint32 cooldown_count = 2;

    pub fn cooldown_count(&self) -> u32 {
        self.cooldown_count.unwrap_or(0)
    }

    pub fn clear_cooldown_count(&mut self) {
        self.cooldown_count = ::std::option::Option::None;
    }

    pub fn has_cooldown_count(&self) -> bool {
        self.cooldown_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_count(&mut self, v: u32) {
        self.cooldown_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_SetFamilyCooldownOverrides_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_SetFamilyCooldownOverrides_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cooldown_count",
            |m: &CFamilyGroups_SetFamilyCooldownOverrides_Request| { &m.cooldown_count },
            |m: &mut CFamilyGroups_SetFamilyCooldownOverrides_Request| { &mut m.cooldown_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_SetFamilyCooldownOverrides_Request>(
            "CFamilyGroups_SetFamilyCooldownOverrides_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_SetFamilyCooldownOverrides_Request {
    const NAME: &'static str = "CFamilyGroups_SetFamilyCooldownOverrides_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.cooldown_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.cooldown_count {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.cooldown_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Request {
        CFamilyGroups_SetFamilyCooldownOverrides_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.cooldown_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_SetFamilyCooldownOverrides_Request {
        static instance: CFamilyGroups_SetFamilyCooldownOverrides_Request = CFamilyGroups_SetFamilyCooldownOverrides_Request {
            family_groupid: ::std::option::Option::None,
            cooldown_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_SetFamilyCooldownOverrides_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_SetFamilyCooldownOverrides_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_SetFamilyCooldownOverrides_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_SetFamilyCooldownOverrides_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_SetFamilyCooldownOverrides_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_SetFamilyCooldownOverrides_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_SetFamilyCooldownOverrides_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_SetFamilyCooldownOverrides_Response {
    fn default() -> &'a CFamilyGroups_SetFamilyCooldownOverrides_Response {
        <CFamilyGroups_SetFamilyCooldownOverrides_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_SetFamilyCooldownOverrides_Response {
    pub fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_SetFamilyCooldownOverrides_Response>(
            "CFamilyGroups_SetFamilyCooldownOverrides_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_SetFamilyCooldownOverrides_Response {
    const NAME: &'static str = "CFamilyGroups_SetFamilyCooldownOverrides_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Response {
        CFamilyGroups_SetFamilyCooldownOverrides_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_SetFamilyCooldownOverrides_Response {
        static instance: CFamilyGroups_SetFamilyCooldownOverrides_Response = CFamilyGroups_SetFamilyCooldownOverrides_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_SetFamilyCooldownOverrides_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_SetFamilyCooldownOverrides_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_SetFamilyCooldownOverrides_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_SetFamilyCooldownOverrides_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetSharedLibraryApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetSharedLibraryApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.include_own)
    pub include_own: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.include_excluded)
    pub include_excluded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.include_free)
    pub include_free: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.max_apps)
    pub max_apps: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetSharedLibraryApps_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetSharedLibraryApps_Request {
    fn default() -> &'a CFamilyGroups_GetSharedLibraryApps_Request {
        <CFamilyGroups_GetSharedLibraryApps_Request as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetSharedLibraryApps_Request {
    pub fn new() -> CFamilyGroups_GetSharedLibraryApps_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool include_own = 2;

    pub fn include_own(&self) -> bool {
        self.include_own.unwrap_or(false)
    }

    pub fn clear_include_own(&mut self) {
        self.include_own = ::std::option::Option::None;
    }

    pub fn has_include_own(&self) -> bool {
        self.include_own.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_own(&mut self, v: bool) {
        self.include_own = ::std::option::Option::Some(v);
    }

    // optional bool include_excluded = 3;

    pub fn include_excluded(&self) -> bool {
        self.include_excluded.unwrap_or(false)
    }

    pub fn clear_include_excluded(&mut self) {
        self.include_excluded = ::std::option::Option::None;
    }

    pub fn has_include_excluded(&self) -> bool {
        self.include_excluded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_excluded(&mut self, v: bool) {
        self.include_excluded = ::std::option::Option::Some(v);
    }

    // optional bool include_free = 4;

    pub fn include_free(&self) -> bool {
        self.include_free.unwrap_or(false)
    }

    pub fn clear_include_free(&mut self) {
        self.include_free = ::std::option::Option::None;
    }

    pub fn has_include_free(&self) -> bool {
        self.include_free.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_free(&mut self, v: bool) {
        self.include_free = ::std::option::Option::Some(v);
    }

    // optional string language = 5;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_apps = 6;

    pub fn max_apps(&self) -> u32 {
        self.max_apps.unwrap_or(0)
    }

    pub fn clear_max_apps(&mut self) {
        self.max_apps = ::std::option::Option::None;
    }

    pub fn has_max_apps(&self) -> bool {
        self.max_apps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_apps(&mut self, v: u32) {
        self.max_apps = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroups_GetSharedLibraryApps_Request| { &m.family_groupid },
            |m: &mut CFamilyGroups_GetSharedLibraryApps_Request| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_own",
            |m: &CFamilyGroups_GetSharedLibraryApps_Request| { &m.include_own },
            |m: &mut CFamilyGroups_GetSharedLibraryApps_Request| { &mut m.include_own },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_excluded",
            |m: &CFamilyGroups_GetSharedLibraryApps_Request| { &m.include_excluded },
            |m: &mut CFamilyGroups_GetSharedLibraryApps_Request| { &mut m.include_excluded },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_free",
            |m: &CFamilyGroups_GetSharedLibraryApps_Request| { &m.include_free },
            |m: &mut CFamilyGroups_GetSharedLibraryApps_Request| { &mut m.include_free },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CFamilyGroups_GetSharedLibraryApps_Request| { &m.language },
            |m: &mut CFamilyGroups_GetSharedLibraryApps_Request| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_apps",
            |m: &CFamilyGroups_GetSharedLibraryApps_Request| { &m.max_apps },
            |m: &mut CFamilyGroups_GetSharedLibraryApps_Request| { &mut m.max_apps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetSharedLibraryApps_Request>(
            "CFamilyGroups_GetSharedLibraryApps_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetSharedLibraryApps_Request {
    const NAME: &'static str = "CFamilyGroups_GetSharedLibraryApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.include_own = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.include_excluded = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.include_free = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.max_apps = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.include_own {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_excluded {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_free {
            my_size += 1 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.max_apps {
            my_size += crate::rt::uint32_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.include_own {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.include_excluded {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.include_free {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.max_apps {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetSharedLibraryApps_Request {
        CFamilyGroups_GetSharedLibraryApps_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.include_own = ::std::option::Option::None;
        self.include_excluded = ::std::option::Option::None;
        self.include_free = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.max_apps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetSharedLibraryApps_Request {
        static instance: CFamilyGroups_GetSharedLibraryApps_Request = CFamilyGroups_GetSharedLibraryApps_Request {
            family_groupid: ::std::option::Option::None,
            include_own: ::std::option::Option::None,
            include_excluded: ::std::option::Option::None,
            include_free: ::std::option::Option::None,
            language: ::std::option::Option::None,
            max_apps: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetSharedLibraryApps_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetSharedLibraryApps_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetSharedLibraryApps_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetSharedLibraryApps_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroups_GetSharedLibraryApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetSharedLibraryApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.apps)
    pub apps: ::std::vec::Vec<cfamily_groups_get_shared_library_apps_response::SharedApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetSharedLibraryApps_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetSharedLibraryApps_Response {
    fn default() -> &'a CFamilyGroups_GetSharedLibraryApps_Response {
        <CFamilyGroups_GetSharedLibraryApps_Response as crate::Message>::default_instance()
    }
}

impl CFamilyGroups_GetSharedLibraryApps_Response {
    pub fn new() -> CFamilyGroups_GetSharedLibraryApps_Response {
        ::std::default::Default::default()
    }

    // repeated .CFamilyGroups_GetSharedLibraryApps_Response.SharedApp apps = 1;

    pub fn apps(&self) -> &[cfamily_groups_get_shared_library_apps_response::SharedApp] {
        &self.apps
    }

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::std::vec::Vec<cfamily_groups_get_shared_library_apps_response::SharedApp>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::std::vec::Vec<cfamily_groups_get_shared_library_apps_response::SharedApp> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::std::vec::Vec<cfamily_groups_get_shared_library_apps_response::SharedApp> {
        ::std::mem::replace(&mut self.apps, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CFamilyGroups_GetSharedLibraryApps_Response| { &m.apps },
            |m: &mut CFamilyGroups_GetSharedLibraryApps_Response| { &mut m.apps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroups_GetSharedLibraryApps_Response>(
            "CFamilyGroups_GetSharedLibraryApps_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroups_GetSharedLibraryApps_Response {
    const NAME: &'static str = "CFamilyGroups_GetSharedLibraryApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.apps {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetSharedLibraryApps_Response {
        CFamilyGroups_GetSharedLibraryApps_Response::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetSharedLibraryApps_Response {
        static instance: CFamilyGroups_GetSharedLibraryApps_Response = CFamilyGroups_GetSharedLibraryApps_Response {
            apps: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroups_GetSharedLibraryApps_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroups_GetSharedLibraryApps_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroups_GetSharedLibraryApps_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroups_GetSharedLibraryApps_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CFamilyGroups_GetSharedLibraryApps_Response`
pub mod cfamily_groups_get_shared_library_apps_response {
    // @@protoc_insertion_point(message:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SharedApp {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.owner_steamids)
        pub owner_steamids: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.free_app)
        pub free_app: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.sort_as)
        pub sort_as: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.capsule_filename)
        pub capsule_filename: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.img_icon_url)
        pub img_icon_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.exclude_reason)
        pub exclude_reason: ::std::option::Option<crate::EnumOrUnknown<super::ESharedLibraryExcludeReason>>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.rt_time_acquired)
        pub rt_time_acquired: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SharedApp {
        fn default() -> &'a SharedApp {
            <SharedApp as crate::Message>::default_instance()
        }
    }

    impl SharedApp {
        pub fn new() -> SharedApp {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // repeated fixed64 owner_steamids = 2;

        pub fn owner_steamids(&self) -> &[u64] {
            &self.owner_steamids
        }

        pub fn clear_owner_steamids(&mut self) {
            self.owner_steamids.clear();
        }

        // Param is passed by value, moved
        pub fn set_owner_steamids(&mut self, v: ::std::vec::Vec<u64>) {
            self.owner_steamids = v;
        }

        // Mutable pointer to the field.
        pub fn mut_owner_steamids(&mut self) -> &mut ::std::vec::Vec<u64> {
            &mut self.owner_steamids
        }

        // Take field
        pub fn take_owner_steamids(&mut self) -> ::std::vec::Vec<u64> {
            ::std::mem::replace(&mut self.owner_steamids, ::std::vec::Vec::new())
        }

        // optional bool free_app = 5;

        pub fn free_app(&self) -> bool {
            self.free_app.unwrap_or(false)
        }

        pub fn clear_free_app(&mut self) {
            self.free_app = ::std::option::Option::None;
        }

        pub fn has_free_app(&self) -> bool {
            self.free_app.is_some()
        }

        // Param is passed by value, moved
        pub fn set_free_app(&mut self, v: bool) {
            self.free_app = ::std::option::Option::Some(v);
        }

        // optional string name = 6;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string sort_as = 7;

        pub fn sort_as(&self) -> &str {
            match self.sort_as.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_sort_as(&mut self) {
            self.sort_as = ::std::option::Option::None;
        }

        pub fn has_sort_as(&self) -> bool {
            self.sort_as.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sort_as(&mut self, v: ::std::string::String) {
            self.sort_as = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sort_as(&mut self) -> &mut ::std::string::String {
            if self.sort_as.is_none() {
                self.sort_as = ::std::option::Option::Some(::std::string::String::new());
            }
            self.sort_as.as_mut().unwrap()
        }

        // Take field
        pub fn take_sort_as(&mut self) -> ::std::string::String {
            self.sort_as.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string capsule_filename = 8;

        pub fn capsule_filename(&self) -> &str {
            match self.capsule_filename.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_capsule_filename(&mut self) {
            self.capsule_filename = ::std::option::Option::None;
        }

        pub fn has_capsule_filename(&self) -> bool {
            self.capsule_filename.is_some()
        }

        // Param is passed by value, moved
        pub fn set_capsule_filename(&mut self, v: ::std::string::String) {
            self.capsule_filename = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_capsule_filename(&mut self) -> &mut ::std::string::String {
            if self.capsule_filename.is_none() {
                self.capsule_filename = ::std::option::Option::Some(::std::string::String::new());
            }
            self.capsule_filename.as_mut().unwrap()
        }

        // Take field
        pub fn take_capsule_filename(&mut self) -> ::std::string::String {
            self.capsule_filename.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string img_icon_url = 9;

        pub fn img_icon_url(&self) -> &str {
            match self.img_icon_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_img_icon_url(&mut self) {
            self.img_icon_url = ::std::option::Option::None;
        }

        pub fn has_img_icon_url(&self) -> bool {
            self.img_icon_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_img_icon_url(&mut self, v: ::std::string::String) {
            self.img_icon_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_img_icon_url(&mut self) -> &mut ::std::string::String {
            if self.img_icon_url.is_none() {
                self.img_icon_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.img_icon_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_img_icon_url(&mut self) -> ::std::string::String {
            self.img_icon_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .ESharedLibraryExcludeReason exclude_reason = 10;

        pub fn exclude_reason(&self) -> super::ESharedLibraryExcludeReason {
            match self.exclude_reason {
                Some(e) => e.enum_value_or(super::ESharedLibraryExcludeReason::k_ESharedLibrary_Included),
                None => super::ESharedLibraryExcludeReason::k_ESharedLibrary_Included,
            }
        }

        pub fn clear_exclude_reason(&mut self) {
            self.exclude_reason = ::std::option::Option::None;
        }

        pub fn has_exclude_reason(&self) -> bool {
            self.exclude_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_exclude_reason(&mut self, v: super::ESharedLibraryExcludeReason) {
            self.exclude_reason = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional uint32 rt_time_acquired = 11;

        pub fn rt_time_acquired(&self) -> u32 {
            self.rt_time_acquired.unwrap_or(0)
        }

        pub fn clear_rt_time_acquired(&mut self) {
            self.rt_time_acquired = ::std::option::Option::None;
        }

        pub fn has_rt_time_acquired(&self) -> bool {
            self.rt_time_acquired.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rt_time_acquired(&mut self, v: u32) {
            self.rt_time_acquired = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &SharedApp| { &m.appid },
                |m: &mut SharedApp| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "owner_steamids",
                |m: &SharedApp| { &m.owner_steamids },
                |m: &mut SharedApp| { &mut m.owner_steamids },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "free_app",
                |m: &SharedApp| { &m.free_app },
                |m: &mut SharedApp| { &mut m.free_app },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &SharedApp| { &m.name },
                |m: &mut SharedApp| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sort_as",
                |m: &SharedApp| { &m.sort_as },
                |m: &mut SharedApp| { &mut m.sort_as },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "capsule_filename",
                |m: &SharedApp| { &m.capsule_filename },
                |m: &mut SharedApp| { &mut m.capsule_filename },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "img_icon_url",
                |m: &SharedApp| { &m.img_icon_url },
                |m: &mut SharedApp| { &mut m.img_icon_url },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "exclude_reason",
                |m: &SharedApp| { &m.exclude_reason },
                |m: &mut SharedApp| { &mut m.exclude_reason },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rt_time_acquired",
                |m: &SharedApp| { &m.rt_time_acquired },
                |m: &mut SharedApp| { &mut m.rt_time_acquired },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<SharedApp>(
                "CFamilyGroups_GetSharedLibraryApps_Response.SharedApp",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for SharedApp {
        const NAME: &'static str = "SharedApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_fixed64_into(&mut self.owner_steamids)?;
                    },
                    17 => {
                        self.owner_steamids.push(is.read_fixed64()?);
                    },
                    40 => {
                        self.free_app = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.sort_as = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.capsule_filename = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.img_icon_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.exclude_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    88 => {
                        self.rt_time_acquired = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += 9 * self.owner_steamids.len() as u64;
            if let Some(v) = self.free_app {
                my_size += 1 + 1;
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(6, &v);
            }
            if let Some(v) = self.sort_as.as_ref() {
                my_size += crate::rt::string_size(7, &v);
            }
            if let Some(v) = self.capsule_filename.as_ref() {
                my_size += crate::rt::string_size(8, &v);
            }
            if let Some(v) = self.img_icon_url.as_ref() {
                my_size += crate::rt::string_size(9, &v);
            }
            if let Some(v) = self.exclude_reason {
                my_size += crate::rt::int32_size(10, v.value());
            }
            if let Some(v) = self.rt_time_acquired {
                my_size += crate::rt::uint32_size(11, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.owner_steamids {
                os.write_fixed64(2, *v)?;
            };
            if let Some(v) = self.free_app {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.sort_as.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.capsule_filename.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.img_icon_url.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.exclude_reason {
                os.write_enum(10, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.rt_time_acquired {
                os.write_uint32(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SharedApp {
            SharedApp::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.owner_steamids.clear();
            self.free_app = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.sort_as = ::std::option::Option::None;
            self.capsule_filename = ::std::option::Option::None;
            self.img_icon_url = ::std::option::Option::None;
            self.exclude_reason = ::std::option::Option::None;
            self.rt_time_acquired = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SharedApp {
            static instance: SharedApp = SharedApp {
                appid: ::std::option::Option::None,
                owner_steamids: ::std::vec::Vec::new(),
                free_app: ::std::option::Option::None,
                name: ::std::option::Option::None,
                sort_as: ::std::option::Option::None,
                capsule_filename: ::std::option::Option::None,
                img_icon_url: ::std::option::Option::None,
                exclude_reason: ::std::option::Option::None,
                rt_time_acquired: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for SharedApp {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CFamilyGroups_GetSharedLibraryApps_Response.SharedApp").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SharedApp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for SharedApp {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CFamilyGroupsClient_NotifyRunningApps_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroupsClient_NotifyRunningApps_Notification {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.running_apps)
    pub running_apps: ::std::vec::Vec<cfamily_groups_client_notify_running_apps_notification::RunningApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroupsClient_NotifyRunningApps_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroupsClient_NotifyRunningApps_Notification {
    fn default() -> &'a CFamilyGroupsClient_NotifyRunningApps_Notification {
        <CFamilyGroupsClient_NotifyRunningApps_Notification as crate::Message>::default_instance()
    }
}

impl CFamilyGroupsClient_NotifyRunningApps_Notification {
    pub fn new() -> CFamilyGroupsClient_NotifyRunningApps_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // repeated .CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp running_apps = 2;

    pub fn running_apps(&self) -> &[cfamily_groups_client_notify_running_apps_notification::RunningApp] {
        &self.running_apps
    }

    pub fn clear_running_apps(&mut self) {
        self.running_apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_running_apps(&mut self, v: ::std::vec::Vec<cfamily_groups_client_notify_running_apps_notification::RunningApp>) {
        self.running_apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_running_apps(&mut self) -> &mut ::std::vec::Vec<cfamily_groups_client_notify_running_apps_notification::RunningApp> {
        &mut self.running_apps
    }

    // Take field
    pub fn take_running_apps(&mut self) -> ::std::vec::Vec<cfamily_groups_client_notify_running_apps_notification::RunningApp> {
        ::std::mem::replace(&mut self.running_apps, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroupsClient_NotifyRunningApps_Notification| { &m.family_groupid },
            |m: &mut CFamilyGroupsClient_NotifyRunningApps_Notification| { &mut m.family_groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "running_apps",
            |m: &CFamilyGroupsClient_NotifyRunningApps_Notification| { &m.running_apps },
            |m: &mut CFamilyGroupsClient_NotifyRunningApps_Notification| { &mut m.running_apps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroupsClient_NotifyRunningApps_Notification>(
            "CFamilyGroupsClient_NotifyRunningApps_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroupsClient_NotifyRunningApps_Notification {
    const NAME: &'static str = "CFamilyGroupsClient_NotifyRunningApps_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.running_apps.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        for value in &self.running_apps {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        for v in &self.running_apps {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroupsClient_NotifyRunningApps_Notification {
        CFamilyGroupsClient_NotifyRunningApps_Notification::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.running_apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroupsClient_NotifyRunningApps_Notification {
        static instance: CFamilyGroupsClient_NotifyRunningApps_Notification = CFamilyGroupsClient_NotifyRunningApps_Notification {
            family_groupid: ::std::option::Option::None,
            running_apps: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroupsClient_NotifyRunningApps_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroupsClient_NotifyRunningApps_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroupsClient_NotifyRunningApps_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroupsClient_NotifyRunningApps_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CFamilyGroupsClient_NotifyRunningApps_Notification`
pub mod cfamily_groups_client_notify_running_apps_notification {
    // @@protoc_insertion_point(message:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayingMember {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember.member_steamid)
        pub member_steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember.owner_steamid)
        pub owner_steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayingMember {
        fn default() -> &'a PlayingMember {
            <PlayingMember as crate::Message>::default_instance()
        }
    }

    impl PlayingMember {
        pub fn new() -> PlayingMember {
            ::std::default::Default::default()
        }

        // optional fixed64 member_steamid = 1;

        pub fn member_steamid(&self) -> u64 {
            self.member_steamid.unwrap_or(0)
        }

        pub fn clear_member_steamid(&mut self) {
            self.member_steamid = ::std::option::Option::None;
        }

        pub fn has_member_steamid(&self) -> bool {
            self.member_steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_steamid(&mut self, v: u64) {
            self.member_steamid = ::std::option::Option::Some(v);
        }

        // optional fixed64 owner_steamid = 2;

        pub fn owner_steamid(&self) -> u64 {
            self.owner_steamid.unwrap_or(0)
        }

        pub fn clear_owner_steamid(&mut self) {
            self.owner_steamid = ::std::option::Option::None;
        }

        pub fn has_owner_steamid(&self) -> bool {
            self.owner_steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_steamid(&mut self, v: u64) {
            self.owner_steamid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "member_steamid",
                |m: &PlayingMember| { &m.member_steamid },
                |m: &mut PlayingMember| { &mut m.member_steamid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_steamid",
                |m: &PlayingMember| { &m.owner_steamid },
                |m: &mut PlayingMember| { &mut m.owner_steamid },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PlayingMember>(
                "CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PlayingMember {
        const NAME: &'static str = "PlayingMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.member_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    17 => {
                        self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.member_steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.owner_steamid {
                my_size += 1 + 8;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.member_steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.owner_steamid {
                os.write_fixed64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayingMember {
            PlayingMember::new()
        }

        fn clear(&mut self) {
            self.member_steamid = ::std::option::Option::None;
            self.owner_steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayingMember {
            static instance: PlayingMember = PlayingMember {
                member_steamid: ::std::option::Option::None,
                owner_steamid: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PlayingMember {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayingMember {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PlayingMember {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RunningApp {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp.is_locked)
        pub is_locked: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp.playing_members)
        pub playing_members: ::std::vec::Vec<PlayingMember>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RunningApp {
        fn default() -> &'a RunningApp {
            <RunningApp as crate::Message>::default_instance()
        }
    }

    impl RunningApp {
        pub fn new() -> RunningApp {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional bool is_locked = 2;

        pub fn is_locked(&self) -> bool {
            self.is_locked.unwrap_or(false)
        }

        pub fn clear_is_locked(&mut self) {
            self.is_locked = ::std::option::Option::None;
        }

        pub fn has_is_locked(&self) -> bool {
            self.is_locked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_locked(&mut self, v: bool) {
            self.is_locked = ::std::option::Option::Some(v);
        }

        // repeated .CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember playing_members = 3;

        pub fn playing_members(&self) -> &[PlayingMember] {
            &self.playing_members
        }

        pub fn clear_playing_members(&mut self) {
            self.playing_members.clear();
        }

        // Param is passed by value, moved
        pub fn set_playing_members(&mut self, v: ::std::vec::Vec<PlayingMember>) {
            self.playing_members = v;
        }

        // Mutable pointer to the field.
        pub fn mut_playing_members(&mut self) -> &mut ::std::vec::Vec<PlayingMember> {
            &mut self.playing_members
        }

        // Take field
        pub fn take_playing_members(&mut self) -> ::std::vec::Vec<PlayingMember> {
            ::std::mem::replace(&mut self.playing_members, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &RunningApp| { &m.appid },
                |m: &mut RunningApp| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_locked",
                |m: &RunningApp| { &m.is_locked },
                |m: &mut RunningApp| { &mut m.is_locked },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "playing_members",
                |m: &RunningApp| { &m.playing_members },
                |m: &mut RunningApp| { &mut m.playing_members },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<RunningApp>(
                "CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for RunningApp {
        const NAME: &'static str = "RunningApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.is_locked = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.playing_members.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.is_locked {
                my_size += 1 + 1;
            }
            for value in &self.playing_members {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.is_locked {
                os.write_bool(2, v)?;
            }
            for v in &self.playing_members {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RunningApp {
            RunningApp::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.is_locked = ::std::option::Option::None;
            self.playing_members.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RunningApp {
            static instance: RunningApp = RunningApp {
                appid: ::std::option::Option::None,
                is_locked: ::std::option::Option::None,
                playing_members: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for RunningApp {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RunningApp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for RunningApp {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CFamilyGroupsClient_InviteStatus_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroupsClient_InviteStatus_Notification {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroupsClient_InviteStatus_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroupsClient_InviteStatus_Notification {
    fn default() -> &'a CFamilyGroupsClient_InviteStatus_Notification {
        <CFamilyGroupsClient_InviteStatus_Notification as crate::Message>::default_instance()
    }
}

impl CFamilyGroupsClient_InviteStatus_Notification {
    pub fn new() -> CFamilyGroupsClient_InviteStatus_Notification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroupsClient_InviteStatus_Notification>(
            "CFamilyGroupsClient_InviteStatus_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroupsClient_InviteStatus_Notification {
    const NAME: &'static str = "CFamilyGroupsClient_InviteStatus_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroupsClient_InviteStatus_Notification {
        CFamilyGroupsClient_InviteStatus_Notification::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroupsClient_InviteStatus_Notification {
        static instance: CFamilyGroupsClient_InviteStatus_Notification = CFamilyGroupsClient_InviteStatus_Notification {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroupsClient_InviteStatus_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroupsClient_InviteStatus_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroupsClient_InviteStatus_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroupsClient_InviteStatus_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFamilyGroupsClient_GroupChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroupsClient_GroupChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroupsClient_GroupChanged_Notification.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroupsClient_GroupChanged_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroupsClient_GroupChanged_Notification {
    fn default() -> &'a CFamilyGroupsClient_GroupChanged_Notification {
        <CFamilyGroupsClient_GroupChanged_Notification as crate::Message>::default_instance()
    }
}

impl CFamilyGroupsClient_GroupChanged_Notification {
    pub fn new() -> CFamilyGroupsClient_GroupChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "family_groupid",
            |m: &CFamilyGroupsClient_GroupChanged_Notification| { &m.family_groupid },
            |m: &mut CFamilyGroupsClient_GroupChanged_Notification| { &mut m.family_groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFamilyGroupsClient_GroupChanged_Notification>(
            "CFamilyGroupsClient_GroupChanged_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFamilyGroupsClient_GroupChanged_Notification {
    const NAME: &'static str = "CFamilyGroupsClient_GroupChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroupsClient_GroupChanged_Notification {
        CFamilyGroupsClient_GroupChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroupsClient_GroupChanged_Notification {
        static instance: CFamilyGroupsClient_GroupChanged_Notification = CFamilyGroupsClient_GroupChanged_Notification {
            family_groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFamilyGroupsClient_GroupChanged_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFamilyGroupsClient_GroupChanged_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFamilyGroupsClient_GroupChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFamilyGroupsClient_GroupChanged_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EFamilyGroupRole)
pub enum EFamilyGroupRole {
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_None)
    k_EFamilyGroupRole_None = 0,
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_Adult)
    k_EFamilyGroupRole_Adult = 1,
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_Child)
    k_EFamilyGroupRole_Child = 2,
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_MAX)
    k_EFamilyGroupRole_MAX = 3,
}

impl crate::Enum for EFamilyGroupRole {
    const NAME: &'static str = "EFamilyGroupRole";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFamilyGroupRole> {
        match value {
            0 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_None),
            1 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Adult),
            2 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Child),
            3 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EFamilyGroupRole> {
        match str {
            "k_EFamilyGroupRole_None" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_None),
            "k_EFamilyGroupRole_Adult" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Adult),
            "k_EFamilyGroupRole_Child" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Child),
            "k_EFamilyGroupRole_MAX" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EFamilyGroupRole] = &[
        EFamilyGroupRole::k_EFamilyGroupRole_None,
        EFamilyGroupRole::k_EFamilyGroupRole_Adult,
        EFamilyGroupRole::k_EFamilyGroupRole_Child,
        EFamilyGroupRole::k_EFamilyGroupRole_MAX,
    ];
}

impl crate::EnumFull for EFamilyGroupRole {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EFamilyGroupRole").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EFamilyGroupRole {
    fn default() -> Self {
        EFamilyGroupRole::k_EFamilyGroupRole_None
    }
}

impl EFamilyGroupRole {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EFamilyGroupRole>("EFamilyGroupRole")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPurchaseRequestAction)
pub enum EPurchaseRequestAction {
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_None)
    k_EPurchaseRequestAction_None = 0,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Decline)
    k_EPurchaseRequestAction_Decline = 1,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Purchased)
    k_EPurchaseRequestAction_Purchased = 2,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Abandoned)
    k_EPurchaseRequestAction_Abandoned = 3,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Cancel)
    k_EPurchaseRequestAction_Cancel = 4,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_MAX)
    k_EPurchaseRequestAction_MAX = 5,
}

impl crate::Enum for EPurchaseRequestAction {
    const NAME: &'static str = "EPurchaseRequestAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPurchaseRequestAction> {
        match value {
            0 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            1 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Decline),
            2 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Purchased),
            3 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Abandoned),
            4 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Cancel),
            5 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPurchaseRequestAction> {
        match str {
            "k_EPurchaseRequestAction_None" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            "k_EPurchaseRequestAction_Decline" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Decline),
            "k_EPurchaseRequestAction_Purchased" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Purchased),
            "k_EPurchaseRequestAction_Abandoned" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Abandoned),
            "k_EPurchaseRequestAction_Cancel" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Cancel),
            "k_EPurchaseRequestAction_MAX" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPurchaseRequestAction] = &[
        EPurchaseRequestAction::k_EPurchaseRequestAction_None,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Decline,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Purchased,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Abandoned,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Cancel,
        EPurchaseRequestAction::k_EPurchaseRequestAction_MAX,
    ];
}

impl crate::EnumFull for EPurchaseRequestAction {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPurchaseRequestAction").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPurchaseRequestAction {
    fn default() -> Self {
        EPurchaseRequestAction::k_EPurchaseRequestAction_None
    }
}

impl EPurchaseRequestAction {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPurchaseRequestAction>("EPurchaseRequestAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EFamilyGroupChangeLogType)
pub enum EFamilyGroupChangeLogType {
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_InvalidChangeType)
    k_InvalidChangeType = 0,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyGroupCreated)
    k_FamilyGroupCreated = 1,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyGroupModified)
    k_FamilyGroupModified = 2,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyGroupDeleted)
    k_FamilyGroupDeleted = 3,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_AccountInvited)
    k_AccountInvited = 4,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_InviteDeniedByGroupSize)
    k_InviteDeniedByGroupSize = 5,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinedFamilyGroup)
    k_JoinedFamilyGroup = 6,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByRegionMismatch)
    k_JoinDeniedByRegionMismatch = 7,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByMissingIpAddress)
    k_JoinDeniedByMissingIpAddress = 8,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByFamilyCooldown)
    k_JoinDeniedByFamilyCooldown = 9,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByUserCooldown)
    k_JoinDeniedByUserCooldown = 10,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByOtherGroup)
    k_JoinDeniedByOtherGroup = 11,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_AccountRemoved)
    k_AccountRemoved = 12,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_InviteCanceled)
    k_InviteCanceled = 13,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequested)
    k_PurchaseRequested = 14,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_ParentalSettingsEnabled)
    k_ParentalSettingsEnabled = 15,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_ParentalSettingsDisabled)
    k_ParentalSettingsDisabled = 16,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_ParentalSettingsChanged)
    k_ParentalSettingsChanged = 17,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyCooldownOverridesChanged)
    k_FamilyCooldownOverridesChanged = 18,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequestCanceled)
    k_PurchaseRequestCanceled = 19,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequestApproved)
    k_PurchaseRequestApproved = 20,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequestDeclined)
    k_PurchaseRequestDeclined = 21,
}

impl crate::Enum for EFamilyGroupChangeLogType {
    const NAME: &'static str = "EFamilyGroupChangeLogType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFamilyGroupChangeLogType> {
        match value {
            0 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InvalidChangeType),
            1 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupCreated),
            2 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupModified),
            3 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupDeleted),
            4 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountInvited),
            5 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteDeniedByGroupSize),
            6 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinedFamilyGroup),
            7 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByRegionMismatch),
            8 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByMissingIpAddress),
            9 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByFamilyCooldown),
            10 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByUserCooldown),
            11 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByOtherGroup),
            12 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountRemoved),
            13 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteCanceled),
            14 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequested),
            15 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsEnabled),
            16 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsDisabled),
            17 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsChanged),
            18 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyCooldownOverridesChanged),
            19 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestCanceled),
            20 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestApproved),
            21 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestDeclined),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EFamilyGroupChangeLogType> {
        match str {
            "k_InvalidChangeType" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InvalidChangeType),
            "k_FamilyGroupCreated" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupCreated),
            "k_FamilyGroupModified" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupModified),
            "k_FamilyGroupDeleted" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupDeleted),
            "k_AccountInvited" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountInvited),
            "k_InviteDeniedByGroupSize" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteDeniedByGroupSize),
            "k_JoinedFamilyGroup" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinedFamilyGroup),
            "k_JoinDeniedByRegionMismatch" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByRegionMismatch),
            "k_JoinDeniedByMissingIpAddress" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByMissingIpAddress),
            "k_JoinDeniedByFamilyCooldown" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByFamilyCooldown),
            "k_JoinDeniedByUserCooldown" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByUserCooldown),
            "k_JoinDeniedByOtherGroup" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByOtherGroup),
            "k_AccountRemoved" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountRemoved),
            "k_InviteCanceled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteCanceled),
            "k_PurchaseRequested" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequested),
            "k_ParentalSettingsEnabled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsEnabled),
            "k_ParentalSettingsDisabled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsDisabled),
            "k_ParentalSettingsChanged" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsChanged),
            "k_FamilyCooldownOverridesChanged" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyCooldownOverridesChanged),
            "k_PurchaseRequestCanceled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestCanceled),
            "k_PurchaseRequestApproved" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestApproved),
            "k_PurchaseRequestDeclined" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestDeclined),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EFamilyGroupChangeLogType] = &[
        EFamilyGroupChangeLogType::k_InvalidChangeType,
        EFamilyGroupChangeLogType::k_FamilyGroupCreated,
        EFamilyGroupChangeLogType::k_FamilyGroupModified,
        EFamilyGroupChangeLogType::k_FamilyGroupDeleted,
        EFamilyGroupChangeLogType::k_AccountInvited,
        EFamilyGroupChangeLogType::k_InviteDeniedByGroupSize,
        EFamilyGroupChangeLogType::k_JoinedFamilyGroup,
        EFamilyGroupChangeLogType::k_JoinDeniedByRegionMismatch,
        EFamilyGroupChangeLogType::k_JoinDeniedByMissingIpAddress,
        EFamilyGroupChangeLogType::k_JoinDeniedByFamilyCooldown,
        EFamilyGroupChangeLogType::k_JoinDeniedByUserCooldown,
        EFamilyGroupChangeLogType::k_JoinDeniedByOtherGroup,
        EFamilyGroupChangeLogType::k_AccountRemoved,
        EFamilyGroupChangeLogType::k_InviteCanceled,
        EFamilyGroupChangeLogType::k_PurchaseRequested,
        EFamilyGroupChangeLogType::k_ParentalSettingsEnabled,
        EFamilyGroupChangeLogType::k_ParentalSettingsDisabled,
        EFamilyGroupChangeLogType::k_ParentalSettingsChanged,
        EFamilyGroupChangeLogType::k_FamilyCooldownOverridesChanged,
        EFamilyGroupChangeLogType::k_PurchaseRequestCanceled,
        EFamilyGroupChangeLogType::k_PurchaseRequestApproved,
        EFamilyGroupChangeLogType::k_PurchaseRequestDeclined,
    ];
}

impl crate::EnumFull for EFamilyGroupChangeLogType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EFamilyGroupChangeLogType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EFamilyGroupChangeLogType {
    fn default() -> Self {
        EFamilyGroupChangeLogType::k_InvalidChangeType
    }
}

impl EFamilyGroupChangeLogType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EFamilyGroupChangeLogType>("EFamilyGroupChangeLogType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESharedLibraryExcludeReason)
pub enum ESharedLibraryExcludeReason {
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_Included)
    k_ESharedLibrary_Included = 0,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_AppExcluded)
    k_ESharedLibrary_AppExcluded = 1,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded)
    k_ESharedLibrary_LicenseExcluded = 2,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_FreeGame)
    k_ESharedLibrary_FreeGame = 3,
}

impl crate::Enum for ESharedLibraryExcludeReason {
    const NAME: &'static str = "ESharedLibraryExcludeReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESharedLibraryExcludeReason> {
        match value {
            0 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_Included),
            1 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded),
            2 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded),
            3 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_FreeGame),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESharedLibraryExcludeReason> {
        match str {
            "k_ESharedLibrary_Included" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_Included),
            "k_ESharedLibrary_AppExcluded" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded),
            "k_ESharedLibrary_LicenseExcluded" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded),
            "k_ESharedLibrary_FreeGame" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_FreeGame),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESharedLibraryExcludeReason] = &[
        ESharedLibraryExcludeReason::k_ESharedLibrary_Included,
        ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded,
        ESharedLibraryExcludeReason::k_ESharedLibrary_FreeGame,
    ];
}

impl crate::EnumFull for ESharedLibraryExcludeReason {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESharedLibraryExcludeReason").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESharedLibraryExcludeReason {
    fn default() -> Self {
        ESharedLibraryExcludeReason::k_ESharedLibrary_Included
    }
}

impl ESharedLibraryExcludeReason {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESharedLibraryExcludeReason>("ESharedLibraryExcludeReason")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,steammessages_familygroups.steamclient.proto\x1a\x18steammessages_bas\
    e.proto\x1a,steammessages_unified_base.steamclient.proto\"W\n'CFamilyGro\
    ups_CreateFamilyGroup_Request\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\"Q\n(CFamilyGr\
    oups_CreateFamilyGroup_Response\x12%\n\x0efamily_groupid\x18\x01\x20\x01\
    (\x04R\rfamilyGroupid\"y\n$CFamilyGroups_GetFamilyGroup_Request\x12%\n\
    \x0efamily_groupid\x18\x01\x20\x01(\x04R\rfamilyGroupid\x12*\n\x11send_r\
    unning_apps\x18\x02\x20\x01(\x08R\x0fsendRunningApps\"\x8e\x01\n\x11Fami\
    lyGroupMember\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12>\
    \n\x04role\x18\x02\x20\x01(\x0e2\x11.EFamilyGroupRole:\x17k_EFamilyGroup\
    Role_NoneR\x04role\x12\x1f\n\x0btime_joined\x18\x03\x20\x01(\rR\ntimeJoi\
    ned\"t\n\x18FamilyGroupPendingInvite\x12\x18\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamid\x12>\n\x04role\x18\x02\x20\x01(\x0e2\x11.EFamilyGr\
    oupRole:\x17k_EFamilyGroupRole_NoneR\x04role\"3\n\x17FamilyGroupFormerMe\
    mber\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\xa6\x03\n%C\
    FamilyGroups_GetFamilyGroup_Response\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12,\n\x07members\x18\x02\x20\x03(\x0b2\x12.FamilyGroupMembe\
    rR\x07members\x12B\n\x0fpending_invites\x18\x03\x20\x03(\x0b2\x19.Family\
    GroupPendingInviteR\x0ependingInvites\x12\x1d\n\nfree_spots\x18\x04\x20\
    \x01(\rR\tfreeSpots\x12\x18\n\x07country\x18\x05\x20\x01(\tR\x07country\
    \x12E\n\x1fslot_cooldown_remaining_seconds\x18\x06\x20\x01(\rR\x1cslotCo\
    oldownRemainingSeconds\x12?\n\x0eformer_members\x18\x07\x20\x03(\x0b2\
    \x18.FamilyGroupFormerMemberR\rformerMembers\x126\n\x17slot_cooldown_ove\
    rrides\x18\x08\x20\x01(\rR\x15slotCooldownOverrides\"G\n+CFamilyGroups_G\
    etFamilyGroupForUser_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x04R\
    \x07steamid\"\xb1\x01\n\x1fFamilyGroupPendingInviteForUser\x12%\n\x0efam\
    ily_groupid\x18\x01\x20\x01(\x04R\rfamilyGroupid\x12>\n\x04role\x18\x02\
    \x20\x01(\x0e2\x11.EFamilyGroupRole:\x17k_EFamilyGroupRole_NoneR\x04role\
    \x12'\n\x0finviter_steamid\x18\x03\x20\x01(\x06R\x0einviterSteamid\"\xa7\
    \x03\n,CFamilyGroups_GetFamilyGroupForUser_Response\x12%\n\x0efamily_gro\
    upid\x18\x01\x20\x01(\x04R\rfamilyGroupid\x129\n\x1ais_not_member_of_any\
    _group\x18\x02\x20\x01(\x08R\x15isNotMemberOfAnyGroup\x12,\n\x12latest_t\
    ime_joined\x18\x03\x20\x01(\rR\x10latestTimeJoined\x12?\n\x1clatest_join\
    ed_family_groupid\x18\x04\x20\x01(\x04R\x19latestJoinedFamilyGroupid\x12\
    T\n\x15pending_group_invites\x18\x05\x20\x03(\x0b2\x20.FamilyGroupPendin\
    gInviteForUserR\x13pendingGroupInvites\x12\x12\n\x04role\x18\x06\x20\x01\
    (\rR\x04role\x12<\n\x1acooldown_seconds_remaining\x18\x07\x20\x01(\rR\
    \x18cooldownSecondsRemaining\"k\n.CFamilyGroups_ModifyFamilyGroupDetails\
    _Request\x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04R\rfamilyGroupid\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"1\n/CFamilyGroups_Modify\
    FamilyGroupDetails_Response\"\xce\x01\n)CFamilyGroups_InviteToFamilyGrou\
    p_Request\x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04R\rfamilyGroupid\
    \x12)\n\x10receiver_steamid\x18\x02\x20\x01(\x06R\x0freceiverSteamid\x12\
    O\n\rreceiver_role\x18\x03\x20\x01(\x0e2\x11.EFamilyGroupRole:\x17k_EFam\
    ilyGroupRole_NoneR\x0creceiverRole\",\n*CFamilyGroups_InviteToFamilyGrou\
    p_Response\"N\n%CFamilyGroups_JoinFamilyGroup_Request\x12%\n\x0efamily_g\
    roupid\x18\x01\x20\x01(\x04R\rfamilyGroupid\"(\n&CFamilyGroups_JoinFamil\
    yGroup_Response\"\x80\x01\n+CFamilyGroups_RemoveFromFamilyGroup_Request\
    \x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04R\rfamilyGroupid\x12*\n\
    \x11steamid_to_remove\x18\x02\x20\x01(\x06R\x0fsteamidToRemove\".\n,CFam\
    ilyGroups_RemoveFromFamilyGroup_Response\"\x82\x01\n-CFamilyGroups_Cance\
    lFamilyGroupInvite_Request\x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04\
    R\rfamilyGroupid\x12*\n\x11steamid_to_cancel\x18\x02\x20\x01(\x06R\x0fst\
    eamidToCancel\"0\n.CFamilyGroups_CancelFamilyGroupInvite_Response\"\x82\
    \x01\n+CFamilyGroups_GetUsersSharingDevice_Request\x12%\n\x0efamily_grou\
    pid\x18\x01\x20\x01(\x04R\rfamilyGroupid\x12,\n\x12client_instance_id\
    \x18\x02\x20\x01(\x04R\x10clientInstanceId\"D\n,CFamilyGroups_GetUsersSh\
    aringDevice_Response\x12\x14\n\x05users\x18\x01\x20\x03(\x06R\x05users\"\
    P\n'CFamilyGroups_DeleteFamilyGroup_Request\x12%\n\x0efamily_groupid\x18\
    \x01\x20\x01(\x04R\rfamilyGroupid\"*\n(CFamilyGroups_DeleteFamilyGroup_R\
    esponse\"Q\n(CFamilyGroups_GetPlaytimeSummary_Request\x12%\n\x0efamily_g\
    roupid\x18\x01\x20\x01(\x06R\rfamilyGroupid\"\xbc\x01\n\x1bCFamilyGroups\
    _PlaytimeEntry\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\
    \x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12!\n\x0cfirst_played\x18\
    \x03\x20\x01(\rR\x0bfirstPlayed\x12#\n\rlatest_played\x18\x04\x20\x01(\r\
    R\x0clatestPlayed\x12%\n\x0eseconds_played\x18\x05\x20\x01(\rR\rsecondsP\
    layed\"c\n)CFamilyGroups_GetPlaytimeSummary_Response\x126\n\x07entries\
    \x18\x01\x20\x03(\x0b2\x1c.CFamilyGroups_PlaytimeEntryR\x07entries\"\xd0\
    \x01\n%CFamilyGroups_RequestPurchase_Request\x12%\n\x0efamily_groupid\
    \x18\x01\x20\x01(\x04R\rfamilyGroupid\x12(\n\x0fgidshoppingcart\x18\x02\
    \x20\x01(\x04R\x0fgidshoppingcart\x12,\n\x12store_country_code\x18\x03\
    \x20\x01(\tR\x10storeCountryCode\x12(\n\x10use_account_cart\x18\x04\x20\
    \x01(\x08R\x0euseAccountCart\"q\n&CFamilyGroups_RequestPurchase_Response\
    \x12(\n\x0fgidshoppingcart\x18\x01\x20\x01(\x04R\x0fgidshoppingcart\x12\
    \x1d\n\nrequest_id\x18\x02\x20\x01(\x04R\trequestId\"\x7f\n)CFamilyGroup\
    s_GetPurchaseRequests_Request\x12%\n\x0efamily_groupid\x18\x01\x20\x01(\
    \x04R\rfamilyGroupid\x12+\n\x11include_completed\x18\x02\x20\x01(\x08R\
    \x10includeCompleted\"\x86\x03\n\x0fPurchaseRequest\x12+\n\x11requester_\
    steamid\x18\x01\x20\x01(\x06R\x10requesterSteamid\x12(\n\x0fgidshoppingc\
    art\x18\x02\x20\x01(\x04R\x0fgidshoppingcart\x12%\n\x0etime_requested\
    \x18\x03\x20\x01(\rR\rtimeRequested\x12%\n\x0etime_responded\x18\x04\x20\
    \x01(\rR\rtimeResponded\x12+\n\x11responder_steamid\x18\x05\x20\x01(\x06\
    R\x10responderSteamid\x12_\n\x0fresponse_action\x18\x06\x20\x01(\x0e2\
    \x17.EPurchaseRequestAction:\x1dk_EPurchaseRequestAction_NoneR\x0erespon\
    seAction\x12!\n\x0cis_completed\x18\x07\x20\x01(\x08R\x0bisCompleted\x12\
    \x1d\n\nrequest_id\x18\x08\x20\x01(\x04R\trequestId\"Z\n*CFamilyGroups_G\
    etPurchaseRequests_Response\x12,\n\x08requests\x18\x01\x20\x03(\x0b2\x10\
    .PurchaseRequestR\x08requests\"\x86\x02\n0CFamilyGroups_RespondToRequest\
    edPurchase_Request\x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04R\rfamil\
    yGroupid\x12<\n\x1apurchase_requester_steamid\x18\x02\x20\x01(\x06R\x18p\
    urchaseRequesterSteamid\x12N\n\x06action\x18\x03\x20\x01(\x0e2\x17.EPurc\
    haseRequestAction:\x1dk_EPurchaseRequestAction_NoneR\x06action\x12\x1d\n\
    \nrequest_id\x18\x04\x20\x01(\x04R\trequestId\"3\n1CFamilyGroups_Respond\
    ToRequestedPurchase_Response\"K\n\"CFamilyGroups_GetChangeLog_Request\
    \x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04R\rfamilyGroupid\"\xb2\x02\
    \n#CFamilyGroups_GetChangeLog_Response\x12E\n\x07changes\x18\x01\x20\x03\
    (\x0b2+.CFamilyGroups_GetChangeLog_Response.ChangeR\x07changes\x1a\xc3\
    \x01\n\x06Change\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x06R\ttimestamp\
    \x12#\n\ractor_steamid\x18\x02\x20\x01(\x06R\x0cactorSteamid\x12C\n\x04t\
    ype\x18\x03\x20\x01(\x0e2\x1a.EFamilyGroupChangeLogType:\x13k_InvalidCha\
    ngeTypeR\x04type\x12\x12\n\x04body\x18\x04\x20\x01(\tR\x04body\x12\x1d\n\
    \nby_support\x18\x05\x20\x01(\x08R\tbySupport\"\x80\x01\n0CFamilyGroups_\
    SetFamilyCooldownOverrides_Request\x12%\n\x0efamily_groupid\x18\x01\x20\
    \x01(\x04R\rfamilyGroupid\x12%\n\x0ecooldown_count\x18\x02\x20\x01(\rR\r\
    cooldownCount\"3\n1CFamilyGroups_SetFamilyCooldownOverrides_Response\"\
    \xf9\x01\n*CFamilyGroups_GetSharedLibraryApps_Request\x12%\n\x0efamily_g\
    roupid\x18\x01\x20\x01(\x06R\rfamilyGroupid\x12\x1f\n\x0binclude_own\x18\
    \x02\x20\x01(\x08R\nincludeOwn\x12)\n\x10include_excluded\x18\x03\x20\
    \x01(\x08R\x0fincludeExcluded\x12!\n\x0cinclude_free\x18\x04\x20\x01(\
    \x08R\x0bincludeFree\x12\x1a\n\x08language\x18\x05\x20\x01(\tR\x08langua\
    ge\x12\x19\n\x08max_apps\x18\x06\x20\x01(\rR\x07maxApps\"\xe3\x03\n+CFam\
    ilyGroups_GetSharedLibraryApps_Response\x12J\n\x04apps\x18\x01\x20\x03(\
    \x0b26.CFamilyGroups_GetSharedLibraryApps_Response.SharedAppR\x04apps\
    \x1a\xe7\x02\n\tSharedApp\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appi\
    d\x12%\n\x0eowner_steamids\x18\x02\x20\x03(\x06R\rownerSteamids\x12\x19\
    \n\x08free_app\x18\x05\x20\x01(\x08R\x07freeApp\x12\x12\n\x04name\x18\
    \x06\x20\x01(\tR\x04name\x12\x17\n\x07sort_as\x18\x07\x20\x01(\tR\x06sor\
    tAs\x12)\n\x10capsule_filename\x18\x08\x20\x01(\tR\x0fcapsuleFilename\
    \x12\x20\n\x0cimg_icon_url\x18\t\x20\x01(\tR\nimgIconUrl\x12^\n\x0eexclu\
    de_reason\x18\n\x20\x01(\x0e2\x1c.ESharedLibraryExcludeReason:\x19k_ESha\
    redLibrary_IncludedR\rexcludeReason\x12(\n\x10rt_time_acquired\x18\x0b\
    \x20\x01(\rR\x0ertTimeAcquired\"\xc9\x03\n2CFamilyGroupsClient_NotifyRun\
    ningApps_Notification\x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04R\rfa\
    milyGroupid\x12a\n\x0crunning_apps\x18\x02\x20\x03(\x0b2>.CFamilyGroupsC\
    lient_NotifyRunningApps_Notification.RunningAppR\x0brunningApps\x1a[\n\r\
    PlayingMember\x12%\n\x0emember_steamid\x18\x01\x20\x01(\x06R\rmemberStea\
    mid\x12#\n\rowner_steamid\x18\x02\x20\x01(\x06R\x0cownerSteamid\x1a\xab\
    \x01\n\nRunningApp\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x1b\n\tis_locked\x18\x02\x20\x01(\x08R\x08isLocked\x12j\n\x0fplaying_me\
    mbers\x18\x03\x20\x03(\x0b2A.CFamilyGroupsClient_NotifyRunningApps_Notif\
    ication.PlayingMemberR\x0eplayingMembers\"/\n-CFamilyGroupsClient_Invite\
    Status_Notification\"V\n-CFamilyGroupsClient_GroupChanged_Notification\
    \x12%\n\x0efamily_groupid\x18\x01\x20\x01(\x04R\rfamilyGroupid*\x87\x01\
    \n\x10EFamilyGroupRole\x12\x1b\n\x17k_EFamilyGroupRole_None\x10\0\x12\
    \x1c\n\x18k_EFamilyGroupRole_Adult\x10\x01\x12\x1c\n\x18k_EFamilyGroupRo\
    le_Child\x10\x02\x12\x1a\n\x16k_EFamilyGroupRole_MAX\x10\x03*\xf8\x01\n\
    \x16EPurchaseRequestAction\x12!\n\x1dk_EPurchaseRequestAction_None\x10\0\
    \x12$\n\x20k_EPurchaseRequestAction_Decline\x10\x01\x12&\n\"k_EPurchaseR\
    equestAction_Purchased\x10\x02\x12&\n\"k_EPurchaseRequestAction_Abandone\
    d\x10\x03\x12#\n\x1fk_EPurchaseRequestAction_Cancel\x10\x04\x12\x20\n\
    \x1ck_EPurchaseRequestAction_MAX\x10\x05*\x9d\x05\n\x19EFamilyGroupChang\
    eLogType\x12\x17\n\x13k_InvalidChangeType\x10\0\x12\x18\n\x14k_FamilyGro\
    upCreated\x10\x01\x12\x19\n\x15k_FamilyGroupModified\x10\x02\x12\x18\n\
    \x14k_FamilyGroupDeleted\x10\x03\x12\x14\n\x10k_AccountInvited\x10\x04\
    \x12\x1d\n\x19k_InviteDeniedByGroupSize\x10\x05\x12\x17\n\x13k_JoinedFam\
    ilyGroup\x10\x06\x12\x20\n\x1ck_JoinDeniedByRegionMismatch\x10\x07\x12\"\
    \n\x1ek_JoinDeniedByMissingIpAddress\x10\x08\x12\x20\n\x1ck_JoinDeniedBy\
    FamilyCooldown\x10\t\x12\x1e\n\x1ak_JoinDeniedByUserCooldown\x10\n\x12\
    \x1c\n\x18k_JoinDeniedByOtherGroup\x10\x0b\x12\x14\n\x10k_AccountRemoved\
    \x10\x0c\x12\x14\n\x10k_InviteCanceled\x10\r\x12\x17\n\x13k_PurchaseRequ\
    ested\x10\x0e\x12\x1d\n\x19k_ParentalSettingsEnabled\x10\x0f\x12\x1e\n\
    \x1ak_ParentalSettingsDisabled\x10\x10\x12\x1d\n\x19k_ParentalSettingsCh\
    anged\x10\x11\x12$\n\x20k_FamilyCooldownOverridesChanged\x10\x12\x12\x1d\
    \n\x19k_PurchaseRequestCanceled\x10\x13\x12\x1d\n\x19k_PurchaseRequestAp\
    proved\x10\x14\x12\x1d\n\x19k_PurchaseRequestDeclined\x10\x15*\xa3\x01\n\
    \x1bESharedLibraryExcludeReason\x12\x1d\n\x19k_ESharedLibrary_Included\
    \x10\0\x12\x20\n\x1ck_ESharedLibrary_AppExcluded\x10\x01\x12$\n\x20k_ESh\
    aredLibrary_LicenseExcluded\x10\x02\x12\x1d\n\x19k_ESharedLibrary_FreeGa\
    me\x10\x032\x8f\x0f\n\x0cFamilyGroups\x12h\n\x11CreateFamilyGroup\x12(.C\
    FamilyGroups_CreateFamilyGroup_Request\x1a).CFamilyGroups_CreateFamilyGr\
    oup_Response\x12_\n\x0eGetFamilyGroup\x12%.CFamilyGroups_GetFamilyGroup_\
    Request\x1a&.CFamilyGroups_GetFamilyGroup_Response\x12t\n\x15GetFamilyGr\
    oupForUser\x12,.CFamilyGroups_GetFamilyGroupForUser_Request\x1a-.CFamily\
    Groups_GetFamilyGroupForUser_Response\x12}\n\x18ModifyFamilyGroupDetails\
    \x12/.CFamilyGroups_ModifyFamilyGroupDetails_Request\x1a0.CFamilyGroups_\
    ModifyFamilyGroupDetails_Response\x12n\n\x13InviteToFamilyGroup\x12*.CFa\
    milyGroups_InviteToFamilyGroup_Request\x1a+.CFamilyGroups_InviteToFamily\
    Group_Response\x12b\n\x0fJoinFamilyGroup\x12&.CFamilyGroups_JoinFamilyGr\
    oup_Request\x1a'.CFamilyGroups_JoinFamilyGroup_Response\x12t\n\x15Remove\
    FromFamilyGroup\x12,.CFamilyGroups_RemoveFromFamilyGroup_Request\x1a-.CF\
    amilyGroups_RemoveFromFamilyGroup_Response\x12z\n\x17CancelFamilyGroupIn\
    vite\x12..CFamilyGroups_CancelFamilyGroupInvite_Request\x1a/.CFamilyGrou\
    ps_CancelFamilyGroupInvite_Response\x12t\n\x15GetUsersSharingDevice\x12,\
    .CFamilyGroups_GetUsersSharingDevice_Request\x1a-.CFamilyGroups_GetUsers\
    SharingDevice_Response\x12h\n\x11DeleteFamilyGroup\x12(.CFamilyGroups_De\
    leteFamilyGroup_Request\x1a).CFamilyGroups_DeleteFamilyGroup_Response\
    \x12k\n\x12GetPlaytimeSummary\x12).CFamilyGroups_GetPlaytimeSummary_Requ\
    est\x1a*.CFamilyGroups_GetPlaytimeSummary_Response\x12b\n\x0fRequestPurc\
    hase\x12&.CFamilyGroups_RequestPurchase_Request\x1a'.CFamilyGroups_Reque\
    stPurchase_Response\x12n\n\x13GetPurchaseRequests\x12*.CFamilyGroups_Get\
    PurchaseRequests_Request\x1a+.CFamilyGroups_GetPurchaseRequests_Response\
    \x12\x83\x01\n\x1aRespondToRequestedPurchase\x121.CFamilyGroups_RespondT\
    oRequestedPurchase_Request\x1a2.CFamilyGroups_RespondToRequestedPurchase\
    _Response\x12Y\n\x0cGetChangeLog\x12#.CFamilyGroups_GetChangeLog_Request\
    \x1a$.CFamilyGroups_GetChangeLog_Response\x12\x83\x01\n\x1aSetFamilyCool\
    downOverrides\x121.CFamilyGroups_SetFamilyCooldownOverrides_Request\x1a2\
    .CFamilyGroups_SetFamilyCooldownOverrides_Response\x12q\n\x14GetSharedLi\
    braryApps\x12+.CFamilyGroups_GetSharedLibraryApps_Request\x1a,.CFamilyGr\
    oups_GetSharedLibraryApps_Response2\x97\x02\n\x12FamilyGroupsClient\x12U\
    \n\x11NotifyRunningApps\x123.CFamilyGroupsClient_NotifyRunningApps_Notif\
    ication\x1a\x0b.NoResponse\x12Q\n\x12NotifyInviteStatus\x12..CFamilyGrou\
    psClient_InviteStatus_Notification\x1a\x0b.NoResponse\x12Q\n\x12NotifyGr\
    oupChanged\x12..CFamilyGroupsClient_GroupChanged_Notification\x1a\x0b.No\
    Response\x1a\x04\xc0\xb5\x18\x02B\x03\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(47);
            messages.push(CFamilyGroups_CreateFamilyGroup_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_CreateFamilyGroup_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetFamilyGroup_Request::generated_message_descriptor_data());
            messages.push(FamilyGroupMember::generated_message_descriptor_data());
            messages.push(FamilyGroupPendingInvite::generated_message_descriptor_data());
            messages.push(FamilyGroupFormerMember::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetFamilyGroup_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetFamilyGroupForUser_Request::generated_message_descriptor_data());
            messages.push(FamilyGroupPendingInviteForUser::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetFamilyGroupForUser_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_ModifyFamilyGroupDetails_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_ModifyFamilyGroupDetails_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_InviteToFamilyGroup_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_InviteToFamilyGroup_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_JoinFamilyGroup_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_JoinFamilyGroup_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_RemoveFromFamilyGroup_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_RemoveFromFamilyGroup_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_CancelFamilyGroupInvite_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_CancelFamilyGroupInvite_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetUsersSharingDevice_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetUsersSharingDevice_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_DeleteFamilyGroup_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_DeleteFamilyGroup_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetPlaytimeSummary_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_PlaytimeEntry::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetPlaytimeSummary_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_RequestPurchase_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_RequestPurchase_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetPurchaseRequests_Request::generated_message_descriptor_data());
            messages.push(PurchaseRequest::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetPurchaseRequests_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_RespondToRequestedPurchase_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_RespondToRequestedPurchase_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetChangeLog_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetChangeLog_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_SetFamilyCooldownOverrides_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_SetFamilyCooldownOverrides_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetSharedLibraryApps_Request::generated_message_descriptor_data());
            messages.push(CFamilyGroups_GetSharedLibraryApps_Response::generated_message_descriptor_data());
            messages.push(CFamilyGroupsClient_NotifyRunningApps_Notification::generated_message_descriptor_data());
            messages.push(CFamilyGroupsClient_InviteStatus_Notification::generated_message_descriptor_data());
            messages.push(CFamilyGroupsClient_GroupChanged_Notification::generated_message_descriptor_data());
            messages.push(cfamily_groups_get_change_log_response::Change::generated_message_descriptor_data());
            messages.push(cfamily_groups_get_shared_library_apps_response::SharedApp::generated_message_descriptor_data());
            messages.push(cfamily_groups_client_notify_running_apps_notification::PlayingMember::generated_message_descriptor_data());
            messages.push(cfamily_groups_client_notify_running_apps_notification::RunningApp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(EFamilyGroupRole::generated_enum_descriptor_data());
            enums.push(EPurchaseRequestAction::generated_enum_descriptor_data());
            enums.push(EFamilyGroupChangeLogType::generated_enum_descriptor_data());
            enums.push(ESharedLibraryExcludeReason::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
