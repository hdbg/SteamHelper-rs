// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_mms.proto`

// @@protoc_insertion_point(message:CMsgClientMMSSetRatelimitPolicyOnClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetRatelimitPolicyOnClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.enable_rate_limits)
    pub enable_rate_limits: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.seconds_per_message)
    pub seconds_per_message: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.milliseconds_per_data_update)
    pub milliseconds_per_data_update: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetRatelimitPolicyOnClient.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetRatelimitPolicyOnClient {
    fn default() -> &'a CMsgClientMMSSetRatelimitPolicyOnClient {
        <CMsgClientMMSSetRatelimitPolicyOnClient as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSetRatelimitPolicyOnClient {
    pub fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bool enable_rate_limits = 2;

    pub fn enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.unwrap_or(false)
    }

    pub fn clear_enable_rate_limits(&mut self) {
        self.enable_rate_limits = ::std::option::Option::None;
    }

    pub fn has_enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_rate_limits(&mut self, v: bool) {
        self.enable_rate_limits = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_per_message = 3;

    pub fn seconds_per_message(&self) -> i32 {
        self.seconds_per_message.unwrap_or(0)
    }

    pub fn clear_seconds_per_message(&mut self) {
        self.seconds_per_message = ::std::option::Option::None;
    }

    pub fn has_seconds_per_message(&self) -> bool {
        self.seconds_per_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_per_message(&mut self, v: i32) {
        self.seconds_per_message = ::std::option::Option::Some(v);
    }

    // optional int32 milliseconds_per_data_update = 4;

    pub fn milliseconds_per_data_update(&self) -> i32 {
        self.milliseconds_per_data_update.unwrap_or(0)
    }

    pub fn clear_milliseconds_per_data_update(&mut self) {
        self.milliseconds_per_data_update = ::std::option::Option::None;
    }

    pub fn has_milliseconds_per_data_update(&self) -> bool {
        self.milliseconds_per_data_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_milliseconds_per_data_update(&mut self, v: i32) {
        self.milliseconds_per_data_update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.app_id },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_rate_limits",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.enable_rate_limits },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.enable_rate_limits },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_per_message",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.seconds_per_message },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.seconds_per_message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "milliseconds_per_data_update",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.milliseconds_per_data_update },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.milliseconds_per_data_update },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetRatelimitPolicyOnClient>(
            "CMsgClientMMSSetRatelimitPolicyOnClient",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSetRatelimitPolicyOnClient {
    const NAME: &'static str = "CMsgClientMMSSetRatelimitPolicyOnClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.enable_rate_limits = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.seconds_per_message = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.milliseconds_per_data_update = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.enable_rate_limits {
            my_size += 1 + 1;
        }
        if let Some(v) = self.seconds_per_message {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.milliseconds_per_data_update {
            my_size += crate::rt::int32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.enable_rate_limits {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.seconds_per_message {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.milliseconds_per_data_update {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        CMsgClientMMSSetRatelimitPolicyOnClient::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.enable_rate_limits = ::std::option::Option::None;
        self.seconds_per_message = ::std::option::Option::None;
        self.milliseconds_per_data_update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetRatelimitPolicyOnClient {
        static instance: CMsgClientMMSSetRatelimitPolicyOnClient = CMsgClientMMSSetRatelimitPolicyOnClient {
            app_id: ::std::option::Option::None,
            enable_rate_limits: ::std::option::Option::None,
            seconds_per_message: ::std::option::Option::None,
            milliseconds_per_data_update: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetRatelimitPolicyOnClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSetRatelimitPolicyOnClient {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSCreateLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSCreateLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.metadata)
    pub metadata: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.persona_name_owner)
    pub persona_name_owner: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.public_ip)
    pub public_ip: crate::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSCreateLobby.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobby {
    fn default() -> &'a CMsgClientMMSCreateLobby {
        <CMsgClientMMSCreateLobby as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobby {
    pub fn new() -> CMsgClientMMSCreateLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 2;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 3;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 4;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 5;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 6;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::bytes::Bytes {
        self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional string persona_name_owner = 8;

    pub fn persona_name_owner(&self) -> &str {
        match self.persona_name_owner.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name_owner(&mut self) {
        self.persona_name_owner = ::std::option::Option::None;
    }

    pub fn has_persona_name_owner(&self) -> bool {
        self.persona_name_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_owner(&mut self, v: ::std::string::String) {
        self.persona_name_owner = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_owner(&mut self) -> &mut ::std::string::String {
        if self.persona_name_owner.is_none() {
            self.persona_name_owner = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_owner(&mut self) -> ::std::string::String {
        self.persona_name_owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgIPAddress public_ip = 9;

    pub fn public_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.public_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
    }

    pub fn clear_public_ip(&mut self) {
        self.public_ip.clear();
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.public_ip = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        self.public_ip.mut_or_insert_default()
    }

    // Take field
    pub fn take_public_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.public_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSCreateLobby| { &m.app_id },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSCreateLobby| { &m.max_members },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.max_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSCreateLobby| { &m.lobby_type },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSCreateLobby| { &m.lobby_flags },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgClientMMSCreateLobby| { &m.cell_id },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.cell_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_public_ip",
            |m: &CMsgClientMMSCreateLobby| { &m.deprecated_public_ip },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.deprecated_public_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSCreateLobby| { &m.metadata },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.metadata },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name_owner",
            |m: &CMsgClientMMSCreateLobby| { &m.persona_name_owner },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.persona_name_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "public_ip",
            |m: &CMsgClientMMSCreateLobby| { &m.public_ip },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.public_ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSCreateLobby>(
            "CMsgClientMMSCreateLobby",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSCreateLobby {
    const NAME: &'static str = "CMsgClientMMSCreateLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.metadata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                66 => {
                    self.persona_name_owner = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_members {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.cell_id {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSCreateLobby {
        CMsgClientMMSCreateLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.persona_name_owner = ::std::option::Option::None;
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobby {
        static instance: CMsgClientMMSCreateLobby = CMsgClientMMSCreateLobby {
            app_id: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            persona_name_owner: ::std::option::Option::None,
            public_ip: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSCreateLobby {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSCreateLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSCreateLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSCreateLobby {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSCreateLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSCreateLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSCreateLobbyResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobbyResponse {
    fn default() -> &'a CMsgClientMMSCreateLobbyResponse {
        <CMsgClientMMSCreateLobbyResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobbyResponse {
    pub fn new() -> CMsgClientMMSCreateLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSCreateLobbyResponse| { &m.app_id },
            |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSCreateLobbyResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSCreateLobbyResponse| { &m.eresult },
            |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSCreateLobbyResponse>(
            "CMsgClientMMSCreateLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSCreateLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSCreateLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSCreateLobbyResponse {
        CMsgClientMMSCreateLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobbyResponse {
        static instance: CMsgClientMMSCreateLobbyResponse = CMsgClientMMSCreateLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSCreateLobbyResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSCreateLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSCreateLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSCreateLobbyResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSJoinLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSJoinLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobby.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobby {
    fn default() -> &'a CMsgClientMMSJoinLobby {
        <CMsgClientMMSJoinLobby as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobby {
    pub fn new() -> CMsgClientMMSJoinLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 3;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSJoinLobby| { &m.app_id },
            |m: &mut CMsgClientMMSJoinLobby| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSJoinLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSJoinLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name",
            |m: &CMsgClientMMSJoinLobby| { &m.persona_name },
            |m: &mut CMsgClientMMSJoinLobby| { &mut m.persona_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSJoinLobby>(
            "CMsgClientMMSJoinLobby",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSJoinLobby {
    const NAME: &'static str = "CMsgClientMMSJoinLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSJoinLobby {
        CMsgClientMMSJoinLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobby {
        static instance: CMsgClientMMSJoinLobby = CMsgClientMMSJoinLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSJoinLobby {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSJoinLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSJoinLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSJoinLobby {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSJoinLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSJoinLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.chat_room_enter_response)
    pub chat_room_enter_response: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.steam_id_owner)
    pub steam_id_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.metadata)
    pub metadata: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.members)
    pub members: ::std::vec::Vec<cmsg_client_mmsjoin_lobby_response::Member>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobbyResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobbyResponse {
    fn default() -> &'a CMsgClientMMSJoinLobbyResponse {
        <CMsgClientMMSJoinLobbyResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobbyResponse {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 chat_room_enter_response = 3;

    pub fn chat_room_enter_response(&self) -> i32 {
        self.chat_room_enter_response.unwrap_or(0)
    }

    pub fn clear_chat_room_enter_response(&mut self) {
        self.chat_room_enter_response = ::std::option::Option::None;
    }

    pub fn has_chat_room_enter_response(&self) -> bool {
        self.chat_room_enter_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_enter_response(&mut self, v: i32) {
        self.chat_room_enter_response = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::bytes::Bytes {
        self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // repeated .CMsgClientMMSJoinLobbyResponse.Member members = 9;

    pub fn members(&self) -> &[cmsg_client_mmsjoin_lobby_response::Member] {
        &self.members
    }

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::std::vec::Vec<cmsg_client_mmsjoin_lobby_response::Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::std::vec::Vec<cmsg_client_mmsjoin_lobby_response::Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::std::vec::Vec<cmsg_client_mmsjoin_lobby_response::Member> {
        ::std::mem::replace(&mut self.members, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.app_id },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_enter_response",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.chat_room_enter_response },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.chat_room_enter_response },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.max_members },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.max_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_type },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_flags },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_owner",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_owner },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.metadata },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.metadata },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.members },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.members },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSJoinLobbyResponse>(
            "CMsgClientMMSJoinLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSJoinLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSJoinLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.chat_room_enter_response = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                57 => {
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                66 => {
                    self.metadata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                74 => {
                    self.members.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_room_enter_response {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.max_members {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_room_enter_response {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSJoinLobbyResponse {
        CMsgClientMMSJoinLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.chat_room_enter_response = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse {
        static instance: CMsgClientMMSJoinLobbyResponse = CMsgClientMMSJoinLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            chat_room_enter_response: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            steam_id_owner: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSJoinLobbyResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSJoinLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSJoinLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSJoinLobbyResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSJoinLobbyResponse`
pub mod cmsg_client_mmsjoin_lobby_response {
    // @@protoc_insertion_point(message:CMsgClientMMSJoinLobbyResponse.Member)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.persona_name)
        pub persona_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.metadata)
        pub metadata: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobbyResponse.Member.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as crate::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name = ::std::option::Option::None;
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::bytes::Bytes {
            self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Member| { &m.steam_id },
                |m: &mut Member| { &mut m.steam_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona_name",
                |m: &Member| { &m.persona_name },
                |m: &mut Member| { &mut m.persona_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "metadata",
                |m: &Member| { &m.metadata },
                |m: &mut Member| { &mut m.metadata },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Member>(
                "CMsgClientMMSJoinLobbyResponse.Member",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.persona_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.metadata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += crate::rt::bytes_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                steam_id: ::std::option::Option::None,
                persona_name: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Member {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSJoinLobbyResponse.Member").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Member {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Member {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSLeaveLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLeaveLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLeaveLobby.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobby {
    fn default() -> &'a CMsgClientMMSLeaveLobby {
        <CMsgClientMMSLeaveLobby as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobby {
    pub fn new() -> CMsgClientMMSLeaveLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLeaveLobby| { &m.app_id },
            |m: &mut CMsgClientMMSLeaveLobby| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLeaveLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLeaveLobby| { &mut m.steam_id_lobby },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLeaveLobby>(
            "CMsgClientMMSLeaveLobby",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSLeaveLobby {
    const NAME: &'static str = "CMsgClientMMSLeaveLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLeaveLobby {
        CMsgClientMMSLeaveLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobby {
        static instance: CMsgClientMMSLeaveLobby = CMsgClientMMSLeaveLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSLeaveLobby {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLeaveLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLeaveLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSLeaveLobby {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLeaveLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLeaveLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLeaveLobbyResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobbyResponse {
    fn default() -> &'a CMsgClientMMSLeaveLobbyResponse {
        <CMsgClientMMSLeaveLobbyResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobbyResponse {
    pub fn new() -> CMsgClientMMSLeaveLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLeaveLobbyResponse| { &m.app_id },
            |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLeaveLobbyResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSLeaveLobbyResponse| { &m.eresult },
            |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLeaveLobbyResponse>(
            "CMsgClientMMSLeaveLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSLeaveLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSLeaveLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLeaveLobbyResponse {
        CMsgClientMMSLeaveLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobbyResponse {
        static instance: CMsgClientMMSLeaveLobbyResponse = CMsgClientMMSLeaveLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSLeaveLobbyResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLeaveLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLeaveLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSLeaveLobbyResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.num_lobbies_requested)
    pub num_lobbies_requested: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.filters)
    pub filters: ::std::vec::Vec<cmsg_client_mmsget_lobby_list::Filter>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.public_ip)
    pub public_ip: crate::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyList {
    fn default() -> &'a CMsgClientMMSGetLobbyList {
        <CMsgClientMMSGetLobbyList as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyList {
    pub fn new() -> CMsgClientMMSGetLobbyList {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_lobbies_requested = 3;

    pub fn num_lobbies_requested(&self) -> i32 {
        self.num_lobbies_requested.unwrap_or(0)
    }

    pub fn clear_num_lobbies_requested(&mut self) {
        self.num_lobbies_requested = ::std::option::Option::None;
    }

    pub fn has_num_lobbies_requested(&self) -> bool {
        self.num_lobbies_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_lobbies_requested(&mut self, v: i32) {
        self.num_lobbies_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 4;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 5;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientMMSGetLobbyList.Filter filters = 6;

    pub fn filters(&self) -> &[cmsg_client_mmsget_lobby_list::Filter] {
        &self.filters
    }

    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::std::vec::Vec<cmsg_client_mmsget_lobby_list::Filter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::std::vec::Vec<cmsg_client_mmsget_lobby_list::Filter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::std::vec::Vec<cmsg_client_mmsget_lobby_list::Filter> {
        ::std::mem::replace(&mut self.filters, ::std::vec::Vec::new())
    }

    // optional .CMsgIPAddress public_ip = 7;

    pub fn public_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.public_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
    }

    pub fn clear_public_ip(&mut self) {
        self.public_ip.clear();
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.public_ip = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        self.public_ip.mut_or_insert_default()
    }

    // Take field
    pub fn take_public_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.public_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyList| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_lobbies_requested",
            |m: &CMsgClientMMSGetLobbyList| { &m.num_lobbies_requested },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.num_lobbies_requested },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgClientMMSGetLobbyList| { &m.cell_id },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.cell_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_public_ip",
            |m: &CMsgClientMMSGetLobbyList| { &m.deprecated_public_ip },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.deprecated_public_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &CMsgClientMMSGetLobbyList| { &m.filters },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.filters },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "public_ip",
            |m: &CMsgClientMMSGetLobbyList| { &m.public_ip },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.public_ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyList>(
            "CMsgClientMMSGetLobbyList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSGetLobbyList {
    const NAME: &'static str = "CMsgClientMMSGetLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_lobbies_requested = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.filters.push(is.read_message()?);
                },
                58 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_lobbies_requested {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.cell_id {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += crate::rt::uint32_size(5, v);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_lobbies_requested {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(5, v)?;
        }
        for v in &self.filters {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.public_ip.as_ref() {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyList {
        CMsgClientMMSGetLobbyList::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.num_lobbies_requested = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.filters.clear();
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyList {
        static instance: CMsgClientMMSGetLobbyList = CMsgClientMMSGetLobbyList {
            app_id: ::std::option::Option::None,
            num_lobbies_requested: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            filters: ::std::vec::Vec::new(),
            public_ip: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSGetLobbyList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSGetLobbyList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyList`
pub mod cmsg_client_mmsget_lobby_list {
    // @@protoc_insertion_point(message:CMsgClientMMSGetLobbyList.Filter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Filter {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.value)
        pub value: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.comparision)
        pub comparision: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.filter_type)
        pub filter_type: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyList.Filter.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as crate::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 comparision = 3;

        pub fn comparision(&self) -> i32 {
            self.comparision.unwrap_or(0)
        }

        pub fn clear_comparision(&mut self) {
            self.comparision = ::std::option::Option::None;
        }

        pub fn has_comparision(&self) -> bool {
            self.comparision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comparision(&mut self, v: i32) {
            self.comparision = ::std::option::Option::Some(v);
        }

        // optional int32 filter_type = 4;

        pub fn filter_type(&self) -> i32 {
            self.filter_type.unwrap_or(0)
        }

        pub fn clear_filter_type(&mut self) {
            self.filter_type = ::std::option::Option::None;
        }

        pub fn has_filter_type(&self) -> bool {
            self.filter_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filter_type(&mut self, v: i32) {
            self.filter_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &Filter| { &m.key },
                |m: &mut Filter| { &mut m.key },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Filter| { &m.value },
                |m: &mut Filter| { &mut m.value },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "comparision",
                |m: &Filter| { &m.comparision },
                |m: &mut Filter| { &mut m.comparision },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "filter_type",
                |m: &Filter| { &m.filter_type },
                |m: &mut Filter| { &mut m.filter_type },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "CMsgClientMMSGetLobbyList.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.comparision = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.filter_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.comparision {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.filter_type {
                my_size += crate::rt::int32_size(4, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.comparision {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.filter_type {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.comparision = ::std::option::Option::None;
            self.filter_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                key: ::std::option::Option::None,
                value: ::std::option::Option::None,
                comparision: ::std::option::Option::None,
                filter_type: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Filter {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyList.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Filter {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<cmsg_client_mmsget_lobby_list_response::Lobby>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyListResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyListResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyListResponse {
        <CMsgClientMMSGetLobbyListResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyListResponse {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientMMSGetLobbyListResponse.Lobby lobbies = 4;

    pub fn lobbies(&self) -> &[cmsg_client_mmsget_lobby_list_response::Lobby] {
        &self.lobbies
    }

    pub fn clear_lobbies(&mut self) {
        self.lobbies.clear();
    }

    // Param is passed by value, moved
    pub fn set_lobbies(&mut self, v: ::std::vec::Vec<cmsg_client_mmsget_lobby_list_response::Lobby>) {
        self.lobbies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lobbies(&mut self) -> &mut ::std::vec::Vec<cmsg_client_mmsget_lobby_list_response::Lobby> {
        &mut self.lobbies
    }

    // Take field
    pub fn take_lobbies(&mut self) -> ::std::vec::Vec<cmsg_client_mmsget_lobby_list_response::Lobby> {
        ::std::mem::replace(&mut self.lobbies, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyListResponse| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSGetLobbyListResponse| { &m.eresult },
            |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobbies",
            |m: &CMsgClientMMSGetLobbyListResponse| { &m.lobbies },
            |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.lobbies },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyListResponse>(
            "CMsgClientMMSGetLobbyListResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSGetLobbyListResponse {
    const NAME: &'static str = "CMsgClientMMSGetLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(3, v);
        }
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        for v in &self.lobbies {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyListResponse {
        CMsgClientMMSGetLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse {
        static instance: CMsgClientMMSGetLobbyListResponse = CMsgClientMMSGetLobbyListResponse {
            app_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            lobbies: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSGetLobbyListResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSGetLobbyListResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyListResponse`
pub mod cmsg_client_mmsget_lobby_list_response {
    // @@protoc_insertion_point(message:CMsgClientMMSGetLobbyListResponse.Lobby)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Lobby {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.max_members)
        pub max_members: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.lobby_type)
        pub lobby_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.lobby_flags)
        pub lobby_flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.metadata)
        pub metadata: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.num_members)
        pub num_members: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.distance)
        pub distance: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.weight)
        pub weight: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyListResponse.Lobby.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Lobby {
        fn default() -> &'a Lobby {
            <Lobby as crate::Message>::default_instance()
        }
    }

    impl Lobby {
        pub fn new() -> Lobby {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional int32 max_members = 2;

        pub fn max_members(&self) -> i32 {
            self.max_members.unwrap_or(0)
        }

        pub fn clear_max_members(&mut self) {
            self.max_members = ::std::option::Option::None;
        }

        pub fn has_max_members(&self) -> bool {
            self.max_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_members(&mut self, v: i32) {
            self.max_members = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_type = 3;

        pub fn lobby_type(&self) -> i32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: i32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_flags = 4;

        pub fn lobby_flags(&self) -> i32 {
            self.lobby_flags.unwrap_or(0)
        }

        pub fn clear_lobby_flags(&mut self) {
            self.lobby_flags = ::std::option::Option::None;
        }

        pub fn has_lobby_flags(&self) -> bool {
            self.lobby_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_flags(&mut self, v: i32) {
            self.lobby_flags = ::std::option::Option::Some(v);
        }

        // optional bytes metadata = 5;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::bytes::Bytes {
            self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional int32 num_members = 6;

        pub fn num_members(&self) -> i32 {
            self.num_members.unwrap_or(0)
        }

        pub fn clear_num_members(&mut self) {
            self.num_members = ::std::option::Option::None;
        }

        pub fn has_num_members(&self) -> bool {
            self.num_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_members(&mut self, v: i32) {
            self.num_members = ::std::option::Option::Some(v);
        }

        // optional float distance = 7;

        pub fn distance(&self) -> f32 {
            self.distance.unwrap_or(0.)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: f32) {
            self.distance = ::std::option::Option::Some(v);
        }

        // optional int64 weight = 8;

        pub fn weight(&self) -> i64 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: i64) {
            self.weight = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Lobby| { &m.steam_id },
                |m: &mut Lobby| { &mut m.steam_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_members",
                |m: &Lobby| { &m.max_members },
                |m: &mut Lobby| { &mut m.max_members },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_type",
                |m: &Lobby| { &m.lobby_type },
                |m: &mut Lobby| { &mut m.lobby_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_flags",
                |m: &Lobby| { &m.lobby_flags },
                |m: &mut Lobby| { &mut m.lobby_flags },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "metadata",
                |m: &Lobby| { &m.metadata },
                |m: &mut Lobby| { &mut m.metadata },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_members",
                |m: &Lobby| { &m.num_members },
                |m: &mut Lobby| { &mut m.num_members },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "distance",
                |m: &Lobby| { &m.distance },
                |m: &mut Lobby| { &mut m.distance },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "weight",
                |m: &Lobby| { &m.weight },
                |m: &mut Lobby| { &mut m.weight },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Lobby>(
                "CMsgClientMMSGetLobbyListResponse.Lobby",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Lobby {
        const NAME: &'static str = "Lobby";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.max_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.metadata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    48 => {
                        self.num_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    61 => {
                        self.distance = ::std::option::Option::Some(is.read_float()?);
                    },
                    64 => {
                        self.weight = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.max_members {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.lobby_type {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.lobby_flags {
                my_size += crate::rt::int32_size(4, v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += crate::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.num_members {
                my_size += crate::rt::int32_size(6, v);
            }
            if let Some(v) = self.distance {
                my_size += 1 + 4;
            }
            if let Some(v) = self.weight {
                my_size += crate::rt::int64_size(8, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.max_members {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.lobby_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.lobby_flags {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.num_members {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.distance {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.weight {
                os.write_int64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Lobby {
            Lobby::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.max_members = ::std::option::Option::None;
            self.lobby_type = ::std::option::Option::None;
            self.lobby_flags = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.num_members = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Lobby {
            static instance: Lobby = Lobby {
                steam_id: ::std::option::Option::None,
                max_members: ::std::option::Option::None,
                lobby_type: ::std::option::Option::None,
                lobby_flags: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                num_members: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                weight: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Lobby {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyListResponse.Lobby").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Lobby {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Lobby {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.steam_id_member)
    pub steam_id_member: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.metadata)
    pub metadata: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyData {
    fn default() -> &'a CMsgClientMMSSetLobbyData {
        <CMsgClientMMSSetLobbyData as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyData {
    pub fn new() -> CMsgClientMMSSetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_member = 3;

    pub fn steam_id_member(&self) -> u64 {
        self.steam_id_member.unwrap_or(0)
    }

    pub fn clear_steam_id_member(&mut self) {
        self.steam_id_member = ::std::option::Option::None;
    }

    pub fn has_steam_id_member(&self) -> bool {
        self.steam_id_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_member(&mut self, v: u64) {
        self.steam_id_member = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::bytes::Bytes {
        self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyData| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_member",
            |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_member },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_member },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSSetLobbyData| { &m.max_members },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.max_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSSetLobbyData| { &m.lobby_type },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSSetLobbyData| { &m.lobby_flags },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSSetLobbyData| { &m.metadata },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.metadata },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyData>(
            "CMsgClientMMSSetLobbyData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSetLobbyData {
    const NAME: &'static str = "CMsgClientMMSSetLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_member = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.metadata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_member {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max_members {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_member {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyData {
        CMsgClientMMSSetLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_member = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyData {
        static instance: CMsgClientMMSSetLobbyData = CMsgClientMMSSetLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_member: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSetLobbyData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSetLobbyData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyDataResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyDataResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyDataResponse {
        <CMsgClientMMSSetLobbyDataResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyDataResponse {
    pub fn new() -> CMsgClientMMSSetLobbyDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyDataResponse| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyDataResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSSetLobbyDataResponse| { &m.eresult },
            |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyDataResponse>(
            "CMsgClientMMSSetLobbyDataResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSetLobbyDataResponse {
    const NAME: &'static str = "CMsgClientMMSSetLobbyDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyDataResponse {
        CMsgClientMMSSetLobbyDataResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyDataResponse {
        static instance: CMsgClientMMSSetLobbyDataResponse = CMsgClientMMSSetLobbyDataResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSetLobbyDataResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSetLobbyDataResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyData {
    fn default() -> &'a CMsgClientMMSGetLobbyData {
        <CMsgClientMMSGetLobbyData as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyData {
    pub fn new() -> CMsgClientMMSGetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyData| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyData| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSGetLobbyData| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSGetLobbyData| { &mut m.steam_id_lobby },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyData>(
            "CMsgClientMMSGetLobbyData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSGetLobbyData {
    const NAME: &'static str = "CMsgClientMMSGetLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyData {
        CMsgClientMMSGetLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyData {
        static instance: CMsgClientMMSGetLobbyData = CMsgClientMMSGetLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSGetLobbyData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSGetLobbyData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.num_members)
    pub num_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.steam_id_owner)
    pub steam_id_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.metadata)
    pub metadata: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.members)
    pub members: ::std::vec::Vec<cmsg_client_mmslobby_data::Member>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_cellid)
    pub lobby_cellid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.owner_should_accept_changes)
    pub owner_should_accept_changes: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyData {
    fn default() -> &'a CMsgClientMMSLobbyData {
        <CMsgClientMMSLobbyData as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyData {
    pub fn new() -> CMsgClientMMSLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 num_members = 3;

    pub fn num_members(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }

    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::bytes::Bytes {
        self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // repeated .CMsgClientMMSLobbyData.Member members = 9;

    pub fn members(&self) -> &[cmsg_client_mmslobby_data::Member] {
        &self.members
    }

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::std::vec::Vec<cmsg_client_mmslobby_data::Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::std::vec::Vec<cmsg_client_mmslobby_data::Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::std::vec::Vec<cmsg_client_mmslobby_data::Member> {
        ::std::mem::replace(&mut self.members, ::std::vec::Vec::new())
    }

    // optional uint32 lobby_cellid = 10;

    pub fn lobby_cellid(&self) -> u32 {
        self.lobby_cellid.unwrap_or(0)
    }

    pub fn clear_lobby_cellid(&mut self) {
        self.lobby_cellid = ::std::option::Option::None;
    }

    pub fn has_lobby_cellid(&self) -> bool {
        self.lobby_cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_cellid(&mut self, v: u32) {
        self.lobby_cellid = ::std::option::Option::Some(v);
    }

    // optional bool owner_should_accept_changes = 11;

    pub fn owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.unwrap_or(false)
    }

    pub fn clear_owner_should_accept_changes(&mut self) {
        self.owner_should_accept_changes = ::std::option::Option::None;
    }

    pub fn has_owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_should_accept_changes(&mut self, v: bool) {
        self.owner_should_accept_changes = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLobbyData| { &m.app_id },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLobbyData| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_members",
            |m: &CMsgClientMMSLobbyData| { &m.num_members },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.num_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSLobbyData| { &m.max_members },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.max_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSLobbyData| { &m.lobby_type },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSLobbyData| { &m.lobby_flags },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_owner",
            |m: &CMsgClientMMSLobbyData| { &m.steam_id_owner },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSLobbyData| { &m.metadata },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.metadata },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CMsgClientMMSLobbyData| { &m.members },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_cellid",
            |m: &CMsgClientMMSLobbyData| { &m.lobby_cellid },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_cellid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_should_accept_changes",
            |m: &CMsgClientMMSLobbyData| { &m.owner_should_accept_changes },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.owner_should_accept_changes },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLobbyData>(
            "CMsgClientMMSLobbyData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSLobbyData {
    const NAME: &'static str = "CMsgClientMMSLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.num_members = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                57 => {
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                66 => {
                    self.metadata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                74 => {
                    self.members.push(is.read_message()?);
                },
                80 => {
                    self.lobby_cellid = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.owner_should_accept_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.num_members {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.max_members {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lobby_cellid {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.owner_should_accept_changes {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.num_members {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.lobby_cellid {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.owner_should_accept_changes {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyData {
        CMsgClientMMSLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.num_members = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.members.clear();
        self.lobby_cellid = ::std::option::Option::None;
        self.owner_should_accept_changes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyData {
        static instance: CMsgClientMMSLobbyData = CMsgClientMMSLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            num_members: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            steam_id_owner: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            lobby_cellid: ::std::option::Option::None,
            owner_should_accept_changes: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSLobbyData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSLobbyData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSLobbyData`
pub mod cmsg_client_mmslobby_data {
    // @@protoc_insertion_point(message:CMsgClientMMSLobbyData.Member)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.persona_name)
        pub persona_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.metadata)
        pub metadata: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyData.Member.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as crate::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name = ::std::option::Option::None;
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::bytes::Bytes {
            self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Member| { &m.steam_id },
                |m: &mut Member| { &mut m.steam_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona_name",
                |m: &Member| { &m.persona_name },
                |m: &mut Member| { &mut m.persona_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "metadata",
                |m: &Member| { &m.metadata },
                |m: &mut Member| { &mut m.metadata },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Member>(
                "CMsgClientMMSLobbyData.Member",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.persona_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.metadata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += crate::rt::bytes_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                steam_id: ::std::option::Option::None,
                persona_name: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Member {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyData.Member").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Member {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Member {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSSendLobbyChatMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSendLobbyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.steam_id_target)
    pub steam_id_target: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.lobby_message)
    pub lobby_message: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSendLobbyChatMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSendLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSSendLobbyChatMsg {
        <CMsgClientMMSSendLobbyChatMsg as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSendLobbyChatMsg {
    pub fn new() -> CMsgClientMMSSendLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_target = 3;

    pub fn steam_id_target(&self) -> u64 {
        self.steam_id_target.unwrap_or(0)
    }

    pub fn clear_steam_id_target(&mut self) {
        self.steam_id_target = ::std::option::Option::None;
    }

    pub fn has_steam_id_target(&self) -> bool {
        self.steam_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_target(&mut self, v: u64) {
        self.steam_id_target = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message = ::std::option::Option::None;
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::bytes::Bytes) {
        self.lobby_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::bytes::Bytes {
        if self.lobby_message.is_none() {
            self.lobby_message = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::bytes::Bytes {
        self.lobby_message.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.app_id },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_target",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_target },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_target },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_message",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.lobby_message },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.lobby_message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSendLobbyChatMsg>(
            "CMsgClientMMSSendLobbyChatMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSendLobbyChatMsg {
    const NAME: &'static str = "CMsgClientMMSSendLobbyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.lobby_message = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_target {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_target {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSendLobbyChatMsg {
        CMsgClientMMSSendLobbyChatMsg::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_target = ::std::option::Option::None;
        self.lobby_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSendLobbyChatMsg {
        static instance: CMsgClientMMSSendLobbyChatMsg = CMsgClientMMSSendLobbyChatMsg {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_target: ::std::option::Option::None,
            lobby_message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSendLobbyChatMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSendLobbyChatMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSendLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSendLobbyChatMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLobbyChatMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLobbyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.steam_id_sender)
    pub steam_id_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.lobby_message)
    pub lobby_message: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyChatMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSLobbyChatMsg {
        <CMsgClientMMSLobbyChatMsg as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyChatMsg {
    pub fn new() -> CMsgClientMMSLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_sender = 3;

    pub fn steam_id_sender(&self) -> u64 {
        self.steam_id_sender.unwrap_or(0)
    }

    pub fn clear_steam_id_sender(&mut self) {
        self.steam_id_sender = ::std::option::Option::None;
    }

    pub fn has_steam_id_sender(&self) -> bool {
        self.steam_id_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_sender(&mut self, v: u64) {
        self.steam_id_sender = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message = ::std::option::Option::None;
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::bytes::Bytes) {
        self.lobby_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::bytes::Bytes {
        if self.lobby_message.is_none() {
            self.lobby_message = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::bytes::Bytes {
        self.lobby_message.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.app_id },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_sender",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_sender },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_sender },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_message",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.lobby_message },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.lobby_message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLobbyChatMsg>(
            "CMsgClientMMSLobbyChatMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSLobbyChatMsg {
    const NAME: &'static str = "CMsgClientMMSLobbyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.lobby_message = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyChatMsg {
        CMsgClientMMSLobbyChatMsg::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_sender = ::std::option::Option::None;
        self.lobby_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyChatMsg {
        static instance: CMsgClientMMSLobbyChatMsg = CMsgClientMMSLobbyChatMsg {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_sender: ::std::option::Option::None,
            lobby_message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSLobbyChatMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyChatMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSLobbyChatMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyOwner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyOwner {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.steam_id_new_owner)
    pub steam_id_new_owner: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyOwner.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwner {
    fn default() -> &'a CMsgClientMMSSetLobbyOwner {
        <CMsgClientMMSSetLobbyOwner as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwner {
    pub fn new() -> CMsgClientMMSSetLobbyOwner {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_new_owner = 3;

    pub fn steam_id_new_owner(&self) -> u64 {
        self.steam_id_new_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_new_owner(&mut self) {
        self.steam_id_new_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_new_owner(&self) -> bool {
        self.steam_id_new_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_new_owner(&mut self, v: u64) {
        self.steam_id_new_owner = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyOwner| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_new_owner",
            |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_new_owner },
            |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_new_owner },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyOwner>(
            "CMsgClientMMSSetLobbyOwner",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSetLobbyOwner {
    const NAME: &'static str = "CMsgClientMMSSetLobbyOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_new_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_new_owner {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_new_owner {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyOwner {
        CMsgClientMMSSetLobbyOwner::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_new_owner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwner {
        static instance: CMsgClientMMSSetLobbyOwner = CMsgClientMMSSetLobbyOwner {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_new_owner: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSetLobbyOwner {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyOwner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwner {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyOwnerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyOwnerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyOwnerResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwnerResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyOwnerResponse {
        <CMsgClientMMSSetLobbyOwnerResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwnerResponse {
    pub fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.eresult },
            |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyOwnerResponse>(
            "CMsgClientMMSSetLobbyOwnerResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSetLobbyOwnerResponse {
    const NAME: &'static str = "CMsgClientMMSSetLobbyOwnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        CMsgClientMMSSetLobbyOwnerResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwnerResponse {
        static instance: CMsgClientMMSSetLobbyOwnerResponse = CMsgClientMMSSetLobbyOwnerResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSetLobbyOwnerResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyOwnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyOwnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwnerResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyLinked)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyLinked {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.steam_id_lobby2)
    pub steam_id_lobby2: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyLinked.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyLinked {
    fn default() -> &'a CMsgClientMMSSetLobbyLinked {
        <CMsgClientMMSSetLobbyLinked as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyLinked {
    pub fn new() -> CMsgClientMMSSetLobbyLinked {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby2 = 3;

    pub fn steam_id_lobby2(&self) -> u64 {
        self.steam_id_lobby2.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby2(&mut self) {
        self.steam_id_lobby2 = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby2(&self) -> bool {
        self.steam_id_lobby2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby2(&mut self, v: u64) {
        self.steam_id_lobby2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyLinked| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby2",
            |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby2 },
            |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby2 },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyLinked>(
            "CMsgClientMMSSetLobbyLinked",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSetLobbyLinked {
    const NAME: &'static str = "CMsgClientMMSSetLobbyLinked";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_lobby2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_lobby2 {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_lobby2 {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyLinked {
        CMsgClientMMSSetLobbyLinked::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_lobby2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyLinked {
        static instance: CMsgClientMMSSetLobbyLinked = CMsgClientMMSSetLobbyLinked {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_lobby2: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSetLobbyLinked {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyLinked").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyLinked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSetLobbyLinked {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyGameServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyGameServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.deprecated_game_server_ip)
    pub deprecated_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_port)
    pub game_server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_ip)
    pub game_server_ip: crate::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyGameServer.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyGameServer {
    fn default() -> &'a CMsgClientMMSSetLobbyGameServer {
        <CMsgClientMMSSetLobbyGameServer as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyGameServer {
    pub fn new() -> CMsgClientMMSSetLobbyGameServer {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgIPAddress game_server_ip = 6;

    pub fn game_server_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
    }

    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip.clear();
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.game_server_ip = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.mut_or_insert_default()
    }

    // Take field
    pub fn take_game_server_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_game_server_ip",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.deprecated_game_server_ip },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.deprecated_game_server_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_port",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_port },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_steam_id",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_steam_id },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_steam_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "game_server_ip",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_ip },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyGameServer>(
            "CMsgClientMMSSetLobbyGameServer",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSSetLobbyGameServer {
    const NAME: &'static str = "CMsgClientMMSSetLobbyGameServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.game_server_ip)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_port {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyGameServer {
        CMsgClientMMSSetLobbyGameServer::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyGameServer {
        static instance: CMsgClientMMSSetLobbyGameServer = CMsgClientMMSSetLobbyGameServer {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            deprecated_game_server_ip: ::std::option::Option::None,
            game_server_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            game_server_ip: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSSetLobbyGameServer {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyGameServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyGameServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSSetLobbyGameServer {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLobbyGameServerSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLobbyGameServerSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.deprecated_game_server_ip)
    pub deprecated_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_port)
    pub game_server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_ip)
    pub game_server_ip: crate::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyGameServerSet.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyGameServerSet {
    fn default() -> &'a CMsgClientMMSLobbyGameServerSet {
        <CMsgClientMMSLobbyGameServerSet as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyGameServerSet {
    pub fn new() -> CMsgClientMMSLobbyGameServerSet {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgIPAddress game_server_ip = 6;

    pub fn game_server_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
    }

    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip.clear();
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.game_server_ip = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.mut_or_insert_default()
    }

    // Take field
    pub fn take_game_server_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.app_id },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_game_server_ip",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.deprecated_game_server_ip },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.deprecated_game_server_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_port",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_port },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_steam_id",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_steam_id },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_steam_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "game_server_ip",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_ip },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLobbyGameServerSet>(
            "CMsgClientMMSLobbyGameServerSet",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSLobbyGameServerSet {
    const NAME: &'static str = "CMsgClientMMSLobbyGameServerSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.game_server_ip)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_port {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyGameServerSet {
        CMsgClientMMSLobbyGameServerSet::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyGameServerSet {
        static instance: CMsgClientMMSLobbyGameServerSet = CMsgClientMMSLobbyGameServerSet {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            deprecated_game_server_ip: ::std::option::Option::None,
            game_server_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            game_server_ip: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSLobbyGameServerSet {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyGameServerSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLobbyGameServerSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSLobbyGameServerSet {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSUserJoinedLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSUserJoinedLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.steam_id_user)
    pub steam_id_user: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSUserJoinedLobby.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserJoinedLobby {
    fn default() -> &'a CMsgClientMMSUserJoinedLobby {
        <CMsgClientMMSUserJoinedLobby as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSUserJoinedLobby {
    pub fn new() -> CMsgClientMMSUserJoinedLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.app_id },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_user",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_user },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_user },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.persona_name },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.persona_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSUserJoinedLobby>(
            "CMsgClientMMSUserJoinedLobby",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSUserJoinedLobby {
    const NAME: &'static str = "CMsgClientMMSUserJoinedLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSUserJoinedLobby {
        CMsgClientMMSUserJoinedLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSUserJoinedLobby {
        static instance: CMsgClientMMSUserJoinedLobby = CMsgClientMMSUserJoinedLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSUserJoinedLobby {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSUserJoinedLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSUserJoinedLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSUserJoinedLobby {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSUserLeftLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSUserLeftLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.steam_id_user)
    pub steam_id_user: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSUserLeftLobby.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserLeftLobby {
    fn default() -> &'a CMsgClientMMSUserLeftLobby {
        <CMsgClientMMSUserLeftLobby as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSUserLeftLobby {
    pub fn new() -> CMsgClientMMSUserLeftLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSUserLeftLobby| { &m.app_id },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_user",
            |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_user },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_user },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name",
            |m: &CMsgClientMMSUserLeftLobby| { &m.persona_name },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.persona_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSUserLeftLobby>(
            "CMsgClientMMSUserLeftLobby",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSUserLeftLobby {
    const NAME: &'static str = "CMsgClientMMSUserLeftLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSUserLeftLobby {
        CMsgClientMMSUserLeftLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSUserLeftLobby {
        static instance: CMsgClientMMSUserLeftLobby = CMsgClientMMSUserLeftLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSUserLeftLobby {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSUserLeftLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSUserLeftLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSUserLeftLobby {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSInviteToLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSInviteToLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.steam_id_user_invited)
    pub steam_id_user_invited: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSInviteToLobby.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSInviteToLobby {
    fn default() -> &'a CMsgClientMMSInviteToLobby {
        <CMsgClientMMSInviteToLobby as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSInviteToLobby {
    pub fn new() -> CMsgClientMMSInviteToLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user_invited = 3;

    pub fn steam_id_user_invited(&self) -> u64 {
        self.steam_id_user_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_user_invited(&mut self) {
        self.steam_id_user_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_user_invited(&self) -> bool {
        self.steam_id_user_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user_invited(&mut self, v: u64) {
        self.steam_id_user_invited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSInviteToLobby| { &m.app_id },
            |m: &mut CMsgClientMMSInviteToLobby| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_user_invited",
            |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_user_invited },
            |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_user_invited },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSInviteToLobby>(
            "CMsgClientMMSInviteToLobby",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSInviteToLobby {
    const NAME: &'static str = "CMsgClientMMSInviteToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user_invited {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user_invited {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSInviteToLobby {
        CMsgClientMMSInviteToLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user_invited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSInviteToLobby {
        static instance: CMsgClientMMSInviteToLobby = CMsgClientMMSInviteToLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user_invited: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSInviteToLobby {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSInviteToLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSInviteToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSInviteToLobby {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.claim_membership)
    pub claim_membership: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.claim_ownership)
    pub claim_ownership: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyStatus.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatus {
    fn default() -> &'a CMsgClientMMSGetLobbyStatus {
        <CMsgClientMMSGetLobbyStatus as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatus {
    pub fn new() -> CMsgClientMMSGetLobbyStatus {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional bool claim_membership = 3;

    pub fn claim_membership(&self) -> bool {
        self.claim_membership.unwrap_or(false)
    }

    pub fn clear_claim_membership(&mut self) {
        self.claim_membership = ::std::option::Option::None;
    }

    pub fn has_claim_membership(&self) -> bool {
        self.claim_membership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_membership(&mut self, v: bool) {
        self.claim_membership = ::std::option::Option::Some(v);
    }

    // optional bool claim_ownership = 4;

    pub fn claim_ownership(&self) -> bool {
        self.claim_ownership.unwrap_or(false)
    }

    pub fn clear_claim_ownership(&mut self) {
        self.claim_ownership = ::std::option::Option::None;
    }

    pub fn has_claim_ownership(&self) -> bool {
        self.claim_ownership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_ownership(&mut self, v: bool) {
        self.claim_ownership = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "claim_membership",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_membership },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_membership },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "claim_ownership",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_ownership },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_ownership },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyStatus>(
            "CMsgClientMMSGetLobbyStatus",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSGetLobbyStatus {
    const NAME: &'static str = "CMsgClientMMSGetLobbyStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.claim_membership = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.claim_ownership = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.claim_membership {
            my_size += 1 + 1;
        }
        if let Some(v) = self.claim_ownership {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.claim_membership {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.claim_ownership {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyStatus {
        CMsgClientMMSGetLobbyStatus::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.claim_membership = ::std::option::Option::None;
        self.claim_ownership = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatus {
        static instance: CMsgClientMMSGetLobbyStatus = CMsgClientMMSGetLobbyStatus {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            claim_membership: ::std::option::Option::None,
            claim_ownership: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSGetLobbyStatus {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatus {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.lobby_status)
    pub lobby_status: ::std::option::Option<crate::EnumOrUnknown<EMMSLobbyStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyStatusResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatusResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyStatusResponse {
        <CMsgClientMMSGetLobbyStatusResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatusResponse {
    pub fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional .EMMSLobbyStatus lobby_status = 3;

    pub fn lobby_status(&self) -> EMMSLobbyStatus {
        match self.lobby_status {
            Some(e) => e.enum_value_or(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            None => EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
        }
    }

    pub fn clear_lobby_status(&mut self) {
        self.lobby_status = ::std::option::Option::None;
    }

    pub fn has_lobby_status(&self) -> bool {
        self.lobby_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_status(&mut self, v: EMMSLobbyStatus) {
        self.lobby_status = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_status",
            |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.lobby_status },
            |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.lobby_status },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyStatusResponse>(
            "CMsgClientMMSGetLobbyStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientMMSGetLobbyStatusResponse {
    const NAME: &'static str = "CMsgClientMMSGetLobbyStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.lobby_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_status {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.lobby_status {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        CMsgClientMMSGetLobbyStatusResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.lobby_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatusResponse {
        static instance: CMsgClientMMSGetLobbyStatusResponse = CMsgClientMMSGetLobbyStatusResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            lobby_status: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientMMSGetLobbyStatusResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatusResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMMSLobbyStatus)
pub enum EMMSLobbyStatus {
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusInvalid)
    k_EMMSLobbyStatusInvalid = 0,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusExists)
    k_EMMSLobbyStatusExists = 1,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusDoesNotExist)
    k_EMMSLobbyStatusDoesNotExist = 2,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusNotAMember)
    k_EMMSLobbyStatusNotAMember = 3,
}

impl crate::Enum for EMMSLobbyStatus {
    const NAME: &'static str = "EMMSLobbyStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMMSLobbyStatus> {
        match value {
            0 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            1 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusExists),
            2 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist),
            3 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMMSLobbyStatus> {
        match str {
            "k_EMMSLobbyStatusInvalid" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            "k_EMMSLobbyStatusExists" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusExists),
            "k_EMMSLobbyStatusDoesNotExist" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist),
            "k_EMMSLobbyStatusNotAMember" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMMSLobbyStatus] = &[
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
        EMMSLobbyStatus::k_EMMSLobbyStatusExists,
        EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist,
        EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember,
    ];
}

impl crate::EnumFull for EMMSLobbyStatus {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMMSLobbyStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMMSLobbyStatus {
    fn default() -> Self {
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid
    }
}

impl EMMSLobbyStatus {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EMMSLobbyStatus>("EMMSLobbyStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_clientserver_mms.proto\x1a\x18steammessages_base.proto\
    \"\xdf\x01\n'CMsgClientMMSSetRatelimitPolicyOnClient\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12,\n\x12enable_rate_limits\x18\x02\x20\
    \x01(\x08R\x10enableRateLimits\x12.\n\x13seconds_per_message\x18\x03\x20\
    \x01(\x05R\x11secondsPerMessage\x12?\n\x1cmilliseconds_per_data_update\
    \x18\x04\x20\x01(\x05R\x19millisecondsPerDataUpdate\"\xd4\x02\n\x18CMsgC\
    lientMMSCreateLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\
    \x1f\n\x0bmax_members\x18\x02\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby\
    _type\x18\x03\x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x04\
    \x20\x01(\x05R\nlobbyFlags\x12\x17\n\x07cell_id\x18\x05\x20\x01(\rR\x06c\
    ellId\x120\n\x14deprecated_public_ip\x18\x06\x20\x01(\rR\x12deprecatedPu\
    blicIp\x12\x1a\n\x08metadata\x18\x07\x20\x01(\x0cR\x08metadata\x12,\n\
    \x12persona_name_owner\x18\x08\x20\x01(\tR\x10personaNameOwner\x12+\n\tp\
    ublic_ip\x18\t\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\"|\n\x20CMsg\
    ClientMMSCreateLobbyResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05\
    appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\
    \x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\x07eresult\"x\n\x16CMsgCli\
    entMMSJoinLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\
    \x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12!\n\x0cperso\
    na_name\x18\x03\x20\x01(\tR\x0bpersonaName\"\xdf\x03\n\x1eCMsgClientMMSJ\
    oinLobbyResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\
    \x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x127\n\x18chat_\
    room_enter_response\x18\x03\x20\x01(\x05R\x15chatRoomEnterResponse\x12\
    \x1f\n\x0bmax_members\x18\x04\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby\
    _type\x18\x05\x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x06\
    \x20\x01(\x05R\nlobbyFlags\x12$\n\x0esteam_id_owner\x18\x07\x20\x01(\x06\
    R\x0csteamIdOwner\x12\x1a\n\x08metadata\x18\x08\x20\x01(\x0cR\x08metadat\
    a\x12@\n\x07members\x18\t\x20\x03(\x0b2&.CMsgClientMMSJoinLobbyResponse.\
    MemberR\x07members\x1ab\n\x06Member\x12\x19\n\x08steam_id\x18\x01\x20\
    \x01(\x06R\x07steamId\x12!\n\x0cpersona_name\x18\x02\x20\x01(\tR\x0bpers\
    onaName\x12\x1a\n\x08metadata\x18\x03\x20\x01(\x0cR\x08metadata\"V\n\x17\
    CMsgClientMMSLeaveLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\"{\n\x1f\
    CMsgClientMMSLeaveLobbyResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\
    \x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\x07eresult\"\x90\x03\n\
    \x19CMsgClientMMSGetLobbyList\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x122\n\x15num_lobbies_requested\x18\x03\x20\x01(\x05R\x13numLo\
    bbiesRequested\x12\x17\n\x07cell_id\x18\x04\x20\x01(\rR\x06cellId\x120\n\
    \x14deprecated_public_ip\x18\x05\x20\x01(\rR\x12deprecatedPublicIp\x12;\
    \n\x07filters\x18\x06\x20\x03(\x0b2!.CMsgClientMMSGetLobbyList.FilterR\
    \x07filters\x12+\n\tpublic_ip\x18\x07\x20\x01(\x0b2\x0e.CMsgIPAddressR\
    \x08publicIp\x1as\n\x06Filter\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12\x20\n\x0bcomparisi\
    on\x18\x03\x20\x01(\x05R\x0bcomparision\x12\x1f\n\x0bfilter_type\x18\x04\
    \x20\x01(\x05R\nfilterType\"\x92\x03\n!CMsgClientMMSGetLobbyListResponse\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\x07eresult\
    \x18\x03\x20\x01(\x05:\x012R\x07eresult\x12B\n\x07lobbies\x18\x04\x20\
    \x03(\x0b2(.CMsgClientMMSGetLobbyListResponse.LobbyR\x07lobbies\x1a\xf4\
    \x01\n\x05Lobby\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\
    \x12\x1f\n\x0bmax_members\x18\x02\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nl\
    obby_type\x18\x03\x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\
    \x04\x20\x01(\x05R\nlobbyFlags\x12\x1a\n\x08metadata\x18\x05\x20\x01(\
    \x0cR\x08metadata\x12\x1f\n\x0bnum_members\x18\x06\x20\x01(\x05R\nnumMem\
    bers\x12\x1a\n\x08distance\x18\x07\x20\x01(\x02R\x08distance\x12\x16\n\
    \x06weight\x18\x08\x20\x01(\x03R\x06weight\"\xfd\x01\n\x19CMsgClientMMSS\
    etLobbyData\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0es\
    team_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_m\
    ember\x18\x03\x20\x01(\x06R\rsteamIdMember\x12\x1f\n\x0bmax_members\x18\
    \x04\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\
    \x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x06\x20\x01(\x05R\nlobbyFl\
    ags\x12\x1a\n\x08metadata\x18\x07\x20\x01(\x0cR\x08metadata\"}\n!CMsgCli\
    entMMSSetLobbyDataResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05ap\
    pId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\
    \x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\x07eresult\"X\n\x19CMsgCli\
    entMMSGetLobbyData\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\
    \n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\"\x99\x04\n\
    \x16CMsgClientMMSLobbyData\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05ap\
    pId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\
    \x1f\n\x0bnum_members\x18\x03\x20\x01(\x05R\nnumMembers\x12\x1f\n\x0bmax\
    _members\x18\x04\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x05\
    \x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x06\x20\x01(\x05R\
    \nlobbyFlags\x12$\n\x0esteam_id_owner\x18\x07\x20\x01(\x06R\x0csteamIdOw\
    ner\x12\x1a\n\x08metadata\x18\x08\x20\x01(\x0cR\x08metadata\x128\n\x07me\
    mbers\x18\t\x20\x03(\x0b2\x1e.CMsgClientMMSLobbyData.MemberR\x07members\
    \x12!\n\x0clobby_cellid\x18\n\x20\x01(\rR\x0blobbyCellid\x12=\n\x1bowner\
    _should_accept_changes\x18\x0b\x20\x01(\x08R\x18ownerShouldAcceptChanges\
    \x1ab\n\x06Member\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\
    \x12!\n\x0cpersona_name\x18\x02\x20\x01(\tR\x0bpersonaName\x12\x1a\n\x08\
    metadata\x18\x03\x20\x01(\x0cR\x08metadata\"\xa9\x01\n\x1dCMsgClientMMSS\
    endLobbyChatMsg\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\
    \x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam\
    _id_target\x18\x03\x20\x01(\x06R\rsteamIdTarget\x12#\n\rlobby_message\
    \x18\x04\x20\x01(\x0cR\x0clobbyMessage\"\xa5\x01\n\x19CMsgClientMMSLobby\
    ChatMsg\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam\
    _id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_sende\
    r\x18\x03\x20\x01(\x06R\rsteamIdSender\x12#\n\rlobby_message\x18\x04\x20\
    \x01(\x0cR\x0clobbyMessage\"\x86\x01\n\x1aCMsgClientMMSSetLobbyOwner\x12\
    \x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\
    \x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12+\n\x12steam_id_new_owner\x18\
    \x03\x20\x01(\x06R\x0fsteamIdNewOwner\"~\n\"CMsgClientMMSSetLobbyOwnerRe\
    sponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_\
    id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\
    \x03\x20\x01(\x05:\x012R\x07eresult\"\x82\x01\n\x1bCMsgClientMMSSetLobby\
    Linked\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_\
    id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_lobby2\
    \x18\x03\x20\x01(\x06R\rsteamIdLobby2\"\xaa\x02\n\x1fCMsgClientMMSSetLob\
    byGameServer\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0e\
    steam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x129\n\x19deprecate\
    d_game_server_ip\x18\x03\x20\x01(\rR\x16deprecatedGameServerIp\x12(\n\
    \x10game_server_port\x18\x04\x20\x01(\rR\x0egameServerPort\x12/\n\x14gam\
    e_server_steam_id\x18\x05\x20\x01(\x06R\x11gameServerSteamId\x124\n\x0eg\
    ame_server_ip\x18\x06\x20\x01(\x0b2\x0e.CMsgIPAddressR\x0cgameServerIp\"\
    \xaa\x02\n\x1fCMsgClientMMSLobbyGameServerSet\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\
    \x0csteamIdLobby\x129\n\x19deprecated_game_server_ip\x18\x03\x20\x01(\rR\
    \x16deprecatedGameServerIp\x12(\n\x10game_server_port\x18\x04\x20\x01(\r\
    R\x0egameServerPort\x12/\n\x14game_server_steam_id\x18\x05\x20\x01(\x06R\
    \x11gameServerSteamId\x124\n\x0egame_server_ip\x18\x06\x20\x01(\x0b2\x0e\
    .CMsgIPAddressR\x0cgameServerIp\"\xa2\x01\n\x1cCMsgClientMMSUserJoinedLo\
    bby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_\
    lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\"\n\rsteam_id_user\x18\
    \x03\x20\x01(\x06R\x0bsteamIdUser\x12!\n\x0cpersona_name\x18\x04\x20\x01\
    (\tR\x0bpersonaName\"\xa0\x01\n\x1aCMsgClientMMSUserLeftLobby\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12\"\n\rsteam_id_user\x18\x03\x20\x01(\
    \x06R\x0bsteamIdUser\x12!\n\x0cpersona_name\x18\x04\x20\x01(\tR\x0bperso\
    naName\"\x8c\x01\n\x1aCMsgClientMMSInviteToLobby\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\
    \x0csteamIdLobby\x121\n\x15steam_id_user_invited\x18\x03\x20\x01(\x06R\
    \x12steamIdUserInvited\"\xae\x01\n\x1bCMsgClientMMSGetLobbyStatus\x12\
    \x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\
    \x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12)\n\x10claim_membership\x18\
    \x03\x20\x01(\x08R\x0fclaimMembership\x12'\n\x0fclaim_ownership\x18\x04\
    \x20\x01(\x08R\x0eclaimOwnership\"\xb1\x01\n#CMsgClientMMSGetLobbyStatus\
    Response\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0estea\
    m_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12M\n\x0clobby_status\
    \x18\x03\x20\x01(\x0e2\x10.EMMSLobbyStatus:\x18k_EMMSLobbyStatusInvalidR\
    \x0blobbyStatus*\x90\x01\n\x0fEMMSLobbyStatus\x12\x1c\n\x18k_EMMSLobbySt\
    atusInvalid\x10\0\x12\x1b\n\x17k_EMMSLobbyStatusExists\x10\x01\x12!\n\
    \x1dk_EMMSLobbyStatusDoesNotExist\x10\x02\x12\x1f\n\x1bk_EMMSLobbyStatus\
    NotAMember\x10\x03B\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(29);
            messages.push(CMsgClientMMSSetRatelimitPolicyOnClient::generated_message_descriptor_data());
            messages.push(CMsgClientMMSCreateLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSCreateLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSJoinLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSJoinLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLeaveLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLeaveLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyList::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyListResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyData::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyDataResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyData::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLobbyData::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSendLobbyChatMsg::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLobbyChatMsg::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyOwner::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyOwnerResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyLinked::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyGameServer::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLobbyGameServerSet::generated_message_descriptor_data());
            messages.push(CMsgClientMMSUserJoinedLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSUserLeftLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSInviteToLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyStatus::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyStatusResponse::generated_message_descriptor_data());
            messages.push(cmsg_client_mmsjoin_lobby_response::Member::generated_message_descriptor_data());
            messages.push(cmsg_client_mmsget_lobby_list::Filter::generated_message_descriptor_data());
            messages.push(cmsg_client_mmsget_lobby_list_response::Lobby::generated_message_descriptor_data());
            messages.push(cmsg_client_mmslobby_data::Member::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(EMMSLobbyStatus::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
