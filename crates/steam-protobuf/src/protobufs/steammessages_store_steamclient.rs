// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_store.steamclient.proto`

// @@protoc_insertion_point(message:CStore_RegisterCDKey_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_RegisterCDKey_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Request.activation_code)
    pub activation_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Request.purchase_platform)
    pub purchase_platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Request.is_request_from_client)
    pub is_request_from_client: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_RegisterCDKey_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_RegisterCDKey_Request {
    fn default() -> &'a CStore_RegisterCDKey_Request {
        <CStore_RegisterCDKey_Request as crate::Message>::default_instance()
    }
}

impl CStore_RegisterCDKey_Request {
    pub fn new() -> CStore_RegisterCDKey_Request {
        ::std::default::Default::default()
    }

    // optional string activation_code = 1;

    pub fn activation_code(&self) -> &str {
        match self.activation_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_activation_code(&mut self) {
        self.activation_code = ::std::option::Option::None;
    }

    pub fn has_activation_code(&self) -> bool {
        self.activation_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activation_code(&mut self, v: ::std::string::String) {
        self.activation_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activation_code(&mut self) -> &mut ::std::string::String {
        if self.activation_code.is_none() {
            self.activation_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.activation_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_activation_code(&mut self) -> ::std::string::String {
        self.activation_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 purchase_platform = 2;

    pub fn purchase_platform(&self) -> i32 {
        self.purchase_platform.unwrap_or(0)
    }

    pub fn clear_purchase_platform(&mut self) {
        self.purchase_platform = ::std::option::Option::None;
    }

    pub fn has_purchase_platform(&self) -> bool {
        self.purchase_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_platform(&mut self, v: i32) {
        self.purchase_platform = ::std::option::Option::Some(v);
    }

    // optional bool is_request_from_client = 3;

    pub fn is_request_from_client(&self) -> bool {
        self.is_request_from_client.unwrap_or(false)
    }

    pub fn clear_is_request_from_client(&mut self) {
        self.is_request_from_client = ::std::option::Option::None;
    }

    pub fn has_is_request_from_client(&self) -> bool {
        self.is_request_from_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_request_from_client(&mut self, v: bool) {
        self.is_request_from_client = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "activation_code",
            |m: &CStore_RegisterCDKey_Request| { &m.activation_code },
            |m: &mut CStore_RegisterCDKey_Request| { &mut m.activation_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_platform",
            |m: &CStore_RegisterCDKey_Request| { &m.purchase_platform },
            |m: &mut CStore_RegisterCDKey_Request| { &mut m.purchase_platform },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_request_from_client",
            |m: &CStore_RegisterCDKey_Request| { &m.is_request_from_client },
            |m: &mut CStore_RegisterCDKey_Request| { &mut m.is_request_from_client },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_RegisterCDKey_Request>(
            "CStore_RegisterCDKey_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_RegisterCDKey_Request {
    const NAME: &'static str = "CStore_RegisterCDKey_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.activation_code = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.purchase_platform = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_request_from_client = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.activation_code.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.purchase_platform {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_request_from_client {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.activation_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.purchase_platform {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_request_from_client {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_RegisterCDKey_Request {
        CStore_RegisterCDKey_Request::new()
    }

    fn clear(&mut self) {
        self.activation_code = ::std::option::Option::None;
        self.purchase_platform = ::std::option::Option::None;
        self.is_request_from_client = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_RegisterCDKey_Request {
        static instance: CStore_RegisterCDKey_Request = CStore_RegisterCDKey_Request {
            activation_code: ::std::option::Option::None,
            purchase_platform: ::std::option::Option::None,
            is_request_from_client: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_RegisterCDKey_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_RegisterCDKey_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_RegisterCDKey_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_RegisterCDKey_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_PurchaseReceiptInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_PurchaseReceiptInfo {
    // message fields
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.transactionid)
    pub transactionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.purchase_status)
    pub purchase_status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.result_detail)
    pub result_detail: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.transaction_time)
    pub transaction_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.payment_method)
    pub payment_method: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.base_price)
    pub base_price: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.total_discount)
    pub total_discount: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.tax)
    pub tax: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.shipping)
    pub shipping: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.currency_code)
    pub currency_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_headline)
    pub error_headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_string)
    pub error_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_link_text)
    pub error_link_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_link_url)
    pub error_link_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_appid)
    pub error_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.line_items)
    pub line_items: ::std::vec::Vec<cstore_purchase_receipt_info::LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_PurchaseReceiptInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_PurchaseReceiptInfo {
    fn default() -> &'a CStore_PurchaseReceiptInfo {
        <CStore_PurchaseReceiptInfo as crate::Message>::default_instance()
    }
}

impl CStore_PurchaseReceiptInfo {
    pub fn new() -> CStore_PurchaseReceiptInfo {
        ::std::default::Default::default()
    }

    // optional uint64 transactionid = 1;

    pub fn transactionid(&self) -> u64 {
        self.transactionid.unwrap_or(0)
    }

    pub fn clear_transactionid(&mut self) {
        self.transactionid = ::std::option::Option::None;
    }

    pub fn has_transactionid(&self) -> bool {
        self.transactionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transactionid(&mut self, v: u64) {
        self.transactionid = ::std::option::Option::Some(v);
    }

    // optional uint32 packageid = 2;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_status = 3;

    pub fn purchase_status(&self) -> u32 {
        self.purchase_status.unwrap_or(0)
    }

    pub fn clear_purchase_status(&mut self) {
        self.purchase_status = ::std::option::Option::None;
    }

    pub fn has_purchase_status(&self) -> bool {
        self.purchase_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_status(&mut self, v: u32) {
        self.purchase_status = ::std::option::Option::Some(v);
    }

    // optional uint32 result_detail = 4;

    pub fn result_detail(&self) -> u32 {
        self.result_detail.unwrap_or(0)
    }

    pub fn clear_result_detail(&mut self) {
        self.result_detail = ::std::option::Option::None;
    }

    pub fn has_result_detail(&self) -> bool {
        self.result_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_detail(&mut self, v: u32) {
        self.result_detail = ::std::option::Option::Some(v);
    }

    // optional uint32 transaction_time = 5;

    pub fn transaction_time(&self) -> u32 {
        self.transaction_time.unwrap_or(0)
    }

    pub fn clear_transaction_time(&mut self) {
        self.transaction_time = ::std::option::Option::None;
    }

    pub fn has_transaction_time(&self) -> bool {
        self.transaction_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_time(&mut self, v: u32) {
        self.transaction_time = ::std::option::Option::Some(v);
    }

    // optional uint32 payment_method = 6;

    pub fn payment_method(&self) -> u32 {
        self.payment_method.unwrap_or(0)
    }

    pub fn clear_payment_method(&mut self) {
        self.payment_method = ::std::option::Option::None;
    }

    pub fn has_payment_method(&self) -> bool {
        self.payment_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_method(&mut self, v: u32) {
        self.payment_method = ::std::option::Option::Some(v);
    }

    // optional uint64 base_price = 7;

    pub fn base_price(&self) -> u64 {
        self.base_price.unwrap_or(0)
    }

    pub fn clear_base_price(&mut self) {
        self.base_price = ::std::option::Option::None;
    }

    pub fn has_base_price(&self) -> bool {
        self.base_price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_price(&mut self, v: u64) {
        self.base_price = ::std::option::Option::Some(v);
    }

    // optional uint64 total_discount = 8;

    pub fn total_discount(&self) -> u64 {
        self.total_discount.unwrap_or(0)
    }

    pub fn clear_total_discount(&mut self) {
        self.total_discount = ::std::option::Option::None;
    }

    pub fn has_total_discount(&self) -> bool {
        self.total_discount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_discount(&mut self, v: u64) {
        self.total_discount = ::std::option::Option::Some(v);
    }

    // optional uint64 tax = 9;

    pub fn tax(&self) -> u64 {
        self.tax.unwrap_or(0)
    }

    pub fn clear_tax(&mut self) {
        self.tax = ::std::option::Option::None;
    }

    pub fn has_tax(&self) -> bool {
        self.tax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tax(&mut self, v: u64) {
        self.tax = ::std::option::Option::Some(v);
    }

    // optional uint64 shipping = 10;

    pub fn shipping(&self) -> u64 {
        self.shipping.unwrap_or(0)
    }

    pub fn clear_shipping(&mut self) {
        self.shipping = ::std::option::Option::None;
    }

    pub fn has_shipping(&self) -> bool {
        self.shipping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shipping(&mut self, v: u64) {
        self.shipping = ::std::option::Option::Some(v);
    }

    // optional uint32 currency_code = 11;

    pub fn currency_code(&self) -> u32 {
        self.currency_code.unwrap_or(0)
    }

    pub fn clear_currency_code(&mut self) {
        self.currency_code = ::std::option::Option::None;
    }

    pub fn has_currency_code(&self) -> bool {
        self.currency_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency_code(&mut self, v: u32) {
        self.currency_code = ::std::option::Option::Some(v);
    }

    // optional string country_code = 12;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_headline = 13;

    pub fn error_headline(&self) -> &str {
        match self.error_headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_headline(&mut self) {
        self.error_headline = ::std::option::Option::None;
    }

    pub fn has_error_headline(&self) -> bool {
        self.error_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_headline(&mut self, v: ::std::string::String) {
        self.error_headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_headline(&mut self) -> &mut ::std::string::String {
        if self.error_headline.is_none() {
            self.error_headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_headline(&mut self) -> ::std::string::String {
        self.error_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_string = 14;

    pub fn error_string(&self) -> &str {
        match self.error_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_string(&mut self) {
        self.error_string = ::std::option::Option::None;
    }

    pub fn has_error_string(&self) -> bool {
        self.error_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_string(&mut self, v: ::std::string::String) {
        self.error_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_string(&mut self) -> &mut ::std::string::String {
        if self.error_string.is_none() {
            self.error_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_string(&mut self) -> ::std::string::String {
        self.error_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_link_text = 15;

    pub fn error_link_text(&self) -> &str {
        match self.error_link_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_link_text(&mut self) {
        self.error_link_text = ::std::option::Option::None;
    }

    pub fn has_error_link_text(&self) -> bool {
        self.error_link_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_link_text(&mut self, v: ::std::string::String) {
        self.error_link_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_link_text(&mut self) -> &mut ::std::string::String {
        if self.error_link_text.is_none() {
            self.error_link_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_link_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_link_text(&mut self) -> ::std::string::String {
        self.error_link_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_link_url = 16;

    pub fn error_link_url(&self) -> &str {
        match self.error_link_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_link_url(&mut self) {
        self.error_link_url = ::std::option::Option::None;
    }

    pub fn has_error_link_url(&self) -> bool {
        self.error_link_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_link_url(&mut self, v: ::std::string::String) {
        self.error_link_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_link_url(&mut self) -> &mut ::std::string::String {
        if self.error_link_url.is_none() {
            self.error_link_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_link_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_link_url(&mut self) -> ::std::string::String {
        self.error_link_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 error_appid = 17;

    pub fn error_appid(&self) -> u32 {
        self.error_appid.unwrap_or(0)
    }

    pub fn clear_error_appid(&mut self) {
        self.error_appid = ::std::option::Option::None;
    }

    pub fn has_error_appid(&self) -> bool {
        self.error_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_appid(&mut self, v: u32) {
        self.error_appid = ::std::option::Option::Some(v);
    }

    // repeated .CStore_PurchaseReceiptInfo.LineItem line_items = 18;

    pub fn line_items(&self) -> &[cstore_purchase_receipt_info::LineItem] {
        &self.line_items
    }

    pub fn clear_line_items(&mut self) {
        self.line_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_line_items(&mut self, v: ::std::vec::Vec<cstore_purchase_receipt_info::LineItem>) {
        self.line_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_line_items(&mut self) -> &mut ::std::vec::Vec<cstore_purchase_receipt_info::LineItem> {
        &mut self.line_items
    }

    // Take field
    pub fn take_line_items(&mut self) -> ::std::vec::Vec<cstore_purchase_receipt_info::LineItem> {
        ::std::mem::replace(&mut self.line_items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "transactionid",
            |m: &CStore_PurchaseReceiptInfo| { &m.transactionid },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.transactionid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packageid",
            |m: &CStore_PurchaseReceiptInfo| { &m.packageid },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.packageid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_status",
            |m: &CStore_PurchaseReceiptInfo| { &m.purchase_status },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.purchase_status },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result_detail",
            |m: &CStore_PurchaseReceiptInfo| { &m.result_detail },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.result_detail },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "transaction_time",
            |m: &CStore_PurchaseReceiptInfo| { &m.transaction_time },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.transaction_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "payment_method",
            |m: &CStore_PurchaseReceiptInfo| { &m.payment_method },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.payment_method },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_price",
            |m: &CStore_PurchaseReceiptInfo| { &m.base_price },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.base_price },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_discount",
            |m: &CStore_PurchaseReceiptInfo| { &m.total_discount },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.total_discount },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tax",
            |m: &CStore_PurchaseReceiptInfo| { &m.tax },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.tax },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shipping",
            |m: &CStore_PurchaseReceiptInfo| { &m.shipping },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.shipping },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency_code",
            |m: &CStore_PurchaseReceiptInfo| { &m.currency_code },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.currency_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CStore_PurchaseReceiptInfo| { &m.country_code },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_headline",
            |m: &CStore_PurchaseReceiptInfo| { &m.error_headline },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.error_headline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_string",
            |m: &CStore_PurchaseReceiptInfo| { &m.error_string },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.error_string },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_link_text",
            |m: &CStore_PurchaseReceiptInfo| { &m.error_link_text },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.error_link_text },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_link_url",
            |m: &CStore_PurchaseReceiptInfo| { &m.error_link_url },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.error_link_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_appid",
            |m: &CStore_PurchaseReceiptInfo| { &m.error_appid },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.error_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &CStore_PurchaseReceiptInfo| { &m.line_items },
            |m: &mut CStore_PurchaseReceiptInfo| { &mut m.line_items },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_PurchaseReceiptInfo>(
            "CStore_PurchaseReceiptInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_PurchaseReceiptInfo {
    const NAME: &'static str = "CStore_PurchaseReceiptInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.transactionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.purchase_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.result_detail = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.transaction_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.payment_method = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.base_price = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.total_discount = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.tax = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.shipping = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.currency_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.error_headline = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.error_string = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.error_link_text = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.error_link_url = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.error_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transactionid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.packageid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.purchase_status {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.result_detail {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.transaction_time {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.payment_method {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.base_price {
            my_size += crate::rt::uint64_size(7, v);
        }
        if let Some(v) = self.total_discount {
            my_size += crate::rt::uint64_size(8, v);
        }
        if let Some(v) = self.tax {
            my_size += crate::rt::uint64_size(9, v);
        }
        if let Some(v) = self.shipping {
            my_size += crate::rt::uint64_size(10, v);
        }
        if let Some(v) = self.currency_code {
            my_size += crate::rt::uint32_size(11, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        if let Some(v) = self.error_headline.as_ref() {
            my_size += crate::rt::string_size(13, &v);
        }
        if let Some(v) = self.error_string.as_ref() {
            my_size += crate::rt::string_size(14, &v);
        }
        if let Some(v) = self.error_link_text.as_ref() {
            my_size += crate::rt::string_size(15, &v);
        }
        if let Some(v) = self.error_link_url.as_ref() {
            my_size += crate::rt::string_size(16, &v);
        }
        if let Some(v) = self.error_appid {
            my_size += crate::rt::uint32_size(17, v);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.transactionid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.packageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.purchase_status {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.result_detail {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.transaction_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.payment_method {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.base_price {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.total_discount {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.tax {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.shipping {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.currency_code {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.error_headline.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.error_string.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.error_link_text.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.error_link_url.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.error_appid {
            os.write_uint32(17, v)?;
        }
        for v in &self.line_items {
            crate::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_PurchaseReceiptInfo {
        CStore_PurchaseReceiptInfo::new()
    }

    fn clear(&mut self) {
        self.transactionid = ::std::option::Option::None;
        self.packageid = ::std::option::Option::None;
        self.purchase_status = ::std::option::Option::None;
        self.result_detail = ::std::option::Option::None;
        self.transaction_time = ::std::option::Option::None;
        self.payment_method = ::std::option::Option::None;
        self.base_price = ::std::option::Option::None;
        self.total_discount = ::std::option::Option::None;
        self.tax = ::std::option::Option::None;
        self.shipping = ::std::option::Option::None;
        self.currency_code = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.error_headline = ::std::option::Option::None;
        self.error_string = ::std::option::Option::None;
        self.error_link_text = ::std::option::Option::None;
        self.error_link_url = ::std::option::Option::None;
        self.error_appid = ::std::option::Option::None;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_PurchaseReceiptInfo {
        static instance: CStore_PurchaseReceiptInfo = CStore_PurchaseReceiptInfo {
            transactionid: ::std::option::Option::None,
            packageid: ::std::option::Option::None,
            purchase_status: ::std::option::Option::None,
            result_detail: ::std::option::Option::None,
            transaction_time: ::std::option::Option::None,
            payment_method: ::std::option::Option::None,
            base_price: ::std::option::Option::None,
            total_discount: ::std::option::Option::None,
            tax: ::std::option::Option::None,
            shipping: ::std::option::Option::None,
            currency_code: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            error_headline: ::std::option::Option::None,
            error_string: ::std::option::Option::None,
            error_link_text: ::std::option::Option::None,
            error_link_url: ::std::option::Option::None,
            error_appid: ::std::option::Option::None,
            line_items: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_PurchaseReceiptInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_PurchaseReceiptInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_PurchaseReceiptInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_PurchaseReceiptInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStore_PurchaseReceiptInfo`
pub mod cstore_purchase_receipt_info {
    // @@protoc_insertion_point(message:CStore_PurchaseReceiptInfo.LineItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LineItem {
        // message fields
        // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.LineItem.packageid)
        pub packageid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.LineItem.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.LineItem.line_item_description)
        pub line_item_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_PurchaseReceiptInfo.LineItem.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LineItem {
        fn default() -> &'a LineItem {
            <LineItem as crate::Message>::default_instance()
        }
    }

    impl LineItem {
        pub fn new() -> LineItem {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 2;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string line_item_description = 3;

        pub fn line_item_description(&self) -> &str {
            match self.line_item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_line_item_description(&mut self) {
            self.line_item_description = ::std::option::Option::None;
        }

        pub fn has_line_item_description(&self) -> bool {
            self.line_item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_line_item_description(&mut self, v: ::std::string::String) {
            self.line_item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_line_item_description(&mut self) -> &mut ::std::string::String {
            if self.line_item_description.is_none() {
                self.line_item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.line_item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_line_item_description(&mut self) -> ::std::string::String {
            self.line_item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "packageid",
                |m: &LineItem| { &m.packageid },
                |m: &mut LineItem| { &mut m.packageid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &LineItem| { &m.appid },
                |m: &mut LineItem| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "line_item_description",
                |m: &LineItem| { &m.line_item_description },
                |m: &mut LineItem| { &mut m.line_item_description },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<LineItem>(
                "CStore_PurchaseReceiptInfo.LineItem",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for LineItem {
        const NAME: &'static str = "LineItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.line_item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.line_item_description.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.line_item_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LineItem {
            LineItem::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.line_item_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LineItem {
            static instance: LineItem = LineItem {
                packageid: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                line_item_description: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for LineItem {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStore_PurchaseReceiptInfo.LineItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LineItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for LineItem {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStore_RegisterCDKey_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_RegisterCDKey_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Response.purchase_result_details)
    pub purchase_result_details: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Response.purchase_receipt_info)
    pub purchase_receipt_info: crate::MessageField<CStore_PurchaseReceiptInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_RegisterCDKey_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_RegisterCDKey_Response {
    fn default() -> &'a CStore_RegisterCDKey_Response {
        <CStore_RegisterCDKey_Response as crate::Message>::default_instance()
    }
}

impl CStore_RegisterCDKey_Response {
    pub fn new() -> CStore_RegisterCDKey_Response {
        ::std::default::Default::default()
    }

    // optional int32 purchase_result_details = 1;

    pub fn purchase_result_details(&self) -> i32 {
        self.purchase_result_details.unwrap_or(0)
    }

    pub fn clear_purchase_result_details(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
    }

    pub fn has_purchase_result_details(&self) -> bool {
        self.purchase_result_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_result_details(&mut self, v: i32) {
        self.purchase_result_details = ::std::option::Option::Some(v);
    }

    // optional .CStore_PurchaseReceiptInfo purchase_receipt_info = 2;

    pub fn purchase_receipt_info(&self) -> &CStore_PurchaseReceiptInfo {
        self.purchase_receipt_info.as_ref().unwrap_or_else(|| <CStore_PurchaseReceiptInfo as crate::Message>::default_instance())
    }

    pub fn clear_purchase_receipt_info(&mut self) {
        self.purchase_receipt_info.clear();
    }

    pub fn has_purchase_receipt_info(&self) -> bool {
        self.purchase_receipt_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_receipt_info(&mut self, v: CStore_PurchaseReceiptInfo) {
        self.purchase_receipt_info = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_receipt_info(&mut self) -> &mut CStore_PurchaseReceiptInfo {
        self.purchase_receipt_info.mut_or_insert_default()
    }

    // Take field
    pub fn take_purchase_receipt_info(&mut self) -> CStore_PurchaseReceiptInfo {
        self.purchase_receipt_info.take().unwrap_or_else(|| CStore_PurchaseReceiptInfo::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_result_details",
            |m: &CStore_RegisterCDKey_Response| { &m.purchase_result_details },
            |m: &mut CStore_RegisterCDKey_Response| { &mut m.purchase_result_details },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStore_PurchaseReceiptInfo>(
            "purchase_receipt_info",
            |m: &CStore_RegisterCDKey_Response| { &m.purchase_receipt_info },
            |m: &mut CStore_RegisterCDKey_Response| { &mut m.purchase_receipt_info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_RegisterCDKey_Response>(
            "CStore_RegisterCDKey_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_RegisterCDKey_Response {
    const NAME: &'static str = "CStore_RegisterCDKey_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.purchase_result_details = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.purchase_receipt_info)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.purchase_result_details {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.purchase_result_details {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_RegisterCDKey_Response {
        CStore_RegisterCDKey_Response::new()
    }

    fn clear(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
        self.purchase_receipt_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_RegisterCDKey_Response {
        static instance: CStore_RegisterCDKey_Response = CStore_RegisterCDKey_Response {
            purchase_result_details: ::std::option::Option::None,
            purchase_receipt_info: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_RegisterCDKey_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_RegisterCDKey_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_RegisterCDKey_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_RegisterCDKey_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetMostPopularTags_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetMostPopularTags_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetMostPopularTags_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetMostPopularTags_Request {
    fn default() -> &'a CStore_GetMostPopularTags_Request {
        <CStore_GetMostPopularTags_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetMostPopularTags_Request {
    pub fn new() -> CStore_GetMostPopularTags_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CStore_GetMostPopularTags_Request| { &m.language },
            |m: &mut CStore_GetMostPopularTags_Request| { &mut m.language },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetMostPopularTags_Request>(
            "CStore_GetMostPopularTags_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetMostPopularTags_Request {
    const NAME: &'static str = "CStore_GetMostPopularTags_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetMostPopularTags_Request {
        CStore_GetMostPopularTags_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetMostPopularTags_Request {
        static instance: CStore_GetMostPopularTags_Request = CStore_GetMostPopularTags_Request {
            language: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetMostPopularTags_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetMostPopularTags_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetMostPopularTags_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetMostPopularTags_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetMostPopularTags_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetMostPopularTags_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Response.tags)
    pub tags: ::std::vec::Vec<cstore_get_most_popular_tags_response::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetMostPopularTags_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetMostPopularTags_Response {
    fn default() -> &'a CStore_GetMostPopularTags_Response {
        <CStore_GetMostPopularTags_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetMostPopularTags_Response {
    pub fn new() -> CStore_GetMostPopularTags_Response {
        ::std::default::Default::default()
    }

    // repeated .CStore_GetMostPopularTags_Response.Tag tags = 1;

    pub fn tags(&self) -> &[cstore_get_most_popular_tags_response::Tag] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<cstore_get_most_popular_tags_response::Tag>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<cstore_get_most_popular_tags_response::Tag> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<cstore_get_most_popular_tags_response::Tag> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CStore_GetMostPopularTags_Response| { &m.tags },
            |m: &mut CStore_GetMostPopularTags_Response| { &mut m.tags },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetMostPopularTags_Response>(
            "CStore_GetMostPopularTags_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetMostPopularTags_Response {
    const NAME: &'static str = "CStore_GetMostPopularTags_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.tags {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetMostPopularTags_Response {
        CStore_GetMostPopularTags_Response::new()
    }

    fn clear(&mut self) {
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetMostPopularTags_Response {
        static instance: CStore_GetMostPopularTags_Response = CStore_GetMostPopularTags_Response {
            tags: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetMostPopularTags_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetMostPopularTags_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetMostPopularTags_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetMostPopularTags_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStore_GetMostPopularTags_Response`
pub mod cstore_get_most_popular_tags_response {
    // @@protoc_insertion_point(message:CStore_GetMostPopularTags_Response.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Response.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Response.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetMostPopularTags_Response.Tag.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as crate::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "tagid",
                |m: &Tag| { &m.tagid },
                |m: &mut Tag| { &mut m.tagid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Tag| { &m.name },
                |m: &mut Tag| { &mut m.name },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "CStore_GetMostPopularTags_Response.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Tag {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStore_GetMostPopularTags_Response.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Tag {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStore_GetLocalizedNameForTags_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetLocalizedNameForTags_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Request.tagids)
    pub tagids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetLocalizedNameForTags_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetLocalizedNameForTags_Request {
    fn default() -> &'a CStore_GetLocalizedNameForTags_Request {
        <CStore_GetLocalizedNameForTags_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetLocalizedNameForTags_Request {
    pub fn new() -> CStore_GetLocalizedNameForTags_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 tagids = 2;

    pub fn tagids(&self) -> &[u32] {
        &self.tagids
    }

    pub fn clear_tagids(&mut self) {
        self.tagids.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagids(&mut self, v: ::std::vec::Vec<u32>) {
        self.tagids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tagids
    }

    // Take field
    pub fn take_tagids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tagids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CStore_GetLocalizedNameForTags_Request| { &m.language },
            |m: &mut CStore_GetLocalizedNameForTags_Request| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagids",
            |m: &CStore_GetLocalizedNameForTags_Request| { &m.tagids },
            |m: &mut CStore_GetLocalizedNameForTags_Request| { &mut m.tagids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetLocalizedNameForTags_Request>(
            "CStore_GetLocalizedNameForTags_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetLocalizedNameForTags_Request {
    const NAME: &'static str = "CStore_GetLocalizedNameForTags_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids)?;
                },
                16 => {
                    self.tagids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.tagids {
            my_size += crate::rt::uint32_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.tagids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetLocalizedNameForTags_Request {
        CStore_GetLocalizedNameForTags_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.tagids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetLocalizedNameForTags_Request {
        static instance: CStore_GetLocalizedNameForTags_Request = CStore_GetLocalizedNameForTags_Request {
            language: ::std::option::Option::None,
            tagids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetLocalizedNameForTags_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetLocalizedNameForTags_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetLocalizedNameForTags_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetLocalizedNameForTags_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetLocalizedNameForTags_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetLocalizedNameForTags_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.tags)
    pub tags: ::std::vec::Vec<cstore_get_localized_name_for_tags_response::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetLocalizedNameForTags_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetLocalizedNameForTags_Response {
    fn default() -> &'a CStore_GetLocalizedNameForTags_Response {
        <CStore_GetLocalizedNameForTags_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetLocalizedNameForTags_Response {
    pub fn new() -> CStore_GetLocalizedNameForTags_Response {
        ::std::default::Default::default()
    }

    // repeated .CStore_GetLocalizedNameForTags_Response.Tag tags = 1;

    pub fn tags(&self) -> &[cstore_get_localized_name_for_tags_response::Tag] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<cstore_get_localized_name_for_tags_response::Tag>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<cstore_get_localized_name_for_tags_response::Tag> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<cstore_get_localized_name_for_tags_response::Tag> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CStore_GetLocalizedNameForTags_Response| { &m.tags },
            |m: &mut CStore_GetLocalizedNameForTags_Response| { &mut m.tags },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetLocalizedNameForTags_Response>(
            "CStore_GetLocalizedNameForTags_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetLocalizedNameForTags_Response {
    const NAME: &'static str = "CStore_GetLocalizedNameForTags_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.tags {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetLocalizedNameForTags_Response {
        CStore_GetLocalizedNameForTags_Response::new()
    }

    fn clear(&mut self) {
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetLocalizedNameForTags_Response {
        static instance: CStore_GetLocalizedNameForTags_Response = CStore_GetLocalizedNameForTags_Response {
            tags: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetLocalizedNameForTags_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetLocalizedNameForTags_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetLocalizedNameForTags_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetLocalizedNameForTags_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStore_GetLocalizedNameForTags_Response`
pub mod cstore_get_localized_name_for_tags_response {
    // @@protoc_insertion_point(message:CStore_GetLocalizedNameForTags_Response.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.english_name)
        pub english_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.normalized_name)
        pub normalized_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetLocalizedNameForTags_Response.Tag.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as crate::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string english_name = 2;

        pub fn english_name(&self) -> &str {
            match self.english_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_english_name(&mut self) {
            self.english_name = ::std::option::Option::None;
        }

        pub fn has_english_name(&self) -> bool {
            self.english_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_english_name(&mut self, v: ::std::string::String) {
            self.english_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_english_name(&mut self) -> &mut ::std::string::String {
            if self.english_name.is_none() {
                self.english_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.english_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_english_name(&mut self) -> ::std::string::String {
            self.english_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string normalized_name = 4;

        pub fn normalized_name(&self) -> &str {
            match self.normalized_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_normalized_name(&mut self) {
            self.normalized_name = ::std::option::Option::None;
        }

        pub fn has_normalized_name(&self) -> bool {
            self.normalized_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_normalized_name(&mut self, v: ::std::string::String) {
            self.normalized_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_normalized_name(&mut self) -> &mut ::std::string::String {
            if self.normalized_name.is_none() {
                self.normalized_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.normalized_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_normalized_name(&mut self) -> ::std::string::String {
            self.normalized_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "tagid",
                |m: &Tag| { &m.tagid },
                |m: &mut Tag| { &mut m.tagid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "english_name",
                |m: &Tag| { &m.english_name },
                |m: &mut Tag| { &mut m.english_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Tag| { &m.name },
                |m: &mut Tag| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "normalized_name",
                |m: &Tag| { &m.normalized_name },
                |m: &mut Tag| { &mut m.normalized_name },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "CStore_GetLocalizedNameForTags_Response.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.english_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.normalized_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.english_name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.normalized_name.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.english_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.normalized_name.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.english_name = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.normalized_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                english_name: ::std::option::Option::None,
                name: ::std::option::Option::None,
                normalized_name: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Tag {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStore_GetLocalizedNameForTags_Response.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Tag {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStore_GetTagList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTagList_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTagList_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetTagList_Request.have_version_hash)
    pub have_version_hash: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTagList_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTagList_Request {
    fn default() -> &'a CStore_GetTagList_Request {
        <CStore_GetTagList_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetTagList_Request {
    pub fn new() -> CStore_GetTagList_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string have_version_hash = 2;

    pub fn have_version_hash(&self) -> &str {
        match self.have_version_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_have_version_hash(&mut self) {
        self.have_version_hash = ::std::option::Option::None;
    }

    pub fn has_have_version_hash(&self) -> bool {
        self.have_version_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_have_version_hash(&mut self, v: ::std::string::String) {
        self.have_version_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_have_version_hash(&mut self) -> &mut ::std::string::String {
        if self.have_version_hash.is_none() {
            self.have_version_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.have_version_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_have_version_hash(&mut self) -> ::std::string::String {
        self.have_version_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CStore_GetTagList_Request| { &m.language },
            |m: &mut CStore_GetTagList_Request| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "have_version_hash",
            |m: &CStore_GetTagList_Request| { &m.have_version_hash },
            |m: &mut CStore_GetTagList_Request| { &mut m.have_version_hash },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetTagList_Request>(
            "CStore_GetTagList_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetTagList_Request {
    const NAME: &'static str = "CStore_GetTagList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.have_version_hash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.have_version_hash.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.have_version_hash.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTagList_Request {
        CStore_GetTagList_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.have_version_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTagList_Request {
        static instance: CStore_GetTagList_Request = CStore_GetTagList_Request {
            language: ::std::option::Option::None,
            have_version_hash: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetTagList_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetTagList_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetTagList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetTagList_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetTagList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTagList_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTagList_Response.version_hash)
    pub version_hash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetTagList_Response.tags)
    pub tags: ::std::vec::Vec<cstore_get_tag_list_response::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTagList_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTagList_Response {
    fn default() -> &'a CStore_GetTagList_Response {
        <CStore_GetTagList_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetTagList_Response {
    pub fn new() -> CStore_GetTagList_Response {
        ::std::default::Default::default()
    }

    // optional string version_hash = 1;

    pub fn version_hash(&self) -> &str {
        match self.version_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_hash(&mut self) {
        self.version_hash = ::std::option::Option::None;
    }

    pub fn has_version_hash(&self) -> bool {
        self.version_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_hash(&mut self, v: ::std::string::String) {
        self.version_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_hash(&mut self) -> &mut ::std::string::String {
        if self.version_hash.is_none() {
            self.version_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_hash(&mut self) -> ::std::string::String {
        self.version_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CStore_GetTagList_Response.Tag tags = 2;

    pub fn tags(&self) -> &[cstore_get_tag_list_response::Tag] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<cstore_get_tag_list_response::Tag>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<cstore_get_tag_list_response::Tag> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<cstore_get_tag_list_response::Tag> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_hash",
            |m: &CStore_GetTagList_Response| { &m.version_hash },
            |m: &mut CStore_GetTagList_Response| { &mut m.version_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CStore_GetTagList_Response| { &m.tags },
            |m: &mut CStore_GetTagList_Response| { &mut m.tags },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetTagList_Response>(
            "CStore_GetTagList_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetTagList_Response {
    const NAME: &'static str = "CStore_GetTagList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_hash = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.tags.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_hash.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.version_hash.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.tags {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTagList_Response {
        CStore_GetTagList_Response::new()
    }

    fn clear(&mut self) {
        self.version_hash = ::std::option::Option::None;
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTagList_Response {
        static instance: CStore_GetTagList_Response = CStore_GetTagList_Response {
            version_hash: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetTagList_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetTagList_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetTagList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetTagList_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStore_GetTagList_Response`
pub mod cstore_get_tag_list_response {
    // @@protoc_insertion_point(message:CStore_GetTagList_Response.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetTagList_Response.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetTagList_Response.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetTagList_Response.Tag.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as crate::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "tagid",
                |m: &Tag| { &m.tagid },
                |m: &mut Tag| { &mut m.tagid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Tag| { &m.name },
                |m: &mut Tag| { &mut m.name },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "CStore_GetTagList_Response.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Tag {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStore_GetTagList_Response.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Tag {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStoreDiscoveryQueueSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreDiscoveryQueueSettings {
    // message fields
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.os_win)
    pub os_win: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.os_mac)
    pub os_mac: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.os_linux)
    pub os_linux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.full_controller_support)
    pub full_controller_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.native_steam_controller)
    pub native_steam_controller: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.include_coming_soon)
    pub include_coming_soon: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.excluded_tagids)
    pub excluded_tagids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_early_access)
    pub exclude_early_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_videos)
    pub exclude_videos: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_software)
    pub exclude_software: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_dlc)
    pub exclude_dlc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_soundtracks)
    pub exclude_soundtracks: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.featured_tagids)
    pub featured_tagids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreDiscoveryQueueSettings.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreDiscoveryQueueSettings {
    fn default() -> &'a CStoreDiscoveryQueueSettings {
        <CStoreDiscoveryQueueSettings as crate::Message>::default_instance()
    }
}

impl CStoreDiscoveryQueueSettings {
    pub fn new() -> CStoreDiscoveryQueueSettings {
        ::std::default::Default::default()
    }

    // optional bool os_win = 4;

    pub fn os_win(&self) -> bool {
        self.os_win.unwrap_or(false)
    }

    pub fn clear_os_win(&mut self) {
        self.os_win = ::std::option::Option::None;
    }

    pub fn has_os_win(&self) -> bool {
        self.os_win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_win(&mut self, v: bool) {
        self.os_win = ::std::option::Option::Some(v);
    }

    // optional bool os_mac = 5;

    pub fn os_mac(&self) -> bool {
        self.os_mac.unwrap_or(false)
    }

    pub fn clear_os_mac(&mut self) {
        self.os_mac = ::std::option::Option::None;
    }

    pub fn has_os_mac(&self) -> bool {
        self.os_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_mac(&mut self, v: bool) {
        self.os_mac = ::std::option::Option::Some(v);
    }

    // optional bool os_linux = 6;

    pub fn os_linux(&self) -> bool {
        self.os_linux.unwrap_or(false)
    }

    pub fn clear_os_linux(&mut self) {
        self.os_linux = ::std::option::Option::None;
    }

    pub fn has_os_linux(&self) -> bool {
        self.os_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_linux(&mut self, v: bool) {
        self.os_linux = ::std::option::Option::Some(v);
    }

    // optional bool full_controller_support = 7;

    pub fn full_controller_support(&self) -> bool {
        self.full_controller_support.unwrap_or(false)
    }

    pub fn clear_full_controller_support(&mut self) {
        self.full_controller_support = ::std::option::Option::None;
    }

    pub fn has_full_controller_support(&self) -> bool {
        self.full_controller_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_controller_support(&mut self, v: bool) {
        self.full_controller_support = ::std::option::Option::Some(v);
    }

    // optional bool native_steam_controller = 8;

    pub fn native_steam_controller(&self) -> bool {
        self.native_steam_controller.unwrap_or(false)
    }

    pub fn clear_native_steam_controller(&mut self) {
        self.native_steam_controller = ::std::option::Option::None;
    }

    pub fn has_native_steam_controller(&self) -> bool {
        self.native_steam_controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_steam_controller(&mut self, v: bool) {
        self.native_steam_controller = ::std::option::Option::Some(v);
    }

    // optional bool include_coming_soon = 9;

    pub fn include_coming_soon(&self) -> bool {
        self.include_coming_soon.unwrap_or(false)
    }

    pub fn clear_include_coming_soon(&mut self) {
        self.include_coming_soon = ::std::option::Option::None;
    }

    pub fn has_include_coming_soon(&self) -> bool {
        self.include_coming_soon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_coming_soon(&mut self, v: bool) {
        self.include_coming_soon = ::std::option::Option::Some(v);
    }

    // repeated uint32 excluded_tagids = 10;

    pub fn excluded_tagids(&self) -> &[u32] {
        &self.excluded_tagids
    }

    pub fn clear_excluded_tagids(&mut self) {
        self.excluded_tagids.clear();
    }

    // Param is passed by value, moved
    pub fn set_excluded_tagids(&mut self, v: ::std::vec::Vec<u32>) {
        self.excluded_tagids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excluded_tagids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.excluded_tagids
    }

    // Take field
    pub fn take_excluded_tagids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.excluded_tagids, ::std::vec::Vec::new())
    }

    // optional bool exclude_early_access = 11;

    pub fn exclude_early_access(&self) -> bool {
        self.exclude_early_access.unwrap_or(false)
    }

    pub fn clear_exclude_early_access(&mut self) {
        self.exclude_early_access = ::std::option::Option::None;
    }

    pub fn has_exclude_early_access(&self) -> bool {
        self.exclude_early_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_early_access(&mut self, v: bool) {
        self.exclude_early_access = ::std::option::Option::Some(v);
    }

    // optional bool exclude_videos = 12;

    pub fn exclude_videos(&self) -> bool {
        self.exclude_videos.unwrap_or(false)
    }

    pub fn clear_exclude_videos(&mut self) {
        self.exclude_videos = ::std::option::Option::None;
    }

    pub fn has_exclude_videos(&self) -> bool {
        self.exclude_videos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_videos(&mut self, v: bool) {
        self.exclude_videos = ::std::option::Option::Some(v);
    }

    // optional bool exclude_software = 13;

    pub fn exclude_software(&self) -> bool {
        self.exclude_software.unwrap_or(false)
    }

    pub fn clear_exclude_software(&mut self) {
        self.exclude_software = ::std::option::Option::None;
    }

    pub fn has_exclude_software(&self) -> bool {
        self.exclude_software.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_software(&mut self, v: bool) {
        self.exclude_software = ::std::option::Option::Some(v);
    }

    // optional bool exclude_dlc = 14;

    pub fn exclude_dlc(&self) -> bool {
        self.exclude_dlc.unwrap_or(false)
    }

    pub fn clear_exclude_dlc(&mut self) {
        self.exclude_dlc = ::std::option::Option::None;
    }

    pub fn has_exclude_dlc(&self) -> bool {
        self.exclude_dlc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_dlc(&mut self, v: bool) {
        self.exclude_dlc = ::std::option::Option::Some(v);
    }

    // optional bool exclude_soundtracks = 15;

    pub fn exclude_soundtracks(&self) -> bool {
        self.exclude_soundtracks.unwrap_or(false)
    }

    pub fn clear_exclude_soundtracks(&mut self) {
        self.exclude_soundtracks = ::std::option::Option::None;
    }

    pub fn has_exclude_soundtracks(&self) -> bool {
        self.exclude_soundtracks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_soundtracks(&mut self, v: bool) {
        self.exclude_soundtracks = ::std::option::Option::Some(v);
    }

    // repeated uint32 featured_tagids = 16;

    pub fn featured_tagids(&self) -> &[u32] {
        &self.featured_tagids
    }

    pub fn clear_featured_tagids(&mut self) {
        self.featured_tagids.clear();
    }

    // Param is passed by value, moved
    pub fn set_featured_tagids(&mut self, v: ::std::vec::Vec<u32>) {
        self.featured_tagids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_featured_tagids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.featured_tagids
    }

    // Take field
    pub fn take_featured_tagids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.featured_tagids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_win",
            |m: &CStoreDiscoveryQueueSettings| { &m.os_win },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.os_win },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_mac",
            |m: &CStoreDiscoveryQueueSettings| { &m.os_mac },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.os_mac },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_linux",
            |m: &CStoreDiscoveryQueueSettings| { &m.os_linux },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.os_linux },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_controller_support",
            |m: &CStoreDiscoveryQueueSettings| { &m.full_controller_support },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.full_controller_support },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "native_steam_controller",
            |m: &CStoreDiscoveryQueueSettings| { &m.native_steam_controller },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.native_steam_controller },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_coming_soon",
            |m: &CStoreDiscoveryQueueSettings| { &m.include_coming_soon },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.include_coming_soon },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "excluded_tagids",
            |m: &CStoreDiscoveryQueueSettings| { &m.excluded_tagids },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.excluded_tagids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclude_early_access",
            |m: &CStoreDiscoveryQueueSettings| { &m.exclude_early_access },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.exclude_early_access },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclude_videos",
            |m: &CStoreDiscoveryQueueSettings| { &m.exclude_videos },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.exclude_videos },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclude_software",
            |m: &CStoreDiscoveryQueueSettings| { &m.exclude_software },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.exclude_software },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclude_dlc",
            |m: &CStoreDiscoveryQueueSettings| { &m.exclude_dlc },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.exclude_dlc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclude_soundtracks",
            |m: &CStoreDiscoveryQueueSettings| { &m.exclude_soundtracks },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.exclude_soundtracks },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "featured_tagids",
            |m: &CStoreDiscoveryQueueSettings| { &m.featured_tagids },
            |m: &mut CStoreDiscoveryQueueSettings| { &mut m.featured_tagids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreDiscoveryQueueSettings>(
            "CStoreDiscoveryQueueSettings",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreDiscoveryQueueSettings {
    const NAME: &'static str = "CStoreDiscoveryQueueSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.os_win = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.os_mac = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.os_linux = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.full_controller_support = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.native_steam_controller = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.include_coming_soon = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.excluded_tagids)?;
                },
                80 => {
                    self.excluded_tagids.push(is.read_uint32()?);
                },
                88 => {
                    self.exclude_early_access = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.exclude_videos = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.exclude_software = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.exclude_dlc = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.exclude_soundtracks = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    is.read_repeated_packed_uint32_into(&mut self.featured_tagids)?;
                },
                128 => {
                    self.featured_tagids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.os_win {
            my_size += 1 + 1;
        }
        if let Some(v) = self.os_mac {
            my_size += 1 + 1;
        }
        if let Some(v) = self.os_linux {
            my_size += 1 + 1;
        }
        if let Some(v) = self.full_controller_support {
            my_size += 1 + 1;
        }
        if let Some(v) = self.native_steam_controller {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_coming_soon {
            my_size += 1 + 1;
        }
        for value in &self.excluded_tagids {
            my_size += crate::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.exclude_early_access {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_videos {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_software {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_dlc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_soundtracks {
            my_size += 1 + 1;
        }
        for value in &self.featured_tagids {
            my_size += crate::rt::uint32_size(16, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.os_win {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.os_mac {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.os_linux {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.full_controller_support {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.native_steam_controller {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.include_coming_soon {
            os.write_bool(9, v)?;
        }
        for v in &self.excluded_tagids {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.exclude_early_access {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.exclude_videos {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.exclude_software {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.exclude_dlc {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.exclude_soundtracks {
            os.write_bool(15, v)?;
        }
        for v in &self.featured_tagids {
            os.write_uint32(16, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreDiscoveryQueueSettings {
        CStoreDiscoveryQueueSettings::new()
    }

    fn clear(&mut self) {
        self.os_win = ::std::option::Option::None;
        self.os_mac = ::std::option::Option::None;
        self.os_linux = ::std::option::Option::None;
        self.full_controller_support = ::std::option::Option::None;
        self.native_steam_controller = ::std::option::Option::None;
        self.include_coming_soon = ::std::option::Option::None;
        self.excluded_tagids.clear();
        self.exclude_early_access = ::std::option::Option::None;
        self.exclude_videos = ::std::option::Option::None;
        self.exclude_software = ::std::option::Option::None;
        self.exclude_dlc = ::std::option::Option::None;
        self.exclude_soundtracks = ::std::option::Option::None;
        self.featured_tagids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreDiscoveryQueueSettings {
        static instance: CStoreDiscoveryQueueSettings = CStoreDiscoveryQueueSettings {
            os_win: ::std::option::Option::None,
            os_mac: ::std::option::Option::None,
            os_linux: ::std::option::Option::None,
            full_controller_support: ::std::option::Option::None,
            native_steam_controller: ::std::option::Option::None,
            include_coming_soon: ::std::option::Option::None,
            excluded_tagids: ::std::vec::Vec::new(),
            exclude_early_access: ::std::option::Option::None,
            exclude_videos: ::std::option::Option::None,
            exclude_software: ::std::option::Option::None,
            exclude_dlc: ::std::option::Option::None,
            exclude_soundtracks: ::std::option::Option::None,
            featured_tagids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreDiscoveryQueueSettings {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreDiscoveryQueueSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreDiscoveryQueueSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreDiscoveryQueueSettings {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueue_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueue_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.queue_type)
    pub queue_type: ::std::option::Option<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.rebuild_queue)
    pub rebuild_queue: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.settings_changed)
    pub settings_changed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.settings)
    pub settings: crate::MessageField<CStoreDiscoveryQueueSettings>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.rebuild_queue_if_stale)
    pub rebuild_queue_if_stale: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.ignore_user_preferences)
    pub ignore_user_preferences: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.no_experimental_results)
    pub no_experimental_results: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.experimental_cohort)
    pub experimental_cohort: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.debug_get_solr_query)
    pub debug_get_solr_query: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.store_page_filter)
    pub store_page_filter: crate::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueue_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueue_Request {
    fn default() -> &'a CStore_GetDiscoveryQueue_Request {
        <CStore_GetDiscoveryQueue_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueue_Request {
    pub fn new() -> CStore_GetDiscoveryQueue_Request {
        ::std::default::Default::default()
    }

    // optional .EStoreDiscoveryQueueType queue_type = 1;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool rebuild_queue = 3;

    pub fn rebuild_queue(&self) -> bool {
        self.rebuild_queue.unwrap_or(false)
    }

    pub fn clear_rebuild_queue(&mut self) {
        self.rebuild_queue = ::std::option::Option::None;
    }

    pub fn has_rebuild_queue(&self) -> bool {
        self.rebuild_queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rebuild_queue(&mut self, v: bool) {
        self.rebuild_queue = ::std::option::Option::Some(v);
    }

    // optional bool settings_changed = 4;

    pub fn settings_changed(&self) -> bool {
        self.settings_changed.unwrap_or(false)
    }

    pub fn clear_settings_changed(&mut self) {
        self.settings_changed = ::std::option::Option::None;
    }

    pub fn has_settings_changed(&self) -> bool {
        self.settings_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings_changed(&mut self, v: bool) {
        self.settings_changed = ::std::option::Option::Some(v);
    }

    // optional .CStoreDiscoveryQueueSettings settings = 5;

    pub fn settings(&self) -> &CStoreDiscoveryQueueSettings {
        self.settings.as_ref().unwrap_or_else(|| <CStoreDiscoveryQueueSettings as crate::Message>::default_instance())
    }

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    pub fn has_settings(&self) -> bool {
        self.settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: CStoreDiscoveryQueueSettings) {
        self.settings = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut CStoreDiscoveryQueueSettings {
        self.settings.mut_or_insert_default()
    }

    // Take field
    pub fn take_settings(&mut self) -> CStoreDiscoveryQueueSettings {
        self.settings.take().unwrap_or_else(|| CStoreDiscoveryQueueSettings::new())
    }

    // optional bool rebuild_queue_if_stale = 6;

    pub fn rebuild_queue_if_stale(&self) -> bool {
        self.rebuild_queue_if_stale.unwrap_or(false)
    }

    pub fn clear_rebuild_queue_if_stale(&mut self) {
        self.rebuild_queue_if_stale = ::std::option::Option::None;
    }

    pub fn has_rebuild_queue_if_stale(&self) -> bool {
        self.rebuild_queue_if_stale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rebuild_queue_if_stale(&mut self, v: bool) {
        self.rebuild_queue_if_stale = ::std::option::Option::Some(v);
    }

    // optional bool ignore_user_preferences = 8;

    pub fn ignore_user_preferences(&self) -> bool {
        self.ignore_user_preferences.unwrap_or(false)
    }

    pub fn clear_ignore_user_preferences(&mut self) {
        self.ignore_user_preferences = ::std::option::Option::None;
    }

    pub fn has_ignore_user_preferences(&self) -> bool {
        self.ignore_user_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_user_preferences(&mut self, v: bool) {
        self.ignore_user_preferences = ::std::option::Option::Some(v);
    }

    // optional bool no_experimental_results = 9;

    pub fn no_experimental_results(&self) -> bool {
        self.no_experimental_results.unwrap_or(false)
    }

    pub fn clear_no_experimental_results(&mut self) {
        self.no_experimental_results = ::std::option::Option::None;
    }

    pub fn has_no_experimental_results(&self) -> bool {
        self.no_experimental_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_experimental_results(&mut self, v: bool) {
        self.no_experimental_results = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental_cohort = 10;

    pub fn experimental_cohort(&self) -> u32 {
        self.experimental_cohort.unwrap_or(0)
    }

    pub fn clear_experimental_cohort(&mut self) {
        self.experimental_cohort = ::std::option::Option::None;
    }

    pub fn has_experimental_cohort(&self) -> bool {
        self.experimental_cohort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_cohort(&mut self, v: u32) {
        self.experimental_cohort = ::std::option::Option::Some(v);
    }

    // optional bool debug_get_solr_query = 11;

    pub fn debug_get_solr_query(&self) -> bool {
        self.debug_get_solr_query.unwrap_or(false)
    }

    pub fn clear_debug_get_solr_query(&mut self) {
        self.debug_get_solr_query = ::std::option::Option::None;
    }

    pub fn has_debug_get_solr_query(&self) -> bool {
        self.debug_get_solr_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_get_solr_query(&mut self, v: bool) {
        self.debug_get_solr_query = ::std::option::Option::Some(v);
    }

    // optional .CStorePageFilter store_page_filter = 12;

    pub fn store_page_filter(&self) -> &super::contenthubs::CStorePageFilter {
        self.store_page_filter.as_ref().unwrap_or_else(|| <super::contenthubs::CStorePageFilter as crate::Message>::default_instance())
    }

    pub fn clear_store_page_filter(&mut self) {
        self.store_page_filter.clear();
    }

    pub fn has_store_page_filter(&self) -> bool {
        self.store_page_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_page_filter(&mut self, v: super::contenthubs::CStorePageFilter) {
        self.store_page_filter = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_page_filter(&mut self) -> &mut super::contenthubs::CStorePageFilter {
        self.store_page_filter.mut_or_insert_default()
    }

    // Take field
    pub fn take_store_page_filter(&mut self) -> super::contenthubs::CStorePageFilter {
        self.store_page_filter.take().unwrap_or_else(|| super::contenthubs::CStorePageFilter::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_type",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.queue_type },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.queue_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.country_code },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rebuild_queue",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.rebuild_queue },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.rebuild_queue },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "settings_changed",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.settings_changed },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.settings_changed },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStoreDiscoveryQueueSettings>(
            "settings",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.settings },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.settings },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rebuild_queue_if_stale",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.rebuild_queue_if_stale },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.rebuild_queue_if_stale },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore_user_preferences",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.ignore_user_preferences },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.ignore_user_preferences },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_experimental_results",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.no_experimental_results },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.no_experimental_results },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental_cohort",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.experimental_cohort },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.experimental_cohort },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_get_solr_query",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.debug_get_solr_query },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.debug_get_solr_query },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::contenthubs::CStorePageFilter>(
            "store_page_filter",
            |m: &CStore_GetDiscoveryQueue_Request| { &m.store_page_filter },
            |m: &mut CStore_GetDiscoveryQueue_Request| { &mut m.store_page_filter },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetDiscoveryQueue_Request>(
            "CStore_GetDiscoveryQueue_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetDiscoveryQueue_Request {
    const NAME: &'static str = "CStore_GetDiscoveryQueue_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.rebuild_queue = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.settings_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                48 => {
                    self.rebuild_queue_if_stale = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.ignore_user_preferences = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.no_experimental_results = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.experimental_cohort = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.debug_get_solr_query = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queue_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.rebuild_queue {
            my_size += 1 + 1;
        }
        if let Some(v) = self.settings_changed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rebuild_queue_if_stale {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ignore_user_preferences {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_experimental_results {
            my_size += 1 + 1;
        }
        if let Some(v) = self.experimental_cohort {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.debug_get_solr_query {
            my_size += 1 + 1;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.queue_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.rebuild_queue {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.settings_changed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.rebuild_queue_if_stale {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.ignore_user_preferences {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.no_experimental_results {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.experimental_cohort {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.debug_get_solr_query {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            crate::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueue_Request {
        CStore_GetDiscoveryQueue_Request::new()
    }

    fn clear(&mut self) {
        self.queue_type = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.rebuild_queue = ::std::option::Option::None;
        self.settings_changed = ::std::option::Option::None;
        self.settings.clear();
        self.rebuild_queue_if_stale = ::std::option::Option::None;
        self.ignore_user_preferences = ::std::option::Option::None;
        self.no_experimental_results = ::std::option::Option::None;
        self.experimental_cohort = ::std::option::Option::None;
        self.debug_get_solr_query = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueue_Request {
        static instance: CStore_GetDiscoveryQueue_Request = CStore_GetDiscoveryQueue_Request {
            queue_type: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            rebuild_queue: ::std::option::Option::None,
            settings_changed: ::std::option::Option::None,
            settings: crate::MessageField::none(),
            rebuild_queue_if_stale: ::std::option::Option::None,
            ignore_user_preferences: ::std::option::Option::None,
            no_experimental_results: ::std::option::Option::None,
            experimental_cohort: ::std::option::Option::None,
            debug_get_solr_query: ::std::option::Option::None,
            store_page_filter: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetDiscoveryQueue_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetDiscoveryQueue_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetDiscoveryQueue_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetDiscoveryQueue_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueue_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueue_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.appids)
    pub appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.settings)
    pub settings: crate::MessageField<CStoreDiscoveryQueueSettings>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.skipped)
    pub skipped: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.exhausted)
    pub exhausted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.experimental_cohort)
    pub experimental_cohort: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.debug_solr_query)
    pub debug_solr_query: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueue_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueue_Response {
    fn default() -> &'a CStore_GetDiscoveryQueue_Response {
        <CStore_GetDiscoveryQueue_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueue_Response {
    pub fn new() -> CStore_GetDiscoveryQueue_Response {
        ::std::default::Default::default()
    }

    // repeated uint32 appids = 1;

    pub fn appids(&self) -> &[u32] {
        &self.appids
    }

    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CStoreDiscoveryQueueSettings settings = 3;

    pub fn settings(&self) -> &CStoreDiscoveryQueueSettings {
        self.settings.as_ref().unwrap_or_else(|| <CStoreDiscoveryQueueSettings as crate::Message>::default_instance())
    }

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    pub fn has_settings(&self) -> bool {
        self.settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: CStoreDiscoveryQueueSettings) {
        self.settings = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut CStoreDiscoveryQueueSettings {
        self.settings.mut_or_insert_default()
    }

    // Take field
    pub fn take_settings(&mut self) -> CStoreDiscoveryQueueSettings {
        self.settings.take().unwrap_or_else(|| CStoreDiscoveryQueueSettings::new())
    }

    // optional int32 skipped = 4;

    pub fn skipped(&self) -> i32 {
        self.skipped.unwrap_or(0)
    }

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: i32) {
        self.skipped = ::std::option::Option::Some(v);
    }

    // optional bool exhausted = 5;

    pub fn exhausted(&self) -> bool {
        self.exhausted.unwrap_or(false)
    }

    pub fn clear_exhausted(&mut self) {
        self.exhausted = ::std::option::Option::None;
    }

    pub fn has_exhausted(&self) -> bool {
        self.exhausted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exhausted(&mut self, v: bool) {
        self.exhausted = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental_cohort = 6;

    pub fn experimental_cohort(&self) -> u32 {
        self.experimental_cohort.unwrap_or(0)
    }

    pub fn clear_experimental_cohort(&mut self) {
        self.experimental_cohort = ::std::option::Option::None;
    }

    pub fn has_experimental_cohort(&self) -> bool {
        self.experimental_cohort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_cohort(&mut self, v: u32) {
        self.experimental_cohort = ::std::option::Option::Some(v);
    }

    // optional string debug_solr_query = 7;

    pub fn debug_solr_query(&self) -> &str {
        match self.debug_solr_query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_solr_query(&mut self) {
        self.debug_solr_query = ::std::option::Option::None;
    }

    pub fn has_debug_solr_query(&self) -> bool {
        self.debug_solr_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_solr_query(&mut self, v: ::std::string::String) {
        self.debug_solr_query = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_solr_query(&mut self) -> &mut ::std::string::String {
        if self.debug_solr_query.is_none() {
            self.debug_solr_query = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_solr_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_solr_query(&mut self) -> ::std::string::String {
        self.debug_solr_query.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CStore_GetDiscoveryQueue_Response| { &m.appids },
            |m: &mut CStore_GetDiscoveryQueue_Response| { &mut m.appids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CStore_GetDiscoveryQueue_Response| { &m.country_code },
            |m: &mut CStore_GetDiscoveryQueue_Response| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStoreDiscoveryQueueSettings>(
            "settings",
            |m: &CStore_GetDiscoveryQueue_Response| { &m.settings },
            |m: &mut CStore_GetDiscoveryQueue_Response| { &mut m.settings },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "skipped",
            |m: &CStore_GetDiscoveryQueue_Response| { &m.skipped },
            |m: &mut CStore_GetDiscoveryQueue_Response| { &mut m.skipped },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exhausted",
            |m: &CStore_GetDiscoveryQueue_Response| { &m.exhausted },
            |m: &mut CStore_GetDiscoveryQueue_Response| { &mut m.exhausted },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental_cohort",
            |m: &CStore_GetDiscoveryQueue_Response| { &m.experimental_cohort },
            |m: &mut CStore_GetDiscoveryQueue_Response| { &mut m.experimental_cohort },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_solr_query",
            |m: &CStore_GetDiscoveryQueue_Response| { &m.debug_solr_query },
            |m: &mut CStore_GetDiscoveryQueue_Response| { &mut m.debug_solr_query },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetDiscoveryQueue_Response>(
            "CStore_GetDiscoveryQueue_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetDiscoveryQueue_Response {
    const NAME: &'static str = "CStore_GetDiscoveryQueue_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                8 => {
                    self.appids.push(is.read_uint32()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                32 => {
                    self.skipped = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.exhausted = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.experimental_cohort = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.debug_solr_query = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += crate::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.skipped {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.exhausted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.experimental_cohort {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.debug_solr_query.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.appids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.skipped {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.exhausted {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.experimental_cohort {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.debug_solr_query.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueue_Response {
        CStore_GetDiscoveryQueue_Response::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.country_code = ::std::option::Option::None;
        self.settings.clear();
        self.skipped = ::std::option::Option::None;
        self.exhausted = ::std::option::Option::None;
        self.experimental_cohort = ::std::option::Option::None;
        self.debug_solr_query = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueue_Response {
        static instance: CStore_GetDiscoveryQueue_Response = CStore_GetDiscoveryQueue_Response {
            appids: ::std::vec::Vec::new(),
            country_code: ::std::option::Option::None,
            settings: crate::MessageField::none(),
            skipped: ::std::option::Option::None,
            exhausted: ::std::option::Option::None,
            experimental_cohort: ::std::option::Option::None,
            debug_solr_query: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetDiscoveryQueue_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetDiscoveryQueue_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetDiscoveryQueue_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetDiscoveryQueue_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSettings_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Request.queue_type)
    pub queue_type: ::std::option::Option<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Request.store_page_filter)
    pub store_page_filter: crate::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSettings_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSettings_Request {
    fn default() -> &'a CStore_GetDiscoveryQueueSettings_Request {
        <CStore_GetDiscoveryQueueSettings_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSettings_Request {
    pub fn new() -> CStore_GetDiscoveryQueueSettings_Request {
        ::std::default::Default::default()
    }

    // optional .EStoreDiscoveryQueueType queue_type = 1;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .CStorePageFilter store_page_filter = 2;

    pub fn store_page_filter(&self) -> &super::contenthubs::CStorePageFilter {
        self.store_page_filter.as_ref().unwrap_or_else(|| <super::contenthubs::CStorePageFilter as crate::Message>::default_instance())
    }

    pub fn clear_store_page_filter(&mut self) {
        self.store_page_filter.clear();
    }

    pub fn has_store_page_filter(&self) -> bool {
        self.store_page_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_page_filter(&mut self, v: super::contenthubs::CStorePageFilter) {
        self.store_page_filter = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_page_filter(&mut self) -> &mut super::contenthubs::CStorePageFilter {
        self.store_page_filter.mut_or_insert_default()
    }

    // Take field
    pub fn take_store_page_filter(&mut self) -> super::contenthubs::CStorePageFilter {
        self.store_page_filter.take().unwrap_or_else(|| super::contenthubs::CStorePageFilter::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_type",
            |m: &CStore_GetDiscoveryQueueSettings_Request| { &m.queue_type },
            |m: &mut CStore_GetDiscoveryQueueSettings_Request| { &mut m.queue_type },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::contenthubs::CStorePageFilter>(
            "store_page_filter",
            |m: &CStore_GetDiscoveryQueueSettings_Request| { &m.store_page_filter },
            |m: &mut CStore_GetDiscoveryQueueSettings_Request| { &mut m.store_page_filter },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetDiscoveryQueueSettings_Request>(
            "CStore_GetDiscoveryQueueSettings_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetDiscoveryQueueSettings_Request {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queue_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.queue_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSettings_Request {
        CStore_GetDiscoveryQueueSettings_Request::new()
    }

    fn clear(&mut self) {
        self.queue_type = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSettings_Request {
        static instance: CStore_GetDiscoveryQueueSettings_Request = CStore_GetDiscoveryQueueSettings_Request {
            queue_type: ::std::option::Option::None,
            store_page_filter: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetDiscoveryQueueSettings_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetDiscoveryQueueSettings_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetDiscoveryQueueSettings_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetDiscoveryQueueSettings_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSettings_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Response.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Response.settings)
    pub settings: crate::MessageField<CStoreDiscoveryQueueSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSettings_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSettings_Response {
    fn default() -> &'a CStore_GetDiscoveryQueueSettings_Response {
        <CStore_GetDiscoveryQueueSettings_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSettings_Response {
    pub fn new() -> CStore_GetDiscoveryQueueSettings_Response {
        ::std::default::Default::default()
    }

    // optional string country_code = 1;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CStoreDiscoveryQueueSettings settings = 2;

    pub fn settings(&self) -> &CStoreDiscoveryQueueSettings {
        self.settings.as_ref().unwrap_or_else(|| <CStoreDiscoveryQueueSettings as crate::Message>::default_instance())
    }

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    pub fn has_settings(&self) -> bool {
        self.settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: CStoreDiscoveryQueueSettings) {
        self.settings = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut CStoreDiscoveryQueueSettings {
        self.settings.mut_or_insert_default()
    }

    // Take field
    pub fn take_settings(&mut self) -> CStoreDiscoveryQueueSettings {
        self.settings.take().unwrap_or_else(|| CStoreDiscoveryQueueSettings::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CStore_GetDiscoveryQueueSettings_Response| { &m.country_code },
            |m: &mut CStore_GetDiscoveryQueueSettings_Response| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStoreDiscoveryQueueSettings>(
            "settings",
            |m: &CStore_GetDiscoveryQueueSettings_Response| { &m.settings },
            |m: &mut CStore_GetDiscoveryQueueSettings_Response| { &mut m.settings },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetDiscoveryQueueSettings_Response>(
            "CStore_GetDiscoveryQueueSettings_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetDiscoveryQueueSettings_Response {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSettings_Response {
        CStore_GetDiscoveryQueueSettings_Response::new()
    }

    fn clear(&mut self) {
        self.country_code = ::std::option::Option::None;
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSettings_Response {
        static instance: CStore_GetDiscoveryQueueSettings_Response = CStore_GetDiscoveryQueueSettings_Response {
            country_code: ::std::option::Option::None,
            settings: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetDiscoveryQueueSettings_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetDiscoveryQueueSettings_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetDiscoveryQueueSettings_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetDiscoveryQueueSettings_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_SkipDiscoveryQueueItem_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_SkipDiscoveryQueueItem_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_SkipDiscoveryQueueItem_Request.queue_type)
    pub queue_type: ::std::option::Option<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_SkipDiscoveryQueueItem_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_SkipDiscoveryQueueItem_Request.store_page_filter)
    pub store_page_filter: crate::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_SkipDiscoveryQueueItem_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_SkipDiscoveryQueueItem_Request {
    fn default() -> &'a CStore_SkipDiscoveryQueueItem_Request {
        <CStore_SkipDiscoveryQueueItem_Request as crate::Message>::default_instance()
    }
}

impl CStore_SkipDiscoveryQueueItem_Request {
    pub fn new() -> CStore_SkipDiscoveryQueueItem_Request {
        ::std::default::Default::default()
    }

    // optional .EStoreDiscoveryQueueType queue_type = 1;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .CStorePageFilter store_page_filter = 3;

    pub fn store_page_filter(&self) -> &super::contenthubs::CStorePageFilter {
        self.store_page_filter.as_ref().unwrap_or_else(|| <super::contenthubs::CStorePageFilter as crate::Message>::default_instance())
    }

    pub fn clear_store_page_filter(&mut self) {
        self.store_page_filter.clear();
    }

    pub fn has_store_page_filter(&self) -> bool {
        self.store_page_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_page_filter(&mut self, v: super::contenthubs::CStorePageFilter) {
        self.store_page_filter = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_page_filter(&mut self) -> &mut super::contenthubs::CStorePageFilter {
        self.store_page_filter.mut_or_insert_default()
    }

    // Take field
    pub fn take_store_page_filter(&mut self) -> super::contenthubs::CStorePageFilter {
        self.store_page_filter.take().unwrap_or_else(|| super::contenthubs::CStorePageFilter::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_type",
            |m: &CStore_SkipDiscoveryQueueItem_Request| { &m.queue_type },
            |m: &mut CStore_SkipDiscoveryQueueItem_Request| { &mut m.queue_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CStore_SkipDiscoveryQueueItem_Request| { &m.appid },
            |m: &mut CStore_SkipDiscoveryQueueItem_Request| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::contenthubs::CStorePageFilter>(
            "store_page_filter",
            |m: &CStore_SkipDiscoveryQueueItem_Request| { &m.store_page_filter },
            |m: &mut CStore_SkipDiscoveryQueueItem_Request| { &mut m.store_page_filter },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_SkipDiscoveryQueueItem_Request>(
            "CStore_SkipDiscoveryQueueItem_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_SkipDiscoveryQueueItem_Request {
    const NAME: &'static str = "CStore_SkipDiscoveryQueueItem_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queue_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.queue_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_SkipDiscoveryQueueItem_Request {
        CStore_SkipDiscoveryQueueItem_Request::new()
    }

    fn clear(&mut self) {
        self.queue_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_SkipDiscoveryQueueItem_Request {
        static instance: CStore_SkipDiscoveryQueueItem_Request = CStore_SkipDiscoveryQueueItem_Request {
            queue_type: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            store_page_filter: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_SkipDiscoveryQueueItem_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_SkipDiscoveryQueueItem_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_SkipDiscoveryQueueItem_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_SkipDiscoveryQueueItem_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_SkipDiscoveryQueueItem_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_SkipDiscoveryQueueItem_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_SkipDiscoveryQueueItem_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_SkipDiscoveryQueueItem_Response {
    fn default() -> &'a CStore_SkipDiscoveryQueueItem_Response {
        <CStore_SkipDiscoveryQueueItem_Response as crate::Message>::default_instance()
    }
}

impl CStore_SkipDiscoveryQueueItem_Response {
    pub fn new() -> CStore_SkipDiscoveryQueueItem_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_SkipDiscoveryQueueItem_Response>(
            "CStore_SkipDiscoveryQueueItem_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_SkipDiscoveryQueueItem_Response {
    const NAME: &'static str = "CStore_SkipDiscoveryQueueItem_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_SkipDiscoveryQueueItem_Response {
        CStore_SkipDiscoveryQueueItem_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_SkipDiscoveryQueueItem_Response {
        static instance: CStore_SkipDiscoveryQueueItem_Response = CStore_SkipDiscoveryQueueItem_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_SkipDiscoveryQueueItem_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_SkipDiscoveryQueueItem_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_SkipDiscoveryQueueItem_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_SkipDiscoveryQueueItem_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetUserGameInterestState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetUserGameInterestState_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Request.store_appid)
    pub store_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Request.beta_appid)
    pub beta_appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetUserGameInterestState_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetUserGameInterestState_Request {
    fn default() -> &'a CStore_GetUserGameInterestState_Request {
        <CStore_GetUserGameInterestState_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetUserGameInterestState_Request {
    pub fn new() -> CStore_GetUserGameInterestState_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 store_appid = 2;

    pub fn store_appid(&self) -> u32 {
        self.store_appid.unwrap_or(0)
    }

    pub fn clear_store_appid(&mut self) {
        self.store_appid = ::std::option::Option::None;
    }

    pub fn has_store_appid(&self) -> bool {
        self.store_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_appid(&mut self, v: u32) {
        self.store_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 beta_appid = 3;

    pub fn beta_appid(&self) -> u32 {
        self.beta_appid.unwrap_or(0)
    }

    pub fn clear_beta_appid(&mut self) {
        self.beta_appid = ::std::option::Option::None;
    }

    pub fn has_beta_appid(&self) -> bool {
        self.beta_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta_appid(&mut self, v: u32) {
        self.beta_appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CStore_GetUserGameInterestState_Request| { &m.appid },
            |m: &mut CStore_GetUserGameInterestState_Request| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "store_appid",
            |m: &CStore_GetUserGameInterestState_Request| { &m.store_appid },
            |m: &mut CStore_GetUserGameInterestState_Request| { &mut m.store_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "beta_appid",
            |m: &CStore_GetUserGameInterestState_Request| { &m.beta_appid },
            |m: &mut CStore_GetUserGameInterestState_Request| { &mut m.beta_appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetUserGameInterestState_Request>(
            "CStore_GetUserGameInterestState_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetUserGameInterestState_Request {
    const NAME: &'static str = "CStore_GetUserGameInterestState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.store_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.beta_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.store_appid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.beta_appid {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.store_appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.beta_appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetUserGameInterestState_Request {
        CStore_GetUserGameInterestState_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.store_appid = ::std::option::Option::None;
        self.beta_appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetUserGameInterestState_Request {
        static instance: CStore_GetUserGameInterestState_Request = CStore_GetUserGameInterestState_Request {
            appid: ::std::option::Option::None,
            store_appid: ::std::option::Option::None,
            beta_appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetUserGameInterestState_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetUserGameInterestState_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetUserGameInterestState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetUserGameInterestState_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetUserGameInterestState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetUserGameInterestState_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.owned)
    pub owned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.wishlist)
    pub wishlist: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.ignored)
    pub ignored: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.following)
    pub following: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.in_queues)
    pub in_queues: ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queues_with_skip)
    pub queues_with_skip: ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queue_items_remaining)
    pub queue_items_remaining: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queue_items_next_appid)
    pub queue_items_next_appid: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.temporarily_owned)
    pub temporarily_owned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queues)
    pub queues: ::std::vec::Vec<cstore_get_user_game_interest_state_response::InQueue>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.ignored_reason)
    pub ignored_reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.beta_status)
    pub beta_status: ::std::option::Option<crate::EnumOrUnknown<EPlaytestStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetUserGameInterestState_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetUserGameInterestState_Response {
    fn default() -> &'a CStore_GetUserGameInterestState_Response {
        <CStore_GetUserGameInterestState_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetUserGameInterestState_Response {
    pub fn new() -> CStore_GetUserGameInterestState_Response {
        ::std::default::Default::default()
    }

    // optional bool owned = 1;

    pub fn owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }

    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }

    // optional bool wishlist = 2;

    pub fn wishlist(&self) -> bool {
        self.wishlist.unwrap_or(false)
    }

    pub fn clear_wishlist(&mut self) {
        self.wishlist = ::std::option::Option::None;
    }

    pub fn has_wishlist(&self) -> bool {
        self.wishlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wishlist(&mut self, v: bool) {
        self.wishlist = ::std::option::Option::Some(v);
    }

    // optional bool ignored = 3;

    pub fn ignored(&self) -> bool {
        self.ignored.unwrap_or(false)
    }

    pub fn clear_ignored(&mut self) {
        self.ignored = ::std::option::Option::None;
    }

    pub fn has_ignored(&self) -> bool {
        self.ignored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignored(&mut self, v: bool) {
        self.ignored = ::std::option::Option::Some(v);
    }

    // optional bool following = 4;

    pub fn following(&self) -> bool {
        self.following.unwrap_or(false)
    }

    pub fn clear_following(&mut self) {
        self.following = ::std::option::Option::None;
    }

    pub fn has_following(&self) -> bool {
        self.following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_following(&mut self, v: bool) {
        self.following = ::std::option::Option::Some(v);
    }

    // repeated .EStoreDiscoveryQueueType in_queues = 5;

    pub fn in_queues(&self) -> &[crate::EnumOrUnknown<EStoreDiscoveryQueueType>] {
        &self.in_queues
    }

    pub fn clear_in_queues(&mut self) {
        self.in_queues.clear();
    }

    // Param is passed by value, moved
    pub fn set_in_queues(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>) {
        self.in_queues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_in_queues(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>> {
        &mut self.in_queues
    }

    // Take field
    pub fn take_in_queues(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>> {
        ::std::mem::replace(&mut self.in_queues, ::std::vec::Vec::new())
    }

    // repeated .EStoreDiscoveryQueueType queues_with_skip = 6;

    pub fn queues_with_skip(&self) -> &[crate::EnumOrUnknown<EStoreDiscoveryQueueType>] {
        &self.queues_with_skip
    }

    pub fn clear_queues_with_skip(&mut self) {
        self.queues_with_skip.clear();
    }

    // Param is passed by value, moved
    pub fn set_queues_with_skip(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>) {
        self.queues_with_skip = v;
    }

    // Mutable pointer to the field.
    pub fn mut_queues_with_skip(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>> {
        &mut self.queues_with_skip
    }

    // Take field
    pub fn take_queues_with_skip(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EStoreDiscoveryQueueType>> {
        ::std::mem::replace(&mut self.queues_with_skip, ::std::vec::Vec::new())
    }

    // repeated int32 queue_items_remaining = 7;

    pub fn queue_items_remaining(&self) -> &[i32] {
        &self.queue_items_remaining
    }

    pub fn clear_queue_items_remaining(&mut self) {
        self.queue_items_remaining.clear();
    }

    // Param is passed by value, moved
    pub fn set_queue_items_remaining(&mut self, v: ::std::vec::Vec<i32>) {
        self.queue_items_remaining = v;
    }

    // Mutable pointer to the field.
    pub fn mut_queue_items_remaining(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.queue_items_remaining
    }

    // Take field
    pub fn take_queue_items_remaining(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.queue_items_remaining, ::std::vec::Vec::new())
    }

    // repeated uint32 queue_items_next_appid = 8;

    pub fn queue_items_next_appid(&self) -> &[u32] {
        &self.queue_items_next_appid
    }

    pub fn clear_queue_items_next_appid(&mut self) {
        self.queue_items_next_appid.clear();
    }

    // Param is passed by value, moved
    pub fn set_queue_items_next_appid(&mut self, v: ::std::vec::Vec<u32>) {
        self.queue_items_next_appid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_queue_items_next_appid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.queue_items_next_appid
    }

    // Take field
    pub fn take_queue_items_next_appid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.queue_items_next_appid, ::std::vec::Vec::new())
    }

    // optional bool temporarily_owned = 9;

    pub fn temporarily_owned(&self) -> bool {
        self.temporarily_owned.unwrap_or(false)
    }

    pub fn clear_temporarily_owned(&mut self) {
        self.temporarily_owned = ::std::option::Option::None;
    }

    pub fn has_temporarily_owned(&self) -> bool {
        self.temporarily_owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporarily_owned(&mut self, v: bool) {
        self.temporarily_owned = ::std::option::Option::Some(v);
    }

    // repeated .CStore_GetUserGameInterestState_Response.InQueue queues = 10;

    pub fn queues(&self) -> &[cstore_get_user_game_interest_state_response::InQueue] {
        &self.queues
    }

    pub fn clear_queues(&mut self) {
        self.queues.clear();
    }

    // Param is passed by value, moved
    pub fn set_queues(&mut self, v: ::std::vec::Vec<cstore_get_user_game_interest_state_response::InQueue>) {
        self.queues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_queues(&mut self) -> &mut ::std::vec::Vec<cstore_get_user_game_interest_state_response::InQueue> {
        &mut self.queues
    }

    // Take field
    pub fn take_queues(&mut self) -> ::std::vec::Vec<cstore_get_user_game_interest_state_response::InQueue> {
        ::std::mem::replace(&mut self.queues, ::std::vec::Vec::new())
    }

    // optional int32 ignored_reason = 11;

    pub fn ignored_reason(&self) -> i32 {
        self.ignored_reason.unwrap_or(0)
    }

    pub fn clear_ignored_reason(&mut self) {
        self.ignored_reason = ::std::option::Option::None;
    }

    pub fn has_ignored_reason(&self) -> bool {
        self.ignored_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignored_reason(&mut self, v: i32) {
        self.ignored_reason = ::std::option::Option::Some(v);
    }

    // optional .EPlaytestStatus beta_status = 12;

    pub fn beta_status(&self) -> EPlaytestStatus {
        match self.beta_status {
            Some(e) => e.enum_value_or(EPlaytestStatus::k_ETesterStatusNone),
            None => EPlaytestStatus::k_ETesterStatusNone,
        }
    }

    pub fn clear_beta_status(&mut self) {
        self.beta_status = ::std::option::Option::None;
    }

    pub fn has_beta_status(&self) -> bool {
        self.beta_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta_status(&mut self, v: EPlaytestStatus) {
        self.beta_status = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owned",
            |m: &CStore_GetUserGameInterestState_Response| { &m.owned },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.owned },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "wishlist",
            |m: &CStore_GetUserGameInterestState_Response| { &m.wishlist },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.wishlist },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignored",
            |m: &CStore_GetUserGameInterestState_Response| { &m.ignored },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.ignored },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "following",
            |m: &CStore_GetUserGameInterestState_Response| { &m.following },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.following },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "in_queues",
            |m: &CStore_GetUserGameInterestState_Response| { &m.in_queues },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.in_queues },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "queues_with_skip",
            |m: &CStore_GetUserGameInterestState_Response| { &m.queues_with_skip },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.queues_with_skip },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "queue_items_remaining",
            |m: &CStore_GetUserGameInterestState_Response| { &m.queue_items_remaining },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.queue_items_remaining },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "queue_items_next_appid",
            |m: &CStore_GetUserGameInterestState_Response| { &m.queue_items_next_appid },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.queue_items_next_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "temporarily_owned",
            |m: &CStore_GetUserGameInterestState_Response| { &m.temporarily_owned },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.temporarily_owned },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "queues",
            |m: &CStore_GetUserGameInterestState_Response| { &m.queues },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.queues },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignored_reason",
            |m: &CStore_GetUserGameInterestState_Response| { &m.ignored_reason },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.ignored_reason },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "beta_status",
            |m: &CStore_GetUserGameInterestState_Response| { &m.beta_status },
            |m: &mut CStore_GetUserGameInterestState_Response| { &mut m.beta_status },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetUserGameInterestState_Response>(
            "CStore_GetUserGameInterestState_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetUserGameInterestState_Response {
    const NAME: &'static str = "CStore_GetUserGameInterestState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owned = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.wishlist = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.ignored = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.following = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.in_queues.push(is.read_enum_or_unknown()?);
                },
                42 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.in_queues)?
                },
                48 => {
                    self.queues_with_skip.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.queues_with_skip)?
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.queue_items_remaining)?;
                },
                56 => {
                    self.queue_items_remaining.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.queue_items_next_appid)?;
                },
                64 => {
                    self.queue_items_next_appid.push(is.read_uint32()?);
                },
                72 => {
                    self.temporarily_owned = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.queues.push(is.read_message()?);
                },
                88 => {
                    self.ignored_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.beta_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.wishlist {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ignored {
            my_size += 1 + 1;
        }
        if let Some(v) = self.following {
            my_size += 1 + 1;
        }
        for value in &self.in_queues {
            my_size += crate::rt::int32_size(5, value.value());
        };
        for value in &self.queues_with_skip {
            my_size += crate::rt::int32_size(6, value.value());
        };
        for value in &self.queue_items_remaining {
            my_size += crate::rt::int32_size(7, *value);
        };
        for value in &self.queue_items_next_appid {
            my_size += crate::rt::uint32_size(8, *value);
        };
        if let Some(v) = self.temporarily_owned {
            my_size += 1 + 1;
        }
        for value in &self.queues {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ignored_reason {
            my_size += crate::rt::int32_size(11, v);
        }
        if let Some(v) = self.beta_status {
            my_size += crate::rt::int32_size(12, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.owned {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.wishlist {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.ignored {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.following {
            os.write_bool(4, v)?;
        }
        for v in &self.in_queues {
            os.write_enum(5, crate::EnumOrUnknown::value(v))?;
        };
        for v in &self.queues_with_skip {
            os.write_enum(6, crate::EnumOrUnknown::value(v))?;
        };
        for v in &self.queue_items_remaining {
            os.write_int32(7, *v)?;
        };
        for v in &self.queue_items_next_appid {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.temporarily_owned {
            os.write_bool(9, v)?;
        }
        for v in &self.queues {
            crate::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.ignored_reason {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.beta_status {
            os.write_enum(12, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetUserGameInterestState_Response {
        CStore_GetUserGameInterestState_Response::new()
    }

    fn clear(&mut self) {
        self.owned = ::std::option::Option::None;
        self.wishlist = ::std::option::Option::None;
        self.ignored = ::std::option::Option::None;
        self.following = ::std::option::Option::None;
        self.in_queues.clear();
        self.queues_with_skip.clear();
        self.queue_items_remaining.clear();
        self.queue_items_next_appid.clear();
        self.temporarily_owned = ::std::option::Option::None;
        self.queues.clear();
        self.ignored_reason = ::std::option::Option::None;
        self.beta_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetUserGameInterestState_Response {
        static instance: CStore_GetUserGameInterestState_Response = CStore_GetUserGameInterestState_Response {
            owned: ::std::option::Option::None,
            wishlist: ::std::option::Option::None,
            ignored: ::std::option::Option::None,
            following: ::std::option::Option::None,
            in_queues: ::std::vec::Vec::new(),
            queues_with_skip: ::std::vec::Vec::new(),
            queue_items_remaining: ::std::vec::Vec::new(),
            queue_items_next_appid: ::std::vec::Vec::new(),
            temporarily_owned: ::std::option::Option::None,
            queues: ::std::vec::Vec::new(),
            ignored_reason: ::std::option::Option::None,
            beta_status: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetUserGameInterestState_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetUserGameInterestState_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetUserGameInterestState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetUserGameInterestState_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStore_GetUserGameInterestState_Response`
pub mod cstore_get_user_game_interest_state_response {
    // @@protoc_insertion_point(message:CStore_GetUserGameInterestState_Response.InQueue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InQueue {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.type)
        pub type_: ::std::option::Option<crate::EnumOrUnknown<super::EStoreDiscoveryQueueType>>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.skipped)
        pub skipped: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.items_remaining)
        pub items_remaining: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.next_appid)
        pub next_appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.experimental_cohort)
        pub experimental_cohort: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetUserGameInterestState_Response.InQueue.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InQueue {
        fn default() -> &'a InQueue {
            <InQueue as crate::Message>::default_instance()
        }
    }

    impl InQueue {
        pub fn new() -> InQueue {
            ::std::default::Default::default()
        }

        // optional .EStoreDiscoveryQueueType type = 1;

        pub fn type_(&self) -> super::EStoreDiscoveryQueueType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
                None => super::EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::EStoreDiscoveryQueueType) {
            self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional bool skipped = 2;

        pub fn skipped(&self) -> bool {
            self.skipped.unwrap_or(false)
        }

        pub fn clear_skipped(&mut self) {
            self.skipped = ::std::option::Option::None;
        }

        pub fn has_skipped(&self) -> bool {
            self.skipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_skipped(&mut self, v: bool) {
            self.skipped = ::std::option::Option::Some(v);
        }

        // optional int32 items_remaining = 3;

        pub fn items_remaining(&self) -> i32 {
            self.items_remaining.unwrap_or(0)
        }

        pub fn clear_items_remaining(&mut self) {
            self.items_remaining = ::std::option::Option::None;
        }

        pub fn has_items_remaining(&self) -> bool {
            self.items_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_items_remaining(&mut self, v: i32) {
            self.items_remaining = ::std::option::Option::Some(v);
        }

        // optional uint32 next_appid = 4;

        pub fn next_appid(&self) -> u32 {
            self.next_appid.unwrap_or(0)
        }

        pub fn clear_next_appid(&mut self) {
            self.next_appid = ::std::option::Option::None;
        }

        pub fn has_next_appid(&self) -> bool {
            self.next_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_next_appid(&mut self, v: u32) {
            self.next_appid = ::std::option::Option::Some(v);
        }

        // optional uint32 experimental_cohort = 5;

        pub fn experimental_cohort(&self) -> u32 {
            self.experimental_cohort.unwrap_or(0)
        }

        pub fn clear_experimental_cohort(&mut self) {
            self.experimental_cohort = ::std::option::Option::None;
        }

        pub fn has_experimental_cohort(&self) -> bool {
            self.experimental_cohort.is_some()
        }

        // Param is passed by value, moved
        pub fn set_experimental_cohort(&mut self, v: u32) {
            self.experimental_cohort = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &InQueue| { &m.type_ },
                |m: &mut InQueue| { &mut m.type_ },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "skipped",
                |m: &InQueue| { &m.skipped },
                |m: &mut InQueue| { &mut m.skipped },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "items_remaining",
                |m: &InQueue| { &m.items_remaining },
                |m: &mut InQueue| { &mut m.items_remaining },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "next_appid",
                |m: &InQueue| { &m.next_appid },
                |m: &mut InQueue| { &mut m.next_appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "experimental_cohort",
                |m: &InQueue| { &m.experimental_cohort },
                |m: &mut InQueue| { &mut m.experimental_cohort },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<InQueue>(
                "CStore_GetUserGameInterestState_Response.InQueue",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for InQueue {
        const NAME: &'static str = "InQueue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.skipped = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.items_remaining = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.next_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.experimental_cohort = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += crate::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.skipped {
                my_size += 1 + 1;
            }
            if let Some(v) = self.items_remaining {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.next_appid {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.experimental_cohort {
                my_size += crate::rt::uint32_size(5, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.type_ {
                os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.skipped {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.items_remaining {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.next_appid {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.experimental_cohort {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InQueue {
            InQueue::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.skipped = ::std::option::Option::None;
            self.items_remaining = ::std::option::Option::None;
            self.next_appid = ::std::option::Option::None;
            self.experimental_cohort = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InQueue {
            static instance: InQueue = InQueue {
                type_: ::std::option::Option::None,
                skipped: ::std::option::Option::None,
                items_remaining: ::std::option::Option::None,
                next_appid: ::std::option::Option::None,
                experimental_cohort: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for InQueue {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStore_GetUserGameInterestState_Response.InQueue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InQueue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for InQueue {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSkippedApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSkippedApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Request.queue_type)
    pub queue_type: ::std::option::Option<crate::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Request.store_page_filter)
    pub store_page_filter: crate::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSkippedApps_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSkippedApps_Request {
    fn default() -> &'a CStore_GetDiscoveryQueueSkippedApps_Request {
        <CStore_GetDiscoveryQueueSkippedApps_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSkippedApps_Request {
    pub fn new() -> CStore_GetDiscoveryQueueSkippedApps_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .EStoreDiscoveryQueueType queue_type = 2;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .CStorePageFilter store_page_filter = 3;

    pub fn store_page_filter(&self) -> &super::contenthubs::CStorePageFilter {
        self.store_page_filter.as_ref().unwrap_or_else(|| <super::contenthubs::CStorePageFilter as crate::Message>::default_instance())
    }

    pub fn clear_store_page_filter(&mut self) {
        self.store_page_filter.clear();
    }

    pub fn has_store_page_filter(&self) -> bool {
        self.store_page_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_page_filter(&mut self, v: super::contenthubs::CStorePageFilter) {
        self.store_page_filter = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_page_filter(&mut self) -> &mut super::contenthubs::CStorePageFilter {
        self.store_page_filter.mut_or_insert_default()
    }

    // Take field
    pub fn take_store_page_filter(&mut self) -> super::contenthubs::CStorePageFilter {
        self.store_page_filter.take().unwrap_or_else(|| super::contenthubs::CStorePageFilter::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CStore_GetDiscoveryQueueSkippedApps_Request| { &m.steamid },
            |m: &mut CStore_GetDiscoveryQueueSkippedApps_Request| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_type",
            |m: &CStore_GetDiscoveryQueueSkippedApps_Request| { &m.queue_type },
            |m: &mut CStore_GetDiscoveryQueueSkippedApps_Request| { &mut m.queue_type },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::contenthubs::CStorePageFilter>(
            "store_page_filter",
            |m: &CStore_GetDiscoveryQueueSkippedApps_Request| { &m.store_page_filter },
            |m: &mut CStore_GetDiscoveryQueueSkippedApps_Request| { &mut m.store_page_filter },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetDiscoveryQueueSkippedApps_Request>(
            "CStore_GetDiscoveryQueueSkippedApps_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetDiscoveryQueueSkippedApps_Request {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSkippedApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.queue_type {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.queue_type {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSkippedApps_Request {
        CStore_GetDiscoveryQueueSkippedApps_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.queue_type = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSkippedApps_Request {
        static instance: CStore_GetDiscoveryQueueSkippedApps_Request = CStore_GetDiscoveryQueueSkippedApps_Request {
            steamid: ::std::option::Option::None,
            queue_type: ::std::option::Option::None,
            store_page_filter: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetDiscoveryQueueSkippedApps_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetDiscoveryQueueSkippedApps_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetDiscoveryQueueSkippedApps_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetDiscoveryQueueSkippedApps_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSkippedApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSkippedApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Response.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSkippedApps_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSkippedApps_Response {
    fn default() -> &'a CStore_GetDiscoveryQueueSkippedApps_Response {
        <CStore_GetDiscoveryQueueSkippedApps_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSkippedApps_Response {
    pub fn new() -> CStore_GetDiscoveryQueueSkippedApps_Response {
        ::std::default::Default::default()
    }

    // repeated uint32 appids = 1;

    pub fn appids(&self) -> &[u32] {
        &self.appids
    }

    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CStore_GetDiscoveryQueueSkippedApps_Response| { &m.appids },
            |m: &mut CStore_GetDiscoveryQueueSkippedApps_Response| { &mut m.appids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetDiscoveryQueueSkippedApps_Response>(
            "CStore_GetDiscoveryQueueSkippedApps_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetDiscoveryQueueSkippedApps_Response {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSkippedApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                8 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += crate::rt::uint32_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.appids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSkippedApps_Response {
        CStore_GetDiscoveryQueueSkippedApps_Response::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSkippedApps_Response {
        static instance: CStore_GetDiscoveryQueueSkippedApps_Response = CStore_GetDiscoveryQueueSkippedApps_Response {
            appids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetDiscoveryQueueSkippedApps_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetDiscoveryQueueSkippedApps_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetDiscoveryQueueSkippedApps_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetDiscoveryQueueSkippedApps_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_ReportApp_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_ReportApp_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_ReportApp_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_ReportApp_Request.report_type)
    pub report_type: ::std::option::Option<crate::EnumOrUnknown<EAppReportType>>,
    // @@protoc_insertion_point(field:CStore_ReportApp_Request.report)
    pub report: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_ReportApp_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_ReportApp_Request {
    fn default() -> &'a CStore_ReportApp_Request {
        <CStore_ReportApp_Request as crate::Message>::default_instance()
    }
}

impl CStore_ReportApp_Request {
    pub fn new() -> CStore_ReportApp_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .EAppReportType report_type = 2;

    pub fn report_type(&self) -> EAppReportType {
        match self.report_type {
            Some(e) => e.enum_value_or(EAppReportType::k_EAppReportType_Invalid),
            None => EAppReportType::k_EAppReportType_Invalid,
        }
    }

    pub fn clear_report_type(&mut self) {
        self.report_type = ::std::option::Option::None;
    }

    pub fn has_report_type(&self) -> bool {
        self.report_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_type(&mut self, v: EAppReportType) {
        self.report_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string report = 3;

    pub fn report(&self) -> &str {
        match self.report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_report(&mut self) {
        self.report = ::std::option::Option::None;
    }

    pub fn has_report(&self) -> bool {
        self.report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::string::String) {
        self.report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::string::String {
        if self.report.is_none() {
            self.report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.report.as_mut().unwrap()
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::string::String {
        self.report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CStore_ReportApp_Request| { &m.appid },
            |m: &mut CStore_ReportApp_Request| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "report_type",
            |m: &CStore_ReportApp_Request| { &m.report_type },
            |m: &mut CStore_ReportApp_Request| { &mut m.report_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "report",
            |m: &CStore_ReportApp_Request| { &m.report },
            |m: &mut CStore_ReportApp_Request| { &mut m.report },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_ReportApp_Request>(
            "CStore_ReportApp_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_ReportApp_Request {
    const NAME: &'static str = "CStore_ReportApp_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.report_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.report = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.report_type {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.report.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.report_type {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.report.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_ReportApp_Request {
        CStore_ReportApp_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.report_type = ::std::option::Option::None;
        self.report = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_ReportApp_Request {
        static instance: CStore_ReportApp_Request = CStore_ReportApp_Request {
            appid: ::std::option::Option::None,
            report_type: ::std::option::Option::None,
            report: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_ReportApp_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_ReportApp_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_ReportApp_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_ReportApp_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_ReportApp_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_ReportApp_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_ReportApp_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_ReportApp_Response {
    fn default() -> &'a CStore_ReportApp_Response {
        <CStore_ReportApp_Response as crate::Message>::default_instance()
    }
}

impl CStore_ReportApp_Response {
    pub fn new() -> CStore_ReportApp_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_ReportApp_Response>(
            "CStore_ReportApp_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_ReportApp_Response {
    const NAME: &'static str = "CStore_ReportApp_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_ReportApp_Response {
        CStore_ReportApp_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_ReportApp_Response {
        static instance: CStore_ReportApp_Response = CStore_ReportApp_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_ReportApp_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_ReportApp_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_ReportApp_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_ReportApp_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetStorePreferences_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetStorePreferences_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetStorePreferences_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetStorePreferences_Request {
    fn default() -> &'a CStore_GetStorePreferences_Request {
        <CStore_GetStorePreferences_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetStorePreferences_Request {
    pub fn new() -> CStore_GetStorePreferences_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetStorePreferences_Request>(
            "CStore_GetStorePreferences_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetStorePreferences_Request {
    const NAME: &'static str = "CStore_GetStorePreferences_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetStorePreferences_Request {
        CStore_GetStorePreferences_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetStorePreferences_Request {
        static instance: CStore_GetStorePreferences_Request = CStore_GetStorePreferences_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetStorePreferences_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetStorePreferences_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetStorePreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetStorePreferences_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_UserPreferences)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_UserPreferences {
    // message fields
    // @@protoc_insertion_point(field:CStore_UserPreferences.primary_language)
    pub primary_language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.secondary_languages)
    pub secondary_languages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.platform_windows)
    pub platform_windows: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.platform_mac)
    pub platform_mac: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.platform_linux)
    pub platform_linux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.timestamp_updated)
    pub timestamp_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.hide_store_broadcast)
    pub hide_store_broadcast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.review_score_preference)
    pub review_score_preference: ::std::option::Option<crate::EnumOrUnknown<EUserReviewScorePreference>>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.timestamp_content_descriptor_preferences_updated)
    pub timestamp_content_descriptor_preferences_updated: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.provide_deck_feedback)
    pub provide_deck_feedback: ::std::option::Option<crate::EnumOrUnknown<super::enums::EProvideDeckFeedbackPreference>>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.additional_languages)
    pub additional_languages: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_UserPreferences.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_UserPreferences {
    fn default() -> &'a CStore_UserPreferences {
        <CStore_UserPreferences as crate::Message>::default_instance()
    }
}

impl CStore_UserPreferences {
    pub fn new() -> CStore_UserPreferences {
        ::std::default::Default::default()
    }

    // optional int32 primary_language = 1;

    pub fn primary_language(&self) -> i32 {
        self.primary_language.unwrap_or(0)
    }

    pub fn clear_primary_language(&mut self) {
        self.primary_language = ::std::option::Option::None;
    }

    pub fn has_primary_language(&self) -> bool {
        self.primary_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_language(&mut self, v: i32) {
        self.primary_language = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_languages = 2;

    pub fn secondary_languages(&self) -> u32 {
        self.secondary_languages.unwrap_or(0)
    }

    pub fn clear_secondary_languages(&mut self) {
        self.secondary_languages = ::std::option::Option::None;
    }

    pub fn has_secondary_languages(&self) -> bool {
        self.secondary_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_languages(&mut self, v: u32) {
        self.secondary_languages = ::std::option::Option::Some(v);
    }

    // optional bool platform_windows = 3;

    pub fn platform_windows(&self) -> bool {
        self.platform_windows.unwrap_or(false)
    }

    pub fn clear_platform_windows(&mut self) {
        self.platform_windows = ::std::option::Option::None;
    }

    pub fn has_platform_windows(&self) -> bool {
        self.platform_windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_windows(&mut self, v: bool) {
        self.platform_windows = ::std::option::Option::Some(v);
    }

    // optional bool platform_mac = 4;

    pub fn platform_mac(&self) -> bool {
        self.platform_mac.unwrap_or(false)
    }

    pub fn clear_platform_mac(&mut self) {
        self.platform_mac = ::std::option::Option::None;
    }

    pub fn has_platform_mac(&self) -> bool {
        self.platform_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_mac(&mut self, v: bool) {
        self.platform_mac = ::std::option::Option::Some(v);
    }

    // optional bool platform_linux = 5;

    pub fn platform_linux(&self) -> bool {
        self.platform_linux.unwrap_or(false)
    }

    pub fn clear_platform_linux(&mut self) {
        self.platform_linux = ::std::option::Option::None;
    }

    pub fn has_platform_linux(&self) -> bool {
        self.platform_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_linux(&mut self, v: bool) {
        self.platform_linux = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 8;

    pub fn timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }

    // optional bool hide_store_broadcast = 9;

    pub fn hide_store_broadcast(&self) -> bool {
        self.hide_store_broadcast.unwrap_or(false)
    }

    pub fn clear_hide_store_broadcast(&mut self) {
        self.hide_store_broadcast = ::std::option::Option::None;
    }

    pub fn has_hide_store_broadcast(&self) -> bool {
        self.hide_store_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_store_broadcast(&mut self, v: bool) {
        self.hide_store_broadcast = ::std::option::Option::Some(v);
    }

    // optional .EUserReviewScorePreference review_score_preference = 10;

    pub fn review_score_preference(&self) -> EUserReviewScorePreference {
        match self.review_score_preference {
            Some(e) => e.enum_value_or(EUserReviewScorePreference::k_EUserReviewScorePreference_Unset),
            None => EUserReviewScorePreference::k_EUserReviewScorePreference_Unset,
        }
    }

    pub fn clear_review_score_preference(&mut self) {
        self.review_score_preference = ::std::option::Option::None;
    }

    pub fn has_review_score_preference(&self) -> bool {
        self.review_score_preference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_review_score_preference(&mut self, v: EUserReviewScorePreference) {
        self.review_score_preference = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 timestamp_content_descriptor_preferences_updated = 11;

    pub fn timestamp_content_descriptor_preferences_updated(&self) -> i32 {
        self.timestamp_content_descriptor_preferences_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_content_descriptor_preferences_updated(&mut self) {
        self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_content_descriptor_preferences_updated(&self) -> bool {
        self.timestamp_content_descriptor_preferences_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_content_descriptor_preferences_updated(&mut self, v: i32) {
        self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::Some(v);
    }

    // optional .EProvideDeckFeedbackPreference provide_deck_feedback = 12;

    pub fn provide_deck_feedback(&self) -> super::enums::EProvideDeckFeedbackPreference {
        match self.provide_deck_feedback {
            Some(e) => e.enum_value_or(super::enums::EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            None => super::enums::EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset,
        }
    }

    pub fn clear_provide_deck_feedback(&mut self) {
        self.provide_deck_feedback = ::std::option::Option::None;
    }

    pub fn has_provide_deck_feedback(&self) -> bool {
        self.provide_deck_feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provide_deck_feedback(&mut self, v: super::enums::EProvideDeckFeedbackPreference) {
        self.provide_deck_feedback = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string additional_languages = 13;

    pub fn additional_languages(&self) -> &str {
        match self.additional_languages.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_additional_languages(&mut self) {
        self.additional_languages = ::std::option::Option::None;
    }

    pub fn has_additional_languages(&self) -> bool {
        self.additional_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_languages(&mut self, v: ::std::string::String) {
        self.additional_languages = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_languages(&mut self) -> &mut ::std::string::String {
        if self.additional_languages.is_none() {
            self.additional_languages = ::std::option::Option::Some(::std::string::String::new());
        }
        self.additional_languages.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_languages(&mut self) -> ::std::string::String {
        self.additional_languages.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_language",
            |m: &CStore_UserPreferences| { &m.primary_language },
            |m: &mut CStore_UserPreferences| { &mut m.primary_language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary_languages",
            |m: &CStore_UserPreferences| { &m.secondary_languages },
            |m: &mut CStore_UserPreferences| { &mut m.secondary_languages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_windows",
            |m: &CStore_UserPreferences| { &m.platform_windows },
            |m: &mut CStore_UserPreferences| { &mut m.platform_windows },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_mac",
            |m: &CStore_UserPreferences| { &m.platform_mac },
            |m: &mut CStore_UserPreferences| { &mut m.platform_mac },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_linux",
            |m: &CStore_UserPreferences| { &m.platform_linux },
            |m: &mut CStore_UserPreferences| { &mut m.platform_linux },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_updated",
            |m: &CStore_UserPreferences| { &m.timestamp_updated },
            |m: &mut CStore_UserPreferences| { &mut m.timestamp_updated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hide_store_broadcast",
            |m: &CStore_UserPreferences| { &m.hide_store_broadcast },
            |m: &mut CStore_UserPreferences| { &mut m.hide_store_broadcast },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "review_score_preference",
            |m: &CStore_UserPreferences| { &m.review_score_preference },
            |m: &mut CStore_UserPreferences| { &mut m.review_score_preference },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_content_descriptor_preferences_updated",
            |m: &CStore_UserPreferences| { &m.timestamp_content_descriptor_preferences_updated },
            |m: &mut CStore_UserPreferences| { &mut m.timestamp_content_descriptor_preferences_updated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "provide_deck_feedback",
            |m: &CStore_UserPreferences| { &m.provide_deck_feedback },
            |m: &mut CStore_UserPreferences| { &mut m.provide_deck_feedback },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_languages",
            |m: &CStore_UserPreferences| { &m.additional_languages },
            |m: &mut CStore_UserPreferences| { &mut m.additional_languages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_UserPreferences>(
            "CStore_UserPreferences",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_UserPreferences {
    const NAME: &'static str = "CStore_UserPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.primary_language = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.secondary_languages = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.platform_windows = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.platform_mac = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.platform_linux = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.timestamp_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.hide_store_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.review_score_preference = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.provide_deck_feedback = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                106 => {
                    self.additional_languages = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.primary_language {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.secondary_languages {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.platform_windows {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_mac {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_linux {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.hide_store_broadcast {
            my_size += 1 + 1;
        }
        if let Some(v) = self.review_score_preference {
            my_size += crate::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.timestamp_content_descriptor_preferences_updated {
            my_size += crate::rt::int32_size(11, v);
        }
        if let Some(v) = self.provide_deck_feedback {
            my_size += crate::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.additional_languages.as_ref() {
            my_size += crate::rt::string_size(13, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.primary_language {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.secondary_languages {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.platform_windows {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.platform_mac {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.platform_linux {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.hide_store_broadcast {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.review_score_preference {
            os.write_enum(10, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp_content_descriptor_preferences_updated {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.provide_deck_feedback {
            os.write_enum(12, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.additional_languages.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_UserPreferences {
        CStore_UserPreferences::new()
    }

    fn clear(&mut self) {
        self.primary_language = ::std::option::Option::None;
        self.secondary_languages = ::std::option::Option::None;
        self.platform_windows = ::std::option::Option::None;
        self.platform_mac = ::std::option::Option::None;
        self.platform_linux = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.hide_store_broadcast = ::std::option::Option::None;
        self.review_score_preference = ::std::option::Option::None;
        self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::None;
        self.provide_deck_feedback = ::std::option::Option::None;
        self.additional_languages = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_UserPreferences {
        static instance: CStore_UserPreferences = CStore_UserPreferences {
            primary_language: ::std::option::Option::None,
            secondary_languages: ::std::option::Option::None,
            platform_windows: ::std::option::Option::None,
            platform_mac: ::std::option::Option::None,
            platform_linux: ::std::option::Option::None,
            timestamp_updated: ::std::option::Option::None,
            hide_store_broadcast: ::std::option::Option::None,
            review_score_preference: ::std::option::Option::None,
            timestamp_content_descriptor_preferences_updated: ::std::option::Option::None,
            provide_deck_feedback: ::std::option::Option::None,
            additional_languages: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_UserPreferences {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_UserPreferences").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_UserPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_UserPreferences {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_UserTagPreferences)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_UserTagPreferences {
    // message fields
    // @@protoc_insertion_point(field:CStore_UserTagPreferences.tags_to_exclude)
    pub tags_to_exclude: ::std::vec::Vec<cstore_user_tag_preferences::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_UserTagPreferences.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_UserTagPreferences {
    fn default() -> &'a CStore_UserTagPreferences {
        <CStore_UserTagPreferences as crate::Message>::default_instance()
    }
}

impl CStore_UserTagPreferences {
    pub fn new() -> CStore_UserTagPreferences {
        ::std::default::Default::default()
    }

    // repeated .CStore_UserTagPreferences.Tag tags_to_exclude = 1;

    pub fn tags_to_exclude(&self) -> &[cstore_user_tag_preferences::Tag] {
        &self.tags_to_exclude
    }

    pub fn clear_tags_to_exclude(&mut self) {
        self.tags_to_exclude.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags_to_exclude(&mut self, v: ::std::vec::Vec<cstore_user_tag_preferences::Tag>) {
        self.tags_to_exclude = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags_to_exclude(&mut self) -> &mut ::std::vec::Vec<cstore_user_tag_preferences::Tag> {
        &mut self.tags_to_exclude
    }

    // Take field
    pub fn take_tags_to_exclude(&mut self) -> ::std::vec::Vec<cstore_user_tag_preferences::Tag> {
        ::std::mem::replace(&mut self.tags_to_exclude, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags_to_exclude",
            |m: &CStore_UserTagPreferences| { &m.tags_to_exclude },
            |m: &mut CStore_UserTagPreferences| { &mut m.tags_to_exclude },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_UserTagPreferences>(
            "CStore_UserTagPreferences",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_UserTagPreferences {
    const NAME: &'static str = "CStore_UserTagPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags_to_exclude.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags_to_exclude {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.tags_to_exclude {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_UserTagPreferences {
        CStore_UserTagPreferences::new()
    }

    fn clear(&mut self) {
        self.tags_to_exclude.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_UserTagPreferences {
        static instance: CStore_UserTagPreferences = CStore_UserTagPreferences {
            tags_to_exclude: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_UserTagPreferences {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_UserTagPreferences").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_UserTagPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_UserTagPreferences {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStore_UserTagPreferences`
pub mod cstore_user_tag_preferences {
    // @@protoc_insertion_point(message:CStore_UserTagPreferences.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_UserTagPreferences.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_UserTagPreferences.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStore_UserTagPreferences.Tag.timestamp_added)
        pub timestamp_added: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_UserTagPreferences.Tag.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as crate::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 timestamp_added = 3;

        pub fn timestamp_added(&self) -> u32 {
            self.timestamp_added.unwrap_or(0)
        }

        pub fn clear_timestamp_added(&mut self) {
            self.timestamp_added = ::std::option::Option::None;
        }

        pub fn has_timestamp_added(&self) -> bool {
            self.timestamp_added.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_added(&mut self, v: u32) {
            self.timestamp_added = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "tagid",
                |m: &Tag| { &m.tagid },
                |m: &mut Tag| { &mut m.tagid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Tag| { &m.name },
                |m: &mut Tag| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp_added",
                |m: &Tag| { &m.timestamp_added },
                |m: &mut Tag| { &mut m.timestamp_added },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "CStore_UserTagPreferences.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.timestamp_added = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.timestamp_added {
                my_size += crate::rt::uint32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.timestamp_added {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.timestamp_added = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                timestamp_added: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Tag {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStore_UserTagPreferences.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Tag {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStore_GetStorePreferences_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetStorePreferences_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetStorePreferences_Response.preferences)
    pub preferences: crate::MessageField<CStore_UserPreferences>,
    // @@protoc_insertion_point(field:CStore_GetStorePreferences_Response.tag_preferences)
    pub tag_preferences: crate::MessageField<CStore_UserTagPreferences>,
    // @@protoc_insertion_point(field:CStore_GetStorePreferences_Response.content_descriptor_preferences)
    pub content_descriptor_preferences: crate::MessageField<super::steammessages_base::UserContentDescriptorPreferences>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetStorePreferences_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetStorePreferences_Response {
    fn default() -> &'a CStore_GetStorePreferences_Response {
        <CStore_GetStorePreferences_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetStorePreferences_Response {
    pub fn new() -> CStore_GetStorePreferences_Response {
        ::std::default::Default::default()
    }

    // optional .CStore_UserPreferences preferences = 1;

    pub fn preferences(&self) -> &CStore_UserPreferences {
        self.preferences.as_ref().unwrap_or_else(|| <CStore_UserPreferences as crate::Message>::default_instance())
    }

    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CStore_UserPreferences) {
        self.preferences = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CStore_UserPreferences {
        self.preferences.mut_or_insert_default()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CStore_UserPreferences {
        self.preferences.take().unwrap_or_else(|| CStore_UserPreferences::new())
    }

    // optional .CStore_UserTagPreferences tag_preferences = 2;

    pub fn tag_preferences(&self) -> &CStore_UserTagPreferences {
        self.tag_preferences.as_ref().unwrap_or_else(|| <CStore_UserTagPreferences as crate::Message>::default_instance())
    }

    pub fn clear_tag_preferences(&mut self) {
        self.tag_preferences.clear();
    }

    pub fn has_tag_preferences(&self) -> bool {
        self.tag_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag_preferences(&mut self, v: CStore_UserTagPreferences) {
        self.tag_preferences = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag_preferences(&mut self) -> &mut CStore_UserTagPreferences {
        self.tag_preferences.mut_or_insert_default()
    }

    // Take field
    pub fn take_tag_preferences(&mut self) -> CStore_UserTagPreferences {
        self.tag_preferences.take().unwrap_or_else(|| CStore_UserTagPreferences::new())
    }

    // optional .UserContentDescriptorPreferences content_descriptor_preferences = 3;

    pub fn content_descriptor_preferences(&self) -> &super::steammessages_base::UserContentDescriptorPreferences {
        self.content_descriptor_preferences.as_ref().unwrap_or_else(|| <super::steammessages_base::UserContentDescriptorPreferences as crate::Message>::default_instance())
    }

    pub fn clear_content_descriptor_preferences(&mut self) {
        self.content_descriptor_preferences.clear();
    }

    pub fn has_content_descriptor_preferences(&self) -> bool {
        self.content_descriptor_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_descriptor_preferences(&mut self, v: super::steammessages_base::UserContentDescriptorPreferences) {
        self.content_descriptor_preferences = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_descriptor_preferences(&mut self) -> &mut super::steammessages_base::UserContentDescriptorPreferences {
        self.content_descriptor_preferences.mut_or_insert_default()
    }

    // Take field
    pub fn take_content_descriptor_preferences(&mut self) -> super::steammessages_base::UserContentDescriptorPreferences {
        self.content_descriptor_preferences.take().unwrap_or_else(|| super::steammessages_base::UserContentDescriptorPreferences::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStore_UserPreferences>(
            "preferences",
            |m: &CStore_GetStorePreferences_Response| { &m.preferences },
            |m: &mut CStore_GetStorePreferences_Response| { &mut m.preferences },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStore_UserTagPreferences>(
            "tag_preferences",
            |m: &CStore_GetStorePreferences_Response| { &m.tag_preferences },
            |m: &mut CStore_GetStorePreferences_Response| { &mut m.tag_preferences },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::UserContentDescriptorPreferences>(
            "content_descriptor_preferences",
            |m: &CStore_GetStorePreferences_Response| { &m.content_descriptor_preferences },
            |m: &mut CStore_GetStorePreferences_Response| { &mut m.content_descriptor_preferences },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetStorePreferences_Response>(
            "CStore_GetStorePreferences_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetStorePreferences_Response {
    const NAME: &'static str = "CStore_GetStorePreferences_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.preferences)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.tag_preferences)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.content_descriptor_preferences)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.preferences.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetStorePreferences_Response {
        CStore_GetStorePreferences_Response::new()
    }

    fn clear(&mut self) {
        self.preferences.clear();
        self.tag_preferences.clear();
        self.content_descriptor_preferences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetStorePreferences_Response {
        static instance: CStore_GetStorePreferences_Response = CStore_GetStorePreferences_Response {
            preferences: crate::MessageField::none(),
            tag_preferences: crate::MessageField::none(),
            content_descriptor_preferences: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetStorePreferences_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetStorePreferences_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetStorePreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetStorePreferences_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetTrendingAppsAmongFriends_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTrendingAppsAmongFriends_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Request.num_apps)
    pub num_apps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Request.num_top_friends)
    pub num_top_friends: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTrendingAppsAmongFriends_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTrendingAppsAmongFriends_Request {
    fn default() -> &'a CStore_GetTrendingAppsAmongFriends_Request {
        <CStore_GetTrendingAppsAmongFriends_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetTrendingAppsAmongFriends_Request {
    pub fn new() -> CStore_GetTrendingAppsAmongFriends_Request {
        ::std::default::Default::default()
    }

    // optional uint32 num_apps = 1;

    pub fn num_apps(&self) -> u32 {
        self.num_apps.unwrap_or(0)
    }

    pub fn clear_num_apps(&mut self) {
        self.num_apps = ::std::option::Option::None;
    }

    pub fn has_num_apps(&self) -> bool {
        self.num_apps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_apps(&mut self, v: u32) {
        self.num_apps = ::std::option::Option::Some(v);
    }

    // optional uint32 num_top_friends = 2;

    pub fn num_top_friends(&self) -> u32 {
        self.num_top_friends.unwrap_or(0)
    }

    pub fn clear_num_top_friends(&mut self) {
        self.num_top_friends = ::std::option::Option::None;
    }

    pub fn has_num_top_friends(&self) -> bool {
        self.num_top_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_top_friends(&mut self, v: u32) {
        self.num_top_friends = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_apps",
            |m: &CStore_GetTrendingAppsAmongFriends_Request| { &m.num_apps },
            |m: &mut CStore_GetTrendingAppsAmongFriends_Request| { &mut m.num_apps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_top_friends",
            |m: &CStore_GetTrendingAppsAmongFriends_Request| { &m.num_top_friends },
            |m: &mut CStore_GetTrendingAppsAmongFriends_Request| { &mut m.num_top_friends },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetTrendingAppsAmongFriends_Request>(
            "CStore_GetTrendingAppsAmongFriends_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetTrendingAppsAmongFriends_Request {
    const NAME: &'static str = "CStore_GetTrendingAppsAmongFriends_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_apps = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_top_friends = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_apps {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_top_friends {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.num_apps {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_top_friends {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTrendingAppsAmongFriends_Request {
        CStore_GetTrendingAppsAmongFriends_Request::new()
    }

    fn clear(&mut self) {
        self.num_apps = ::std::option::Option::None;
        self.num_top_friends = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTrendingAppsAmongFriends_Request {
        static instance: CStore_GetTrendingAppsAmongFriends_Request = CStore_GetTrendingAppsAmongFriends_Request {
            num_apps: ::std::option::Option::None,
            num_top_friends: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetTrendingAppsAmongFriends_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetTrendingAppsAmongFriends_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetTrendingAppsAmongFriends_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetTrendingAppsAmongFriends_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetTrendingAppsAmongFriends_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTrendingAppsAmongFriends_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.trending_apps)
    pub trending_apps: ::std::vec::Vec<cstore_get_trending_apps_among_friends_response::TrendingAppData>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTrendingAppsAmongFriends_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTrendingAppsAmongFriends_Response {
    fn default() -> &'a CStore_GetTrendingAppsAmongFriends_Response {
        <CStore_GetTrendingAppsAmongFriends_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetTrendingAppsAmongFriends_Response {
    pub fn new() -> CStore_GetTrendingAppsAmongFriends_Response {
        ::std::default::Default::default()
    }

    // repeated .CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData trending_apps = 1;

    pub fn trending_apps(&self) -> &[cstore_get_trending_apps_among_friends_response::TrendingAppData] {
        &self.trending_apps
    }

    pub fn clear_trending_apps(&mut self) {
        self.trending_apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_trending_apps(&mut self, v: ::std::vec::Vec<cstore_get_trending_apps_among_friends_response::TrendingAppData>) {
        self.trending_apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trending_apps(&mut self) -> &mut ::std::vec::Vec<cstore_get_trending_apps_among_friends_response::TrendingAppData> {
        &mut self.trending_apps
    }

    // Take field
    pub fn take_trending_apps(&mut self) -> ::std::vec::Vec<cstore_get_trending_apps_among_friends_response::TrendingAppData> {
        ::std::mem::replace(&mut self.trending_apps, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trending_apps",
            |m: &CStore_GetTrendingAppsAmongFriends_Response| { &m.trending_apps },
            |m: &mut CStore_GetTrendingAppsAmongFriends_Response| { &mut m.trending_apps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetTrendingAppsAmongFriends_Response>(
            "CStore_GetTrendingAppsAmongFriends_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetTrendingAppsAmongFriends_Response {
    const NAME: &'static str = "CStore_GetTrendingAppsAmongFriends_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trending_apps.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.trending_apps {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.trending_apps {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTrendingAppsAmongFriends_Response {
        CStore_GetTrendingAppsAmongFriends_Response::new()
    }

    fn clear(&mut self) {
        self.trending_apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTrendingAppsAmongFriends_Response {
        static instance: CStore_GetTrendingAppsAmongFriends_Response = CStore_GetTrendingAppsAmongFriends_Response {
            trending_apps: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetTrendingAppsAmongFriends_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetTrendingAppsAmongFriends_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetTrendingAppsAmongFriends_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetTrendingAppsAmongFriends_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStore_GetTrendingAppsAmongFriends_Response`
pub mod cstore_get_trending_apps_among_friends_response {
    // @@protoc_insertion_point(message:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TrendingAppData {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.steamids_top_friends)
        pub steamids_top_friends: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.total_friends)
        pub total_friends: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TrendingAppData {
        fn default() -> &'a TrendingAppData {
            <TrendingAppData as crate::Message>::default_instance()
        }
    }

    impl TrendingAppData {
        pub fn new() -> TrendingAppData {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // repeated uint64 steamids_top_friends = 2;

        pub fn steamids_top_friends(&self) -> &[u64] {
            &self.steamids_top_friends
        }

        pub fn clear_steamids_top_friends(&mut self) {
            self.steamids_top_friends.clear();
        }

        // Param is passed by value, moved
        pub fn set_steamids_top_friends(&mut self, v: ::std::vec::Vec<u64>) {
            self.steamids_top_friends = v;
        }

        // Mutable pointer to the field.
        pub fn mut_steamids_top_friends(&mut self) -> &mut ::std::vec::Vec<u64> {
            &mut self.steamids_top_friends
        }

        // Take field
        pub fn take_steamids_top_friends(&mut self) -> ::std::vec::Vec<u64> {
            ::std::mem::replace(&mut self.steamids_top_friends, ::std::vec::Vec::new())
        }

        // optional uint32 total_friends = 3;

        pub fn total_friends(&self) -> u32 {
            self.total_friends.unwrap_or(0)
        }

        pub fn clear_total_friends(&mut self) {
            self.total_friends = ::std::option::Option::None;
        }

        pub fn has_total_friends(&self) -> bool {
            self.total_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_friends(&mut self, v: u32) {
            self.total_friends = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &TrendingAppData| { &m.appid },
                |m: &mut TrendingAppData| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "steamids_top_friends",
                |m: &TrendingAppData| { &m.steamids_top_friends },
                |m: &mut TrendingAppData| { &mut m.steamids_top_friends },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_friends",
                |m: &TrendingAppData| { &m.total_friends },
                |m: &mut TrendingAppData| { &mut m.total_friends },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<TrendingAppData>(
                "CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for TrendingAppData {
        const NAME: &'static str = "TrendingAppData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint64_into(&mut self.steamids_top_friends)?;
                    },
                    16 => {
                        self.steamids_top_friends.push(is.read_uint64()?);
                    },
                    24 => {
                        self.total_friends = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            for value in &self.steamids_top_friends {
                my_size += crate::rt::uint64_size(2, *value);
            };
            if let Some(v) = self.total_friends {
                my_size += crate::rt::uint32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.steamids_top_friends {
                os.write_uint64(2, *v)?;
            };
            if let Some(v) = self.total_friends {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TrendingAppData {
            TrendingAppData::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.steamids_top_friends.clear();
            self.total_friends = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TrendingAppData {
            static instance: TrendingAppData = TrendingAppData {
                appid: ::std::option::Option::None,
                steamids_top_friends: ::std::vec::Vec::new(),
                total_friends: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for TrendingAppData {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TrendingAppData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for TrendingAppData {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStore_MigratePartnerLinkTracking_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_MigratePartnerLinkTracking_Notification {
    // message fields
    // @@protoc_insertion_point(field:CStore_MigratePartnerLinkTracking_Notification.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_MigratePartnerLinkTracking_Notification.browserid)
    pub browserid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_MigratePartnerLinkTracking_Notification.backfill_source)
    pub backfill_source: ::std::option::Option<crate::EnumOrUnknown<EPartnerLinkTrackingBackfillSource>>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_MigratePartnerLinkTracking_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_MigratePartnerLinkTracking_Notification {
    fn default() -> &'a CStore_MigratePartnerLinkTracking_Notification {
        <CStore_MigratePartnerLinkTracking_Notification as crate::Message>::default_instance()
    }
}

impl CStore_MigratePartnerLinkTracking_Notification {
    pub fn new() -> CStore_MigratePartnerLinkTracking_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 browserid = 2;

    pub fn browserid(&self) -> u64 {
        self.browserid.unwrap_or(0)
    }

    pub fn clear_browserid(&mut self) {
        self.browserid = ::std::option::Option::None;
    }

    pub fn has_browserid(&self) -> bool {
        self.browserid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browserid(&mut self, v: u64) {
        self.browserid = ::std::option::Option::Some(v);
    }

    // optional .EPartnerLinkTrackingBackfillSource backfill_source = 3;

    pub fn backfill_source(&self) -> EPartnerLinkTrackingBackfillSource {
        match self.backfill_source {
            Some(e) => e.enum_value_or(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_None),
            None => EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_None,
        }
    }

    pub fn clear_backfill_source(&mut self) {
        self.backfill_source = ::std::option::Option::None;
    }

    pub fn has_backfill_source(&self) -> bool {
        self.backfill_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backfill_source(&mut self, v: EPartnerLinkTrackingBackfillSource) {
        self.backfill_source = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CStore_MigratePartnerLinkTracking_Notification| { &m.accountid },
            |m: &mut CStore_MigratePartnerLinkTracking_Notification| { &mut m.accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browserid",
            |m: &CStore_MigratePartnerLinkTracking_Notification| { &m.browserid },
            |m: &mut CStore_MigratePartnerLinkTracking_Notification| { &mut m.browserid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "backfill_source",
            |m: &CStore_MigratePartnerLinkTracking_Notification| { &m.backfill_source },
            |m: &mut CStore_MigratePartnerLinkTracking_Notification| { &mut m.backfill_source },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_MigratePartnerLinkTracking_Notification>(
            "CStore_MigratePartnerLinkTracking_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_MigratePartnerLinkTracking_Notification {
    const NAME: &'static str = "CStore_MigratePartnerLinkTracking_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.browserid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.backfill_source = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.browserid {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.backfill_source {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.browserid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.backfill_source {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_MigratePartnerLinkTracking_Notification {
        CStore_MigratePartnerLinkTracking_Notification::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.browserid = ::std::option::Option::None;
        self.backfill_source = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_MigratePartnerLinkTracking_Notification {
        static instance: CStore_MigratePartnerLinkTracking_Notification = CStore_MigratePartnerLinkTracking_Notification {
            accountid: ::std::option::Option::None,
            browserid: ::std::option::Option::None,
            backfill_source: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_MigratePartnerLinkTracking_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_MigratePartnerLinkTracking_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_MigratePartnerLinkTracking_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_MigratePartnerLinkTracking_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_UpdatePackageReservations_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_UpdatePackageReservations_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_UpdatePackageReservations_Request.packages_to_reserve)
    pub packages_to_reserve: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStore_UpdatePackageReservations_Request.packages_to_unreserve)
    pub packages_to_unreserve: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStore_UpdatePackageReservations_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_UpdatePackageReservations_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_UpdatePackageReservations_Request {
    fn default() -> &'a CStore_UpdatePackageReservations_Request {
        <CStore_UpdatePackageReservations_Request as crate::Message>::default_instance()
    }
}

impl CStore_UpdatePackageReservations_Request {
    pub fn new() -> CStore_UpdatePackageReservations_Request {
        ::std::default::Default::default()
    }

    // repeated uint32 packages_to_reserve = 1;

    pub fn packages_to_reserve(&self) -> &[u32] {
        &self.packages_to_reserve
    }

    pub fn clear_packages_to_reserve(&mut self) {
        self.packages_to_reserve.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages_to_reserve(&mut self, v: ::std::vec::Vec<u32>) {
        self.packages_to_reserve = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages_to_reserve(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packages_to_reserve
    }

    // Take field
    pub fn take_packages_to_reserve(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packages_to_reserve, ::std::vec::Vec::new())
    }

    // repeated uint32 packages_to_unreserve = 2;

    pub fn packages_to_unreserve(&self) -> &[u32] {
        &self.packages_to_unreserve
    }

    pub fn clear_packages_to_unreserve(&mut self) {
        self.packages_to_unreserve.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages_to_unreserve(&mut self, v: ::std::vec::Vec<u32>) {
        self.packages_to_unreserve = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages_to_unreserve(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packages_to_unreserve
    }

    // Take field
    pub fn take_packages_to_unreserve(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packages_to_unreserve, ::std::vec::Vec::new())
    }

    // optional string country_code = 3;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packages_to_reserve",
            |m: &CStore_UpdatePackageReservations_Request| { &m.packages_to_reserve },
            |m: &mut CStore_UpdatePackageReservations_Request| { &mut m.packages_to_reserve },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packages_to_unreserve",
            |m: &CStore_UpdatePackageReservations_Request| { &m.packages_to_unreserve },
            |m: &mut CStore_UpdatePackageReservations_Request| { &mut m.packages_to_unreserve },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CStore_UpdatePackageReservations_Request| { &m.country_code },
            |m: &mut CStore_UpdatePackageReservations_Request| { &mut m.country_code },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_UpdatePackageReservations_Request>(
            "CStore_UpdatePackageReservations_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_UpdatePackageReservations_Request {
    const NAME: &'static str = "CStore_UpdatePackageReservations_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.packages_to_reserve)?;
                },
                8 => {
                    self.packages_to_reserve.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.packages_to_unreserve)?;
                },
                16 => {
                    self.packages_to_unreserve.push(is.read_uint32()?);
                },
                26 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.packages_to_reserve {
            my_size += crate::rt::uint32_size(1, *value);
        };
        for value in &self.packages_to_unreserve {
            my_size += crate::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.packages_to_reserve {
            os.write_uint32(1, *v)?;
        };
        for v in &self.packages_to_unreserve {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_UpdatePackageReservations_Request {
        CStore_UpdatePackageReservations_Request::new()
    }

    fn clear(&mut self) {
        self.packages_to_reserve.clear();
        self.packages_to_unreserve.clear();
        self.country_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_UpdatePackageReservations_Request {
        static instance: CStore_UpdatePackageReservations_Request = CStore_UpdatePackageReservations_Request {
            packages_to_reserve: ::std::vec::Vec::new(),
            packages_to_unreserve: ::std::vec::Vec::new(),
            country_code: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_UpdatePackageReservations_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_UpdatePackageReservations_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_UpdatePackageReservations_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_UpdatePackageReservations_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_UpdatePackageReservations_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_UpdatePackageReservations_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_UpdatePackageReservations_Response.reservation_status)
    pub reservation_status: ::std::vec::Vec<super::steammessages_base::CPackageReservationStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_UpdatePackageReservations_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_UpdatePackageReservations_Response {
    fn default() -> &'a CStore_UpdatePackageReservations_Response {
        <CStore_UpdatePackageReservations_Response as crate::Message>::default_instance()
    }
}

impl CStore_UpdatePackageReservations_Response {
    pub fn new() -> CStore_UpdatePackageReservations_Response {
        ::std::default::Default::default()
    }

    // repeated .CPackageReservationStatus reservation_status = 1;

    pub fn reservation_status(&self) -> &[super::steammessages_base::CPackageReservationStatus] {
        &self.reservation_status
    }

    pub fn clear_reservation_status(&mut self) {
        self.reservation_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_reservation_status(&mut self, v: ::std::vec::Vec<super::steammessages_base::CPackageReservationStatus>) {
        self.reservation_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reservation_status(&mut self) -> &mut ::std::vec::Vec<super::steammessages_base::CPackageReservationStatus> {
        &mut self.reservation_status
    }

    // Take field
    pub fn take_reservation_status(&mut self) -> ::std::vec::Vec<super::steammessages_base::CPackageReservationStatus> {
        ::std::mem::replace(&mut self.reservation_status, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reservation_status",
            |m: &CStore_UpdatePackageReservations_Response| { &m.reservation_status },
            |m: &mut CStore_UpdatePackageReservations_Response| { &mut m.reservation_status },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_UpdatePackageReservations_Response>(
            "CStore_UpdatePackageReservations_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_UpdatePackageReservations_Response {
    const NAME: &'static str = "CStore_UpdatePackageReservations_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reservation_status.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reservation_status {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.reservation_status {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_UpdatePackageReservations_Response {
        CStore_UpdatePackageReservations_Response::new()
    }

    fn clear(&mut self) {
        self.reservation_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_UpdatePackageReservations_Response {
        static instance: CStore_UpdatePackageReservations_Response = CStore_UpdatePackageReservations_Response {
            reservation_status: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_UpdatePackageReservations_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_UpdatePackageReservations_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_UpdatePackageReservations_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_UpdatePackageReservations_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CReservationPositionMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CReservationPositionMessage {
    // message fields
    // @@protoc_insertion_point(field:CReservationPositionMessage.edistributor)
    pub edistributor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReservationPositionMessage.product_identifier)
    pub product_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CReservationPositionMessage.start_queue_position)
    pub start_queue_position: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReservationPositionMessage.rtime_estimated_notification)
    pub rtime_estimated_notification: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReservationPositionMessage.localization_token)
    pub localization_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CReservationPositionMessage.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReservationPositionMessage.rtime_created)
    pub rtime_created: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CReservationPositionMessage.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CReservationPositionMessage {
    fn default() -> &'a CReservationPositionMessage {
        <CReservationPositionMessage as crate::Message>::default_instance()
    }
}

impl CReservationPositionMessage {
    pub fn new() -> CReservationPositionMessage {
        ::std::default::Default::default()
    }

    // optional uint32 edistributor = 1;

    pub fn edistributor(&self) -> u32 {
        self.edistributor.unwrap_or(0)
    }

    pub fn clear_edistributor(&mut self) {
        self.edistributor = ::std::option::Option::None;
    }

    pub fn has_edistributor(&self) -> bool {
        self.edistributor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edistributor(&mut self, v: u32) {
        self.edistributor = ::std::option::Option::Some(v);
    }

    // optional string product_identifier = 2;

    pub fn product_identifier(&self) -> &str {
        match self.product_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product_identifier(&mut self) {
        self.product_identifier = ::std::option::Option::None;
    }

    pub fn has_product_identifier(&self) -> bool {
        self.product_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_identifier(&mut self, v: ::std::string::String) {
        self.product_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_identifier(&mut self) -> &mut ::std::string::String {
        if self.product_identifier.is_none() {
            self.product_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_identifier(&mut self) -> ::std::string::String {
        self.product_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 start_queue_position = 3;

    pub fn start_queue_position(&self) -> u32 {
        self.start_queue_position.unwrap_or(0)
    }

    pub fn clear_start_queue_position(&mut self) {
        self.start_queue_position = ::std::option::Option::None;
    }

    pub fn has_start_queue_position(&self) -> bool {
        self.start_queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_queue_position(&mut self, v: u32) {
        self.start_queue_position = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_estimated_notification = 4;

    pub fn rtime_estimated_notification(&self) -> u32 {
        self.rtime_estimated_notification.unwrap_or(0)
    }

    pub fn clear_rtime_estimated_notification(&mut self) {
        self.rtime_estimated_notification = ::std::option::Option::None;
    }

    pub fn has_rtime_estimated_notification(&self) -> bool {
        self.rtime_estimated_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_estimated_notification(&mut self, v: u32) {
        self.rtime_estimated_notification = ::std::option::Option::Some(v);
    }

    // optional string localization_token = 5;

    pub fn localization_token(&self) -> &str {
        match self.localization_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localization_token(&mut self) {
        self.localization_token = ::std::option::Option::None;
    }

    pub fn has_localization_token(&self) -> bool {
        self.localization_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localization_token(&mut self, v: ::std::string::String) {
        self.localization_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localization_token(&mut self) -> &mut ::std::string::String {
        if self.localization_token.is_none() {
            self.localization_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localization_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_localization_token(&mut self) -> ::std::string::String {
        self.localization_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid = 6;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_created = 7;

    pub fn rtime_created(&self) -> u32 {
        self.rtime_created.unwrap_or(0)
    }

    pub fn clear_rtime_created(&mut self) {
        self.rtime_created = ::std::option::Option::None;
    }

    pub fn has_rtime_created(&self) -> bool {
        self.rtime_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_created(&mut self, v: u32) {
        self.rtime_created = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edistributor",
            |m: &CReservationPositionMessage| { &m.edistributor },
            |m: &mut CReservationPositionMessage| { &mut m.edistributor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "product_identifier",
            |m: &CReservationPositionMessage| { &m.product_identifier },
            |m: &mut CReservationPositionMessage| { &mut m.product_identifier },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_queue_position",
            |m: &CReservationPositionMessage| { &m.start_queue_position },
            |m: &mut CReservationPositionMessage| { &mut m.start_queue_position },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_estimated_notification",
            |m: &CReservationPositionMessage| { &m.rtime_estimated_notification },
            |m: &mut CReservationPositionMessage| { &mut m.rtime_estimated_notification },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "localization_token",
            |m: &CReservationPositionMessage| { &m.localization_token },
            |m: &mut CReservationPositionMessage| { &mut m.localization_token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CReservationPositionMessage| { &m.accountid },
            |m: &mut CReservationPositionMessage| { &mut m.accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_created",
            |m: &CReservationPositionMessage| { &m.rtime_created },
            |m: &mut CReservationPositionMessage| { &mut m.rtime_created },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CReservationPositionMessage>(
            "CReservationPositionMessage",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CReservationPositionMessage {
    const NAME: &'static str = "CReservationPositionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.edistributor = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.product_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.start_queue_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rtime_estimated_notification = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.localization_token = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.rtime_created = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.edistributor {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.product_identifier.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.start_queue_position {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rtime_estimated_notification {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.localization_token.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.accountid {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.rtime_created {
            my_size += crate::rt::uint32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.edistributor {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.product_identifier.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.start_queue_position {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rtime_estimated_notification {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.localization_token.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rtime_created {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CReservationPositionMessage {
        CReservationPositionMessage::new()
    }

    fn clear(&mut self) {
        self.edistributor = ::std::option::Option::None;
        self.product_identifier = ::std::option::Option::None;
        self.start_queue_position = ::std::option::Option::None;
        self.rtime_estimated_notification = ::std::option::Option::None;
        self.localization_token = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.rtime_created = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CReservationPositionMessage {
        static instance: CReservationPositionMessage = CReservationPositionMessage {
            edistributor: ::std::option::Option::None,
            product_identifier: ::std::option::Option::None,
            start_queue_position: ::std::option::Option::None,
            rtime_estimated_notification: ::std::option::Option::None,
            localization_token: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            rtime_created: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CReservationPositionMessage {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CReservationPositionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CReservationPositionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CReservationPositionMessage {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_SetReservationPositionMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_SetReservationPositionMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_SetReservationPositionMessage_Request.settings)
    pub settings: ::std::vec::Vec<CReservationPositionMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_SetReservationPositionMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_SetReservationPositionMessage_Request {
    fn default() -> &'a CStore_SetReservationPositionMessage_Request {
        <CStore_SetReservationPositionMessage_Request as crate::Message>::default_instance()
    }
}

impl CStore_SetReservationPositionMessage_Request {
    pub fn new() -> CStore_SetReservationPositionMessage_Request {
        ::std::default::Default::default()
    }

    // repeated .CReservationPositionMessage settings = 1;

    pub fn settings(&self) -> &[CReservationPositionMessage] {
        &self.settings
    }

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: ::std::vec::Vec<CReservationPositionMessage>) {
        self.settings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_settings(&mut self) -> &mut ::std::vec::Vec<CReservationPositionMessage> {
        &mut self.settings
    }

    // Take field
    pub fn take_settings(&mut self) -> ::std::vec::Vec<CReservationPositionMessage> {
        ::std::mem::replace(&mut self.settings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "settings",
            |m: &CStore_SetReservationPositionMessage_Request| { &m.settings },
            |m: &mut CStore_SetReservationPositionMessage_Request| { &mut m.settings },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_SetReservationPositionMessage_Request>(
            "CStore_SetReservationPositionMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_SetReservationPositionMessage_Request {
    const NAME: &'static str = "CStore_SetReservationPositionMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.settings.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.settings {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_SetReservationPositionMessage_Request {
        CStore_SetReservationPositionMessage_Request::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_SetReservationPositionMessage_Request {
        static instance: CStore_SetReservationPositionMessage_Request = CStore_SetReservationPositionMessage_Request {
            settings: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_SetReservationPositionMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_SetReservationPositionMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_SetReservationPositionMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_SetReservationPositionMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_SetReservationPositionMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_SetReservationPositionMessage_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_SetReservationPositionMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_SetReservationPositionMessage_Response {
    fn default() -> &'a CStore_SetReservationPositionMessage_Response {
        <CStore_SetReservationPositionMessage_Response as crate::Message>::default_instance()
    }
}

impl CStore_SetReservationPositionMessage_Response {
    pub fn new() -> CStore_SetReservationPositionMessage_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_SetReservationPositionMessage_Response>(
            "CStore_SetReservationPositionMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_SetReservationPositionMessage_Response {
    const NAME: &'static str = "CStore_SetReservationPositionMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_SetReservationPositionMessage_Response {
        CStore_SetReservationPositionMessage_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_SetReservationPositionMessage_Response {
        static instance: CStore_SetReservationPositionMessage_Response = CStore_SetReservationPositionMessage_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_SetReservationPositionMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_SetReservationPositionMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_SetReservationPositionMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_SetReservationPositionMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_DeleteReservationPositionMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_DeleteReservationPositionMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_DeleteReservationPositionMessage_Request.edistributor)
    pub edistributor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_DeleteReservationPositionMessage_Request.product_identifier)
    pub product_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_DeleteReservationPositionMessage_Request.start_queue_position)
    pub start_queue_position: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_DeleteReservationPositionMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_DeleteReservationPositionMessage_Request {
    fn default() -> &'a CStore_DeleteReservationPositionMessage_Request {
        <CStore_DeleteReservationPositionMessage_Request as crate::Message>::default_instance()
    }
}

impl CStore_DeleteReservationPositionMessage_Request {
    pub fn new() -> CStore_DeleteReservationPositionMessage_Request {
        ::std::default::Default::default()
    }

    // optional uint32 edistributor = 1;

    pub fn edistributor(&self) -> u32 {
        self.edistributor.unwrap_or(0)
    }

    pub fn clear_edistributor(&mut self) {
        self.edistributor = ::std::option::Option::None;
    }

    pub fn has_edistributor(&self) -> bool {
        self.edistributor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edistributor(&mut self, v: u32) {
        self.edistributor = ::std::option::Option::Some(v);
    }

    // optional string product_identifier = 2;

    pub fn product_identifier(&self) -> &str {
        match self.product_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product_identifier(&mut self) {
        self.product_identifier = ::std::option::Option::None;
    }

    pub fn has_product_identifier(&self) -> bool {
        self.product_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_identifier(&mut self, v: ::std::string::String) {
        self.product_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_identifier(&mut self) -> &mut ::std::string::String {
        if self.product_identifier.is_none() {
            self.product_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_identifier(&mut self) -> ::std::string::String {
        self.product_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 start_queue_position = 3;

    pub fn start_queue_position(&self) -> u32 {
        self.start_queue_position.unwrap_or(0)
    }

    pub fn clear_start_queue_position(&mut self) {
        self.start_queue_position = ::std::option::Option::None;
    }

    pub fn has_start_queue_position(&self) -> bool {
        self.start_queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_queue_position(&mut self, v: u32) {
        self.start_queue_position = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edistributor",
            |m: &CStore_DeleteReservationPositionMessage_Request| { &m.edistributor },
            |m: &mut CStore_DeleteReservationPositionMessage_Request| { &mut m.edistributor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "product_identifier",
            |m: &CStore_DeleteReservationPositionMessage_Request| { &m.product_identifier },
            |m: &mut CStore_DeleteReservationPositionMessage_Request| { &mut m.product_identifier },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_queue_position",
            |m: &CStore_DeleteReservationPositionMessage_Request| { &m.start_queue_position },
            |m: &mut CStore_DeleteReservationPositionMessage_Request| { &mut m.start_queue_position },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_DeleteReservationPositionMessage_Request>(
            "CStore_DeleteReservationPositionMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_DeleteReservationPositionMessage_Request {
    const NAME: &'static str = "CStore_DeleteReservationPositionMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.edistributor = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.product_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.start_queue_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.edistributor {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.product_identifier.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.start_queue_position {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.edistributor {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.product_identifier.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.start_queue_position {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_DeleteReservationPositionMessage_Request {
        CStore_DeleteReservationPositionMessage_Request::new()
    }

    fn clear(&mut self) {
        self.edistributor = ::std::option::Option::None;
        self.product_identifier = ::std::option::Option::None;
        self.start_queue_position = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_DeleteReservationPositionMessage_Request {
        static instance: CStore_DeleteReservationPositionMessage_Request = CStore_DeleteReservationPositionMessage_Request {
            edistributor: ::std::option::Option::None,
            product_identifier: ::std::option::Option::None,
            start_queue_position: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_DeleteReservationPositionMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_DeleteReservationPositionMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_DeleteReservationPositionMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_DeleteReservationPositionMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_DeleteReservationPositionMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_DeleteReservationPositionMessage_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_DeleteReservationPositionMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_DeleteReservationPositionMessage_Response {
    fn default() -> &'a CStore_DeleteReservationPositionMessage_Response {
        <CStore_DeleteReservationPositionMessage_Response as crate::Message>::default_instance()
    }
}

impl CStore_DeleteReservationPositionMessage_Response {
    pub fn new() -> CStore_DeleteReservationPositionMessage_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_DeleteReservationPositionMessage_Response>(
            "CStore_DeleteReservationPositionMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_DeleteReservationPositionMessage_Response {
    const NAME: &'static str = "CStore_DeleteReservationPositionMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_DeleteReservationPositionMessage_Response {
        CStore_DeleteReservationPositionMessage_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_DeleteReservationPositionMessage_Response {
        static instance: CStore_DeleteReservationPositionMessage_Response = CStore_DeleteReservationPositionMessage_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_DeleteReservationPositionMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_DeleteReservationPositionMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_DeleteReservationPositionMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_DeleteReservationPositionMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetAllReservationPositionMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetAllReservationPositionMessages_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetAllReservationPositionMessages_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetAllReservationPositionMessages_Request {
    fn default() -> &'a CStore_GetAllReservationPositionMessages_Request {
        <CStore_GetAllReservationPositionMessages_Request as crate::Message>::default_instance()
    }
}

impl CStore_GetAllReservationPositionMessages_Request {
    pub fn new() -> CStore_GetAllReservationPositionMessages_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetAllReservationPositionMessages_Request>(
            "CStore_GetAllReservationPositionMessages_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetAllReservationPositionMessages_Request {
    const NAME: &'static str = "CStore_GetAllReservationPositionMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetAllReservationPositionMessages_Request {
        CStore_GetAllReservationPositionMessages_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetAllReservationPositionMessages_Request {
        static instance: CStore_GetAllReservationPositionMessages_Request = CStore_GetAllReservationPositionMessages_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetAllReservationPositionMessages_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetAllReservationPositionMessages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetAllReservationPositionMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetAllReservationPositionMessages_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_GetAllReservationPositionMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetAllReservationPositionMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetAllReservationPositionMessages_Response.settings)
    pub settings: ::std::vec::Vec<CReservationPositionMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetAllReservationPositionMessages_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetAllReservationPositionMessages_Response {
    fn default() -> &'a CStore_GetAllReservationPositionMessages_Response {
        <CStore_GetAllReservationPositionMessages_Response as crate::Message>::default_instance()
    }
}

impl CStore_GetAllReservationPositionMessages_Response {
    pub fn new() -> CStore_GetAllReservationPositionMessages_Response {
        ::std::default::Default::default()
    }

    // repeated .CReservationPositionMessage settings = 1;

    pub fn settings(&self) -> &[CReservationPositionMessage] {
        &self.settings
    }

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: ::std::vec::Vec<CReservationPositionMessage>) {
        self.settings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_settings(&mut self) -> &mut ::std::vec::Vec<CReservationPositionMessage> {
        &mut self.settings
    }

    // Take field
    pub fn take_settings(&mut self) -> ::std::vec::Vec<CReservationPositionMessage> {
        ::std::mem::replace(&mut self.settings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "settings",
            |m: &CStore_GetAllReservationPositionMessages_Response| { &m.settings },
            |m: &mut CStore_GetAllReservationPositionMessages_Response| { &mut m.settings },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_GetAllReservationPositionMessages_Response>(
            "CStore_GetAllReservationPositionMessages_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_GetAllReservationPositionMessages_Response {
    const NAME: &'static str = "CStore_GetAllReservationPositionMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.settings.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.settings {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetAllReservationPositionMessages_Response {
        CStore_GetAllReservationPositionMessages_Response::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetAllReservationPositionMessages_Response {
        static instance: CStore_GetAllReservationPositionMessages_Response = CStore_GetAllReservationPositionMessages_Response {
            settings: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_GetAllReservationPositionMessages_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_GetAllReservationPositionMessages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_GetAllReservationPositionMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_GetAllReservationPositionMessages_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_ReloadAllReservationPositionMessages_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_ReloadAllReservationPositionMessages_Notification {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_ReloadAllReservationPositionMessages_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_ReloadAllReservationPositionMessages_Notification {
    fn default() -> &'a CStore_ReloadAllReservationPositionMessages_Notification {
        <CStore_ReloadAllReservationPositionMessages_Notification as crate::Message>::default_instance()
    }
}

impl CStore_ReloadAllReservationPositionMessages_Notification {
    pub fn new() -> CStore_ReloadAllReservationPositionMessages_Notification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_ReloadAllReservationPositionMessages_Notification>(
            "CStore_ReloadAllReservationPositionMessages_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_ReloadAllReservationPositionMessages_Notification {
    const NAME: &'static str = "CStore_ReloadAllReservationPositionMessages_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_ReloadAllReservationPositionMessages_Notification {
        CStore_ReloadAllReservationPositionMessages_Notification::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_ReloadAllReservationPositionMessages_Notification {
        static instance: CStore_ReloadAllReservationPositionMessages_Notification = CStore_ReloadAllReservationPositionMessages_Notification {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_ReloadAllReservationPositionMessages_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_ReloadAllReservationPositionMessages_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_ReloadAllReservationPositionMessages_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_ReloadAllReservationPositionMessages_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamDeckCompatibility_SetFeedback_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_SetFeedback_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_SetFeedback_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_SetFeedback_Request.feedback)
    pub feedback: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESteamDeckCompatibilityFeedback>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_SetFeedback_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_SetFeedback_Request {
    fn default() -> &'a CSteamDeckCompatibility_SetFeedback_Request {
        <CSteamDeckCompatibility_SetFeedback_Request as crate::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_SetFeedback_Request {
    pub fn new() -> CSteamDeckCompatibility_SetFeedback_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .ESteamDeckCompatibilityFeedback feedback = 2;

    pub fn feedback(&self) -> super::enums::ESteamDeckCompatibilityFeedback {
        match self.feedback {
            Some(e) => e.enum_value_or(super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            None => super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset,
        }
    }

    pub fn clear_feedback(&mut self) {
        self.feedback = ::std::option::Option::None;
    }

    pub fn has_feedback(&self) -> bool {
        self.feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feedback(&mut self, v: super::enums::ESteamDeckCompatibilityFeedback) {
        self.feedback = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSteamDeckCompatibility_SetFeedback_Request| { &m.appid },
            |m: &mut CSteamDeckCompatibility_SetFeedback_Request| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "feedback",
            |m: &CSteamDeckCompatibility_SetFeedback_Request| { &m.feedback },
            |m: &mut CSteamDeckCompatibility_SetFeedback_Request| { &mut m.feedback },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamDeckCompatibility_SetFeedback_Request>(
            "CSteamDeckCompatibility_SetFeedback_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamDeckCompatibility_SetFeedback_Request {
    const NAME: &'static str = "CSteamDeckCompatibility_SetFeedback_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.feedback = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.feedback {
            my_size += crate::rt::int32_size(2, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.feedback {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_SetFeedback_Request {
        CSteamDeckCompatibility_SetFeedback_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.feedback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_SetFeedback_Request {
        static instance: CSteamDeckCompatibility_SetFeedback_Request = CSteamDeckCompatibility_SetFeedback_Request {
            appid: ::std::option::Option::None,
            feedback: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamDeckCompatibility_SetFeedback_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamDeckCompatibility_SetFeedback_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamDeckCompatibility_SetFeedback_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamDeckCompatibility_SetFeedback_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamDeckCompatibility_SetFeedback_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_SetFeedback_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_SetFeedback_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_SetFeedback_Response {
    fn default() -> &'a CSteamDeckCompatibility_SetFeedback_Response {
        <CSteamDeckCompatibility_SetFeedback_Response as crate::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_SetFeedback_Response {
    pub fn new() -> CSteamDeckCompatibility_SetFeedback_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamDeckCompatibility_SetFeedback_Response>(
            "CSteamDeckCompatibility_SetFeedback_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamDeckCompatibility_SetFeedback_Response {
    const NAME: &'static str = "CSteamDeckCompatibility_SetFeedback_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_SetFeedback_Response {
        CSteamDeckCompatibility_SetFeedback_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_SetFeedback_Response {
        static instance: CSteamDeckCompatibility_SetFeedback_Response = CSteamDeckCompatibility_SetFeedback_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamDeckCompatibility_SetFeedback_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamDeckCompatibility_SetFeedback_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamDeckCompatibility_SetFeedback_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamDeckCompatibility_SetFeedback_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamDeckCompatibility_ShouldPrompt_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_ShouldPrompt_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_ShouldPrompt_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_ShouldPrompt_Request {
    fn default() -> &'a CSteamDeckCompatibility_ShouldPrompt_Request {
        <CSteamDeckCompatibility_ShouldPrompt_Request as crate::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_ShouldPrompt_Request {
    pub fn new() -> CSteamDeckCompatibility_ShouldPrompt_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSteamDeckCompatibility_ShouldPrompt_Request| { &m.appid },
            |m: &mut CSteamDeckCompatibility_ShouldPrompt_Request| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamDeckCompatibility_ShouldPrompt_Request>(
            "CSteamDeckCompatibility_ShouldPrompt_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamDeckCompatibility_ShouldPrompt_Request {
    const NAME: &'static str = "CSteamDeckCompatibility_ShouldPrompt_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_ShouldPrompt_Request {
        CSteamDeckCompatibility_ShouldPrompt_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_ShouldPrompt_Request {
        static instance: CSteamDeckCompatibility_ShouldPrompt_Request = CSteamDeckCompatibility_ShouldPrompt_Request {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamDeckCompatibility_ShouldPrompt_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamDeckCompatibility_ShouldPrompt_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamDeckCompatibility_ShouldPrompt_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamDeckCompatibility_ShouldPrompt_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamDeckCompatibility_ShouldPrompt_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_ShouldPrompt_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Response.prompt)
    pub prompt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Response.feedback_eligible)
    pub feedback_eligible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Response.existing_feedback)
    pub existing_feedback: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESteamDeckCompatibilityFeedback>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_ShouldPrompt_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_ShouldPrompt_Response {
    fn default() -> &'a CSteamDeckCompatibility_ShouldPrompt_Response {
        <CSteamDeckCompatibility_ShouldPrompt_Response as crate::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_ShouldPrompt_Response {
    pub fn new() -> CSteamDeckCompatibility_ShouldPrompt_Response {
        ::std::default::Default::default()
    }

    // optional bool prompt = 1;

    pub fn prompt(&self) -> bool {
        self.prompt.unwrap_or(false)
    }

    pub fn clear_prompt(&mut self) {
        self.prompt = ::std::option::Option::None;
    }

    pub fn has_prompt(&self) -> bool {
        self.prompt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prompt(&mut self, v: bool) {
        self.prompt = ::std::option::Option::Some(v);
    }

    // optional bool feedback_eligible = 2;

    pub fn feedback_eligible(&self) -> bool {
        self.feedback_eligible.unwrap_or(false)
    }

    pub fn clear_feedback_eligible(&mut self) {
        self.feedback_eligible = ::std::option::Option::None;
    }

    pub fn has_feedback_eligible(&self) -> bool {
        self.feedback_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feedback_eligible(&mut self, v: bool) {
        self.feedback_eligible = ::std::option::Option::Some(v);
    }

    // optional .ESteamDeckCompatibilityFeedback existing_feedback = 3;

    pub fn existing_feedback(&self) -> super::enums::ESteamDeckCompatibilityFeedback {
        match self.existing_feedback {
            Some(e) => e.enum_value_or(super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            None => super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset,
        }
    }

    pub fn clear_existing_feedback(&mut self) {
        self.existing_feedback = ::std::option::Option::None;
    }

    pub fn has_existing_feedback(&self) -> bool {
        self.existing_feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_existing_feedback(&mut self, v: super::enums::ESteamDeckCompatibilityFeedback) {
        self.existing_feedback = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "prompt",
            |m: &CSteamDeckCompatibility_ShouldPrompt_Response| { &m.prompt },
            |m: &mut CSteamDeckCompatibility_ShouldPrompt_Response| { &mut m.prompt },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "feedback_eligible",
            |m: &CSteamDeckCompatibility_ShouldPrompt_Response| { &m.feedback_eligible },
            |m: &mut CSteamDeckCompatibility_ShouldPrompt_Response| { &mut m.feedback_eligible },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "existing_feedback",
            |m: &CSteamDeckCompatibility_ShouldPrompt_Response| { &m.existing_feedback },
            |m: &mut CSteamDeckCompatibility_ShouldPrompt_Response| { &mut m.existing_feedback },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamDeckCompatibility_ShouldPrompt_Response>(
            "CSteamDeckCompatibility_ShouldPrompt_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamDeckCompatibility_ShouldPrompt_Response {
    const NAME: &'static str = "CSteamDeckCompatibility_ShouldPrompt_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prompt = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.feedback_eligible = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.existing_feedback = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prompt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.feedback_eligible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.existing_feedback {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.prompt {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.feedback_eligible {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.existing_feedback {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_ShouldPrompt_Response {
        CSteamDeckCompatibility_ShouldPrompt_Response::new()
    }

    fn clear(&mut self) {
        self.prompt = ::std::option::Option::None;
        self.feedback_eligible = ::std::option::Option::None;
        self.existing_feedback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_ShouldPrompt_Response {
        static instance: CSteamDeckCompatibility_ShouldPrompt_Response = CSteamDeckCompatibility_ShouldPrompt_Response {
            prompt: ::std::option::Option::None,
            feedback_eligible: ::std::option::Option::None,
            existing_feedback: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamDeckCompatibility_ShouldPrompt_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamDeckCompatibility_ShouldPrompt_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamDeckCompatibility_ShouldPrompt_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamDeckCompatibility_ShouldPrompt_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStore_StorePreferencesChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_StorePreferencesChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CStore_StorePreferencesChanged_Notification.preferences)
    pub preferences: crate::MessageField<CStore_UserPreferences>,
    // @@protoc_insertion_point(field:CStore_StorePreferencesChanged_Notification.tag_preferences)
    pub tag_preferences: crate::MessageField<CStore_UserTagPreferences>,
    // @@protoc_insertion_point(field:CStore_StorePreferencesChanged_Notification.content_descriptor_preferences)
    pub content_descriptor_preferences: crate::MessageField<super::steammessages_base::UserContentDescriptorPreferences>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_StorePreferencesChanged_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_StorePreferencesChanged_Notification {
    fn default() -> &'a CStore_StorePreferencesChanged_Notification {
        <CStore_StorePreferencesChanged_Notification as crate::Message>::default_instance()
    }
}

impl CStore_StorePreferencesChanged_Notification {
    pub fn new() -> CStore_StorePreferencesChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .CStore_UserPreferences preferences = 1;

    pub fn preferences(&self) -> &CStore_UserPreferences {
        self.preferences.as_ref().unwrap_or_else(|| <CStore_UserPreferences as crate::Message>::default_instance())
    }

    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CStore_UserPreferences) {
        self.preferences = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CStore_UserPreferences {
        self.preferences.mut_or_insert_default()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CStore_UserPreferences {
        self.preferences.take().unwrap_or_else(|| CStore_UserPreferences::new())
    }

    // optional .CStore_UserTagPreferences tag_preferences = 2;

    pub fn tag_preferences(&self) -> &CStore_UserTagPreferences {
        self.tag_preferences.as_ref().unwrap_or_else(|| <CStore_UserTagPreferences as crate::Message>::default_instance())
    }

    pub fn clear_tag_preferences(&mut self) {
        self.tag_preferences.clear();
    }

    pub fn has_tag_preferences(&self) -> bool {
        self.tag_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag_preferences(&mut self, v: CStore_UserTagPreferences) {
        self.tag_preferences = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag_preferences(&mut self) -> &mut CStore_UserTagPreferences {
        self.tag_preferences.mut_or_insert_default()
    }

    // Take field
    pub fn take_tag_preferences(&mut self) -> CStore_UserTagPreferences {
        self.tag_preferences.take().unwrap_or_else(|| CStore_UserTagPreferences::new())
    }

    // optional .UserContentDescriptorPreferences content_descriptor_preferences = 3;

    pub fn content_descriptor_preferences(&self) -> &super::steammessages_base::UserContentDescriptorPreferences {
        self.content_descriptor_preferences.as_ref().unwrap_or_else(|| <super::steammessages_base::UserContentDescriptorPreferences as crate::Message>::default_instance())
    }

    pub fn clear_content_descriptor_preferences(&mut self) {
        self.content_descriptor_preferences.clear();
    }

    pub fn has_content_descriptor_preferences(&self) -> bool {
        self.content_descriptor_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_descriptor_preferences(&mut self, v: super::steammessages_base::UserContentDescriptorPreferences) {
        self.content_descriptor_preferences = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_descriptor_preferences(&mut self) -> &mut super::steammessages_base::UserContentDescriptorPreferences {
        self.content_descriptor_preferences.mut_or_insert_default()
    }

    // Take field
    pub fn take_content_descriptor_preferences(&mut self) -> super::steammessages_base::UserContentDescriptorPreferences {
        self.content_descriptor_preferences.take().unwrap_or_else(|| super::steammessages_base::UserContentDescriptorPreferences::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStore_UserPreferences>(
            "preferences",
            |m: &CStore_StorePreferencesChanged_Notification| { &m.preferences },
            |m: &mut CStore_StorePreferencesChanged_Notification| { &mut m.preferences },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStore_UserTagPreferences>(
            "tag_preferences",
            |m: &CStore_StorePreferencesChanged_Notification| { &m.tag_preferences },
            |m: &mut CStore_StorePreferencesChanged_Notification| { &mut m.tag_preferences },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::UserContentDescriptorPreferences>(
            "content_descriptor_preferences",
            |m: &CStore_StorePreferencesChanged_Notification| { &m.content_descriptor_preferences },
            |m: &mut CStore_StorePreferencesChanged_Notification| { &mut m.content_descriptor_preferences },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStore_StorePreferencesChanged_Notification>(
            "CStore_StorePreferencesChanged_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStore_StorePreferencesChanged_Notification {
    const NAME: &'static str = "CStore_StorePreferencesChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.preferences)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.tag_preferences)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.content_descriptor_preferences)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.preferences.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_StorePreferencesChanged_Notification {
        CStore_StorePreferencesChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.preferences.clear();
        self.tag_preferences.clear();
        self.content_descriptor_preferences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_StorePreferencesChanged_Notification {
        static instance: CStore_StorePreferencesChanged_Notification = CStore_StorePreferencesChanged_Notification {
            preferences: crate::MessageField::none(),
            tag_preferences: crate::MessageField::none(),
            content_descriptor_preferences: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStore_StorePreferencesChanged_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStore_StorePreferencesChanged_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStore_StorePreferencesChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStore_StorePreferencesChanged_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreDiscoveryQueueType)
pub enum EStoreDiscoveryQueueType {
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeNew)
    k_EStoreDiscoveryQueueTypeNew = 0,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeComingSoon)
    k_EStoreDiscoveryQueueTypeComingSoon = 1,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommended)
    k_EStoreDiscoveryQueueTypeRecommended = 2,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeEveryNewRelease)
    k_EStoreDiscoveryQueueTypeEveryNewRelease = 3,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeMLRecommender)
    k_EStoreDiscoveryQueueTypeMLRecommender = 5,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeWishlistOnSale)
    k_EStoreDiscoveryQueueTypeWishlistOnSale = 6,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLC)
    k_EStoreDiscoveryQueueTypeDLC = 7,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLCOnSale)
    k_EStoreDiscoveryQueueTypeDLCOnSale = 8,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedComingSoon)
    k_EStoreDiscoveryQueueTypeRecommendedComingSoon = 9,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedFree)
    k_EStoreDiscoveryQueueTypeRecommendedFree = 10,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedOnSale)
    k_EStoreDiscoveryQueueTypeRecommendedOnSale = 11,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedDemos)
    k_EStoreDiscoveryQueueTypeRecommendedDemos = 12,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLCNewReleases)
    k_EStoreDiscoveryQueueTypeDLCNewReleases = 13,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLCTopSellers)
    k_EStoreDiscoveryQueueTypeDLCTopSellers = 14,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeMAX)
    k_EStoreDiscoveryQueueTypeMAX = 15,
}

impl crate::Enum for EStoreDiscoveryQueueType {
    const NAME: &'static str = "EStoreDiscoveryQueueType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreDiscoveryQueueType> {
        match value {
            0 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            1 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeComingSoon),
            2 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommended),
            3 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeEveryNewRelease),
            5 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMLRecommender),
            6 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeWishlistOnSale),
            7 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLC),
            8 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCOnSale),
            9 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedComingSoon),
            10 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedFree),
            11 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedOnSale),
            12 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedDemos),
            13 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCNewReleases),
            14 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCTopSellers),
            15 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreDiscoveryQueueType> {
        match str {
            "k_EStoreDiscoveryQueueTypeNew" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            "k_EStoreDiscoveryQueueTypeComingSoon" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeComingSoon),
            "k_EStoreDiscoveryQueueTypeRecommended" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommended),
            "k_EStoreDiscoveryQueueTypeEveryNewRelease" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeEveryNewRelease),
            "k_EStoreDiscoveryQueueTypeMLRecommender" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMLRecommender),
            "k_EStoreDiscoveryQueueTypeWishlistOnSale" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeWishlistOnSale),
            "k_EStoreDiscoveryQueueTypeDLC" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLC),
            "k_EStoreDiscoveryQueueTypeDLCOnSale" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCOnSale),
            "k_EStoreDiscoveryQueueTypeRecommendedComingSoon" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedComingSoon),
            "k_EStoreDiscoveryQueueTypeRecommendedFree" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedFree),
            "k_EStoreDiscoveryQueueTypeRecommendedOnSale" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedOnSale),
            "k_EStoreDiscoveryQueueTypeRecommendedDemos" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedDemos),
            "k_EStoreDiscoveryQueueTypeDLCNewReleases" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCNewReleases),
            "k_EStoreDiscoveryQueueTypeDLCTopSellers" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCTopSellers),
            "k_EStoreDiscoveryQueueTypeMAX" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreDiscoveryQueueType] = &[
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeComingSoon,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommended,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeEveryNewRelease,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMLRecommender,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeWishlistOnSale,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLC,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCOnSale,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedComingSoon,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedFree,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedOnSale,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedDemos,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCNewReleases,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCTopSellers,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMAX,
    ];
}

impl crate::EnumFull for EStoreDiscoveryQueueType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStoreDiscoveryQueueType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew => 0,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeComingSoon => 1,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommended => 2,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeEveryNewRelease => 3,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMLRecommender => 4,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeWishlistOnSale => 5,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLC => 6,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCOnSale => 7,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedComingSoon => 8,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedFree => 9,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedOnSale => 10,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedDemos => 11,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCNewReleases => 12,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCTopSellers => 13,
            EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMAX => 14,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStoreDiscoveryQueueType {
    fn default() -> Self {
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew
    }
}

impl EStoreDiscoveryQueueType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStoreDiscoveryQueueType>("EStoreDiscoveryQueueType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPlaytestStatus)
pub enum EPlaytestStatus {
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusNone)
    k_ETesterStatusNone = 0,
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusPending)
    k_ETesterStatusPending = 1,
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusInvited)
    k_ETesterStatusInvited = 2,
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusGranted)
    k_ETesterStatusGranted = 3,
}

impl crate::Enum for EPlaytestStatus {
    const NAME: &'static str = "EPlaytestStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlaytestStatus> {
        match value {
            0 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusNone),
            1 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusPending),
            2 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusInvited),
            3 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusGranted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPlaytestStatus> {
        match str {
            "k_ETesterStatusNone" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusNone),
            "k_ETesterStatusPending" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusPending),
            "k_ETesterStatusInvited" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusInvited),
            "k_ETesterStatusGranted" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusGranted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPlaytestStatus] = &[
        EPlaytestStatus::k_ETesterStatusNone,
        EPlaytestStatus::k_ETesterStatusPending,
        EPlaytestStatus::k_ETesterStatusInvited,
        EPlaytestStatus::k_ETesterStatusGranted,
    ];
}

impl crate::EnumFull for EPlaytestStatus {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPlaytestStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPlaytestStatus {
    fn default() -> Self {
        EPlaytestStatus::k_ETesterStatusNone
    }
}

impl EPlaytestStatus {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPlaytestStatus>("EPlaytestStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EAppReportType)
pub enum EAppReportType {
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Invalid)
    k_EAppReportType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Scam)
    k_EAppReportType_Scam = 1,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Malware)
    k_EAppReportType_Malware = 2,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_HateSpeech)
    k_EAppReportType_HateSpeech = 3,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Pornography)
    k_EAppReportType_Pornography = 4,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_NonLabeledAdultContent)
    k_EAppReportType_NonLabeledAdultContent = 5,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Libelous)
    k_EAppReportType_Libelous = 6,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Offensive)
    k_EAppReportType_Offensive = 7,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_ExploitsChildren)
    k_EAppReportType_ExploitsChildren = 8,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_MtxWithNonSteamWalletPaymentMethods)
    k_EAppReportType_MtxWithNonSteamWalletPaymentMethods = 9,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_CopyrightViolation)
    k_EAppReportType_CopyrightViolation = 10,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_ViolatesLaws)
    k_EAppReportType_ViolatesLaws = 11,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Other)
    k_EAppReportType_Other = 12,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_Broken)
    k_EAppReportType_Broken = 13,
    // @@protoc_insertion_point(enum_value:EAppReportType.k_EAppReportType_AIContentReport)
    k_EAppReportType_AIContentReport = 14,
}

impl crate::Enum for EAppReportType {
    const NAME: &'static str = "EAppReportType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAppReportType> {
        match value {
            0 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Invalid),
            1 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Scam),
            2 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Malware),
            3 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_HateSpeech),
            4 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Pornography),
            5 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_NonLabeledAdultContent),
            6 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Libelous),
            7 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Offensive),
            8 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_ExploitsChildren),
            9 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_MtxWithNonSteamWalletPaymentMethods),
            10 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_CopyrightViolation),
            11 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_ViolatesLaws),
            12 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Other),
            13 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Broken),
            14 => ::std::option::Option::Some(EAppReportType::k_EAppReportType_AIContentReport),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EAppReportType> {
        match str {
            "k_EAppReportType_Invalid" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Invalid),
            "k_EAppReportType_Scam" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Scam),
            "k_EAppReportType_Malware" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Malware),
            "k_EAppReportType_HateSpeech" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_HateSpeech),
            "k_EAppReportType_Pornography" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Pornography),
            "k_EAppReportType_NonLabeledAdultContent" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_NonLabeledAdultContent),
            "k_EAppReportType_Libelous" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Libelous),
            "k_EAppReportType_Offensive" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Offensive),
            "k_EAppReportType_ExploitsChildren" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_ExploitsChildren),
            "k_EAppReportType_MtxWithNonSteamWalletPaymentMethods" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_MtxWithNonSteamWalletPaymentMethods),
            "k_EAppReportType_CopyrightViolation" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_CopyrightViolation),
            "k_EAppReportType_ViolatesLaws" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_ViolatesLaws),
            "k_EAppReportType_Other" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Other),
            "k_EAppReportType_Broken" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_Broken),
            "k_EAppReportType_AIContentReport" => ::std::option::Option::Some(EAppReportType::k_EAppReportType_AIContentReport),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EAppReportType] = &[
        EAppReportType::k_EAppReportType_Invalid,
        EAppReportType::k_EAppReportType_Scam,
        EAppReportType::k_EAppReportType_Malware,
        EAppReportType::k_EAppReportType_HateSpeech,
        EAppReportType::k_EAppReportType_Pornography,
        EAppReportType::k_EAppReportType_NonLabeledAdultContent,
        EAppReportType::k_EAppReportType_Libelous,
        EAppReportType::k_EAppReportType_Offensive,
        EAppReportType::k_EAppReportType_ExploitsChildren,
        EAppReportType::k_EAppReportType_MtxWithNonSteamWalletPaymentMethods,
        EAppReportType::k_EAppReportType_CopyrightViolation,
        EAppReportType::k_EAppReportType_ViolatesLaws,
        EAppReportType::k_EAppReportType_Other,
        EAppReportType::k_EAppReportType_Broken,
        EAppReportType::k_EAppReportType_AIContentReport,
    ];
}

impl crate::EnumFull for EAppReportType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EAppReportType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EAppReportType {
    fn default() -> Self {
        EAppReportType::k_EAppReportType_Invalid
    }
}

impl EAppReportType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EAppReportType>("EAppReportType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUserReviewScorePreference)
pub enum EUserReviewScorePreference {
    // @@protoc_insertion_point(enum_value:EUserReviewScorePreference.k_EUserReviewScorePreference_Unset)
    k_EUserReviewScorePreference_Unset = 0,
    // @@protoc_insertion_point(enum_value:EUserReviewScorePreference.k_EUserReviewScorePreference_IncludeAll)
    k_EUserReviewScorePreference_IncludeAll = 1,
    // @@protoc_insertion_point(enum_value:EUserReviewScorePreference.k_EUserReviewScorePreference_ExcludeBombs)
    k_EUserReviewScorePreference_ExcludeBombs = 2,
}

impl crate::Enum for EUserReviewScorePreference {
    const NAME: &'static str = "EUserReviewScorePreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUserReviewScorePreference> {
        match value {
            0 => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_Unset),
            1 => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_IncludeAll),
            2 => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_ExcludeBombs),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUserReviewScorePreference> {
        match str {
            "k_EUserReviewScorePreference_Unset" => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_Unset),
            "k_EUserReviewScorePreference_IncludeAll" => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_IncludeAll),
            "k_EUserReviewScorePreference_ExcludeBombs" => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_ExcludeBombs),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUserReviewScorePreference] = &[
        EUserReviewScorePreference::k_EUserReviewScorePreference_Unset,
        EUserReviewScorePreference::k_EUserReviewScorePreference_IncludeAll,
        EUserReviewScorePreference::k_EUserReviewScorePreference_ExcludeBombs,
    ];
}

impl crate::EnumFull for EUserReviewScorePreference {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EUserReviewScorePreference").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EUserReviewScorePreference {
    fn default() -> Self {
        EUserReviewScorePreference::k_EUserReviewScorePreference_Unset
    }
}

impl EUserReviewScorePreference {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EUserReviewScorePreference>("EUserReviewScorePreference")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPartnerLinkTrackingBackfillSource)
pub enum EPartnerLinkTrackingBackfillSource {
    // @@protoc_insertion_point(enum_value:EPartnerLinkTrackingBackfillSource.k_EPartnerLinkTrackingBackfillSource_None)
    k_EPartnerLinkTrackingBackfillSource_None = 0,
    // @@protoc_insertion_point(enum_value:EPartnerLinkTrackingBackfillSource.k_EPartnerLinkTrackingBackfillSource_Web)
    k_EPartnerLinkTrackingBackfillSource_Web = 1,
    // @@protoc_insertion_point(enum_value:EPartnerLinkTrackingBackfillSource.k_EPartnerLinkTrackingBackfillSource_Mobile)
    k_EPartnerLinkTrackingBackfillSource_Mobile = 2,
    // @@protoc_insertion_point(enum_value:EPartnerLinkTrackingBackfillSource.k_EPartnerLinkTrackingBackfillSource_Desktop)
    k_EPartnerLinkTrackingBackfillSource_Desktop = 3,
}

impl crate::Enum for EPartnerLinkTrackingBackfillSource {
    const NAME: &'static str = "EPartnerLinkTrackingBackfillSource";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPartnerLinkTrackingBackfillSource> {
        match value {
            0 => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_None),
            1 => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Web),
            2 => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Mobile),
            3 => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Desktop),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPartnerLinkTrackingBackfillSource> {
        match str {
            "k_EPartnerLinkTrackingBackfillSource_None" => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_None),
            "k_EPartnerLinkTrackingBackfillSource_Web" => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Web),
            "k_EPartnerLinkTrackingBackfillSource_Mobile" => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Mobile),
            "k_EPartnerLinkTrackingBackfillSource_Desktop" => ::std::option::Option::Some(EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Desktop),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPartnerLinkTrackingBackfillSource] = &[
        EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_None,
        EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Web,
        EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Mobile,
        EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_Desktop,
    ];
}

impl crate::EnumFull for EPartnerLinkTrackingBackfillSource {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPartnerLinkTrackingBackfillSource").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPartnerLinkTrackingBackfillSource {
    fn default() -> Self {
        EPartnerLinkTrackingBackfillSource::k_EPartnerLinkTrackingBackfillSource_None
    }
}

impl EPartnerLinkTrackingBackfillSource {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPartnerLinkTrackingBackfillSource>("EPartnerLinkTrackingBackfillSource")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%steammessages_store.steamclient.proto\x1a\x18steammessages_base.proto\
    \x1a,steammessages_unified_base.steamclient.proto\x1a\x11contenthubs.pro\
    to\x1a\x0benums.proto\"\xa9\x01\n\x1cCStore_RegisterCDKey_Request\x12'\n\
    \x0factivation_code\x18\x01\x20\x01(\tR\x0eactivationCode\x12+\n\x11purc\
    hase_platform\x18\x02\x20\x01(\x05R\x10purchasePlatform\x123\n\x16is_req\
    uest_from_client\x18\x03\x20\x01(\x08R\x13isRequestFromClient\"\xae\x06\
    \n\x1aCStore_PurchaseReceiptInfo\x12$\n\rtransactionid\x18\x01\x20\x01(\
    \x04R\rtransactionid\x12\x1c\n\tpackageid\x18\x02\x20\x01(\rR\tpackageid\
    \x12'\n\x0fpurchase_status\x18\x03\x20\x01(\rR\x0epurchaseStatus\x12#\n\
    \rresult_detail\x18\x04\x20\x01(\rR\x0cresultDetail\x12)\n\x10transactio\
    n_time\x18\x05\x20\x01(\rR\x0ftransactionTime\x12%\n\x0epayment_method\
    \x18\x06\x20\x01(\rR\rpaymentMethod\x12\x1d\n\nbase_price\x18\x07\x20\
    \x01(\x04R\tbasePrice\x12%\n\x0etotal_discount\x18\x08\x20\x01(\x04R\rto\
    talDiscount\x12\x10\n\x03tax\x18\t\x20\x01(\x04R\x03tax\x12\x1a\n\x08shi\
    pping\x18\n\x20\x01(\x04R\x08shipping\x12#\n\rcurrency_code\x18\x0b\x20\
    \x01(\rR\x0ccurrencyCode\x12!\n\x0ccountry_code\x18\x0c\x20\x01(\tR\x0bc\
    ountryCode\x12%\n\x0eerror_headline\x18\r\x20\x01(\tR\rerrorHeadline\x12\
    !\n\x0cerror_string\x18\x0e\x20\x01(\tR\x0berrorString\x12&\n\x0ferror_l\
    ink_text\x18\x0f\x20\x01(\tR\rerrorLinkText\x12$\n\x0eerror_link_url\x18\
    \x10\x20\x01(\tR\x0cerrorLinkUrl\x12\x1f\n\x0berror_appid\x18\x11\x20\
    \x01(\rR\nerrorAppid\x12C\n\nline_items\x18\x12\x20\x03(\x0b2$.CStore_Pu\
    rchaseReceiptInfo.LineItemR\tlineItems\x1ar\n\x08LineItem\x12\x1c\n\tpac\
    kageid\x18\x01\x20\x01(\rR\tpackageid\x12\x14\n\x05appid\x18\x02\x20\x01\
    (\rR\x05appid\x122\n\x15line_item_description\x18\x03\x20\x01(\tR\x13lin\
    eItemDescription\"\xa8\x01\n\x1dCStore_RegisterCDKey_Response\x126\n\x17\
    purchase_result_details\x18\x01\x20\x01(\x05R\x15purchaseResultDetails\
    \x12O\n\x15purchase_receipt_info\x18\x02\x20\x01(\x0b2\x1b.CStore_Purcha\
    seReceiptInfoR\x13purchaseReceiptInfo\"?\n!CStore_GetMostPopularTags_Req\
    uest\x12\x1a\n\x08language\x18\x01\x20\x01(\tR\x08language\"\x92\x01\n\"\
    CStore_GetMostPopularTags_Response\x12;\n\x04tags\x18\x01\x20\x03(\x0b2'\
    .CStore_GetMostPopularTags_Response.TagR\x04tags\x1a/\n\x03Tag\x12\x14\n\
    \x05tagid\x18\x01\x20\x01(\rR\x05tagid\x12\x12\n\x04name\x18\x02\x20\x01\
    (\tR\x04name\"\\\n&CStore_GetLocalizedNameForTags_Request\x12\x1a\n\x08l\
    anguage\x18\x01\x20\x01(\tR\x08language\x12\x16\n\x06tagids\x18\x02\x20\
    \x03(\rR\x06tagids\"\xe8\x01\n'CStore_GetLocalizedNameForTags_Response\
    \x12@\n\x04tags\x18\x01\x20\x03(\x0b2,.CStore_GetLocalizedNameForTags_Re\
    sponse.TagR\x04tags\x1a{\n\x03Tag\x12\x14\n\x05tagid\x18\x01\x20\x01(\rR\
    \x05tagid\x12!\n\x0cenglish_name\x18\x02\x20\x01(\tR\x0benglishName\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12'\n\x0fnormalized_name\x18\
    \x04\x20\x01(\tR\x0enormalizedName\"c\n\x19CStore_GetTagList_Request\x12\
    \x1a\n\x08language\x18\x01\x20\x01(\tR\x08language\x12*\n\x11have_versio\
    n_hash\x18\x02\x20\x01(\tR\x0fhaveVersionHash\"\xa5\x01\n\x1aCStore_GetT\
    agList_Response\x12!\n\x0cversion_hash\x18\x01\x20\x01(\tR\x0bversionHas\
    h\x123\n\x04tags\x18\x02\x20\x03(\x0b2\x1f.CStore_GetTagList_Response.Ta\
    gR\x04tags\x1a/\n\x03Tag\x12\x14\n\x05tagid\x18\x01\x20\x01(\rR\x05tagid\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"\xaf\x04\n\x1cCStoreDisc\
    overyQueueSettings\x12\x15\n\x06os_win\x18\x04\x20\x01(\x08R\x05osWin\
    \x12\x15\n\x06os_mac\x18\x05\x20\x01(\x08R\x05osMac\x12\x19\n\x08os_linu\
    x\x18\x06\x20\x01(\x08R\x07osLinux\x126\n\x17full_controller_support\x18\
    \x07\x20\x01(\x08R\x15fullControllerSupport\x126\n\x17native_steam_contr\
    oller\x18\x08\x20\x01(\x08R\x15nativeSteamController\x12.\n\x13include_c\
    oming_soon\x18\t\x20\x01(\x08R\x11includeComingSoon\x12'\n\x0fexcluded_t\
    agids\x18\n\x20\x03(\rR\x0eexcludedTagids\x120\n\x14exclude_early_access\
    \x18\x0b\x20\x01(\x08R\x12excludeEarlyAccess\x12%\n\x0eexclude_videos\
    \x18\x0c\x20\x01(\x08R\rexcludeVideos\x12)\n\x10exclude_software\x18\r\
    \x20\x01(\x08R\x0fexcludeSoftware\x12\x1f\n\x0bexclude_dlc\x18\x0e\x20\
    \x01(\x08R\nexcludeDlc\x12/\n\x13exclude_soundtracks\x18\x0f\x20\x01(\
    \x08R\x12excludeSoundtracks\x12'\n\x0ffeatured_tagids\x18\x10\x20\x03(\r\
    R\x0efeaturedTagids\"\xef\x04\n\x20CStore_GetDiscoveryQueue_Request\x12W\
    \n\nqueue_type\x18\x01\x20\x01(\x0e2\x19.EStoreDiscoveryQueueType:\x1dk_\
    EStoreDiscoveryQueueTypeNewR\tqueueType\x12!\n\x0ccountry_code\x18\x02\
    \x20\x01(\tR\x0bcountryCode\x12#\n\rrebuild_queue\x18\x03\x20\x01(\x08R\
    \x0crebuildQueue\x12)\n\x10settings_changed\x18\x04\x20\x01(\x08R\x0fset\
    tingsChanged\x129\n\x08settings\x18\x05\x20\x01(\x0b2\x1d.CStoreDiscover\
    yQueueSettingsR\x08settings\x123\n\x16rebuild_queue_if_stale\x18\x06\x20\
    \x01(\x08R\x13rebuildQueueIfStale\x126\n\x17ignore_user_preferences\x18\
    \x08\x20\x01(\x08R\x15ignoreUserPreferences\x126\n\x17no_experimental_re\
    sults\x18\t\x20\x01(\x08R\x15noExperimentalResults\x12/\n\x13experimenta\
    l_cohort\x18\n\x20\x01(\rR\x12experimentalCohort\x12/\n\x14debug_get_sol\
    r_query\x18\x0b\x20\x01(\x08R\x11debugGetSolrQuery\x12=\n\x11store_page_\
    filter\x18\x0c\x20\x01(\x0b2\x11.CStorePageFilterR\x0fstorePageFilter\"\
    \xac\x02\n!CStore_GetDiscoveryQueue_Response\x12\x16\n\x06appids\x18\x01\
    \x20\x03(\rR\x06appids\x12!\n\x0ccountry_code\x18\x02\x20\x01(\tR\x0bcou\
    ntryCode\x129\n\x08settings\x18\x03\x20\x01(\x0b2\x1d.CStoreDiscoveryQue\
    ueSettingsR\x08settings\x12\x18\n\x07skipped\x18\x04\x20\x01(\x05R\x07sk\
    ipped\x12\x1c\n\texhausted\x18\x05\x20\x01(\x08R\texhausted\x12/\n\x13ex\
    perimental_cohort\x18\x06\x20\x01(\rR\x12experimentalCohort\x12(\n\x10de\
    bug_solr_query\x18\x07\x20\x01(\tR\x0edebugSolrQuery\"\xc2\x01\n(CStore_\
    GetDiscoveryQueueSettings_Request\x12W\n\nqueue_type\x18\x01\x20\x01(\
    \x0e2\x19.EStoreDiscoveryQueueType:\x1dk_EStoreDiscoveryQueueTypeNewR\tq\
    ueueType\x12=\n\x11store_page_filter\x18\x02\x20\x01(\x0b2\x11.CStorePag\
    eFilterR\x0fstorePageFilter\"\x89\x01\n)CStore_GetDiscoveryQueueSettings\
    _Response\x12!\n\x0ccountry_code\x18\x01\x20\x01(\tR\x0bcountryCode\x129\
    \n\x08settings\x18\x02\x20\x01(\x0b2\x1d.CStoreDiscoveryQueueSettingsR\
    \x08settings\"\xd5\x01\n%CStore_SkipDiscoveryQueueItem_Request\x12W\n\nq\
    ueue_type\x18\x01\x20\x01(\x0e2\x19.EStoreDiscoveryQueueType:\x1dk_EStor\
    eDiscoveryQueueTypeNewR\tqueueType\x12\x14\n\x05appid\x18\x02\x20\x01(\r\
    R\x05appid\x12=\n\x11store_page_filter\x18\x03\x20\x01(\x0b2\x11.CStoreP\
    ageFilterR\x0fstorePageFilter\"(\n&CStore_SkipDiscoveryQueueItem_Respons\
    e\"\x7f\n'CStore_GetUserGameInterestState_Request\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x1f\n\x0bstore_appid\x18\x02\x20\x01(\rR\n\
    storeAppid\x12\x1d\n\nbeta_appid\x18\x03\x20\x01(\rR\tbetaAppid\"\xce\
    \x06\n(CStore_GetUserGameInterestState_Response\x12\x14\n\x05owned\x18\
    \x01\x20\x01(\x08R\x05owned\x12\x1a\n\x08wishlist\x18\x02\x20\x01(\x08R\
    \x08wishlist\x12\x18\n\x07ignored\x18\x03\x20\x01(\x08R\x07ignored\x12\
    \x1c\n\tfollowing\x18\x04\x20\x01(\x08R\tfollowing\x126\n\tin_queues\x18\
    \x05\x20\x03(\x0e2\x19.EStoreDiscoveryQueueTypeR\x08inQueues\x12C\n\x10q\
    ueues_with_skip\x18\x06\x20\x03(\x0e2\x19.EStoreDiscoveryQueueTypeR\x0eq\
    ueuesWithSkip\x122\n\x15queue_items_remaining\x18\x07\x20\x03(\x05R\x13q\
    ueueItemsRemaining\x123\n\x16queue_items_next_appid\x18\x08\x20\x03(\rR\
    \x13queueItemsNextAppid\x12+\n\x11temporarily_owned\x18\t\x20\x01(\x08R\
    \x10temporarilyOwned\x12I\n\x06queues\x18\n\x20\x03(\x0b21.CStore_GetUse\
    rGameInterestState_Response.InQueueR\x06queues\x12%\n\x0eignored_reason\
    \x18\x0b\x20\x01(\x05R\rignoredReason\x12F\n\x0bbeta_status\x18\x0c\x20\
    \x01(\x0e2\x10.EPlaytestStatus:\x13k_ETesterStatusNoneR\nbetaStatus\x1a\
    \xea\x01\n\x07InQueue\x12L\n\x04type\x18\x01\x20\x01(\x0e2\x19.EStoreDis\
    coveryQueueType:\x1dk_EStoreDiscoveryQueueTypeNewR\x04type\x12\x18\n\x07\
    skipped\x18\x02\x20\x01(\x08R\x07skipped\x12'\n\x0fitems_remaining\x18\
    \x03\x20\x01(\x05R\x0eitemsRemaining\x12\x1d\n\nnext_appid\x18\x04\x20\
    \x01(\rR\tnextAppid\x12/\n\x13experimental_cohort\x18\x05\x20\x01(\rR\
    \x12experimentalCohort\"\xdf\x01\n+CStore_GetDiscoveryQueueSkippedApps_R\
    equest\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12W\n\nque\
    ue_type\x18\x02\x20\x01(\x0e2\x19.EStoreDiscoveryQueueType:\x1dk_EStoreD\
    iscoveryQueueTypeNewR\tqueueType\x12=\n\x11store_page_filter\x18\x03\x20\
    \x01(\x0b2\x11.CStorePageFilterR\x0fstorePageFilter\"F\n,CStore_GetDisco\
    veryQueueSkippedApps_Response\x12\x16\n\x06appids\x18\x01\x20\x03(\rR\
    \x06appids\"\x94\x01\n\x18CStore_ReportApp_Request\x12\x14\n\x05appid\
    \x18\x01\x20\x01(\rR\x05appid\x12J\n\x0breport_type\x18\x02\x20\x01(\x0e\
    2\x0f.EAppReportType:\x18k_EAppReportType_InvalidR\nreportType\x12\x16\n\
    \x06report\x18\x03\x20\x01(\tR\x06report\"\x1b\n\x19CStore_ReportApp_Res\
    ponse\"$\n\"CStore_GetStorePreferences_Request\"\xd9\x05\n\x16CStore_Use\
    rPreferences\x12)\n\x10primary_language\x18\x01\x20\x01(\x05R\x0fprimary\
    Language\x12/\n\x13secondary_languages\x18\x02\x20\x01(\rR\x12secondaryL\
    anguages\x12)\n\x10platform_windows\x18\x03\x20\x01(\x08R\x0fplatformWin\
    dows\x12!\n\x0cplatform_mac\x18\x04\x20\x01(\x08R\x0bplatformMac\x12%\n\
    \x0eplatform_linux\x18\x05\x20\x01(\x08R\rplatformLinux\x12+\n\x11timest\
    amp_updated\x18\x08\x20\x01(\rR\x10timestampUpdated\x120\n\x14hide_store\
    _broadcast\x18\t\x20\x01(\x08R\x12hideStoreBroadcast\x12w\n\x17review_sc\
    ore_preference\x18\n\x20\x01(\x0e2\x1b.EUserReviewScorePreference:\"k_EU\
    serReviewScorePreference_UnsetR\x15reviewScorePreference\x12f\n0timestam\
    p_content_descriptor_preferences_updated\x18\x0b\x20\x01(\x05R,timestamp\
    ContentDescriptorPreferencesUpdated\x12{\n\x15provide_deck_feedback\x18\
    \x0c\x20\x01(\x0e2\x1f.EProvideDeckFeedbackPreference:&k_EProvideDeckFee\
    dbackPreference_UnsetR\x13provideDeckFeedback\x121\n\x14additional_langu\
    ages\x18\r\x20\x01(\tR\x13additionalLanguages\"\xbd\x01\n\x19CStore_User\
    TagPreferences\x12F\n\x0ftags_to_exclude\x18\x01\x20\x03(\x0b2\x1e.CStor\
    e_UserTagPreferences.TagR\rtagsToExclude\x1aX\n\x03Tag\x12\x14\n\x05tagi\
    d\x18\x01\x20\x01(\rR\x05tagid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04\
    name\x12'\n\x0ftimestamp_added\x18\x03\x20\x01(\rR\x0etimestampAdded\"\
    \x8e\x02\n#CStore_GetStorePreferences_Response\x129\n\x0bpreferences\x18\
    \x01\x20\x01(\x0b2\x17.CStore_UserPreferencesR\x0bpreferences\x12C\n\x0f\
    tag_preferences\x18\x02\x20\x01(\x0b2\x1a.CStore_UserTagPreferencesR\x0e\
    tagPreferences\x12g\n\x1econtent_descriptor_preferences\x18\x03\x20\x01(\
    \x0b2!.UserContentDescriptorPreferencesR\x1ccontentDescriptorPreferences\
    \"o\n*CStore_GetTrendingAppsAmongFriends_Request\x12\x19\n\x08num_apps\
    \x18\x01\x20\x01(\rR\x07numApps\x12&\n\x0fnum_top_friends\x18\x02\x20\
    \x01(\rR\rnumTopFriends\"\x90\x02\n+CStore_GetTrendingAppsAmongFriends_R\
    esponse\x12a\n\rtrending_apps\x18\x01\x20\x03(\x0b2<.CStore_GetTrendingA\
    ppsAmongFriends_Response.TrendingAppDataR\x0ctrendingApps\x1a~\n\x0fTren\
    dingAppData\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x120\n\x14st\
    eamids_top_friends\x18\x02\x20\x03(\x04R\x12steamidsTopFriends\x12#\n\rt\
    otal_friends\x18\x03\x20\x01(\rR\x0ctotalFriends\"\xe5\x01\n.CStore_Migr\
    atePartnerLinkTracking_Notification\x12\x1c\n\taccountid\x18\x01\x20\x01\
    (\rR\taccountid\x12\x1c\n\tbrowserid\x18\x02\x20\x01(\x04R\tbrowserid\
    \x12w\n\x0fbackfill_source\x18\x03\x20\x01(\x0e2#.EPartnerLinkTrackingBa\
    ckfillSource:)k_EPartnerLinkTrackingBackfillSource_NoneR\x0ebackfillSour\
    ce\"\xb1\x01\n(CStore_UpdatePackageReservations_Request\x12.\n\x13packag\
    es_to_reserve\x18\x01\x20\x03(\rR\x11packagesToReserve\x122\n\x15package\
    s_to_unreserve\x18\x02\x20\x03(\rR\x13packagesToUnreserve\x12!\n\x0ccoun\
    try_code\x18\x03\x20\x01(\tR\x0bcountryCode\"v\n)CStore_UpdatePackageRes\
    ervations_Response\x12I\n\x12reservation_status\x18\x01\x20\x03(\x0b2\
    \x1a.CPackageReservationStatusR\x11reservationStatus\"\xd6\x02\n\x1bCRes\
    ervationPositionMessage\x12\"\n\x0cedistributor\x18\x01\x20\x01(\rR\x0ce\
    distributor\x12-\n\x12product_identifier\x18\x02\x20\x01(\tR\x11productI\
    dentifier\x120\n\x14start_queue_position\x18\x03\x20\x01(\rR\x12startQue\
    uePosition\x12@\n\x1crtime_estimated_notification\x18\x04\x20\x01(\rR\
    \x1artimeEstimatedNotification\x12-\n\x12localization_token\x18\x05\x20\
    \x01(\tR\x11localizationToken\x12\x1c\n\taccountid\x18\x06\x20\x01(\rR\t\
    accountid\x12#\n\rrtime_created\x18\x07\x20\x01(\rR\x0crtimeCreated\"h\n\
    ,CStore_SetReservationPositionMessage_Request\x128\n\x08settings\x18\x01\
    \x20\x03(\x0b2\x1c.CReservationPositionMessageR\x08settings\"/\n-CStore_\
    SetReservationPositionMessage_Response\"\xb6\x01\n/CStore_DeleteReservat\
    ionPositionMessage_Request\x12\"\n\x0cedistributor\x18\x01\x20\x01(\rR\
    \x0cedistributor\x12-\n\x12product_identifier\x18\x02\x20\x01(\tR\x11pro\
    ductIdentifier\x120\n\x14start_queue_position\x18\x03\x20\x01(\rR\x12sta\
    rtQueuePosition\"2\n0CStore_DeleteReservationPositionMessage_Response\"2\
    \n0CStore_GetAllReservationPositionMessages_Request\"m\n1CStore_GetAllRe\
    servationPositionMessages_Response\x128\n\x08settings\x18\x01\x20\x03(\
    \x0b2\x1c.CReservationPositionMessageR\x08settings\":\n8CStore_ReloadAll\
    ReservationPositionMessages_Notification\"\xaa\x01\n+CSteamDeckCompatibi\
    lity_SetFeedback_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12e\n\x08feedback\x18\x02\x20\x01(\x0e2\x20.ESteamDeckCompatibilityFee\
    dback:'k_ESteamDeckCompatibilityFeedback_UnsetR\x08feedback\".\n,CSteamD\
    eckCompatibility_SetFeedback_Response\"D\n,CSteamDeckCompatibility_Shoul\
    dPrompt_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\xec\
    \x01\n-CSteamDeckCompatibility_ShouldPrompt_Response\x12\x16\n\x06prompt\
    \x18\x01\x20\x01(\x08R\x06prompt\x12+\n\x11feedback_eligible\x18\x02\x20\
    \x01(\x08R\x10feedbackEligible\x12v\n\x11existing_feedback\x18\x03\x20\
    \x01(\x0e2\x20.ESteamDeckCompatibilityFeedback:'k_ESteamDeckCompatibilit\
    yFeedback_UnsetR\x10existingFeedback\"\x96\x02\n+CStore_StorePreferences\
    Changed_Notification\x129\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x17.CSt\
    ore_UserPreferencesR\x0bpreferences\x12C\n\x0ftag_preferences\x18\x02\
    \x20\x01(\x0b2\x1a.CStore_UserTagPreferencesR\x0etagPreferences\x12g\n\
    \x1econtent_descriptor_preferences\x18\x03\x20\x01(\x0b2!.UserContentDes\
    criptorPreferencesR\x1ccontentDescriptorPreferences*\xab\x05\n\x18EStore\
    DiscoveryQueueType\x12!\n\x1dk_EStoreDiscoveryQueueTypeNew\x10\0\x12(\n$\
    k_EStoreDiscoveryQueueTypeComingSoon\x10\x01\x12)\n%k_EStoreDiscoveryQue\
    ueTypeRecommended\x10\x02\x12-\n)k_EStoreDiscoveryQueueTypeEveryNewRelea\
    se\x10\x03\x12+\n'k_EStoreDiscoveryQueueTypeMLRecommender\x10\x05\x12,\n\
    (k_EStoreDiscoveryQueueTypeWishlistOnSale\x10\x06\x12!\n\x1dk_EStoreDisc\
    overyQueueTypeDLC\x10\x07\x12'\n#k_EStoreDiscoveryQueueTypeDLCOnSale\x10\
    \x08\x123\n/k_EStoreDiscoveryQueueTypeRecommendedComingSoon\x10\t\x12-\n\
    )k_EStoreDiscoveryQueueTypeRecommendedFree\x10\n\x12/\n+k_EStoreDiscover\
    yQueueTypeRecommendedOnSale\x10\x0b\x12.\n*k_EStoreDiscoveryQueueTypeRec\
    ommendedDemos\x10\x0c\x12,\n(k_EStoreDiscoveryQueueTypeDLCNewReleases\
    \x10\r\x12+\n'k_EStoreDiscoveryQueueTypeDLCTopSellers\x10\x0e\x12!\n\x1d\
    k_EStoreDiscoveryQueueTypeMAX\x10\x0f*~\n\x0fEPlaytestStatus\x12\x17\n\
    \x13k_ETesterStatusNone\x10\0\x12\x1a\n\x16k_ETesterStatusPending\x10\
    \x01\x12\x1a\n\x16k_ETesterStatusInvited\x10\x02\x12\x1a\n\x16k_ETesterS\
    tatusGranted\x10\x03*\xa2\x04\n\x0eEAppReportType\x12\x1c\n\x18k_EAppRep\
    ortType_Invalid\x10\0\x12\x19\n\x15k_EAppReportType_Scam\x10\x01\x12\x1c\
    \n\x18k_EAppReportType_Malware\x10\x02\x12\x1f\n\x1bk_EAppReportType_Hat\
    eSpeech\x10\x03\x12\x20\n\x1ck_EAppReportType_Pornography\x10\x04\x12+\n\
    'k_EAppReportType_NonLabeledAdultContent\x10\x05\x12\x1d\n\x19k_EAppRepo\
    rtType_Libelous\x10\x06\x12\x1e\n\x1ak_EAppReportType_Offensive\x10\x07\
    \x12%\n!k_EAppReportType_ExploitsChildren\x10\x08\x128\n4k_EAppReportTyp\
    e_MtxWithNonSteamWalletPaymentMethods\x10\t\x12'\n#k_EAppReportType_Copy\
    rightViolation\x10\n\x12!\n\x1dk_EAppReportType_ViolatesLaws\x10\x0b\x12\
    \x1a\n\x16k_EAppReportType_Other\x10\x0c\x12\x1b\n\x17k_EAppReportType_B\
    roken\x10\r\x12$\n\x20k_EAppReportType_AIContentReport\x10\x0e*\xa0\x01\
    \n\x1aEUserReviewScorePreference\x12&\n\"k_EUserReviewScorePreference_Un\
    set\x10\0\x12+\n'k_EUserReviewScorePreference_IncludeAll\x10\x01\x12-\n)\
    k_EUserReviewScorePreference_ExcludeBombs\x10\x02*\xe4\x01\n\"EPartnerLi\
    nkTrackingBackfillSource\x12-\n)k_EPartnerLinkTrackingBackfillSource_Non\
    e\x10\0\x12,\n(k_EPartnerLinkTrackingBackfillSource_Web\x10\x01\x12/\n+k\
    _EPartnerLinkTrackingBackfillSource_Mobile\x10\x02\x120\n,k_EPartnerLink\
    TrackingBackfillSource_Desktop\x10\x032\x8c\x11\n\x05Store\x12N\n\rRegis\
    terCDKey\x12\x1d.CStore_RegisterCDKey_Request\x1a\x1e.CStore_RegisterCDK\
    ey_Response\x12]\n\x12GetMostPopularTags\x12\".CStore_GetMostPopularTags\
    _Request\x1a#.CStore_GetMostPopularTags_Response\x12l\n\x17GetLocalizedN\
    ameForTags\x12'.CStore_GetLocalizedNameForTags_Request\x1a(.CStore_GetLo\
    calizedNameForTags_Response\x12E\n\nGetTagList\x12\x1a.CStore_GetTagList\
    _Request\x1a\x1b.CStore_GetTagList_Response\x12Z\n\x11GetDiscoveryQueue\
    \x12!.CStore_GetDiscoveryQueue_Request\x1a\".CStore_GetDiscoveryQueue_Re\
    sponse\x12r\n\x19GetDiscoveryQueueSettings\x12).CStore_GetDiscoveryQueue\
    Settings_Request\x1a*.CStore_GetDiscoveryQueueSettings_Response\x12i\n\
    \x16SkipDiscoveryQueueItem\x12&.CStore_SkipDiscoveryQueueItem_Request\
    \x1a'.CStore_SkipDiscoveryQueueItem_Response\x12o\n\x18GetUserGameIntere\
    stState\x12(.CStore_GetUserGameInterestState_Request\x1a).CStore_GetUser\
    GameInterestState_Response\x12{\n\x1cGetDiscoveryQueueSkippedApps\x12,.C\
    Store_GetDiscoveryQueueSkippedApps_Request\x1a-.CStore_GetDiscoveryQueue\
    SkippedApps_Response\x12B\n\tReportApp\x12\x19.CStore_ReportApp_Request\
    \x1a\x1a.CStore_ReportApp_Response\x12`\n\x13GetStorePreferences\x12#.CS\
    tore_GetStorePreferences_Request\x1a$.CStore_GetStorePreferences_Respons\
    e\x12x\n\x1bGetTrendingAppsAmongFriends\x12+.CStore_GetTrendingAppsAmong\
    Friends_Request\x1a,.CStore_GetTrendingAppsAmongFriends_Response\x12Z\n\
    \x1aMigratePartnerLinkTracking\x12/.CStore_MigratePartnerLinkTracking_No\
    tification\x1a\x0b.NoResponse\x12r\n\x19UpdatePackageReservations\x12).C\
    Store_UpdatePackageReservations_Request\x1a*.CStore_UpdatePackageReserva\
    tions_Response\x12~\n\x1dSetReservationPositionMessage\x12-.CStore_SetRe\
    servationPositionMessage_Request\x1a..CStore_SetReservationPositionMessa\
    ge_Response\x12\x87\x01\n\x20DeleteReservationPositionMessage\x120.CStor\
    e_DeleteReservationPositionMessage_Request\x1a1.CStore_DeleteReservation\
    PositionMessage_Response\x12\x8a\x01\n!GetAllReservationPositionMessages\
    \x121.CStore_GetAllReservationPositionMessages_Request\x1a2.CStore_GetAl\
    lReservationPositionMessages_Response\x12n\n$ReloadAllReservationPositio\
    nMessages\x129.CStore_ReloadAllReservationPositionMessages_Notification\
    \x1a\x0b.NoResponse\x12w\n\x18SetCompatibilityFeedback\x12,.CSteamDeckCo\
    mpatibility_SetFeedback_Request\x1a-.CSteamDeckCompatibility_SetFeedback\
    _Response\x12\x85\x01\n$ShouldPromptForCompatibilityFeedback\x12-.CSteam\
    DeckCompatibility_ShouldPrompt_Request\x1a..CSteamDeckCompatibility_Shou\
    ldPrompt_Response2o\n\x0bStoreClient\x12Z\n\x1dNotifyStorePreferencesCha\
    nged\x12,.CStore_StorePreferencesChanged_Notification\x1a\x0b.NoResponse\
    \x1a\x04\xc0\xb5\x18\x02B\x03\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            deps.push(super::contenthubs::file_descriptor().clone());
            deps.push(super::enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(51);
            messages.push(CStore_RegisterCDKey_Request::generated_message_descriptor_data());
            messages.push(CStore_PurchaseReceiptInfo::generated_message_descriptor_data());
            messages.push(CStore_RegisterCDKey_Response::generated_message_descriptor_data());
            messages.push(CStore_GetMostPopularTags_Request::generated_message_descriptor_data());
            messages.push(CStore_GetMostPopularTags_Response::generated_message_descriptor_data());
            messages.push(CStore_GetLocalizedNameForTags_Request::generated_message_descriptor_data());
            messages.push(CStore_GetLocalizedNameForTags_Response::generated_message_descriptor_data());
            messages.push(CStore_GetTagList_Request::generated_message_descriptor_data());
            messages.push(CStore_GetTagList_Response::generated_message_descriptor_data());
            messages.push(CStoreDiscoveryQueueSettings::generated_message_descriptor_data());
            messages.push(CStore_GetDiscoveryQueue_Request::generated_message_descriptor_data());
            messages.push(CStore_GetDiscoveryQueue_Response::generated_message_descriptor_data());
            messages.push(CStore_GetDiscoveryQueueSettings_Request::generated_message_descriptor_data());
            messages.push(CStore_GetDiscoveryQueueSettings_Response::generated_message_descriptor_data());
            messages.push(CStore_SkipDiscoveryQueueItem_Request::generated_message_descriptor_data());
            messages.push(CStore_SkipDiscoveryQueueItem_Response::generated_message_descriptor_data());
            messages.push(CStore_GetUserGameInterestState_Request::generated_message_descriptor_data());
            messages.push(CStore_GetUserGameInterestState_Response::generated_message_descriptor_data());
            messages.push(CStore_GetDiscoveryQueueSkippedApps_Request::generated_message_descriptor_data());
            messages.push(CStore_GetDiscoveryQueueSkippedApps_Response::generated_message_descriptor_data());
            messages.push(CStore_ReportApp_Request::generated_message_descriptor_data());
            messages.push(CStore_ReportApp_Response::generated_message_descriptor_data());
            messages.push(CStore_GetStorePreferences_Request::generated_message_descriptor_data());
            messages.push(CStore_UserPreferences::generated_message_descriptor_data());
            messages.push(CStore_UserTagPreferences::generated_message_descriptor_data());
            messages.push(CStore_GetStorePreferences_Response::generated_message_descriptor_data());
            messages.push(CStore_GetTrendingAppsAmongFriends_Request::generated_message_descriptor_data());
            messages.push(CStore_GetTrendingAppsAmongFriends_Response::generated_message_descriptor_data());
            messages.push(CStore_MigratePartnerLinkTracking_Notification::generated_message_descriptor_data());
            messages.push(CStore_UpdatePackageReservations_Request::generated_message_descriptor_data());
            messages.push(CStore_UpdatePackageReservations_Response::generated_message_descriptor_data());
            messages.push(CReservationPositionMessage::generated_message_descriptor_data());
            messages.push(CStore_SetReservationPositionMessage_Request::generated_message_descriptor_data());
            messages.push(CStore_SetReservationPositionMessage_Response::generated_message_descriptor_data());
            messages.push(CStore_DeleteReservationPositionMessage_Request::generated_message_descriptor_data());
            messages.push(CStore_DeleteReservationPositionMessage_Response::generated_message_descriptor_data());
            messages.push(CStore_GetAllReservationPositionMessages_Request::generated_message_descriptor_data());
            messages.push(CStore_GetAllReservationPositionMessages_Response::generated_message_descriptor_data());
            messages.push(CStore_ReloadAllReservationPositionMessages_Notification::generated_message_descriptor_data());
            messages.push(CSteamDeckCompatibility_SetFeedback_Request::generated_message_descriptor_data());
            messages.push(CSteamDeckCompatibility_SetFeedback_Response::generated_message_descriptor_data());
            messages.push(CSteamDeckCompatibility_ShouldPrompt_Request::generated_message_descriptor_data());
            messages.push(CSteamDeckCompatibility_ShouldPrompt_Response::generated_message_descriptor_data());
            messages.push(CStore_StorePreferencesChanged_Notification::generated_message_descriptor_data());
            messages.push(cstore_purchase_receipt_info::LineItem::generated_message_descriptor_data());
            messages.push(cstore_get_most_popular_tags_response::Tag::generated_message_descriptor_data());
            messages.push(cstore_get_localized_name_for_tags_response::Tag::generated_message_descriptor_data());
            messages.push(cstore_get_tag_list_response::Tag::generated_message_descriptor_data());
            messages.push(cstore_get_user_game_interest_state_response::InQueue::generated_message_descriptor_data());
            messages.push(cstore_user_tag_preferences::Tag::generated_message_descriptor_data());
            messages.push(cstore_get_trending_apps_among_friends_response::TrendingAppData::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(EStoreDiscoveryQueueType::generated_enum_descriptor_data());
            enums.push(EPlaytestStatus::generated_enum_descriptor_data());
            enums.push(EAppReportType::generated_enum_descriptor_data());
            enums.push(EUserReviewScorePreference::generated_enum_descriptor_data());
            enums.push(EPartnerLinkTrackingBackfillSource::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
