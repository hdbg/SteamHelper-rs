// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_ucm.proto`

// @@protoc_insertion_point(message:CMsgClientUCMAddScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMAddScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.thumbname)
    pub thumbname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.vr_filename)
    pub vr_filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.rtime32_created)
    pub rtime32_created: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.permissions)
    pub permissions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.shortcut_name)
    pub shortcut_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tag)
    pub tag: ::std::vec::Vec<cmsg_client_ucmadd_screenshot::Tag>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tagged_steamid)
    pub tagged_steamid: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.spoiler_tag)
    pub spoiler_tag: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tagged_publishedfileid)
    pub tagged_publishedfileid: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshot.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshot {
    fn default() -> &'a CMsgClientUCMAddScreenshot {
        <CMsgClientUCMAddScreenshot as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshot {
    pub fn new() -> CMsgClientUCMAddScreenshot {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string filename = 2;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbname = 3;

    pub fn thumbname(&self) -> &str {
        match self.thumbname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbname(&mut self) {
        self.thumbname = ::std::option::Option::None;
    }

    pub fn has_thumbname(&self) -> bool {
        self.thumbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbname(&mut self, v: ::std::string::String) {
        self.thumbname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbname(&mut self) -> &mut ::std::string::String {
        if self.thumbname.is_none() {
            self.thumbname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbname(&mut self) -> ::std::string::String {
        self.thumbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vr_filename = 14;

    pub fn vr_filename(&self) -> &str {
        match self.vr_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vr_filename(&mut self) {
        self.vr_filename = ::std::option::Option::None;
    }

    pub fn has_vr_filename(&self) -> bool {
        self.vr_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_filename(&mut self, v: ::std::string::String) {
        self.vr_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_filename(&mut self) -> &mut ::std::string::String {
        if self.vr_filename.is_none() {
            self.vr_filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vr_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_filename(&mut self) -> ::std::string::String {
        self.vr_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 rtime32_created = 4;

    pub fn rtime32_created(&self) -> u32 {
        self.rtime32_created.unwrap_or(0)
    }

    pub fn clear_rtime32_created(&mut self) {
        self.rtime32_created = ::std::option::Option::None;
    }

    pub fn has_rtime32_created(&self) -> bool {
        self.rtime32_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_created(&mut self, v: u32) {
        self.rtime32_created = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 5;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 permissions = 7;

    pub fn permissions(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    // optional string caption = 8;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shortcut_name = 9;

    pub fn shortcut_name(&self) -> &str {
        match self.shortcut_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shortcut_name(&mut self) {
        self.shortcut_name = ::std::option::Option::None;
    }

    pub fn has_shortcut_name(&self) -> bool {
        self.shortcut_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcut_name(&mut self, v: ::std::string::String) {
        self.shortcut_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcut_name(&mut self) -> &mut ::std::string::String {
        if self.shortcut_name.is_none() {
            self.shortcut_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shortcut_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcut_name(&mut self) -> ::std::string::String {
        self.shortcut_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgClientUCMAddScreenshot.Tag tag = 10;

    pub fn tag(&self) -> &[cmsg_client_ucmadd_screenshot::Tag] {
        &self.tag
    }

    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::vec::Vec<cmsg_client_ucmadd_screenshot::Tag>) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tag(&mut self) -> &mut ::std::vec::Vec<cmsg_client_ucmadd_screenshot::Tag> {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::vec::Vec<cmsg_client_ucmadd_screenshot::Tag> {
        ::std::mem::replace(&mut self.tag, ::std::vec::Vec::new())
    }

    // repeated fixed64 tagged_steamid = 11;

    pub fn tagged_steamid(&self) -> &[u64] {
        &self.tagged_steamid
    }

    pub fn clear_tagged_steamid(&mut self) {
        self.tagged_steamid.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagged_steamid(&mut self, v: ::std::vec::Vec<u64>) {
        self.tagged_steamid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagged_steamid(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.tagged_steamid
    }

    // Take field
    pub fn take_tagged_steamid(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.tagged_steamid, ::std::vec::Vec::new())
    }

    // optional bool spoiler_tag = 12;

    pub fn spoiler_tag(&self) -> bool {
        self.spoiler_tag.unwrap_or(false)
    }

    pub fn clear_spoiler_tag(&mut self) {
        self.spoiler_tag = ::std::option::Option::None;
    }

    pub fn has_spoiler_tag(&self) -> bool {
        self.spoiler_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spoiler_tag(&mut self, v: bool) {
        self.spoiler_tag = ::std::option::Option::Some(v);
    }

    // repeated uint64 tagged_publishedfileid = 13;

    pub fn tagged_publishedfileid(&self) -> &[u64] {
        &self.tagged_publishedfileid
    }

    pub fn clear_tagged_publishedfileid(&mut self) {
        self.tagged_publishedfileid.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagged_publishedfileid(&mut self, v: ::std::vec::Vec<u64>) {
        self.tagged_publishedfileid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagged_publishedfileid(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.tagged_publishedfileid
    }

    // Take field
    pub fn take_tagged_publishedfileid(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.tagged_publishedfileid, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUCMAddScreenshot| { &m.appid },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientUCMAddScreenshot| { &m.filename },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbname",
            |m: &CMsgClientUCMAddScreenshot| { &m.thumbname },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.thumbname },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_filename",
            |m: &CMsgClientUCMAddScreenshot| { &m.vr_filename },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.vr_filename },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_created",
            |m: &CMsgClientUCMAddScreenshot| { &m.rtime32_created },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.rtime32_created },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgClientUCMAddScreenshot| { &m.width },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgClientUCMAddScreenshot| { &m.height },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "permissions",
            |m: &CMsgClientUCMAddScreenshot| { &m.permissions },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.permissions },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &CMsgClientUCMAddScreenshot| { &m.caption },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.caption },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shortcut_name",
            |m: &CMsgClientUCMAddScreenshot| { &m.shortcut_name },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.shortcut_name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tag",
            |m: &CMsgClientUCMAddScreenshot| { &m.tag },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tag },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagged_steamid",
            |m: &CMsgClientUCMAddScreenshot| { &m.tagged_steamid },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "spoiler_tag",
            |m: &CMsgClientUCMAddScreenshot| { &m.spoiler_tag },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.spoiler_tag },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagged_publishedfileid",
            |m: &CMsgClientUCMAddScreenshot| { &m.tagged_publishedfileid },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_publishedfileid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMAddScreenshot>(
            "CMsgClientUCMAddScreenshot",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMAddScreenshot {
    const NAME: &'static str = "CMsgClientUCMAddScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.thumbname = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.vr_filename = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.rtime32_created = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.permissions = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.shortcut_name = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.tag.push(is.read_message()?);
                },
                90 => {
                    is.read_repeated_packed_fixed64_into(&mut self.tagged_steamid)?;
                },
                89 => {
                    self.tagged_steamid.push(is.read_fixed64()?);
                },
                96 => {
                    self.spoiler_tag = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    is.read_repeated_packed_uint64_into(&mut self.tagged_publishedfileid)?;
                },
                104 => {
                    self.tagged_publishedfileid.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbname.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.vr_filename.as_ref() {
            my_size += crate::rt::string_size(14, &v);
        }
        if let Some(v) = self.rtime32_created {
            my_size += 1 + 4;
        }
        if let Some(v) = self.width {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.permissions {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        for value in &self.tag {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 9 * self.tagged_steamid.len() as u64;
        if let Some(v) = self.spoiler_tag {
            my_size += 1 + 1;
        }
        for value in &self.tagged_publishedfileid {
            my_size += crate::rt::uint64_size(13, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbname.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.vr_filename.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.rtime32_created {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.tag {
            crate::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.tagged_steamid {
            os.write_fixed64(11, *v)?;
        };
        if let Some(v) = self.spoiler_tag {
            os.write_bool(12, v)?;
        }
        for v in &self.tagged_publishedfileid {
            os.write_uint64(13, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMAddScreenshot {
        CMsgClientUCMAddScreenshot::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.thumbname = ::std::option::Option::None;
        self.vr_filename = ::std::option::Option::None;
        self.rtime32_created = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.shortcut_name = ::std::option::Option::None;
        self.tag.clear();
        self.tagged_steamid.clear();
        self.spoiler_tag = ::std::option::Option::None;
        self.tagged_publishedfileid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshot {
        static instance: CMsgClientUCMAddScreenshot = CMsgClientUCMAddScreenshot {
            appid: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            thumbname: ::std::option::Option::None,
            vr_filename: ::std::option::Option::None,
            rtime32_created: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            permissions: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            shortcut_name: ::std::option::Option::None,
            tag: ::std::vec::Vec::new(),
            tagged_steamid: ::std::vec::Vec::new(),
            spoiler_tag: ::std::option::Option::None,
            tagged_publishedfileid: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMAddScreenshot {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMAddScreenshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMAddScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMAddScreenshot {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMAddScreenshot`
pub mod cmsg_client_ucmadd_screenshot {
    // @@protoc_insertion_point(message:CMsgClientUCMAddScreenshot.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.Tag.tag_name)
        pub tag_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.Tag.tag_value)
        pub tag_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshot.Tag.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as crate::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional string tag_name = 1;

        pub fn tag_name(&self) -> &str {
            match self.tag_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_name(&mut self) {
            self.tag_name = ::std::option::Option::None;
        }

        pub fn has_tag_name(&self) -> bool {
            self.tag_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_name(&mut self, v: ::std::string::String) {
            self.tag_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_name(&mut self) -> &mut ::std::string::String {
            if self.tag_name.is_none() {
                self.tag_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tag_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_name(&mut self) -> ::std::string::String {
            self.tag_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string tag_value = 2;

        pub fn tag_value(&self) -> &str {
            match self.tag_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_value(&mut self) {
            self.tag_value = ::std::option::Option::None;
        }

        pub fn has_tag_value(&self) -> bool {
            self.tag_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_value(&mut self, v: ::std::string::String) {
            self.tag_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_value(&mut self) -> &mut ::std::string::String {
            if self.tag_value.is_none() {
                self.tag_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tag_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_value(&mut self) -> ::std::string::String {
            self.tag_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "tag_name",
                |m: &Tag| { &m.tag_name },
                |m: &mut Tag| { &mut m.tag_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "tag_value",
                |m: &Tag| { &m.tag_value },
                |m: &mut Tag| { &mut m.tag_value },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "CMsgClientUCMAddScreenshot.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tag_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.tag_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tag_name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.tag_value.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.tag_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.tag_value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tag_name = ::std::option::Option::None;
            self.tag_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tag_name: ::std::option::Option::None,
                tag_value: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Tag {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMAddScreenshot.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Tag {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMAddScreenshotResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMAddScreenshotResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshotResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshotResponse.screenshotid)
    pub screenshotid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshotResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshotResponse {
    fn default() -> &'a CMsgClientUCMAddScreenshotResponse {
        <CMsgClientUCMAddScreenshotResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshotResponse {
    pub fn new() -> CMsgClientUCMAddScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 screenshotid = 2;

    pub fn screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMAddScreenshotResponse| { &m.eresult },
            |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshotid",
            |m: &CMsgClientUCMAddScreenshotResponse| { &m.screenshotid },
            |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.screenshotid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMAddScreenshotResponse>(
            "CMsgClientUCMAddScreenshotResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMAddScreenshotResponse {
    const NAME: &'static str = "CMsgClientUCMAddScreenshotResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.screenshotid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.screenshotid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMAddScreenshotResponse {
        CMsgClientUCMAddScreenshotResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.screenshotid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshotResponse {
        static instance: CMsgClientUCMAddScreenshotResponse = CMsgClientUCMAddScreenshotResponse {
            eresult: ::std::option::Option::None,
            screenshotid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMAddScreenshotResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMAddScreenshotResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMAddScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMAddScreenshotResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeleteScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeleteScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeleteScreenshot.screenshotid)
    pub screenshotid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeleteScreenshot.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshot {
    fn default() -> &'a CMsgClientUCMDeleteScreenshot {
        <CMsgClientUCMDeleteScreenshot as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshot {
    pub fn new() -> CMsgClientUCMDeleteScreenshot {
        ::std::default::Default::default()
    }

    // optional fixed64 screenshotid = 1;

    pub fn screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshotid",
            |m: &CMsgClientUCMDeleteScreenshot| { &m.screenshotid },
            |m: &mut CMsgClientUCMDeleteScreenshot| { &mut m.screenshotid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeleteScreenshot>(
            "CMsgClientUCMDeleteScreenshot",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMDeleteScreenshot {
    const NAME: &'static str = "CMsgClientUCMDeleteScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshotid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.screenshotid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeleteScreenshot {
        CMsgClientUCMDeleteScreenshot::new()
    }

    fn clear(&mut self) {
        self.screenshotid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshot {
        static instance: CMsgClientUCMDeleteScreenshot = CMsgClientUCMDeleteScreenshot {
            screenshotid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMDeleteScreenshot {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeleteScreenshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeleteScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshot {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeleteScreenshotResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeleteScreenshotResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeleteScreenshotResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeleteScreenshotResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshotResponse {
    fn default() -> &'a CMsgClientUCMDeleteScreenshotResponse {
        <CMsgClientUCMDeleteScreenshotResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshotResponse {
    pub fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMDeleteScreenshotResponse| { &m.eresult },
            |m: &mut CMsgClientUCMDeleteScreenshotResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeleteScreenshotResponse>(
            "CMsgClientUCMDeleteScreenshotResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMDeleteScreenshotResponse {
    const NAME: &'static str = "CMsgClientUCMDeleteScreenshotResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        CMsgClientUCMDeleteScreenshotResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshotResponse {
        static instance: CMsgClientUCMDeleteScreenshotResponse = CMsgClientUCMDeleteScreenshotResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMDeleteScreenshotResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeleteScreenshotResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeleteScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshotResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.preview_file_name)
    pub preview_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.consumer_app_id)
    pub consumer_app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.workshop_file)
    pub workshop_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.visibility)
    pub visibility: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.file_type)
    pub file_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_provider)
    pub video_provider: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_account_name)
    pub video_account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_identifier)
    pub video_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.in_progress)
    pub in_progress: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishFile.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFile {
    fn default() -> &'a CMsgClientUCMPublishFile {
        <CMsgClientUCMPublishFile as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFile {
    pub fn new() -> CMsgClientUCMPublishFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 3;

    pub fn preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name = ::std::option::Option::None;
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 consumer_app_id = 4;

    pub fn consumer_app_id(&self) -> u32 {
        self.consumer_app_id.unwrap_or(0)
    }

    pub fn clear_consumer_app_id(&mut self) {
        self.consumer_app_id = ::std::option::Option::None;
    }

    pub fn has_consumer_app_id(&self) -> bool {
        self.consumer_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_app_id(&mut self, v: u32) {
        self.consumer_app_id = ::std::option::Option::Some(v);
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tags = 8;

    pub fn tags(&self) -> &[::std::string::String] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    // optional bool workshop_file = 9;

    pub fn workshop_file(&self) -> bool {
        self.workshop_file.unwrap_or(false)
    }

    pub fn clear_workshop_file(&mut self) {
        self.workshop_file = ::std::option::Option::None;
    }

    pub fn has_workshop_file(&self) -> bool {
        self.workshop_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file(&mut self, v: bool) {
        self.workshop_file = ::std::option::Option::Some(v);
    }

    // optional int32 visibility = 10;

    pub fn visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional uint32 file_type = 11;

    pub fn file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }

    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional string url = 12;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 video_provider = 13;

    pub fn video_provider(&self) -> u32 {
        self.video_provider.unwrap_or(0)
    }

    pub fn clear_video_provider(&mut self) {
        self.video_provider = ::std::option::Option::None;
    }

    pub fn has_video_provider(&self) -> bool {
        self.video_provider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_provider(&mut self, v: u32) {
        self.video_provider = ::std::option::Option::Some(v);
    }

    // optional string video_account_name = 14;

    pub fn video_account_name(&self) -> &str {
        match self.video_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_account_name(&mut self) {
        self.video_account_name = ::std::option::Option::None;
    }

    pub fn has_video_account_name(&self) -> bool {
        self.video_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_account_name(&mut self, v: ::std::string::String) {
        self.video_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_account_name(&mut self) -> &mut ::std::string::String {
        if self.video_account_name.is_none() {
            self.video_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_account_name(&mut self) -> ::std::string::String {
        self.video_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string video_identifier = 15;

    pub fn video_identifier(&self) -> &str {
        match self.video_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_identifier(&mut self) {
        self.video_identifier = ::std::option::Option::None;
    }

    pub fn has_video_identifier(&self) -> bool {
        self.video_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_identifier(&mut self, v: ::std::string::String) {
        self.video_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_identifier(&mut self) -> &mut ::std::string::String {
        if self.video_identifier.is_none() {
            self.video_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_identifier(&mut self) -> ::std::string::String {
        self.video_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_progress = 16;

    pub fn in_progress(&self) -> bool {
        self.in_progress.unwrap_or(false)
    }

    pub fn clear_in_progress(&mut self) {
        self.in_progress = ::std::option::Option::None;
    }

    pub fn has_in_progress(&self) -> bool {
        self.in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_progress(&mut self, v: bool) {
        self.in_progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMPublishFile| { &m.app_id },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUCMPublishFile| { &m.file_name },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.file_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "preview_file_name",
            |m: &CMsgClientUCMPublishFile| { &m.preview_file_name },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.preview_file_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "consumer_app_id",
            |m: &CMsgClientUCMPublishFile| { &m.consumer_app_id },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.consumer_app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgClientUCMPublishFile| { &m.title },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgClientUCMPublishFile| { &m.description },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.description },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CMsgClientUCMPublishFile| { &m.tags },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.tags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "workshop_file",
            |m: &CMsgClientUCMPublishFile| { &m.workshop_file },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.workshop_file },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &CMsgClientUCMPublishFile| { &m.visibility },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.visibility },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_type",
            |m: &CMsgClientUCMPublishFile| { &m.file_type },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.file_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgClientUCMPublishFile| { &m.url },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_provider",
            |m: &CMsgClientUCMPublishFile| { &m.video_provider },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.video_provider },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_account_name",
            |m: &CMsgClientUCMPublishFile| { &m.video_account_name },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.video_account_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_identifier",
            |m: &CMsgClientUCMPublishFile| { &m.video_identifier },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.video_identifier },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_progress",
            |m: &CMsgClientUCMPublishFile| { &m.in_progress },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.in_progress },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMPublishFile>(
            "CMsgClientUCMPublishFile",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMPublishFile {
    const NAME: &'static str = "CMsgClientUCMPublishFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.preview_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.consumer_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.tags.push(is.read_string()?);
                },
                72 => {
                    self.workshop_file = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.video_provider = ::std::option::Option::Some(is.read_uint32()?);
                },
                114 => {
                    self.video_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.video_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.consumer_app_id {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += crate::rt::string_size(8, &value);
        };
        if let Some(v) = self.workshop_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.visibility {
            my_size += crate::rt::int32_size(10, v);
        }
        if let Some(v) = self.file_type {
            my_size += crate::rt::uint32_size(11, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        if let Some(v) = self.video_provider {
            my_size += crate::rt::uint32_size(13, v);
        }
        if let Some(v) = self.video_account_name.as_ref() {
            my_size += crate::rt::string_size(14, &v);
        }
        if let Some(v) = self.video_identifier.as_ref() {
            my_size += crate::rt::string_size(15, &v);
        }
        if let Some(v) = self.in_progress {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.consumer_app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.workshop_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.video_provider {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.video_account_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.video_identifier.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.in_progress {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishFile {
        CMsgClientUCMPublishFile::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.preview_file_name = ::std::option::Option::None;
        self.consumer_app_id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.tags.clear();
        self.workshop_file = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.file_type = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.video_provider = ::std::option::Option::None;
        self.video_account_name = ::std::option::Option::None;
        self.video_identifier = ::std::option::Option::None;
        self.in_progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFile {
        static instance: CMsgClientUCMPublishFile = CMsgClientUCMPublishFile {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            preview_file_name: ::std::option::Option::None,
            consumer_app_id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            workshop_file: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            file_type: ::std::option::Option::None,
            url: ::std::option::Option::None,
            video_provider: ::std::option::Option::None,
            video_account_name: ::std::option::Option::None,
            video_identifier: ::std::option::Option::None,
            in_progress: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMPublishFile {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMPublishFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMPublishFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMPublishFile {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.needs_workshop_legal_agreement_acceptance)
    pub needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishFileResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFileResponse {
    fn default() -> &'a CMsgClientUCMPublishFileResponse {
        <CMsgClientUCMPublishFileResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFileResponse {
    pub fn new() -> CMsgClientUCMPublishFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 3;

    pub fn needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMPublishFileResponse| { &m.eresult },
            |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMPublishFileResponse| { &m.published_file_id },
            |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.published_file_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_workshop_legal_agreement_acceptance",
            |m: &CMsgClientUCMPublishFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
            |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMPublishFileResponse>(
            "CMsgClientUCMPublishFileResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMPublishFileResponse {
    const NAME: &'static str = "CMsgClientUCMPublishFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishFileResponse {
        CMsgClientUCMPublishFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFileResponse {
        static instance: CMsgClientUCMPublishFileResponse = CMsgClientUCMPublishFileResponse {
            eresult: ::std::option::Option::None,
            published_file_id: ::std::option::Option::None,
            needs_workshop_legal_agreement_acceptance: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMPublishFileResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMPublishFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMPublishFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMPublishFileResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMUpdatePublishedFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.preview_file_name)
    pub preview_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.visibility)
    pub visibility: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_file)
    pub update_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_preview_file)
    pub update_preview_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_title)
    pub update_title: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_description)
    pub update_description: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_tags)
    pub update_tags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_visibility)
    pub update_visibility: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.change_description)
    pub change_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_url)
    pub update_url: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_content_manifest)
    pub update_content_manifest: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.content_manifest)
    pub content_manifest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.metadata)
    pub metadata: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_metadata)
    pub update_metadata: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.removed_kvtags)
    pub removed_kvtags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.kvtags)
    pub kvtags: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::KeyValueTag>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.previews)
    pub previews: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::AdditionalPreview>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.previews_to_remove)
    pub previews_to_remove: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.clear_in_progress)
    pub clear_in_progress: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.remove_all_kvtags)
    pub remove_all_kvtags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.content_descriptors_to_add)
    pub content_descriptors_to_add: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.content_descriptors_to_remove)
    pub content_descriptors_to_remove: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.allow_admin_tags)
    pub allow_admin_tags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.external_asset_id)
    pub external_asset_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFile {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFile {
        <CMsgClientUCMUpdatePublishedFile as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFile {
    pub fn new() -> CMsgClientUCMUpdatePublishedFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 4;

    pub fn preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name = ::std::option::Option::None;
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tags = 7;

    pub fn tags(&self) -> &[::std::string::String] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    // optional int32 visibility = 8;

    pub fn visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional bool update_file = 9;

    pub fn update_file(&self) -> bool {
        self.update_file.unwrap_or(false)
    }

    pub fn clear_update_file(&mut self) {
        self.update_file = ::std::option::Option::None;
    }

    pub fn has_update_file(&self) -> bool {
        self.update_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_file(&mut self, v: bool) {
        self.update_file = ::std::option::Option::Some(v);
    }

    // optional bool update_preview_file = 10;

    pub fn update_preview_file(&self) -> bool {
        self.update_preview_file.unwrap_or(false)
    }

    pub fn clear_update_preview_file(&mut self) {
        self.update_preview_file = ::std::option::Option::None;
    }

    pub fn has_update_preview_file(&self) -> bool {
        self.update_preview_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_preview_file(&mut self, v: bool) {
        self.update_preview_file = ::std::option::Option::Some(v);
    }

    // optional bool update_title = 11;

    pub fn update_title(&self) -> bool {
        self.update_title.unwrap_or(false)
    }

    pub fn clear_update_title(&mut self) {
        self.update_title = ::std::option::Option::None;
    }

    pub fn has_update_title(&self) -> bool {
        self.update_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_title(&mut self, v: bool) {
        self.update_title = ::std::option::Option::Some(v);
    }

    // optional bool update_description = 12;

    pub fn update_description(&self) -> bool {
        self.update_description.unwrap_or(false)
    }

    pub fn clear_update_description(&mut self) {
        self.update_description = ::std::option::Option::None;
    }

    pub fn has_update_description(&self) -> bool {
        self.update_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_description(&mut self, v: bool) {
        self.update_description = ::std::option::Option::Some(v);
    }

    // optional bool update_tags = 13;

    pub fn update_tags(&self) -> bool {
        self.update_tags.unwrap_or(false)
    }

    pub fn clear_update_tags(&mut self) {
        self.update_tags = ::std::option::Option::None;
    }

    pub fn has_update_tags(&self) -> bool {
        self.update_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_tags(&mut self, v: bool) {
        self.update_tags = ::std::option::Option::Some(v);
    }

    // optional bool update_visibility = 14;

    pub fn update_visibility(&self) -> bool {
        self.update_visibility.unwrap_or(false)
    }

    pub fn clear_update_visibility(&mut self) {
        self.update_visibility = ::std::option::Option::None;
    }

    pub fn has_update_visibility(&self) -> bool {
        self.update_visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_visibility(&mut self, v: bool) {
        self.update_visibility = ::std::option::Option::Some(v);
    }

    // optional string change_description = 15;

    pub fn change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_change_description(&mut self) {
        self.change_description = ::std::option::Option::None;
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_url = 16;

    pub fn update_url(&self) -> bool {
        self.update_url.unwrap_or(false)
    }

    pub fn clear_update_url(&mut self) {
        self.update_url = ::std::option::Option::None;
    }

    pub fn has_update_url(&self) -> bool {
        self.update_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_url(&mut self, v: bool) {
        self.update_url = ::std::option::Option::Some(v);
    }

    // optional string url = 17;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_content_manifest = 18;

    pub fn update_content_manifest(&self) -> bool {
        self.update_content_manifest.unwrap_or(false)
    }

    pub fn clear_update_content_manifest(&mut self) {
        self.update_content_manifest = ::std::option::Option::None;
    }

    pub fn has_update_content_manifest(&self) -> bool {
        self.update_content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_content_manifest(&mut self, v: bool) {
        self.update_content_manifest = ::std::option::Option::Some(v);
    }

    // optional fixed64 content_manifest = 19;

    pub fn content_manifest(&self) -> u64 {
        self.content_manifest.unwrap_or(0)
    }

    pub fn clear_content_manifest(&mut self) {
        self.content_manifest = ::std::option::Option::None;
    }

    pub fn has_content_manifest(&self) -> bool {
        self.content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_manifest(&mut self, v: u64) {
        self.content_manifest = ::std::option::Option::Some(v);
    }

    // optional string metadata = 20;

    pub fn metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_metadata = 21;

    pub fn update_metadata(&self) -> bool {
        self.update_metadata.unwrap_or(false)
    }

    pub fn clear_update_metadata(&mut self) {
        self.update_metadata = ::std::option::Option::None;
    }

    pub fn has_update_metadata(&self) -> bool {
        self.update_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_metadata(&mut self, v: bool) {
        self.update_metadata = ::std::option::Option::Some(v);
    }

    // optional int32 language = 22;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // repeated string removed_kvtags = 23;

    pub fn removed_kvtags(&self) -> &[::std::string::String] {
        &self.removed_kvtags
    }

    pub fn clear_removed_kvtags(&mut self) {
        self.removed_kvtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_removed_kvtags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.removed_kvtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_removed_kvtags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.removed_kvtags
    }

    // Take field
    pub fn take_removed_kvtags(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.removed_kvtags, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientUCMUpdatePublishedFile.KeyValueTag kvtags = 24;

    pub fn kvtags(&self) -> &[cmsg_client_ucmupdate_published_file::KeyValueTag] {
        &self.kvtags
    }

    pub fn clear_kvtags(&mut self) {
        self.kvtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvtags(&mut self, v: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::KeyValueTag>) {
        self.kvtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvtags(&mut self) -> &mut ::std::vec::Vec<cmsg_client_ucmupdate_published_file::KeyValueTag> {
        &mut self.kvtags
    }

    // Take field
    pub fn take_kvtags(&mut self) -> ::std::vec::Vec<cmsg_client_ucmupdate_published_file::KeyValueTag> {
        ::std::mem::replace(&mut self.kvtags, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientUCMUpdatePublishedFile.AdditionalPreview previews = 25;

    pub fn previews(&self) -> &[cmsg_client_ucmupdate_published_file::AdditionalPreview] {
        &self.previews
    }

    pub fn clear_previews(&mut self) {
        self.previews.clear();
    }

    // Param is passed by value, moved
    pub fn set_previews(&mut self, v: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::AdditionalPreview>) {
        self.previews = v;
    }

    // Mutable pointer to the field.
    pub fn mut_previews(&mut self) -> &mut ::std::vec::Vec<cmsg_client_ucmupdate_published_file::AdditionalPreview> {
        &mut self.previews
    }

    // Take field
    pub fn take_previews(&mut self) -> ::std::vec::Vec<cmsg_client_ucmupdate_published_file::AdditionalPreview> {
        ::std::mem::replace(&mut self.previews, ::std::vec::Vec::new())
    }

    // repeated int32 previews_to_remove = 26;

    pub fn previews_to_remove(&self) -> &[i32] {
        &self.previews_to_remove
    }

    pub fn clear_previews_to_remove(&mut self) {
        self.previews_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_previews_to_remove(&mut self, v: ::std::vec::Vec<i32>) {
        self.previews_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_previews_to_remove(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.previews_to_remove
    }

    // Take field
    pub fn take_previews_to_remove(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.previews_to_remove, ::std::vec::Vec::new())
    }

    // optional bool clear_in_progress = 27;

    pub fn clear_in_progress(&self) -> bool {
        self.clear_in_progress.unwrap_or(false)
    }

    pub fn clear_clear_in_progress(&mut self) {
        self.clear_in_progress = ::std::option::Option::None;
    }

    pub fn has_clear_in_progress(&self) -> bool {
        self.clear_in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_in_progress(&mut self, v: bool) {
        self.clear_in_progress = ::std::option::Option::Some(v);
    }

    // optional bool remove_all_kvtags = 28;

    pub fn remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.unwrap_or(false)
    }

    pub fn clear_remove_all_kvtags(&mut self) {
        self.remove_all_kvtags = ::std::option::Option::None;
    }

    pub fn has_remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_all_kvtags(&mut self, v: bool) {
        self.remove_all_kvtags = ::std::option::Option::Some(v);
    }

    // repeated int32 content_descriptors_to_add = 29;

    pub fn content_descriptors_to_add(&self) -> &[i32] {
        &self.content_descriptors_to_add
    }

    pub fn clear_content_descriptors_to_add(&mut self) {
        self.content_descriptors_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_descriptors_to_add(&mut self, v: ::std::vec::Vec<i32>) {
        self.content_descriptors_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_content_descriptors_to_add(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.content_descriptors_to_add
    }

    // Take field
    pub fn take_content_descriptors_to_add(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.content_descriptors_to_add, ::std::vec::Vec::new())
    }

    // repeated int32 content_descriptors_to_remove = 30;

    pub fn content_descriptors_to_remove(&self) -> &[i32] {
        &self.content_descriptors_to_remove
    }

    pub fn clear_content_descriptors_to_remove(&mut self) {
        self.content_descriptors_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_descriptors_to_remove(&mut self, v: ::std::vec::Vec<i32>) {
        self.content_descriptors_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_content_descriptors_to_remove(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.content_descriptors_to_remove
    }

    // Take field
    pub fn take_content_descriptors_to_remove(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.content_descriptors_to_remove, ::std::vec::Vec::new())
    }

    // optional bool allow_admin_tags = 31;

    pub fn allow_admin_tags(&self) -> bool {
        self.allow_admin_tags.unwrap_or(false)
    }

    pub fn clear_allow_admin_tags(&mut self) {
        self.allow_admin_tags = ::std::option::Option::None;
    }

    pub fn has_allow_admin_tags(&self) -> bool {
        self.allow_admin_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_admin_tags(&mut self, v: bool) {
        self.allow_admin_tags = ::std::option::Option::Some(v);
    }

    // optional uint64 external_asset_id = 32;

    pub fn external_asset_id(&self) -> u64 {
        self.external_asset_id.unwrap_or(0)
    }

    pub fn clear_external_asset_id(&mut self) {
        self.external_asset_id = ::std::option::Option::None;
    }

    pub fn has_external_asset_id(&self) -> bool {
        self.external_asset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_asset_id(&mut self, v: u64) {
        self.external_asset_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(32);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.app_id },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.published_file_id },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.published_file_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.file_name },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.file_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "preview_file_name",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.preview_file_name },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.preview_file_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.title },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.description },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.description },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.tags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.tags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.visibility },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.visibility },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_file",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_file },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_file },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_preview_file",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_preview_file },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_preview_file },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_title",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_title },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_description",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_description },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_tags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_tags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_tags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_visibility",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_visibility },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_visibility },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "change_description",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.change_description },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.change_description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_url",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_url },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.url },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_content_manifest",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_content_manifest },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_content_manifest },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "content_manifest",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.content_manifest },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.content_manifest },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.metadata },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.metadata },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_metadata",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_metadata },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_metadata },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.language },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "removed_kvtags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.removed_kvtags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.removed_kvtags },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kvtags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.kvtags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.kvtags },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previews",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previews_to_remove",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews_to_remove },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews_to_remove },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clear_in_progress",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.clear_in_progress },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.clear_in_progress },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "remove_all_kvtags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.remove_all_kvtags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.remove_all_kvtags },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_descriptors_to_add",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.content_descriptors_to_add },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.content_descriptors_to_add },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_descriptors_to_remove",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.content_descriptors_to_remove },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.content_descriptors_to_remove },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_admin_tags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.allow_admin_tags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.allow_admin_tags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "external_asset_id",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.external_asset_id },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.external_asset_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMUpdatePublishedFile>(
            "CMsgClientUCMUpdatePublishedFile",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMUpdatePublishedFile {
    const NAME: &'static str = "CMsgClientUCMUpdatePublishedFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.preview_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.tags.push(is.read_string()?);
                },
                64 => {
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.update_file = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.update_preview_file = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.update_title = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.update_description = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.update_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.update_visibility = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.change_description = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.update_url = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.update_content_manifest = ::std::option::Option::Some(is.read_bool()?);
                },
                153 => {
                    self.content_manifest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                162 => {
                    self.metadata = ::std::option::Option::Some(is.read_string()?);
                },
                168 => {
                    self.update_metadata = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                186 => {
                    self.removed_kvtags.push(is.read_string()?);
                },
                194 => {
                    self.kvtags.push(is.read_message()?);
                },
                202 => {
                    self.previews.push(is.read_message()?);
                },
                210 => {
                    is.read_repeated_packed_int32_into(&mut self.previews_to_remove)?;
                },
                208 => {
                    self.previews_to_remove.push(is.read_int32()?);
                },
                216 => {
                    self.clear_in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.remove_all_kvtags = ::std::option::Option::Some(is.read_bool()?);
                },
                234 => {
                    is.read_repeated_packed_int32_into(&mut self.content_descriptors_to_add)?;
                },
                232 => {
                    self.content_descriptors_to_add.push(is.read_int32()?);
                },
                242 => {
                    is.read_repeated_packed_int32_into(&mut self.content_descriptors_to_remove)?;
                },
                240 => {
                    self.content_descriptors_to_remove.push(is.read_int32()?);
                },
                248 => {
                    self.allow_admin_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                256 => {
                    self.external_asset_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += crate::rt::string_size(7, &value);
        };
        if let Some(v) = self.visibility {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.update_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_preview_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_title {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_description {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_tags {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_visibility {
            my_size += 1 + 1;
        }
        if let Some(v) = self.change_description.as_ref() {
            my_size += crate::rt::string_size(15, &v);
        }
        if let Some(v) = self.update_url {
            my_size += 2 + 1;
        }
        if let Some(v) = self.url.as_ref() {
            my_size += crate::rt::string_size(17, &v);
        }
        if let Some(v) = self.update_content_manifest {
            my_size += 2 + 1;
        }
        if let Some(v) = self.content_manifest {
            my_size += 2 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += crate::rt::string_size(20, &v);
        }
        if let Some(v) = self.update_metadata {
            my_size += 2 + 1;
        }
        if let Some(v) = self.language {
            my_size += crate::rt::int32_size(22, v);
        }
        for value in &self.removed_kvtags {
            my_size += crate::rt::string_size(23, &value);
        };
        for value in &self.kvtags {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.previews {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.previews_to_remove {
            my_size += crate::rt::int32_size(26, *value);
        };
        if let Some(v) = self.clear_in_progress {
            my_size += 2 + 1;
        }
        if let Some(v) = self.remove_all_kvtags {
            my_size += 2 + 1;
        }
        for value in &self.content_descriptors_to_add {
            my_size += crate::rt::int32_size(29, *value);
        };
        for value in &self.content_descriptors_to_remove {
            my_size += crate::rt::int32_size(30, *value);
        };
        if let Some(v) = self.allow_admin_tags {
            my_size += 2 + 1;
        }
        if let Some(v) = self.external_asset_id {
            my_size += crate::rt::uint64_size(32, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.visibility {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.update_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.update_preview_file {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.update_title {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.update_description {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.update_tags {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.update_visibility {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.change_description.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.update_url {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.update_content_manifest {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_manifest {
            os.write_fixed64(19, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.update_metadata {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(22, v)?;
        }
        for v in &self.removed_kvtags {
            os.write_string(23, &v)?;
        };
        for v in &self.kvtags {
            crate::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        for v in &self.previews {
            crate::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.previews_to_remove {
            os.write_int32(26, *v)?;
        };
        if let Some(v) = self.clear_in_progress {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.remove_all_kvtags {
            os.write_bool(28, v)?;
        }
        for v in &self.content_descriptors_to_add {
            os.write_int32(29, *v)?;
        };
        for v in &self.content_descriptors_to_remove {
            os.write_int32(30, *v)?;
        };
        if let Some(v) = self.allow_admin_tags {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.external_asset_id {
            os.write_uint64(32, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMUpdatePublishedFile {
        CMsgClientUCMUpdatePublishedFile::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.preview_file_name = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.tags.clear();
        self.visibility = ::std::option::Option::None;
        self.update_file = ::std::option::Option::None;
        self.update_preview_file = ::std::option::Option::None;
        self.update_title = ::std::option::Option::None;
        self.update_description = ::std::option::Option::None;
        self.update_tags = ::std::option::Option::None;
        self.update_visibility = ::std::option::Option::None;
        self.change_description = ::std::option::Option::None;
        self.update_url = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.update_content_manifest = ::std::option::Option::None;
        self.content_manifest = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.update_metadata = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.removed_kvtags.clear();
        self.kvtags.clear();
        self.previews.clear();
        self.previews_to_remove.clear();
        self.clear_in_progress = ::std::option::Option::None;
        self.remove_all_kvtags = ::std::option::Option::None;
        self.content_descriptors_to_add.clear();
        self.content_descriptors_to_remove.clear();
        self.allow_admin_tags = ::std::option::Option::None;
        self.external_asset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFile {
        static instance: CMsgClientUCMUpdatePublishedFile = CMsgClientUCMUpdatePublishedFile {
            app_id: ::std::option::Option::None,
            published_file_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            preview_file_name: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            visibility: ::std::option::Option::None,
            update_file: ::std::option::Option::None,
            update_preview_file: ::std::option::Option::None,
            update_title: ::std::option::Option::None,
            update_description: ::std::option::Option::None,
            update_tags: ::std::option::Option::None,
            update_visibility: ::std::option::Option::None,
            change_description: ::std::option::Option::None,
            update_url: ::std::option::Option::None,
            url: ::std::option::Option::None,
            update_content_manifest: ::std::option::Option::None,
            content_manifest: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            update_metadata: ::std::option::Option::None,
            language: ::std::option::Option::None,
            removed_kvtags: ::std::vec::Vec::new(),
            kvtags: ::std::vec::Vec::new(),
            previews: ::std::vec::Vec::new(),
            previews_to_remove: ::std::vec::Vec::new(),
            clear_in_progress: ::std::option::Option::None,
            remove_all_kvtags: ::std::option::Option::None,
            content_descriptors_to_add: ::std::vec::Vec::new(),
            content_descriptors_to_remove: ::std::vec::Vec::new(),
            allow_admin_tags: ::std::option::Option::None,
            external_asset_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMUpdatePublishedFile {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMUpdatePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFile {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMUpdatePublishedFile`
pub mod cmsg_client_ucmupdate_published_file {
    // @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile.KeyValueTag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KeyValueTag {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KeyValueTag {
        fn default() -> &'a KeyValueTag {
            <KeyValueTag as crate::Message>::default_instance()
        }
    }

    impl KeyValueTag {
        pub fn new() -> KeyValueTag {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &KeyValueTag| { &m.key },
                |m: &mut KeyValueTag| { &mut m.key },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &KeyValueTag| { &m.value },
                |m: &mut KeyValueTag| { &mut m.value },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<KeyValueTag>(
                "CMsgClientUCMUpdatePublishedFile.KeyValueTag",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for KeyValueTag {
        const NAME: &'static str = "KeyValueTag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KeyValueTag {
            KeyValueTag::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KeyValueTag {
            static instance: KeyValueTag = KeyValueTag {
                key: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for KeyValueTag {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFile.KeyValueTag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KeyValueTag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for KeyValueTag {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile.AdditionalPreview)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalPreview {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.original_file_name)
        pub original_file_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.internal_file_name)
        pub internal_file_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.videoid)
        pub videoid: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.preview_type)
        pub preview_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.update_index)
        pub update_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalPreview {
        fn default() -> &'a AdditionalPreview {
            <AdditionalPreview as crate::Message>::default_instance()
        }
    }

    impl AdditionalPreview {
        pub fn new() -> AdditionalPreview {
            ::std::default::Default::default()
        }

        // optional string original_file_name = 1;

        pub fn original_file_name(&self) -> &str {
            match self.original_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_original_file_name(&mut self) {
            self.original_file_name = ::std::option::Option::None;
        }

        pub fn has_original_file_name(&self) -> bool {
            self.original_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_file_name(&mut self, v: ::std::string::String) {
            self.original_file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_original_file_name(&mut self) -> &mut ::std::string::String {
            if self.original_file_name.is_none() {
                self.original_file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.original_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_original_file_name(&mut self) -> ::std::string::String {
            self.original_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string internal_file_name = 2;

        pub fn internal_file_name(&self) -> &str {
            match self.internal_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_internal_file_name(&mut self) {
            self.internal_file_name = ::std::option::Option::None;
        }

        pub fn has_internal_file_name(&self) -> bool {
            self.internal_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_file_name(&mut self, v: ::std::string::String) {
            self.internal_file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_internal_file_name(&mut self) -> &mut ::std::string::String {
            if self.internal_file_name.is_none() {
                self.internal_file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.internal_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_internal_file_name(&mut self) -> ::std::string::String {
            self.internal_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string videoid = 3;

        pub fn videoid(&self) -> &str {
            match self.videoid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_videoid(&mut self) {
            self.videoid = ::std::option::Option::None;
        }

        pub fn has_videoid(&self) -> bool {
            self.videoid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_videoid(&mut self, v: ::std::string::String) {
            self.videoid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_videoid(&mut self) -> &mut ::std::string::String {
            if self.videoid.is_none() {
                self.videoid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.videoid.as_mut().unwrap()
        }

        // Take field
        pub fn take_videoid(&mut self) -> ::std::string::String {
            self.videoid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 preview_type = 4;

        pub fn preview_type(&self) -> u32 {
            self.preview_type.unwrap_or(0)
        }

        pub fn clear_preview_type(&mut self) {
            self.preview_type = ::std::option::Option::None;
        }

        pub fn has_preview_type(&self) -> bool {
            self.preview_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_preview_type(&mut self, v: u32) {
            self.preview_type = ::std::option::Option::Some(v);
        }

        // optional int32 update_index = 5;

        pub fn update_index(&self) -> i32 {
            self.update_index.unwrap_or(-1i32)
        }

        pub fn clear_update_index(&mut self) {
            self.update_index = ::std::option::Option::None;
        }

        pub fn has_update_index(&self) -> bool {
            self.update_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_update_index(&mut self, v: i32) {
            self.update_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "original_file_name",
                |m: &AdditionalPreview| { &m.original_file_name },
                |m: &mut AdditionalPreview| { &mut m.original_file_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "internal_file_name",
                |m: &AdditionalPreview| { &m.internal_file_name },
                |m: &mut AdditionalPreview| { &mut m.internal_file_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "videoid",
                |m: &AdditionalPreview| { &m.videoid },
                |m: &mut AdditionalPreview| { &mut m.videoid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "preview_type",
                |m: &AdditionalPreview| { &m.preview_type },
                |m: &mut AdditionalPreview| { &mut m.preview_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "update_index",
                |m: &AdditionalPreview| { &m.update_index },
                |m: &mut AdditionalPreview| { &mut m.update_index },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalPreview>(
                "CMsgClientUCMUpdatePublishedFile.AdditionalPreview",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for AdditionalPreview {
        const NAME: &'static str = "AdditionalPreview";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.original_file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.internal_file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.videoid = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.preview_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.update_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.original_file_name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.videoid.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.preview_type {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.update_index {
                my_size += crate::rt::int32_size(5, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.original_file_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.videoid.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.preview_type {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.update_index {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalPreview {
            AdditionalPreview::new()
        }

        fn clear(&mut self) {
            self.original_file_name = ::std::option::Option::None;
            self.internal_file_name = ::std::option::Option::None;
            self.videoid = ::std::option::Option::None;
            self.preview_type = ::std::option::Option::None;
            self.update_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalPreview {
            static instance: AdditionalPreview = AdditionalPreview {
                original_file_name: ::std::option::Option::None,
                internal_file_name: ::std::option::Option::None,
                videoid: ::std::option::Option::None,
                preview_type: ::std::option::Option::None,
                update_index: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for AdditionalPreview {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFile.AdditionalPreview").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdditionalPreview {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for AdditionalPreview {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMUpdatePublishedFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFileResponse.needs_workshop_legal_agreement_acceptance)
    pub needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFileResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFileResponse {
        <CMsgClientUCMUpdatePublishedFileResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFileResponse {
    pub fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 2;

    pub fn needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.eresult },
            |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_workshop_legal_agreement_acceptance",
            |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
            |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMUpdatePublishedFileResponse>(
            "CMsgClientUCMUpdatePublishedFileResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMUpdatePublishedFileResponse {
    const NAME: &'static str = "CMsgClientUCMUpdatePublishedFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        CMsgClientUCMUpdatePublishedFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFileResponse {
        static instance: CMsgClientUCMUpdatePublishedFileResponse = CMsgClientUCMUpdatePublishedFileResponse {
            eresult: ::std::option::Option::None,
            needs_workshop_legal_agreement_acceptance: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMUpdatePublishedFileResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMUpdatePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFileResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeletePublishedFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeletePublishedFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFile.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeletePublishedFile.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFile {
    fn default() -> &'a CMsgClientUCMDeletePublishedFile {
        <CMsgClientUCMDeletePublishedFile as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFile {
    pub fn new() -> CMsgClientUCMDeletePublishedFile {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMDeletePublishedFile| { &m.published_file_id },
            |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.published_file_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMDeletePublishedFile| { &m.app_id },
            |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeletePublishedFile>(
            "CMsgClientUCMDeletePublishedFile",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMDeletePublishedFile {
    const NAME: &'static str = "CMsgClientUCMDeletePublishedFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeletePublishedFile {
        CMsgClientUCMDeletePublishedFile::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFile {
        static instance: CMsgClientUCMDeletePublishedFile = CMsgClientUCMDeletePublishedFile {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMDeletePublishedFile {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeletePublishedFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeletePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFile {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeletePublishedFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeletePublishedFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeletePublishedFileResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMDeletePublishedFileResponse {
        <CMsgClientUCMDeletePublishedFileResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFileResponse {
    pub fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMDeletePublishedFileResponse| { &m.eresult },
            |m: &mut CMsgClientUCMDeletePublishedFileResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeletePublishedFileResponse>(
            "CMsgClientUCMDeletePublishedFileResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMDeletePublishedFileResponse {
    const NAME: &'static str = "CMsgClientUCMDeletePublishedFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        CMsgClientUCMDeletePublishedFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFileResponse {
        static instance: CMsgClientUCMDeletePublishedFileResponse = CMsgClientUCMDeletePublishedFileResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMDeletePublishedFileResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeletePublishedFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeletePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFileResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.desired_revision)
    pub desired_revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 3;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_revision = 4;

    pub fn desired_revision(&self) -> u32 {
        self.desired_revision.unwrap_or(0u32)
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: u32) {
        self.desired_revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.app_id },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_index },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_time },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_revision",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.desired_revision },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.desired_revision },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates>(
            "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.start_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.desired_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desired_revision {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        static instance: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates = CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            desired_revision: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.subscribed_files)
    pub subscribed_files: ::std::vec::Vec<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId subscribed_files = 2;

    pub fn subscribed_files(&self) -> &[cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId] {
        &self.subscribed_files
    }

    pub fn clear_subscribed_files(&mut self) {
        self.subscribed_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscribed_files(&mut self, v: ::std::vec::Vec<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId>) {
        self.subscribed_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscribed_files(&mut self) -> &mut ::std::vec::Vec<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId> {
        &mut self.subscribed_files
    }

    // Take field
    pub fn take_subscribed_files(&mut self) -> ::std::vec::Vec<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId> {
        ::std::mem::replace(&mut self.subscribed_files, ::std::vec::Vec::new())
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.eresult },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscribed_files",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.subscribed_files },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.subscribed_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.total_results },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.total_results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse>(
            "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.subscribed_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        static instance: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse = CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
            eresult: ::std::option::Option::None,
            subscribed_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse`
pub mod cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.rtime32_subscribed)
        pub rtime32_subscribed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.file_hcontent)
        pub file_hcontent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.file_size)
        pub file_size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.rtime32_last_updated)
        pub rtime32_last_updated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.is_depot_content)
        pub is_depot_content: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as crate::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_subscribed = 2;

        pub fn rtime32_subscribed(&self) -> u32 {
            self.rtime32_subscribed.unwrap_or(0u32)
        }

        pub fn clear_rtime32_subscribed(&mut self) {
            self.rtime32_subscribed = ::std::option::Option::None;
        }

        pub fn has_rtime32_subscribed(&self) -> bool {
            self.rtime32_subscribed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_subscribed(&mut self, v: u32) {
            self.rtime32_subscribed = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 3;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional fixed64 file_hcontent = 4;

        pub fn file_hcontent(&self) -> u64 {
            self.file_hcontent.unwrap_or(0)
        }

        pub fn clear_file_hcontent(&mut self) {
            self.file_hcontent = ::std::option::Option::None;
        }

        pub fn has_file_hcontent(&self) -> bool {
            self.file_hcontent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_hcontent(&mut self, v: u64) {
            self.file_hcontent = ::std::option::Option::Some(v);
        }

        // optional uint32 file_size = 5;

        pub fn file_size(&self) -> u32 {
            self.file_size.unwrap_or(0)
        }

        pub fn clear_file_size(&mut self) {
            self.file_size = ::std::option::Option::None;
        }

        pub fn has_file_size(&self) -> bool {
            self.file_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_size(&mut self, v: u32) {
            self.file_size = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_last_updated = 6;

        pub fn rtime32_last_updated(&self) -> u32 {
            self.rtime32_last_updated.unwrap_or(0)
        }

        pub fn clear_rtime32_last_updated(&mut self) {
            self.rtime32_last_updated = ::std::option::Option::None;
        }

        pub fn has_rtime32_last_updated(&self) -> bool {
            self.rtime32_last_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_last_updated(&mut self, v: u32) {
            self.rtime32_last_updated = ::std::option::Option::Some(v);
        }

        // optional bool is_depot_content = 7;

        pub fn is_depot_content(&self) -> bool {
            self.is_depot_content.unwrap_or(false)
        }

        pub fn clear_is_depot_content(&mut self) {
            self.is_depot_content = ::std::option::Option::None;
        }

        pub fn has_is_depot_content(&self) -> bool {
            self.is_depot_content.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_depot_content(&mut self, v: bool) {
            self.is_depot_content = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime32_subscribed",
                |m: &PublishedFileId| { &m.rtime32_subscribed },
                |m: &mut PublishedFileId| { &mut m.rtime32_subscribed },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &PublishedFileId| { &m.appid },
                |m: &mut PublishedFileId| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "file_hcontent",
                |m: &PublishedFileId| { &m.file_hcontent },
                |m: &mut PublishedFileId| { &mut m.file_hcontent },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "file_size",
                |m: &PublishedFileId| { &m.file_size },
                |m: &mut PublishedFileId| { &mut m.file_size },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime32_last_updated",
                |m: &PublishedFileId| { &m.rtime32_last_updated },
                |m: &mut PublishedFileId| { &mut m.rtime32_last_updated },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_depot_content",
                |m: &PublishedFileId| { &m.is_depot_content },
                |m: &mut PublishedFileId| { &mut m.is_depot_content },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.rtime32_subscribed = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    33 => {
                        self.file_hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.rtime32_last_updated = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    56 => {
                        self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rtime32_subscribed {
                my_size += 1 + 4;
            }
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.file_hcontent {
                my_size += 1 + 8;
            }
            if let Some(v) = self.file_size {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.rtime32_last_updated {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_depot_content {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime32_subscribed {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.file_hcontent {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.file_size {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.rtime32_last_updated {
                os.write_fixed32(6, v)?;
            }
            if let Some(v) = self.is_depot_content {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime32_subscribed = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.file_hcontent = ::std::option::Option::None;
            self.file_size = ::std::option::Option::None;
            self.rtime32_last_updated = ::std::option::Option::None;
            self.is_depot_content = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                rtime32_subscribed: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                file_hcontent: ::std::option::Option::None,
                file_size: ::std::option::Option::None,
                rtime32_last_updated: ::std::option::Option::None,
                is_depot_content: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PublishedFileId {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishedFileUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishedFileUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.time_updated)
    pub time_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.hcontent)
    pub hcontent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.is_depot_content)
    pub is_depot_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.revision)
    pub revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishedFileUpdated.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishedFileUpdated {
    fn default() -> &'a CMsgClientUCMPublishedFileUpdated {
        <CMsgClientUCMPublishedFileUpdated as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishedFileUpdated {
    pub fn new() -> CMsgClientUCMPublishedFileUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 3;

    pub fn time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }

    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 4;

    pub fn hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(0)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    // optional fixed32 file_size = 5;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 6;

    pub fn is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }

    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 7;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.published_file_id },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.published_file_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.app_id },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_updated",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.time_updated },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.time_updated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hcontent",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.hcontent },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.hcontent },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.file_size },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.file_size },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_depot_content",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.is_depot_content },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.is_depot_content },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.revision },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.revision },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMPublishedFileUpdated>(
            "CMsgClientUCMPublishedFileUpdated",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMPublishedFileUpdated {
    const NAME: &'static str = "CMsgClientUCMPublishedFileUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.file_size = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_updated {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hcontent {
            my_size += 1 + 8;
        }
        if let Some(v) = self.file_size {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_depot_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.revision {
            my_size += crate::rt::uint32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishedFileUpdated {
        CMsgClientUCMPublishedFileUpdated::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishedFileUpdated {
        static instance: CMsgClientUCMPublishedFileUpdated = CMsgClientUCMPublishedFileUpdated {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            time_updated: ::std::option::Option::None,
            hcontent: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            is_depot_content: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMPublishedFileUpdated {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMPublishedFileUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMPublishedFileUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMPublishedFileUpdated {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemChangesRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.last_time_updated)
    pub last_time_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.num_items_needed)
    pub num_items_needed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesRequest {
    fn default() -> &'a CMsgClientWorkshopItemChangesRequest {
        <CMsgClientWorkshopItemChangesRequest as crate::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesRequest {
    pub fn new() -> CMsgClientWorkshopItemChangesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;

    pub fn last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }

    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    // optional uint32 num_items_needed = 3;

    pub fn num_items_needed(&self) -> u32 {
        self.num_items_needed.unwrap_or(0)
    }

    pub fn clear_num_items_needed(&mut self) {
        self.num_items_needed = ::std::option::Option::None;
    }

    pub fn has_num_items_needed(&self) -> bool {
        self.num_items_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_items_needed(&mut self, v: u32) {
        self.num_items_needed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientWorkshopItemChangesRequest| { &m.app_id },
            |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_time_updated",
            |m: &CMsgClientWorkshopItemChangesRequest| { &m.last_time_updated },
            |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.last_time_updated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_items_needed",
            |m: &CMsgClientWorkshopItemChangesRequest| { &m.num_items_needed },
            |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.num_items_needed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWorkshopItemChangesRequest>(
            "CMsgClientWorkshopItemChangesRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientWorkshopItemChangesRequest {
    const NAME: &'static str = "CMsgClientWorkshopItemChangesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_items_needed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_time_updated {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_items_needed {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_items_needed {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemChangesRequest {
        CMsgClientWorkshopItemChangesRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.num_items_needed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesRequest {
        static instance: CMsgClientWorkshopItemChangesRequest = CMsgClientWorkshopItemChangesRequest {
            app_id: ::std::option::Option::None,
            last_time_updated: ::std::option::Option::None,
            num_items_needed: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientWorkshopItemChangesRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemChangesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWorkshopItemChangesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientWorkshopItemChangesRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemChangesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.update_time)
    pub update_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.workshop_items)
    pub workshop_items: ::std::vec::Vec<cmsg_client_workshop_item_changes_response::WorkshopItemInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesResponse {
    fn default() -> &'a CMsgClientWorkshopItemChangesResponse {
        <CMsgClientWorkshopItemChangesResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesResponse {
    pub fn new() -> CMsgClientWorkshopItemChangesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;

    pub fn update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }

    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo workshop_items = 5;

    pub fn workshop_items(&self) -> &[cmsg_client_workshop_item_changes_response::WorkshopItemInfo] {
        &self.workshop_items
    }

    pub fn clear_workshop_items(&mut self) {
        self.workshop_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_workshop_items(&mut self, v: ::std::vec::Vec<cmsg_client_workshop_item_changes_response::WorkshopItemInfo>) {
        self.workshop_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workshop_items(&mut self) -> &mut ::std::vec::Vec<cmsg_client_workshop_item_changes_response::WorkshopItemInfo> {
        &mut self.workshop_items
    }

    // Take field
    pub fn take_workshop_items(&mut self) -> ::std::vec::Vec<cmsg_client_workshop_item_changes_response::WorkshopItemInfo> {
        ::std::mem::replace(&mut self.workshop_items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientWorkshopItemChangesResponse| { &m.eresult },
            |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_time",
            |m: &CMsgClientWorkshopItemChangesResponse| { &m.update_time },
            |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.update_time },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workshop_items",
            |m: &CMsgClientWorkshopItemChangesResponse| { &m.workshop_items },
            |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.workshop_items },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWorkshopItemChangesResponse>(
            "CMsgClientWorkshopItemChangesResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientWorkshopItemChangesResponse {
    const NAME: &'static str = "CMsgClientWorkshopItemChangesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.update_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.workshop_items.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.update_time {
            my_size += crate::rt::uint32_size(2, v);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemChangesResponse {
        CMsgClientWorkshopItemChangesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesResponse {
        static instance: CMsgClientWorkshopItemChangesResponse = CMsgClientWorkshopItemChangesResponse {
            eresult: ::std::option::Option::None,
            update_time: ::std::option::Option::None,
            workshop_items: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientWorkshopItemChangesResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemChangesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWorkshopItemChangesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientWorkshopItemChangesResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientWorkshopItemChangesResponse`
pub mod cmsg_client_workshop_item_changes_response {
    // @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.time_updated)
        pub time_updated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.manifest_id)
        pub manifest_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemInfo {
        fn default() -> &'a WorkshopItemInfo {
            <WorkshopItemInfo as crate::Message>::default_instance()
        }
    }

    impl WorkshopItemInfo {
        pub fn new() -> WorkshopItemInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional fixed64 manifest_id = 3;

        pub fn manifest_id(&self) -> u64 {
            self.manifest_id.unwrap_or(0)
        }

        pub fn clear_manifest_id(&mut self) {
            self.manifest_id = ::std::option::Option::None;
        }

        pub fn has_manifest_id(&self) -> bool {
            self.manifest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manifest_id(&mut self, v: u64) {
            self.manifest_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &WorkshopItemInfo| { &m.published_file_id },
                |m: &mut WorkshopItemInfo| { &mut m.published_file_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_updated",
                |m: &WorkshopItemInfo| { &m.time_updated },
                |m: &mut WorkshopItemInfo| { &mut m.time_updated },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "manifest_id",
                |m: &WorkshopItemInfo| { &m.manifest_id },
                |m: &mut WorkshopItemInfo| { &mut m.manifest_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopItemInfo>(
                "CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for WorkshopItemInfo {
        const NAME: &'static str = "WorkshopItemInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    25 => {
                        self.manifest_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_updated {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.manifest_id {
                my_size += 1 + 8;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.manifest_id {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemInfo {
            WorkshopItemInfo::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.manifest_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemInfo {
            static instance: WorkshopItemInfo = WorkshopItemInfo {
                published_file_id: ::std::option::Option::None,
                time_updated: ::std::option::Option::None,
                manifest_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for WorkshopItemInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopItemInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for WorkshopItemInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMSetUserPublishedFileAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMSetUserPublishedFileAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.action)
    pub action: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMSetUserPublishedFileAction.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileAction {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileAction {
        <CMsgClientUCMSetUserPublishedFileAction as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileAction {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.published_file_id },
            |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.published_file_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.app_id },
            |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.action },
            |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.action },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMSetUserPublishedFileAction>(
            "CMsgClientUCMSetUserPublishedFileAction",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMSetUserPublishedFileAction {
    const NAME: &'static str = "CMsgClientUCMSetUserPublishedFileAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        CMsgClientUCMSetUserPublishedFileAction::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileAction {
        static instance: CMsgClientUCMSetUserPublishedFileAction = CMsgClientUCMSetUserPublishedFileAction {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMSetUserPublishedFileAction {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMSetUserPublishedFileAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMSetUserPublishedFileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileAction {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMSetUserPublishedFileActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMSetUserPublishedFileActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileActionResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMSetUserPublishedFileActionResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileActionResponse {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileActionResponse {
        <CMsgClientUCMSetUserPublishedFileActionResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileActionResponse {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMSetUserPublishedFileActionResponse| { &m.eresult },
            |m: &mut CMsgClientUCMSetUserPublishedFileActionResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMSetUserPublishedFileActionResponse>(
            "CMsgClientUCMSetUserPublishedFileActionResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMSetUserPublishedFileActionResponse {
    const NAME: &'static str = "CMsgClientUCMSetUserPublishedFileActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        CMsgClientUCMSetUserPublishedFileActionResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileActionResponse {
        static instance: CMsgClientUCMSetUserPublishedFileActionResponse = CMsgClientUCMSetUserPublishedFileActionResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMSetUserPublishedFileActionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileActionResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.action)
    pub action: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserAction.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
        <CMsgClientUCMEnumeratePublishedFilesByUserAction as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserAction {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.app_id },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.start_index },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.start_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.action },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.action },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumeratePublishedFilesByUserAction>(
            "CMsgClientUCMEnumeratePublishedFilesByUserAction",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    const NAME: &'static str = "CMsgClientUCMEnumeratePublishedFilesByUserAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        CMsgClientUCMEnumeratePublishedFilesByUserAction::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserAction {
        static instance: CMsgClientUCMEnumeratePublishedFilesByUserAction = CMsgClientUCMEnumeratePublishedFilesByUserAction {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumeratePublishedFilesByUserAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.published_files)
    pub published_files: ::std::vec::Vec<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        <CMsgClientUCMEnumeratePublishedFilesByUserActionResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId published_files = 2;

    pub fn published_files(&self) -> &[cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId] {
        &self.published_files
    }

    pub fn clear_published_files(&mut self) {
        self.published_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_files(&mut self, v: ::std::vec::Vec<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId>) {
        self.published_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_files(&mut self) -> &mut ::std::vec::Vec<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId> {
        &mut self.published_files
    }

    // Take field
    pub fn take_published_files(&mut self) -> ::std::vec::Vec<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId> {
        ::std::mem::replace(&mut self.published_files, ::std::vec::Vec::new())
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.eresult },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_files",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.published_files },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.published_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.total_results },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.total_results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse>(
            "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    const NAME: &'static str = "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.published_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        static instance: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse = CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
            eresult: ::std::option::Option::None,
            published_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumeratePublishedFilesByUserActionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMEnumeratePublishedFilesByUserActionResponse`
pub mod cmsg_client_ucmenumerate_published_files_by_user_action_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.rtime_time_stamp)
        pub rtime_time_stamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as crate::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime_time_stamp = 2;

        pub fn rtime_time_stamp(&self) -> u32 {
            self.rtime_time_stamp.unwrap_or(0u32)
        }

        pub fn clear_rtime_time_stamp(&mut self) {
            self.rtime_time_stamp = ::std::option::Option::None;
        }

        pub fn has_rtime_time_stamp(&self) -> bool {
            self.rtime_time_stamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime_time_stamp(&mut self, v: u32) {
            self.rtime_time_stamp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime_time_stamp",
                |m: &PublishedFileId| { &m.rtime_time_stamp },
                |m: &mut PublishedFileId| { &mut m.rtime_time_stamp },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.rtime_time_stamp = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rtime_time_stamp {
                my_size += 1 + 4;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime_time_stamp {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime_time_stamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                rtime_time_stamp: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PublishedFileId {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientScreenshotsChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientScreenshotsChanged {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientScreenshotsChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientScreenshotsChanged {
    fn default() -> &'a CMsgClientScreenshotsChanged {
        <CMsgClientScreenshotsChanged as crate::Message>::default_instance()
    }
}

impl CMsgClientScreenshotsChanged {
    pub fn new() -> CMsgClientScreenshotsChanged {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientScreenshotsChanged>(
            "CMsgClientScreenshotsChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientScreenshotsChanged {
    const NAME: &'static str = "CMsgClientScreenshotsChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientScreenshotsChanged {
        CMsgClientScreenshotsChanged::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientScreenshotsChanged {
        static instance: CMsgClientScreenshotsChanged = CMsgClientScreenshotsChanged {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientScreenshotsChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientScreenshotsChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientScreenshotsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientScreenshotsChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_clientserver_ucm.proto\x1a\x18steammessages_base.proto\
    \"\xb6\x04\n\x1aCMsgClientUCMAddScreenshot\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\x12\x1a\n\x08filename\x18\x02\x20\x01(\tR\x08filen\
    ame\x12\x1c\n\tthumbname\x18\x03\x20\x01(\tR\tthumbname\x12\x1f\n\x0bvr_\
    filename\x18\x0e\x20\x01(\tR\nvrFilename\x12'\n\x0frtime32_created\x18\
    \x04\x20\x01(\x07R\x0ertime32Created\x12\x14\n\x05width\x18\x05\x20\x01(\
    \rR\x05width\x12\x16\n\x06height\x18\x06\x20\x01(\rR\x06height\x12\x20\n\
    \x0bpermissions\x18\x07\x20\x01(\rR\x0bpermissions\x12\x18\n\x07caption\
    \x18\x08\x20\x01(\tR\x07caption\x12#\n\rshortcut_name\x18\t\x20\x01(\tR\
    \x0cshortcutName\x121\n\x03tag\x18\n\x20\x03(\x0b2\x1f.CMsgClientUCMAddS\
    creenshot.TagR\x03tag\x12%\n\x0etagged_steamid\x18\x0b\x20\x03(\x06R\rta\
    ggedSteamid\x12\x1f\n\x0bspoiler_tag\x18\x0c\x20\x01(\x08R\nspoilerTag\
    \x125\n\x16tagged_publishedfileid\x18\r\x20\x03(\x04R\x15taggedPublished\
    fileid\x1a=\n\x03Tag\x12\x19\n\x08tag_name\x18\x01\x20\x01(\tR\x07tagNam\
    e\x12\x1b\n\ttag_value\x18\x02\x20\x01(\tR\x08tagValue\"{\n\"CMsgClientU\
    CMAddScreenshotResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x128\n\x0cscreenshotid\x18\x02\x20\x01(\x06:\x14184467440737\
    09551615R\x0cscreenshotid\"Y\n\x1dCMsgClientUCMDeleteScreenshot\x128\n\
    \x0cscreenshotid\x18\x01\x20\x01(\x06:\x1418446744073709551615R\x0cscree\
    nshotid\"D\n%CMsgClientUCMDeleteScreenshotResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\"\x83\x04\n\x18CMsgClientUCMPubl\
    ishFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile\
    _name\x18\x02\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\x18\
    \x03\x20\x01(\tR\x0fpreviewFileName\x12&\n\x0fconsumer_app_id\x18\x04\
    \x20\x01(\rR\rconsumerAppId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05ti\
    tle\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12\x12\
    \n\x04tags\x18\x08\x20\x03(\tR\x04tags\x12#\n\rworkshop_file\x18\t\x20\
    \x01(\x08R\x0cworkshopFile\x12\x1e\n\nvisibility\x18\n\x20\x01(\x05R\nvi\
    sibility\x12\x1b\n\tfile_type\x18\x0b\x20\x01(\rR\x08fileType\x12\x10\n\
    \x03url\x18\x0c\x20\x01(\tR\x03url\x12%\n\x0evideo_provider\x18\r\x20\
    \x01(\rR\rvideoProvider\x12,\n\x12video_account_name\x18\x0e\x20\x01(\tR\
    \x10videoAccountName\x12)\n\x10video_identifier\x18\x0f\x20\x01(\tR\x0fv\
    ideoIdentifier\x12\x1f\n\x0bin_progress\x18\x10\x20\x01(\x08R\ninProgres\
    s\"\xe2\x01\n\x20CMsgClientUCMPublishFileResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12@\n\x11published_file_id\x18\
    \x02\x20\x01(\x06:\x1418446744073709551615R\x0fpublishedFileId\x12_\n)ne\
    eds_workshop_legal_agreement_acceptance\x18\x03\x20\x01(\x08:\x05falseR%\
    needsWorkshopLegalAgreementAcceptance\"\xe1\x0c\n\x20CMsgClientUCMUpdate\
    PublishedFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\
    \x11published_file_id\x18\x02\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\
    \tfile_name\x18\x03\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\
    \x18\x04\x20\x01(\tR\x0fpreviewFileName\x12\x14\n\x05title\x18\x05\x20\
    \x01(\tR\x05title\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescri\
    ption\x12\x12\n\x04tags\x18\x07\x20\x03(\tR\x04tags\x12\x1e\n\nvisibilit\
    y\x18\x08\x20\x01(\x05R\nvisibility\x12\x1f\n\x0bupdate_file\x18\t\x20\
    \x01(\x08R\nupdateFile\x12.\n\x13update_preview_file\x18\n\x20\x01(\x08R\
    \x11updatePreviewFile\x12!\n\x0cupdate_title\x18\x0b\x20\x01(\x08R\x0bup\
    dateTitle\x12-\n\x12update_description\x18\x0c\x20\x01(\x08R\x11updateDe\
    scription\x12\x1f\n\x0bupdate_tags\x18\r\x20\x01(\x08R\nupdateTags\x12+\
    \n\x11update_visibility\x18\x0e\x20\x01(\x08R\x10updateVisibility\x12-\n\
    \x12change_description\x18\x0f\x20\x01(\tR\x11changeDescription\x12\x1d\
    \n\nupdate_url\x18\x10\x20\x01(\x08R\tupdateUrl\x12\x10\n\x03url\x18\x11\
    \x20\x01(\tR\x03url\x126\n\x17update_content_manifest\x18\x12\x20\x01(\
    \x08R\x15updateContentManifest\x12)\n\x10content_manifest\x18\x13\x20\
    \x01(\x06R\x0fcontentManifest\x12\x1a\n\x08metadata\x18\x14\x20\x01(\tR\
    \x08metadata\x12'\n\x0fupdate_metadata\x18\x15\x20\x01(\x08R\x0eupdateMe\
    tadata\x12\x1d\n\x08language\x18\x16\x20\x01(\x05:\x010R\x08language\x12\
    %\n\x0eremoved_kvtags\x18\x17\x20\x03(\tR\rremovedKvtags\x12E\n\x06kvtag\
    s\x18\x18\x20\x03(\x0b2-.CMsgClientUCMUpdatePublishedFile.KeyValueTagR\
    \x06kvtags\x12O\n\x08previews\x18\x19\x20\x03(\x0b23.CMsgClientUCMUpdate\
    PublishedFile.AdditionalPreviewR\x08previews\x12,\n\x12previews_to_remov\
    e\x18\x1a\x20\x03(\x05R\x10previewsToRemove\x12*\n\x11clear_in_progress\
    \x18\x1b\x20\x01(\x08R\x0fclearInProgress\x12*\n\x11remove_all_kvtags\
    \x18\x1c\x20\x01(\x08R\x0fremoveAllKvtags\x12;\n\x1acontent_descriptors_\
    to_add\x18\x1d\x20\x03(\x05R\x17contentDescriptorsToAdd\x12A\n\x1dconten\
    t_descriptors_to_remove\x18\x1e\x20\x03(\x05R\x1acontentDescriptorsToRem\
    ove\x12/\n\x10allow_admin_tags\x18\x1f\x20\x01(\x08:\x05falseR\x0eallowA\
    dminTags\x12*\n\x11external_asset_id\x18\x20\x20\x01(\x04R\x0fexternalAs\
    setId\x1a5\n\x0bKeyValueTag\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x1a\xd3\x01\n\x11Additi\
    onalPreview\x12,\n\x12original_file_name\x18\x01\x20\x01(\tR\x10original\
    FileName\x12,\n\x12internal_file_name\x18\x02\x20\x01(\tR\x10internalFil\
    eName\x12\x18\n\x07videoid\x18\x03\x20\x01(\tR\x07videoid\x12!\n\x0cprev\
    iew_type\x18\x04\x20\x01(\rR\x0bpreviewType\x12%\n\x0cupdate_index\x18\
    \x05\x20\x01(\x05:\x02-1R\x0bupdateIndex\"\xa8\x01\n(CMsgClientUCMUpdate\
    PublishedFileResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12_\n)needs_workshop_legal_agreement_acceptance\x18\x02\x20\
    \x01(\x08:\x05falseR%needsWorkshopLegalAgreementAcceptance\"e\n\x20CMsgC\
    lientUCMDeletePublishedFile\x12*\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileId\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appI\
    d\"G\n(CMsgClientUCMDeletePublishedFileResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\"\xbb\x01\n4CMsgClientUCMEnumerateUs\
    erSubscribedFilesWithUpdates\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05\
    appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\x1d\n\
    \nstart_time\x18\x03\x20\x01(\x07R\tstartTime\x12,\n\x10desired_revision\
    \x18\x04\x20\x01(\r:\x010R\x0fdesiredRevision\"\xa0\x04\n<CMsgClientUCME\
    numerateUserSubscribedFilesWithUpdatesResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12x\n\x10subscribed_files\x18\x02\
    \x20\x03(\x0b2M.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResp\
    onse.PublishedFileIdR\x0fsubscribedFiles\x12#\n\rtotal_results\x18\x03\
    \x20\x01(\rR\x0ctotalResults\x1a\xa3\x02\n\x0fPublishedFileId\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x120\n\x12rti\
    me32_subscribed\x18\x02\x20\x01(\x07:\x010R\x11rtime32Subscribed\x12\x14\
    \n\x05appid\x18\x03\x20\x01(\rR\x05appid\x12#\n\rfile_hcontent\x18\x04\
    \x20\x01(\x06R\x0cfileHcontent\x12\x1b\n\tfile_size\x18\x05\x20\x01(\rR\
    \x08fileSize\x120\n\x14rtime32_last_updated\x18\x06\x20\x01(\x07R\x12rti\
    me32LastUpdated\x12(\n\x10is_depot_content\x18\x07\x20\x01(\x08R\x0eisDe\
    potContent\"\x88\x02\n!CMsgClientUCMPublishedFileUpdated\x12*\n\x11publi\
    shed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06app_i\
    d\x18\x02\x20\x01(\rR\x05appId\x12!\n\x0ctime_updated\x18\x03\x20\x01(\r\
    R\x0btimeUpdated\x12\x1a\n\x08hcontent\x18\x04\x20\x01(\x06R\x08hcontent\
    \x12\x1b\n\tfile_size\x18\x05\x20\x01(\x07R\x08fileSize\x12(\n\x10is_dep\
    ot_content\x18\x06\x20\x01(\x08R\x0eisDepotContent\x12\x1a\n\x08revision\
    \x18\x07\x20\x01(\rR\x08revision\"\x93\x01\n$CMsgClientWorkshopItemChang\
    esRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\x11las\
    t_time_updated\x18\x02\x20\x01(\rR\x0flastTimeUpdated\x12(\n\x10num_item\
    s_needed\x18\x03\x20\x01(\rR\x0enumItemsNeeded\"\xca\x02\n%CMsgClientWor\
    kshopItemChangesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012\
    R\x07eresult\x12\x1f\n\x0bupdate_time\x18\x02\x20\x01(\rR\nupdateTime\
    \x12^\n\x0eworkshop_items\x18\x05\x20\x03(\x0b27.CMsgClientWorkshopItemC\
    hangesResponse.WorkshopItemInfoR\rworkshopItems\x1a\x82\x01\n\x10Worksho\
    pItemInfo\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublished\
    FileId\x12!\n\x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\x12\x1f\
    \n\x0bmanifest_id\x18\x03\x20\x01(\x06R\nmanifestId\"\x84\x01\n'CMsgClie\
    ntUCMSetUserPublishedFileAction\x12*\n\x11published_file_id\x18\x01\x20\
    \x01(\x06R\x0fpublishedFileId\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\
    \x05appId\x12\x16\n\x06action\x18\x03\x20\x01(\x05R\x06action\"N\n/CMsgC\
    lientUCMSetUserPublishedFileActionResponse\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\"\x82\x01\n0CMsgClientUCMEnumeratePublis\
    hedFilesByUserAction\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\x16\n\x06a\
    ction\x18\x03\x20\x01(\x05R\x06action\"\xdc\x02\n8CMsgClientUCMEnumerate\
    PublishedFilesByUserActionResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12r\n\x0fpublished_files\x18\x02\x20\x03(\x0b2I.\
    CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId\
    R\x0epublishedFiles\x12#\n\rtotal_results\x18\x03\x20\x01(\rR\x0ctotalRe\
    sults\x1aj\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\
    \x01(\x06R\x0fpublishedFileId\x12+\n\x10rtime_time_stamp\x18\x02\x20\x01\
    (\x07:\x010R\x0ertimeTimeStamp\"\x1e\n\x1cCMsgClientScreenshotsChangedB\
    \x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(26);
            messages.push(CMsgClientUCMAddScreenshot::generated_message_descriptor_data());
            messages.push(CMsgClientUCMAddScreenshotResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeleteScreenshot::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeleteScreenshotResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMPublishFile::generated_message_descriptor_data());
            messages.push(CMsgClientUCMPublishFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMUpdatePublishedFile::generated_message_descriptor_data());
            messages.push(CMsgClientUCMUpdatePublishedFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeletePublishedFile::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeletePublishedFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMPublishedFileUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientWorkshopItemChangesRequest::generated_message_descriptor_data());
            messages.push(CMsgClientWorkshopItemChangesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMSetUserPublishedFileAction::generated_message_descriptor_data());
            messages.push(CMsgClientUCMSetUserPublishedFileActionResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumeratePublishedFilesByUserAction::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::generated_message_descriptor_data());
            messages.push(CMsgClientScreenshotsChanged::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmadd_screenshot::Tag::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmupdate_published_file::KeyValueTag::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmupdate_published_file::AdditionalPreview::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_client_workshop_item_changes_response::WorkshopItemInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
