// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver.proto`

// @@protoc_insertion_point(message:CMsgClientRegisterAuthTicketWithCM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterAuthTicketWithCM {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.ticket)
    pub ticket: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.client_instance_id)
    pub client_instance_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterAuthTicketWithCM.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterAuthTicketWithCM {
    fn default() -> &'a CMsgClientRegisterAuthTicketWithCM {
        <CMsgClientRegisterAuthTicketWithCM as crate::Message>::default_instance()
    }
}

impl CMsgClientRegisterAuthTicketWithCM {
    pub fn new() -> CMsgClientRegisterAuthTicketWithCM {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::bytes::Bytes) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::bytes::Bytes {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::bytes::Bytes {
        self.ticket.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint64 client_instance_id = 4;

    pub fn client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgClientRegisterAuthTicketWithCM| { &m.protocol_version },
            |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.protocol_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgClientRegisterAuthTicketWithCM| { &m.ticket },
            |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.ticket },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_instance_id",
            |m: &CMsgClientRegisterAuthTicketWithCM| { &m.client_instance_id },
            |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.client_instance_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterAuthTicketWithCM>(
            "CMsgClientRegisterAuthTicketWithCM",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRegisterAuthTicketWithCM {
    const NAME: &'static str = "CMsgClientRegisterAuthTicketWithCM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                32 => {
                    self.client_instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += crate::rt::uint64_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterAuthTicketWithCM {
        CMsgClientRegisterAuthTicketWithCM::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.client_instance_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterAuthTicketWithCM {
        static instance: CMsgClientRegisterAuthTicketWithCM = CMsgClientRegisterAuthTicketWithCM {
            protocol_version: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            client_instance_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRegisterAuthTicketWithCM {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterAuthTicketWithCM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterAuthTicketWithCM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRegisterAuthTicketWithCM {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientTicketAuthComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientTicketAuthComplete {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.estate)
    pub estate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.eauth_session_response)
    pub eauth_session_response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.DEPRECATED_ticket)
    pub DEPRECATED_ticket: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.ticket_crc)
    pub ticket_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.ticket_sequence)
    pub ticket_sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.owner_steam_id)
    pub owner_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientTicketAuthComplete.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientTicketAuthComplete {
    fn default() -> &'a CMsgClientTicketAuthComplete {
        <CMsgClientTicketAuthComplete as crate::Message>::default_instance()
    }
}

impl CMsgClientTicketAuthComplete {
    pub fn new() -> CMsgClientTicketAuthComplete {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 estate = 3;

    pub fn estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eauth_session_response = 4;

    pub fn eauth_session_response(&self) -> u32 {
        self.eauth_session_response.unwrap_or(0)
    }

    pub fn clear_eauth_session_response(&mut self) {
        self.eauth_session_response = ::std::option::Option::None;
    }

    pub fn has_eauth_session_response(&self) -> bool {
        self.eauth_session_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eauth_session_response(&mut self, v: u32) {
        self.eauth_session_response = ::std::option::Option::Some(v);
    }

    // optional bytes DEPRECATED_ticket = 5;

    pub fn DEPRECATED_ticket(&self) -> &[u8] {
        match self.DEPRECATED_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_DEPRECATED_ticket(&mut self) {
        self.DEPRECATED_ticket = ::std::option::Option::None;
    }

    pub fn has_DEPRECATED_ticket(&self) -> bool {
        self.DEPRECATED_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_ticket(&mut self, v: ::bytes::Bytes) {
        self.DEPRECATED_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DEPRECATED_ticket(&mut self) -> &mut ::bytes::Bytes {
        if self.DEPRECATED_ticket.is_none() {
            self.DEPRECATED_ticket = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.DEPRECATED_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_DEPRECATED_ticket(&mut self) -> ::bytes::Bytes {
        self.DEPRECATED_ticket.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 ticket_crc = 6;

    pub fn ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_sequence = 7;

    pub fn ticket_sequence(&self) -> u32 {
        self.ticket_sequence.unwrap_or(0)
    }

    pub fn clear_ticket_sequence(&mut self) {
        self.ticket_sequence = ::std::option::Option::None;
    }

    pub fn has_ticket_sequence(&self) -> bool {
        self.ticket_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_sequence(&mut self, v: u32) {
        self.ticket_sequence = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 8;

    pub fn owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgClientTicketAuthComplete| { &m.steam_id },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.steam_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientTicketAuthComplete| { &m.game_id },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.game_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "estate",
            |m: &CMsgClientTicketAuthComplete| { &m.estate },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.estate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eauth_session_response",
            |m: &CMsgClientTicketAuthComplete| { &m.eauth_session_response },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.eauth_session_response },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "DEPRECATED_ticket",
            |m: &CMsgClientTicketAuthComplete| { &m.DEPRECATED_ticket },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.DEPRECATED_ticket },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_crc",
            |m: &CMsgClientTicketAuthComplete| { &m.ticket_crc },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_crc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_sequence",
            |m: &CMsgClientTicketAuthComplete| { &m.ticket_sequence },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_sequence },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_steam_id",
            |m: &CMsgClientTicketAuthComplete| { &m.owner_steam_id },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.owner_steam_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientTicketAuthComplete>(
            "CMsgClientTicketAuthComplete",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientTicketAuthComplete {
    const NAME: &'static str = "CMsgClientTicketAuthComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.estate = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.eauth_session_response = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.DEPRECATED_ticket = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                48 => {
                    self.ticket_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ticket_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                65 => {
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.estate {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.eauth_session_response {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            my_size += crate::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ticket_sequence {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.estate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.eauth_session_response {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket_sequence {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientTicketAuthComplete {
        CMsgClientTicketAuthComplete::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.estate = ::std::option::Option::None;
        self.eauth_session_response = ::std::option::Option::None;
        self.DEPRECATED_ticket = ::std::option::Option::None;
        self.ticket_crc = ::std::option::Option::None;
        self.ticket_sequence = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientTicketAuthComplete {
        static instance: CMsgClientTicketAuthComplete = CMsgClientTicketAuthComplete {
            steam_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            estate: ::std::option::Option::None,
            eauth_session_response: ::std::option::Option::None,
            DEPRECATED_ticket: ::std::option::Option::None,
            ticket_crc: ::std::option::Option::None,
            ticket_sequence: ::std::option::Option::None,
            owner_steam_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientTicketAuthComplete {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientTicketAuthComplete").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientTicketAuthComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientTicketAuthComplete {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCMList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCMList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_addresses)
    pub cm_addresses: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_ports)
    pub cm_ports: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_websocket_addresses)
    pub cm_websocket_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCMList.percent_default_to_websocket)
    pub percent_default_to_websocket: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCMList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCMList {
    fn default() -> &'a CMsgClientCMList {
        <CMsgClientCMList as crate::Message>::default_instance()
    }
}

impl CMsgClientCMList {
    pub fn new() -> CMsgClientCMList {
        ::std::default::Default::default()
    }

    // repeated uint32 cm_addresses = 1;

    pub fn cm_addresses(&self) -> &[u32] {
        &self.cm_addresses
    }

    pub fn clear_cm_addresses(&mut self) {
        self.cm_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_addresses(&mut self, v: ::std::vec::Vec<u32>) {
        self.cm_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_addresses(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.cm_addresses
    }

    // Take field
    pub fn take_cm_addresses(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.cm_addresses, ::std::vec::Vec::new())
    }

    // repeated uint32 cm_ports = 2;

    pub fn cm_ports(&self) -> &[u32] {
        &self.cm_ports
    }

    pub fn clear_cm_ports(&mut self) {
        self.cm_ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_ports(&mut self, v: ::std::vec::Vec<u32>) {
        self.cm_ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_ports(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.cm_ports
    }

    // Take field
    pub fn take_cm_ports(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.cm_ports, ::std::vec::Vec::new())
    }

    // repeated string cm_websocket_addresses = 3;

    pub fn cm_websocket_addresses(&self) -> &[::std::string::String] {
        &self.cm_websocket_addresses
    }

    pub fn clear_cm_websocket_addresses(&mut self) {
        self.cm_websocket_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_websocket_addresses(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.cm_websocket_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_websocket_addresses(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.cm_websocket_addresses
    }

    // Take field
    pub fn take_cm_websocket_addresses(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.cm_websocket_addresses, ::std::vec::Vec::new())
    }

    // optional uint32 percent_default_to_websocket = 4;

    pub fn percent_default_to_websocket(&self) -> u32 {
        self.percent_default_to_websocket.unwrap_or(0)
    }

    pub fn clear_percent_default_to_websocket(&mut self) {
        self.percent_default_to_websocket = ::std::option::Option::None;
    }

    pub fn has_percent_default_to_websocket(&self) -> bool {
        self.percent_default_to_websocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percent_default_to_websocket(&mut self, v: u32) {
        self.percent_default_to_websocket = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cm_addresses",
            |m: &CMsgClientCMList| { &m.cm_addresses },
            |m: &mut CMsgClientCMList| { &mut m.cm_addresses },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cm_ports",
            |m: &CMsgClientCMList| { &m.cm_ports },
            |m: &mut CMsgClientCMList| { &mut m.cm_ports },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cm_websocket_addresses",
            |m: &CMsgClientCMList| { &m.cm_websocket_addresses },
            |m: &mut CMsgClientCMList| { &mut m.cm_websocket_addresses },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "percent_default_to_websocket",
            |m: &CMsgClientCMList| { &m.percent_default_to_websocket },
            |m: &mut CMsgClientCMList| { &mut m.percent_default_to_websocket },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCMList>(
            "CMsgClientCMList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCMList {
    const NAME: &'static str = "CMsgClientCMList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.cm_addresses)?;
                },
                8 => {
                    self.cm_addresses.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.cm_ports)?;
                },
                16 => {
                    self.cm_ports.push(is.read_uint32()?);
                },
                26 => {
                    self.cm_websocket_addresses.push(is.read_string()?);
                },
                32 => {
                    self.percent_default_to_websocket = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cm_addresses {
            my_size += crate::rt::uint32_size(1, *value);
        };
        for value in &self.cm_ports {
            my_size += crate::rt::uint32_size(2, *value);
        };
        for value in &self.cm_websocket_addresses {
            my_size += crate::rt::string_size(3, &value);
        };
        if let Some(v) = self.percent_default_to_websocket {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.cm_addresses {
            os.write_uint32(1, *v)?;
        };
        for v in &self.cm_ports {
            os.write_uint32(2, *v)?;
        };
        for v in &self.cm_websocket_addresses {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.percent_default_to_websocket {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCMList {
        CMsgClientCMList::new()
    }

    fn clear(&mut self) {
        self.cm_addresses.clear();
        self.cm_ports.clear();
        self.cm_websocket_addresses.clear();
        self.percent_default_to_websocket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCMList {
        static instance: CMsgClientCMList = CMsgClientCMList {
            cm_addresses: ::std::vec::Vec::new(),
            cm_ports: ::std::vec::Vec::new(),
            cm_websocket_addresses: ::std::vec::Vec::new(),
            percent_default_to_websocket: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCMList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCMList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCMList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCMList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientP2PConnectionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientP2PConnectionInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.candidate)
    pub candidate: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.legacy_connection_id_src)
    pub legacy_connection_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.rendezvous)
    pub rendezvous: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientP2PConnectionInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionInfo {
    fn default() -> &'a CMsgClientP2PConnectionInfo {
        <CMsgClientP2PConnectionInfo as crate::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionInfo {
    pub fn new() -> CMsgClientP2PConnectionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes candidate = 4;

    pub fn candidate(&self) -> &[u8] {
        match self.candidate.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_candidate(&mut self) {
        self.candidate = ::std::option::Option::None;
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::bytes::Bytes) {
        self.candidate = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::bytes::Bytes {
        if self.candidate.is_none() {
            self.candidate = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::bytes::Bytes {
        self.candidate.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed64 legacy_connection_id_src = 5;

    pub fn legacy_connection_id_src(&self) -> u64 {
        self.legacy_connection_id_src.unwrap_or(0)
    }

    pub fn clear_legacy_connection_id_src(&mut self) {
        self.legacy_connection_id_src = ::std::option::Option::None;
    }

    pub fn has_legacy_connection_id_src(&self) -> bool {
        self.legacy_connection_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_connection_id_src(&mut self, v: u64) {
        self.legacy_connection_id_src = ::std::option::Option::Some(v);
    }

    // optional bytes rendezvous = 6;

    pub fn rendezvous(&self) -> &[u8] {
        match self.rendezvous.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rendezvous(&mut self) {
        self.rendezvous = ::std::option::Option::None;
    }

    pub fn has_rendezvous(&self) -> bool {
        self.rendezvous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rendezvous(&mut self, v: ::bytes::Bytes) {
        self.rendezvous = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rendezvous(&mut self) -> &mut ::bytes::Bytes {
        if self.rendezvous.is_none() {
            self.rendezvous = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.rendezvous.as_mut().unwrap()
    }

    // Take field
    pub fn take_rendezvous(&mut self) -> ::bytes::Bytes {
        self.rendezvous.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_dest",
            |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_dest },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_dest },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_src",
            |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_src },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_src },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientP2PConnectionInfo| { &m.app_id },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "candidate",
            |m: &CMsgClientP2PConnectionInfo| { &m.candidate },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.candidate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_connection_id_src",
            |m: &CMsgClientP2PConnectionInfo| { &m.legacy_connection_id_src },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.legacy_connection_id_src },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rendezvous",
            |m: &CMsgClientP2PConnectionInfo| { &m.rendezvous },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.rendezvous },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientP2PConnectionInfo>(
            "CMsgClientP2PConnectionInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientP2PConnectionInfo {
    const NAME: &'static str = "CMsgClientP2PConnectionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.candidate = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                41 => {
                    self.legacy_connection_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.rendezvous = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.candidate.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.legacy_connection_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            my_size += crate::rt::bytes_size(6, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.legacy_connection_id_src {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientP2PConnectionInfo {
        CMsgClientP2PConnectionInfo::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.candidate = ::std::option::Option::None;
        self.legacy_connection_id_src = ::std::option::Option::None;
        self.rendezvous = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionInfo {
        static instance: CMsgClientP2PConnectionInfo = CMsgClientP2PConnectionInfo {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            candidate: ::std::option::Option::None,
            legacy_connection_id_src: ::std::option::Option::None,
            rendezvous: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientP2PConnectionInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientP2PConnectionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientP2PConnectionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientP2PConnectionInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientP2PConnectionFailInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientP2PConnectionFailInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.ep2p_session_error)
    pub ep2p_session_error: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.connection_id_dest)
    pub connection_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.close_reason)
    pub close_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.close_message)
    pub close_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientP2PConnectionFailInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionFailInfo {
    fn default() -> &'a CMsgClientP2PConnectionFailInfo {
        <CMsgClientP2PConnectionFailInfo as crate::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionFailInfo {
    pub fn new() -> CMsgClientP2PConnectionFailInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ep2p_session_error = 4;

    pub fn ep2p_session_error(&self) -> u32 {
        self.ep2p_session_error.unwrap_or(0)
    }

    pub fn clear_ep2p_session_error(&mut self) {
        self.ep2p_session_error = ::std::option::Option::None;
    }

    pub fn has_ep2p_session_error(&self) -> bool {
        self.ep2p_session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ep2p_session_error(&mut self, v: u32) {
        self.ep2p_session_error = ::std::option::Option::Some(v);
    }

    // optional fixed64 connection_id_dest = 5;

    pub fn connection_id_dest(&self) -> u64 {
        self.connection_id_dest.unwrap_or(0)
    }

    pub fn clear_connection_id_dest(&mut self) {
        self.connection_id_dest = ::std::option::Option::None;
    }

    pub fn has_connection_id_dest(&self) -> bool {
        self.connection_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_dest(&mut self, v: u64) {
        self.connection_id_dest = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 7;

    pub fn close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }

    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 8;

    pub fn close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_close_message(&mut self) {
        self.close_message = ::std::option::Option::None;
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_dest",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_dest },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_dest },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_src",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_src },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_src },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.app_id },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ep2p_session_error",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.ep2p_session_error },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.ep2p_session_error },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id_dest",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.connection_id_dest },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.connection_id_dest },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_reason",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.close_reason },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_reason },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_message",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.close_message },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientP2PConnectionFailInfo>(
            "CMsgClientP2PConnectionFailInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientP2PConnectionFailInfo {
    const NAME: &'static str = "CMsgClientP2PConnectionFailInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ep2p_session_error = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.connection_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                56 => {
                    self.close_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.close_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ep2p_session_error {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.connection_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.close_reason {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.close_message.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ep2p_session_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.connection_id_dest {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.close_message.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientP2PConnectionFailInfo {
        CMsgClientP2PConnectionFailInfo::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ep2p_session_error = ::std::option::Option::None;
        self.connection_id_dest = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionFailInfo {
        static instance: CMsgClientP2PConnectionFailInfo = CMsgClientP2PConnectionFailInfo {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            ep2p_session_error: ::std::option::Option::None,
            connection_id_dest: ::std::option::Option::None,
            close_reason: ::std::option::Option::None,
            close_message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientP2PConnectionFailInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientP2PConnectionFailInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientP2PConnectionFailInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientP2PConnectionFailInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingCertRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingCertRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertRequest.key_data)
    pub key_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingCertRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertRequest {
    fn default() -> &'a CMsgClientNetworkingCertRequest {
        <CMsgClientNetworkingCertRequest as crate::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertRequest {
    pub fn new() -> CMsgClientNetworkingCertRequest {
        ::std::default::Default::default()
    }

    // optional bytes key_data = 2;

    pub fn key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_data(&mut self) {
        self.key_data = ::std::option::Option::None;
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::bytes::Bytes) {
        self.key_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::bytes::Bytes {
        if self.key_data.is_none() {
            self.key_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::bytes::Bytes {
        self.key_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_data",
            |m: &CMsgClientNetworkingCertRequest| { &m.key_data },
            |m: &mut CMsgClientNetworkingCertRequest| { &mut m.key_data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientNetworkingCertRequest| { &m.app_id },
            |m: &mut CMsgClientNetworkingCertRequest| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingCertRequest>(
            "CMsgClientNetworkingCertRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientNetworkingCertRequest {
    const NAME: &'static str = "CMsgClientNetworkingCertRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.key_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_data.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.key_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingCertRequest {
        CMsgClientNetworkingCertRequest::new()
    }

    fn clear(&mut self) {
        self.key_data = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertRequest {
        static instance: CMsgClientNetworkingCertRequest = CMsgClientNetworkingCertRequest {
            key_data: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientNetworkingCertRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingCertRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientNetworkingCertRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingCertReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingCertReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.cert)
    pub cert: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.ca_key_id)
    pub ca_key_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.ca_signature)
    pub ca_signature: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingCertReply.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertReply {
    fn default() -> &'a CMsgClientNetworkingCertReply {
        <CMsgClientNetworkingCertReply as crate::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertReply {
    pub fn new() -> CMsgClientNetworkingCertReply {
        ::std::default::Default::default()
    }

    // optional bytes cert = 4;

    pub fn cert(&self) -> &[u8] {
        match self.cert.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert = ::std::option::Option::None;
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::bytes::Bytes) {
        self.cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::bytes::Bytes {
        if self.cert.is_none() {
            self.cert = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::bytes::Bytes {
        self.cert.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed64 ca_key_id = 5;

    pub fn ca_key_id(&self) -> u64 {
        self.ca_key_id.unwrap_or(0)
    }

    pub fn clear_ca_key_id(&mut self) {
        self.ca_key_id = ::std::option::Option::None;
    }

    pub fn has_ca_key_id(&self) -> bool {
        self.ca_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_key_id(&mut self, v: u64) {
        self.ca_key_id = ::std::option::Option::Some(v);
    }

    // optional bytes ca_signature = 6;

    pub fn ca_signature(&self) -> &[u8] {
        match self.ca_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ca_signature(&mut self) {
        self.ca_signature = ::std::option::Option::None;
    }

    pub fn has_ca_signature(&self) -> bool {
        self.ca_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_signature(&mut self, v: ::bytes::Bytes) {
        self.ca_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca_signature(&mut self) -> &mut ::bytes::Bytes {
        if self.ca_signature.is_none() {
            self.ca_signature = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.ca_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_ca_signature(&mut self) -> ::bytes::Bytes {
        self.ca_signature.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cert",
            |m: &CMsgClientNetworkingCertReply| { &m.cert },
            |m: &mut CMsgClientNetworkingCertReply| { &mut m.cert },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ca_key_id",
            |m: &CMsgClientNetworkingCertReply| { &m.ca_key_id },
            |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_key_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ca_signature",
            |m: &CMsgClientNetworkingCertReply| { &m.ca_signature },
            |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_signature },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingCertReply>(
            "CMsgClientNetworkingCertReply",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientNetworkingCertReply {
    const NAME: &'static str = "CMsgClientNetworkingCertReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.cert = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                41 => {
                    self.ca_key_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.ca_signature = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cert.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ca_key_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            my_size += crate::rt::bytes_size(6, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cert.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ca_key_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingCertReply {
        CMsgClientNetworkingCertReply::new()
    }

    fn clear(&mut self) {
        self.cert = ::std::option::Option::None;
        self.ca_key_id = ::std::option::Option::None;
        self.ca_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertReply {
        static instance: CMsgClientNetworkingCertReply = CMsgClientNetworkingCertReply {
            cert: ::std::option::Option::None,
            ca_key_id: ::std::option::Option::None,
            ca_signature: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientNetworkingCertReply {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingCertReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientNetworkingCertReply {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingMobileCertRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingMobileCertRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingMobileCertRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingMobileCertRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertRequest {
    fn default() -> &'a CMsgClientNetworkingMobileCertRequest {
        <CMsgClientNetworkingMobileCertRequest as crate::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertRequest {
    pub fn new() -> CMsgClientNetworkingMobileCertRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientNetworkingMobileCertRequest| { &m.app_id },
            |m: &mut CMsgClientNetworkingMobileCertRequest| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingMobileCertRequest>(
            "CMsgClientNetworkingMobileCertRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientNetworkingMobileCertRequest {
    const NAME: &'static str = "CMsgClientNetworkingMobileCertRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingMobileCertRequest {
        CMsgClientNetworkingMobileCertRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertRequest {
        static instance: CMsgClientNetworkingMobileCertRequest = CMsgClientNetworkingMobileCertRequest {
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientNetworkingMobileCertRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingMobileCertRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingMobileCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientNetworkingMobileCertRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingMobileCertReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingMobileCertReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingMobileCertReply.encoded_cert)
    pub encoded_cert: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingMobileCertReply.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertReply {
    fn default() -> &'a CMsgClientNetworkingMobileCertReply {
        <CMsgClientNetworkingMobileCertReply as crate::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertReply {
    pub fn new() -> CMsgClientNetworkingMobileCertReply {
        ::std::default::Default::default()
    }

    // optional string encoded_cert = 1;

    pub fn encoded_cert(&self) -> &str {
        match self.encoded_cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encoded_cert(&mut self) {
        self.encoded_cert = ::std::option::Option::None;
    }

    pub fn has_encoded_cert(&self) -> bool {
        self.encoded_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoded_cert(&mut self, v: ::std::string::String) {
        self.encoded_cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_cert(&mut self) -> &mut ::std::string::String {
        if self.encoded_cert.is_none() {
            self.encoded_cert = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encoded_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoded_cert(&mut self) -> ::std::string::String {
        self.encoded_cert.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "encoded_cert",
            |m: &CMsgClientNetworkingMobileCertReply| { &m.encoded_cert },
            |m: &mut CMsgClientNetworkingMobileCertReply| { &mut m.encoded_cert },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingMobileCertReply>(
            "CMsgClientNetworkingMobileCertReply",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientNetworkingMobileCertReply {
    const NAME: &'static str = "CMsgClientNetworkingMobileCertReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encoded_cert = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encoded_cert.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.encoded_cert.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingMobileCertReply {
        CMsgClientNetworkingMobileCertReply::new()
    }

    fn clear(&mut self) {
        self.encoded_cert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertReply {
        static instance: CMsgClientNetworkingMobileCertReply = CMsgClientNetworkingMobileCertReply {
            encoded_cert: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientNetworkingMobileCertReply {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingMobileCertReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingMobileCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientNetworkingMobileCertReply {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetAppOwnershipTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAppOwnershipTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicket.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAppOwnershipTicket.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicket {
    fn default() -> &'a CMsgClientGetAppOwnershipTicket {
        <CMsgClientGetAppOwnershipTicket as crate::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicket {
    pub fn new() -> CMsgClientGetAppOwnershipTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetAppOwnershipTicket| { &m.app_id },
            |m: &mut CMsgClientGetAppOwnershipTicket| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAppOwnershipTicket>(
            "CMsgClientGetAppOwnershipTicket",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetAppOwnershipTicket {
    const NAME: &'static str = "CMsgClientGetAppOwnershipTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAppOwnershipTicket {
        CMsgClientGetAppOwnershipTicket::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicket {
        static instance: CMsgClientGetAppOwnershipTicket = CMsgClientGetAppOwnershipTicket {
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetAppOwnershipTicket {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAppOwnershipTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAppOwnershipTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicket {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetAppOwnershipTicketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAppOwnershipTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.ticket)
    pub ticket: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAppOwnershipTicketResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicketResponse {
    fn default() -> &'a CMsgClientGetAppOwnershipTicketResponse {
        <CMsgClientGetAppOwnershipTicketResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicketResponse {
    pub fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::bytes::Bytes) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::bytes::Bytes {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::bytes::Bytes {
        self.ticket.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.eresult },
            |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.app_id },
            |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.ticket },
            |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.ticket },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAppOwnershipTicketResponse>(
            "CMsgClientGetAppOwnershipTicketResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetAppOwnershipTicketResponse {
    const NAME: &'static str = "CMsgClientGetAppOwnershipTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        CMsgClientGetAppOwnershipTicketResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicketResponse {
        static instance: CMsgClientGetAppOwnershipTicketResponse = CMsgClientGetAppOwnershipTicketResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetAppOwnershipTicketResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAppOwnershipTicketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAppOwnershipTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicketResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSessionToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSessionToken {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSessionToken.token)
    pub token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSessionToken.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSessionToken {
    fn default() -> &'a CMsgClientSessionToken {
        <CMsgClientSessionToken as crate::Message>::default_instance()
    }
}

impl CMsgClientSessionToken {
    pub fn new() -> CMsgClientSessionToken {
        ::std::default::Default::default()
    }

    // optional uint64 token = 1;

    pub fn token(&self) -> u64 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u64) {
        self.token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientSessionToken| { &m.token },
            |m: &mut CMsgClientSessionToken| { &mut m.token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSessionToken>(
            "CMsgClientSessionToken",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSessionToken {
    const NAME: &'static str = "CMsgClientSessionToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.token {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSessionToken {
        CMsgClientSessionToken::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSessionToken {
        static instance: CMsgClientSessionToken = CMsgClientSessionToken {
            token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSessionToken {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSessionToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSessionToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSessionToken {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGameConnectTokens)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGameConnectTokens {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGameConnectTokens.max_tokens_to_keep)
    pub max_tokens_to_keep: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGameConnectTokens.tokens)
    pub tokens: ::std::vec::Vec<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGameConnectTokens.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGameConnectTokens {
    fn default() -> &'a CMsgClientGameConnectTokens {
        <CMsgClientGameConnectTokens as crate::Message>::default_instance()
    }
}

impl CMsgClientGameConnectTokens {
    pub fn new() -> CMsgClientGameConnectTokens {
        ::std::default::Default::default()
    }

    // optional uint32 max_tokens_to_keep = 1;

    pub fn max_tokens_to_keep(&self) -> u32 {
        self.max_tokens_to_keep.unwrap_or(10u32)
    }

    pub fn clear_max_tokens_to_keep(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
    }

    pub fn has_max_tokens_to_keep(&self) -> bool {
        self.max_tokens_to_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_tokens_to_keep(&mut self, v: u32) {
        self.max_tokens_to_keep = ::std::option::Option::Some(v);
    }

    // repeated bytes tokens = 2;

    pub fn tokens(&self) -> &[::bytes::Bytes] {
        &self.tokens
    }

    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::std::vec::Vec<::bytes::Bytes>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::std::vec::Vec<::bytes::Bytes> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::std::vec::Vec<::bytes::Bytes> {
        ::std::mem::replace(&mut self.tokens, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_tokens_to_keep",
            |m: &CMsgClientGameConnectTokens| { &m.max_tokens_to_keep },
            |m: &mut CMsgClientGameConnectTokens| { &mut m.max_tokens_to_keep },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tokens",
            |m: &CMsgClientGameConnectTokens| { &m.tokens },
            |m: &mut CMsgClientGameConnectTokens| { &mut m.tokens },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGameConnectTokens>(
            "CMsgClientGameConnectTokens",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGameConnectTokens {
    const NAME: &'static str = "CMsgClientGameConnectTokens";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_tokens_to_keep = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.tokens.push(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_tokens_to_keep {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.tokens {
            my_size += crate::rt::bytes_size(2, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.max_tokens_to_keep {
            os.write_uint32(1, v)?;
        }
        for v in &self.tokens {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGameConnectTokens {
        CMsgClientGameConnectTokens::new()
    }

    fn clear(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
        self.tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGameConnectTokens {
        static instance: CMsgClientGameConnectTokens = CMsgClientGameConnectTokens {
            max_tokens_to_keep: ::std::option::Option::None,
            tokens: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGameConnectTokens {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGameConnectTokens").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGameConnectTokens {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGameConnectTokens {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGamesPlayed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGamesPlayed {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.games_played)
    pub games_played: ::std::vec::Vec<cmsg_client_games_played::GamePlayed>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.client_os_type)
    pub client_os_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.cloud_gaming_platform)
    pub cloud_gaming_platform: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.recent_reauthentication)
    pub recent_reauthentication: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGamesPlayed {
    fn default() -> &'a CMsgClientGamesPlayed {
        <CMsgClientGamesPlayed as crate::Message>::default_instance()
    }
}

impl CMsgClientGamesPlayed {
    pub fn new() -> CMsgClientGamesPlayed {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientGamesPlayed.GamePlayed games_played = 1;

    pub fn games_played(&self) -> &[cmsg_client_games_played::GamePlayed] {
        &self.games_played
    }

    pub fn clear_games_played(&mut self) {
        self.games_played.clear();
    }

    // Param is passed by value, moved
    pub fn set_games_played(&mut self, v: ::std::vec::Vec<cmsg_client_games_played::GamePlayed>) {
        self.games_played = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games_played(&mut self) -> &mut ::std::vec::Vec<cmsg_client_games_played::GamePlayed> {
        &mut self.games_played
    }

    // Take field
    pub fn take_games_played(&mut self) -> ::std::vec::Vec<cmsg_client_games_played::GamePlayed> {
        ::std::mem::replace(&mut self.games_played, ::std::vec::Vec::new())
    }

    // optional uint32 client_os_type = 2;

    pub fn client_os_type(&self) -> u32 {
        self.client_os_type.unwrap_or(0)
    }

    pub fn clear_client_os_type(&mut self) {
        self.client_os_type = ::std::option::Option::None;
    }

    pub fn has_client_os_type(&self) -> bool {
        self.client_os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_os_type(&mut self, v: u32) {
        self.client_os_type = ::std::option::Option::Some(v);
    }

    // optional uint32 cloud_gaming_platform = 3;

    pub fn cloud_gaming_platform(&self) -> u32 {
        self.cloud_gaming_platform.unwrap_or(0)
    }

    pub fn clear_cloud_gaming_platform(&mut self) {
        self.cloud_gaming_platform = ::std::option::Option::None;
    }

    pub fn has_cloud_gaming_platform(&self) -> bool {
        self.cloud_gaming_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_gaming_platform(&mut self, v: u32) {
        self.cloud_gaming_platform = ::std::option::Option::Some(v);
    }

    // optional bool recent_reauthentication = 4;

    pub fn recent_reauthentication(&self) -> bool {
        self.recent_reauthentication.unwrap_or(false)
    }

    pub fn clear_recent_reauthentication(&mut self) {
        self.recent_reauthentication = ::std::option::Option::None;
    }

    pub fn has_recent_reauthentication(&self) -> bool {
        self.recent_reauthentication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_reauthentication(&mut self, v: bool) {
        self.recent_reauthentication = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "games_played",
            |m: &CMsgClientGamesPlayed| { &m.games_played },
            |m: &mut CMsgClientGamesPlayed| { &mut m.games_played },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_os_type",
            |m: &CMsgClientGamesPlayed| { &m.client_os_type },
            |m: &mut CMsgClientGamesPlayed| { &mut m.client_os_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cloud_gaming_platform",
            |m: &CMsgClientGamesPlayed| { &m.cloud_gaming_platform },
            |m: &mut CMsgClientGamesPlayed| { &mut m.cloud_gaming_platform },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_reauthentication",
            |m: &CMsgClientGamesPlayed| { &m.recent_reauthentication },
            |m: &mut CMsgClientGamesPlayed| { &mut m.recent_reauthentication },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGamesPlayed>(
            "CMsgClientGamesPlayed",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGamesPlayed {
    const NAME: &'static str = "CMsgClientGamesPlayed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games_played.push(is.read_message()?);
                },
                16 => {
                    self.client_os_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cloud_gaming_platform = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.recent_reauthentication = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games_played {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.client_os_type {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cloud_gaming_platform {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.recent_reauthentication {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.games_played {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.client_os_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cloud_gaming_platform {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.recent_reauthentication {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGamesPlayed {
        CMsgClientGamesPlayed::new()
    }

    fn clear(&mut self) {
        self.games_played.clear();
        self.client_os_type = ::std::option::Option::None;
        self.cloud_gaming_platform = ::std::option::Option::None;
        self.recent_reauthentication = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGamesPlayed {
        static instance: CMsgClientGamesPlayed = CMsgClientGamesPlayed {
            games_played: ::std::vec::Vec::new(),
            client_os_type: ::std::option::Option::None,
            cloud_gaming_platform: ::std::option::Option::None,
            recent_reauthentication: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGamesPlayed {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGamesPlayed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGamesPlayed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGamesPlayed {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGamesPlayed`
pub mod cmsg_client_games_played {
    // @@protoc_insertion_point(message:CMsgClientGamesPlayed.ProcessInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProcessInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.ProcessInfo.process_id)
        pub process_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.ProcessInfo.process_id_parent)
        pub process_id_parent: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.ProcessInfo.parent_is_steam)
        pub parent_is_steam: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.ProcessInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProcessInfo {
        fn default() -> &'a ProcessInfo {
            <ProcessInfo as crate::Message>::default_instance()
        }
    }

    impl ProcessInfo {
        pub fn new() -> ProcessInfo {
            ::std::default::Default::default()
        }

        // optional uint32 process_id = 1;

        pub fn process_id(&self) -> u32 {
            self.process_id.unwrap_or(0)
        }

        pub fn clear_process_id(&mut self) {
            self.process_id = ::std::option::Option::None;
        }

        pub fn has_process_id(&self) -> bool {
            self.process_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id(&mut self, v: u32) {
            self.process_id = ::std::option::Option::Some(v);
        }

        // optional uint32 process_id_parent = 2;

        pub fn process_id_parent(&self) -> u32 {
            self.process_id_parent.unwrap_or(0)
        }

        pub fn clear_process_id_parent(&mut self) {
            self.process_id_parent = ::std::option::Option::None;
        }

        pub fn has_process_id_parent(&self) -> bool {
            self.process_id_parent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id_parent(&mut self, v: u32) {
            self.process_id_parent = ::std::option::Option::Some(v);
        }

        // optional bool parent_is_steam = 3;

        pub fn parent_is_steam(&self) -> bool {
            self.parent_is_steam.unwrap_or(false)
        }

        pub fn clear_parent_is_steam(&mut self) {
            self.parent_is_steam = ::std::option::Option::None;
        }

        pub fn has_parent_is_steam(&self) -> bool {
            self.parent_is_steam.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_is_steam(&mut self, v: bool) {
            self.parent_is_steam = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "process_id",
                |m: &ProcessInfo| { &m.process_id },
                |m: &mut ProcessInfo| { &mut m.process_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "process_id_parent",
                |m: &ProcessInfo| { &m.process_id_parent },
                |m: &mut ProcessInfo| { &mut m.process_id_parent },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "parent_is_steam",
                |m: &ProcessInfo| { &m.parent_is_steam },
                |m: &mut ProcessInfo| { &mut m.parent_is_steam },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ProcessInfo>(
                "CMsgClientGamesPlayed.ProcessInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ProcessInfo {
        const NAME: &'static str = "ProcessInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.process_id_parent = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.parent_is_steam = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.process_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.process_id_parent {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.parent_is_steam {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.process_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.process_id_parent {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.parent_is_steam {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProcessInfo {
            ProcessInfo::new()
        }

        fn clear(&mut self) {
            self.process_id = ::std::option::Option::None;
            self.process_id_parent = ::std::option::Option::None;
            self.parent_is_steam = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProcessInfo {
            static instance: ProcessInfo = ProcessInfo {
                process_id: ::std::option::Option::None,
                process_id_parent: ::std::option::Option::None,
                parent_is_steam: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ProcessInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGamesPlayed.ProcessInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProcessInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ProcessInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientGamesPlayed.GamePlayed)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GamePlayed {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.steam_id_gs)
        pub steam_id_gs: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.deprecated_game_ip_address)
        pub deprecated_game_ip_address: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_port)
        pub game_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.is_secure)
        pub is_secure: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.token)
        pub token: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_extra_info)
        pub game_extra_info: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_data_blob)
        pub game_data_blob: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.process_id)
        pub process_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.streaming_provider_id)
        pub streaming_provider_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_flags)
        pub game_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_vendor)
        pub vr_hmd_vendor: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_model)
        pub vr_hmd_model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.launch_option_type)
        pub launch_option_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.primary_controller_type)
        pub primary_controller_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.primary_steam_controller_serial)
        pub primary_steam_controller_serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.total_steam_controller_count)
        pub total_steam_controller_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.total_non_steam_controller_count)
        pub total_non_steam_controller_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.controller_workshop_file_id)
        pub controller_workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.launch_source)
        pub launch_source: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_runtime)
        pub vr_hmd_runtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_ip_address)
        pub game_ip_address: crate::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.controller_connection_type)
        pub controller_connection_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_os_platform)
        pub game_os_platform: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_build_id)
        pub game_build_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.compat_tool_id)
        pub compat_tool_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.compat_tool_cmd)
        pub compat_tool_cmd: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.compat_tool_build_id)
        pub compat_tool_build_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.beta_name)
        pub beta_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.dlc_context)
        pub dlc_context: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.process_id_list)
        pub process_id_list: ::std::vec::Vec<ProcessInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.GamePlayed.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GamePlayed {
        fn default() -> &'a GamePlayed {
            <GamePlayed as crate::Message>::default_instance()
        }
    }

    impl GamePlayed {
        pub fn new() -> GamePlayed {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id_gs = 1;

        pub fn steam_id_gs(&self) -> u64 {
            self.steam_id_gs.unwrap_or(0)
        }

        pub fn clear_steam_id_gs(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
        }

        pub fn has_steam_id_gs(&self) -> bool {
            self.steam_id_gs.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id_gs(&mut self, v: u64) {
            self.steam_id_gs = ::std::option::Option::Some(v);
        }

        // optional fixed64 game_id = 2;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_game_ip_address = 3;

        pub fn deprecated_game_ip_address(&self) -> u32 {
            self.deprecated_game_ip_address.unwrap_or(0)
        }

        pub fn clear_deprecated_game_ip_address(&mut self) {
            self.deprecated_game_ip_address = ::std::option::Option::None;
        }

        pub fn has_deprecated_game_ip_address(&self) -> bool {
            self.deprecated_game_ip_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
            self.deprecated_game_ip_address = ::std::option::Option::Some(v);
        }

        // optional uint32 game_port = 4;

        pub fn game_port(&self) -> u32 {
            self.game_port.unwrap_or(0)
        }

        pub fn clear_game_port(&mut self) {
            self.game_port = ::std::option::Option::None;
        }

        pub fn has_game_port(&self) -> bool {
            self.game_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_port(&mut self, v: u32) {
            self.game_port = ::std::option::Option::Some(v);
        }

        // optional bool is_secure = 5;

        pub fn is_secure(&self) -> bool {
            self.is_secure.unwrap_or(false)
        }

        pub fn clear_is_secure(&mut self) {
            self.is_secure = ::std::option::Option::None;
        }

        pub fn has_is_secure(&self) -> bool {
            self.is_secure.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_secure(&mut self, v: bool) {
            self.is_secure = ::std::option::Option::Some(v);
        }

        // optional bytes token = 6;

        pub fn token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::bytes::Bytes) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::bytes::Bytes {
            self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional string game_extra_info = 7;

        pub fn game_extra_info(&self) -> &str {
            match self.game_extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_extra_info(&mut self) {
            self.game_extra_info = ::std::option::Option::None;
        }

        pub fn has_game_extra_info(&self) -> bool {
            self.game_extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_extra_info(&mut self, v: ::std::string::String) {
            self.game_extra_info = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_extra_info(&mut self) -> &mut ::std::string::String {
            if self.game_extra_info.is_none() {
                self.game_extra_info = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_extra_info(&mut self) -> ::std::string::String {
            self.game_extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes game_data_blob = 8;

        pub fn game_data_blob(&self) -> &[u8] {
            match self.game_data_blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_game_data_blob(&mut self) {
            self.game_data_blob = ::std::option::Option::None;
        }

        pub fn has_game_data_blob(&self) -> bool {
            self.game_data_blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_data_blob(&mut self, v: ::bytes::Bytes) {
            self.game_data_blob = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_data_blob(&mut self) -> &mut ::bytes::Bytes {
            if self.game_data_blob.is_none() {
                self.game_data_blob = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.game_data_blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_data_blob(&mut self) -> ::bytes::Bytes {
            self.game_data_blob.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional uint32 process_id = 9;

        pub fn process_id(&self) -> u32 {
            self.process_id.unwrap_or(0)
        }

        pub fn clear_process_id(&mut self) {
            self.process_id = ::std::option::Option::None;
        }

        pub fn has_process_id(&self) -> bool {
            self.process_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id(&mut self, v: u32) {
            self.process_id = ::std::option::Option::Some(v);
        }

        // optional uint32 streaming_provider_id = 10;

        pub fn streaming_provider_id(&self) -> u32 {
            self.streaming_provider_id.unwrap_or(0)
        }

        pub fn clear_streaming_provider_id(&mut self) {
            self.streaming_provider_id = ::std::option::Option::None;
        }

        pub fn has_streaming_provider_id(&self) -> bool {
            self.streaming_provider_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_streaming_provider_id(&mut self, v: u32) {
            self.streaming_provider_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_flags = 11;

        pub fn game_flags(&self) -> u32 {
            self.game_flags.unwrap_or(0)
        }

        pub fn clear_game_flags(&mut self) {
            self.game_flags = ::std::option::Option::None;
        }

        pub fn has_game_flags(&self) -> bool {
            self.game_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_flags(&mut self, v: u32) {
            self.game_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional string vr_hmd_vendor = 13;

        pub fn vr_hmd_vendor(&self) -> &str {
            match self.vr_hmd_vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_vendor(&mut self) {
            self.vr_hmd_vendor = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_vendor(&self) -> bool {
            self.vr_hmd_vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_vendor(&mut self, v: ::std::string::String) {
            self.vr_hmd_vendor = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_vendor(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_vendor.is_none() {
                self.vr_hmd_vendor = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vr_hmd_vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_vendor(&mut self) -> ::std::string::String {
            self.vr_hmd_vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vr_hmd_model = 14;

        pub fn vr_hmd_model(&self) -> &str {
            match self.vr_hmd_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_model(&mut self) {
            self.vr_hmd_model = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_model(&self) -> bool {
            self.vr_hmd_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_model(&mut self, v: ::std::string::String) {
            self.vr_hmd_model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_model(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_model.is_none() {
                self.vr_hmd_model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vr_hmd_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_model(&mut self) -> ::std::string::String {
            self.vr_hmd_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 launch_option_type = 15;

        pub fn launch_option_type(&self) -> u32 {
            self.launch_option_type.unwrap_or(0u32)
        }

        pub fn clear_launch_option_type(&mut self) {
            self.launch_option_type = ::std::option::Option::None;
        }

        pub fn has_launch_option_type(&self) -> bool {
            self.launch_option_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_option_type(&mut self, v: u32) {
            self.launch_option_type = ::std::option::Option::Some(v);
        }

        // optional int32 primary_controller_type = 16;

        pub fn primary_controller_type(&self) -> i32 {
            self.primary_controller_type.unwrap_or(-1i32)
        }

        pub fn clear_primary_controller_type(&mut self) {
            self.primary_controller_type = ::std::option::Option::None;
        }

        pub fn has_primary_controller_type(&self) -> bool {
            self.primary_controller_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_controller_type(&mut self, v: i32) {
            self.primary_controller_type = ::std::option::Option::Some(v);
        }

        // optional string primary_steam_controller_serial = 17;

        pub fn primary_steam_controller_serial(&self) -> &str {
            match self.primary_steam_controller_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_primary_steam_controller_serial(&mut self) {
            self.primary_steam_controller_serial = ::std::option::Option::None;
        }

        pub fn has_primary_steam_controller_serial(&self) -> bool {
            self.primary_steam_controller_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_steam_controller_serial(&mut self, v: ::std::string::String) {
            self.primary_steam_controller_serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_primary_steam_controller_serial(&mut self) -> &mut ::std::string::String {
            if self.primary_steam_controller_serial.is_none() {
                self.primary_steam_controller_serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.primary_steam_controller_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_primary_steam_controller_serial(&mut self) -> ::std::string::String {
            self.primary_steam_controller_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 total_steam_controller_count = 18;

        pub fn total_steam_controller_count(&self) -> u32 {
            self.total_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_steam_controller_count(&mut self) {
            self.total_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_steam_controller_count(&self) -> bool {
            self.total_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_steam_controller_count(&mut self, v: u32) {
            self.total_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint32 total_non_steam_controller_count = 19;

        pub fn total_non_steam_controller_count(&self) -> u32 {
            self.total_non_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_non_steam_controller_count(&mut self) {
            self.total_non_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_non_steam_controller_count(&self) -> bool {
            self.total_non_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_non_steam_controller_count(&mut self, v: u32) {
            self.total_non_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint64 controller_workshop_file_id = 20;

        pub fn controller_workshop_file_id(&self) -> u64 {
            self.controller_workshop_file_id.unwrap_or(0u64)
        }

        pub fn clear_controller_workshop_file_id(&mut self) {
            self.controller_workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_controller_workshop_file_id(&self) -> bool {
            self.controller_workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_workshop_file_id(&mut self, v: u64) {
            self.controller_workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 launch_source = 21;

        pub fn launch_source(&self) -> u32 {
            self.launch_source.unwrap_or(0u32)
        }

        pub fn clear_launch_source(&mut self) {
            self.launch_source = ::std::option::Option::None;
        }

        pub fn has_launch_source(&self) -> bool {
            self.launch_source.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_source(&mut self, v: u32) {
            self.launch_source = ::std::option::Option::Some(v);
        }

        // optional uint32 vr_hmd_runtime = 22;

        pub fn vr_hmd_runtime(&self) -> u32 {
            self.vr_hmd_runtime.unwrap_or(0)
        }

        pub fn clear_vr_hmd_runtime(&mut self) {
            self.vr_hmd_runtime = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_runtime(&self) -> bool {
            self.vr_hmd_runtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_runtime(&mut self, v: u32) {
            self.vr_hmd_runtime = ::std::option::Option::Some(v);
        }

        // optional .CMsgIPAddress game_ip_address = 23;

        pub fn game_ip_address(&self) -> &super::super::steammessages_base::CMsgIPAddress {
            self.game_ip_address.as_ref().unwrap_or_else(|| <super::super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
        }

        pub fn clear_game_ip_address(&mut self) {
            self.game_ip_address.clear();
        }

        pub fn has_game_ip_address(&self) -> bool {
            self.game_ip_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_ip_address(&mut self, v: super::super::steammessages_base::CMsgIPAddress) {
            self.game_ip_address = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_ip_address(&mut self) -> &mut super::super::steammessages_base::CMsgIPAddress {
            self.game_ip_address.mut_or_insert_default()
        }

        // Take field
        pub fn take_game_ip_address(&mut self) -> super::super::steammessages_base::CMsgIPAddress {
            self.game_ip_address.take().unwrap_or_else(|| super::super::steammessages_base::CMsgIPAddress::new())
        }

        // optional uint32 controller_connection_type = 24;

        pub fn controller_connection_type(&self) -> u32 {
            self.controller_connection_type.unwrap_or(0u32)
        }

        pub fn clear_controller_connection_type(&mut self) {
            self.controller_connection_type = ::std::option::Option::None;
        }

        pub fn has_controller_connection_type(&self) -> bool {
            self.controller_connection_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_connection_type(&mut self, v: u32) {
            self.controller_connection_type = ::std::option::Option::Some(v);
        }

        // optional int32 game_os_platform = 25;

        pub fn game_os_platform(&self) -> i32 {
            self.game_os_platform.unwrap_or(0)
        }

        pub fn clear_game_os_platform(&mut self) {
            self.game_os_platform = ::std::option::Option::None;
        }

        pub fn has_game_os_platform(&self) -> bool {
            self.game_os_platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_os_platform(&mut self, v: i32) {
            self.game_os_platform = ::std::option::Option::Some(v);
        }

        // optional uint32 game_build_id = 26;

        pub fn game_build_id(&self) -> u32 {
            self.game_build_id.unwrap_or(0)
        }

        pub fn clear_game_build_id(&mut self) {
            self.game_build_id = ::std::option::Option::None;
        }

        pub fn has_game_build_id(&self) -> bool {
            self.game_build_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_build_id(&mut self, v: u32) {
            self.game_build_id = ::std::option::Option::Some(v);
        }

        // optional uint32 compat_tool_id = 27;

        pub fn compat_tool_id(&self) -> u32 {
            self.compat_tool_id.unwrap_or(0u32)
        }

        pub fn clear_compat_tool_id(&mut self) {
            self.compat_tool_id = ::std::option::Option::None;
        }

        pub fn has_compat_tool_id(&self) -> bool {
            self.compat_tool_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compat_tool_id(&mut self, v: u32) {
            self.compat_tool_id = ::std::option::Option::Some(v);
        }

        // optional string compat_tool_cmd = 28;

        pub fn compat_tool_cmd(&self) -> &str {
            match self.compat_tool_cmd.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_compat_tool_cmd(&mut self) {
            self.compat_tool_cmd = ::std::option::Option::None;
        }

        pub fn has_compat_tool_cmd(&self) -> bool {
            self.compat_tool_cmd.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compat_tool_cmd(&mut self, v: ::std::string::String) {
            self.compat_tool_cmd = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_compat_tool_cmd(&mut self) -> &mut ::std::string::String {
            if self.compat_tool_cmd.is_none() {
                self.compat_tool_cmd = ::std::option::Option::Some(::std::string::String::new());
            }
            self.compat_tool_cmd.as_mut().unwrap()
        }

        // Take field
        pub fn take_compat_tool_cmd(&mut self) -> ::std::string::String {
            self.compat_tool_cmd.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 compat_tool_build_id = 29;

        pub fn compat_tool_build_id(&self) -> u32 {
            self.compat_tool_build_id.unwrap_or(0)
        }

        pub fn clear_compat_tool_build_id(&mut self) {
            self.compat_tool_build_id = ::std::option::Option::None;
        }

        pub fn has_compat_tool_build_id(&self) -> bool {
            self.compat_tool_build_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compat_tool_build_id(&mut self, v: u32) {
            self.compat_tool_build_id = ::std::option::Option::Some(v);
        }

        // optional string beta_name = 30;

        pub fn beta_name(&self) -> &str {
            match self.beta_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_beta_name(&mut self) {
            self.beta_name = ::std::option::Option::None;
        }

        pub fn has_beta_name(&self) -> bool {
            self.beta_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_beta_name(&mut self, v: ::std::string::String) {
            self.beta_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_beta_name(&mut self) -> &mut ::std::string::String {
            if self.beta_name.is_none() {
                self.beta_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.beta_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_beta_name(&mut self) -> ::std::string::String {
            self.beta_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 dlc_context = 31;

        pub fn dlc_context(&self) -> u32 {
            self.dlc_context.unwrap_or(0)
        }

        pub fn clear_dlc_context(&mut self) {
            self.dlc_context = ::std::option::Option::None;
        }

        pub fn has_dlc_context(&self) -> bool {
            self.dlc_context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dlc_context(&mut self, v: u32) {
            self.dlc_context = ::std::option::Option::Some(v);
        }

        // repeated .CMsgClientGamesPlayed.ProcessInfo process_id_list = 32;

        pub fn process_id_list(&self) -> &[ProcessInfo] {
            &self.process_id_list
        }

        pub fn clear_process_id_list(&mut self) {
            self.process_id_list.clear();
        }

        // Param is passed by value, moved
        pub fn set_process_id_list(&mut self, v: ::std::vec::Vec<ProcessInfo>) {
            self.process_id_list = v;
        }

        // Mutable pointer to the field.
        pub fn mut_process_id_list(&mut self) -> &mut ::std::vec::Vec<ProcessInfo> {
            &mut self.process_id_list
        }

        // Take field
        pub fn take_process_id_list(&mut self) -> ::std::vec::Vec<ProcessInfo> {
            ::std::mem::replace(&mut self.process_id_list, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(32);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id_gs",
                |m: &GamePlayed| { &m.steam_id_gs },
                |m: &mut GamePlayed| { &mut m.steam_id_gs },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_id",
                |m: &GamePlayed| { &m.game_id },
                |m: &mut GamePlayed| { &mut m.game_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "deprecated_game_ip_address",
                |m: &GamePlayed| { &m.deprecated_game_ip_address },
                |m: &mut GamePlayed| { &mut m.deprecated_game_ip_address },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_port",
                |m: &GamePlayed| { &m.game_port },
                |m: &mut GamePlayed| { &mut m.game_port },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_secure",
                |m: &GamePlayed| { &m.is_secure },
                |m: &mut GamePlayed| { &mut m.is_secure },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "token",
                |m: &GamePlayed| { &m.token },
                |m: &mut GamePlayed| { &mut m.token },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_extra_info",
                |m: &GamePlayed| { &m.game_extra_info },
                |m: &mut GamePlayed| { &mut m.game_extra_info },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_data_blob",
                |m: &GamePlayed| { &m.game_data_blob },
                |m: &mut GamePlayed| { &mut m.game_data_blob },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "process_id",
                |m: &GamePlayed| { &m.process_id },
                |m: &mut GamePlayed| { &mut m.process_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "streaming_provider_id",
                |m: &GamePlayed| { &m.streaming_provider_id },
                |m: &mut GamePlayed| { &mut m.streaming_provider_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_flags",
                |m: &GamePlayed| { &m.game_flags },
                |m: &mut GamePlayed| { &mut m.game_flags },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &GamePlayed| { &m.owner_id },
                |m: &mut GamePlayed| { &mut m.owner_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "vr_hmd_vendor",
                |m: &GamePlayed| { &m.vr_hmd_vendor },
                |m: &mut GamePlayed| { &mut m.vr_hmd_vendor },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "vr_hmd_model",
                |m: &GamePlayed| { &m.vr_hmd_model },
                |m: &mut GamePlayed| { &mut m.vr_hmd_model },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "launch_option_type",
                |m: &GamePlayed| { &m.launch_option_type },
                |m: &mut GamePlayed| { &mut m.launch_option_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "primary_controller_type",
                |m: &GamePlayed| { &m.primary_controller_type },
                |m: &mut GamePlayed| { &mut m.primary_controller_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "primary_steam_controller_serial",
                |m: &GamePlayed| { &m.primary_steam_controller_serial },
                |m: &mut GamePlayed| { &mut m.primary_steam_controller_serial },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_steam_controller_count",
                |m: &GamePlayed| { &m.total_steam_controller_count },
                |m: &mut GamePlayed| { &mut m.total_steam_controller_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_non_steam_controller_count",
                |m: &GamePlayed| { &m.total_non_steam_controller_count },
                |m: &mut GamePlayed| { &mut m.total_non_steam_controller_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_workshop_file_id",
                |m: &GamePlayed| { &m.controller_workshop_file_id },
                |m: &mut GamePlayed| { &mut m.controller_workshop_file_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "launch_source",
                |m: &GamePlayed| { &m.launch_source },
                |m: &mut GamePlayed| { &mut m.launch_source },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "vr_hmd_runtime",
                |m: &GamePlayed| { &m.vr_hmd_runtime },
                |m: &mut GamePlayed| { &mut m.vr_hmd_runtime },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_base::CMsgIPAddress>(
                "game_ip_address",
                |m: &GamePlayed| { &m.game_ip_address },
                |m: &mut GamePlayed| { &mut m.game_ip_address },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_connection_type",
                |m: &GamePlayed| { &m.controller_connection_type },
                |m: &mut GamePlayed| { &mut m.controller_connection_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_os_platform",
                |m: &GamePlayed| { &m.game_os_platform },
                |m: &mut GamePlayed| { &mut m.game_os_platform },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_build_id",
                |m: &GamePlayed| { &m.game_build_id },
                |m: &mut GamePlayed| { &mut m.game_build_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "compat_tool_id",
                |m: &GamePlayed| { &m.compat_tool_id },
                |m: &mut GamePlayed| { &mut m.compat_tool_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "compat_tool_cmd",
                |m: &GamePlayed| { &m.compat_tool_cmd },
                |m: &mut GamePlayed| { &mut m.compat_tool_cmd },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "compat_tool_build_id",
                |m: &GamePlayed| { &m.compat_tool_build_id },
                |m: &mut GamePlayed| { &mut m.compat_tool_build_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "beta_name",
                |m: &GamePlayed| { &m.beta_name },
                |m: &mut GamePlayed| { &mut m.beta_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "dlc_context",
                |m: &GamePlayed| { &m.dlc_context },
                |m: &mut GamePlayed| { &mut m.dlc_context },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "process_id_list",
                |m: &GamePlayed| { &m.process_id_list },
                |m: &mut GamePlayed| { &mut m.process_id_list },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<GamePlayed>(
                "CMsgClientGamesPlayed.GamePlayed",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for GamePlayed {
        const NAME: &'static str = "GamePlayed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_id_gs = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    17 => {
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    58 => {
                        self.game_extra_info = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.game_data_blob = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    72 => {
                        self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.streaming_provider_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.game_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    106 => {
                        self.vr_hmd_vendor = ::std::option::Option::Some(is.read_string()?);
                    },
                    114 => {
                        self.vr_hmd_model = ::std::option::Option::Some(is.read_string()?);
                    },
                    120 => {
                        self.launch_option_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.primary_controller_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    138 => {
                        self.primary_steam_controller_serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    144 => {
                        self.total_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.total_non_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.controller_workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    168 => {
                        self.launch_source = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.vr_hmd_runtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    186 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.game_ip_address)?;
                    },
                    192 => {
                        self.controller_connection_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.game_os_platform = ::std::option::Option::Some(is.read_int32()?);
                    },
                    208 => {
                        self.game_build_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    216 => {
                        self.compat_tool_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    226 => {
                        self.compat_tool_cmd = ::std::option::Option::Some(is.read_string()?);
                    },
                    232 => {
                        self.compat_tool_build_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    242 => {
                        self.beta_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    248 => {
                        self.dlc_context = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    258 => {
                        self.process_id_list.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id_gs {
                my_size += crate::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_port {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.is_secure {
                my_size += 1 + 1;
            }
            if let Some(v) = self.token.as_ref() {
                my_size += crate::rt::bytes_size(6, &v);
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                my_size += crate::rt::string_size(7, &v);
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                my_size += crate::rt::bytes_size(8, &v);
            }
            if let Some(v) = self.process_id {
                my_size += crate::rt::uint32_size(9, v);
            }
            if let Some(v) = self.streaming_provider_id {
                my_size += crate::rt::uint32_size(10, v);
            }
            if let Some(v) = self.game_flags {
                my_size += crate::rt::uint32_size(11, v);
            }
            if let Some(v) = self.owner_id {
                my_size += crate::rt::uint32_size(12, v);
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                my_size += crate::rt::string_size(13, &v);
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                my_size += crate::rt::string_size(14, &v);
            }
            if let Some(v) = self.launch_option_type {
                my_size += crate::rt::uint32_size(15, v);
            }
            if let Some(v) = self.primary_controller_type {
                my_size += crate::rt::int32_size(16, v);
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                my_size += crate::rt::string_size(17, &v);
            }
            if let Some(v) = self.total_steam_controller_count {
                my_size += crate::rt::uint32_size(18, v);
            }
            if let Some(v) = self.total_non_steam_controller_count {
                my_size += crate::rt::uint32_size(19, v);
            }
            if let Some(v) = self.controller_workshop_file_id {
                my_size += crate::rt::uint64_size(20, v);
            }
            if let Some(v) = self.launch_source {
                my_size += crate::rt::uint32_size(21, v);
            }
            if let Some(v) = self.vr_hmd_runtime {
                my_size += crate::rt::uint32_size(22, v);
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                let len = v.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.controller_connection_type {
                my_size += crate::rt::uint32_size(24, v);
            }
            if let Some(v) = self.game_os_platform {
                my_size += crate::rt::int32_size(25, v);
            }
            if let Some(v) = self.game_build_id {
                my_size += crate::rt::uint32_size(26, v);
            }
            if let Some(v) = self.compat_tool_id {
                my_size += crate::rt::uint32_size(27, v);
            }
            if let Some(v) = self.compat_tool_cmd.as_ref() {
                my_size += crate::rt::string_size(28, &v);
            }
            if let Some(v) = self.compat_tool_build_id {
                my_size += crate::rt::uint32_size(29, v);
            }
            if let Some(v) = self.beta_name.as_ref() {
                my_size += crate::rt::string_size(30, &v);
            }
            if let Some(v) = self.dlc_context {
                my_size += crate::rt::uint32_size(31, v);
            }
            for value in &self.process_id_list {
                let len = value.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steam_id_gs {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_port {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_secure {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(6, v)?;
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                os.write_bytes(8, v)?;
            }
            if let Some(v) = self.process_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.streaming_provider_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.game_flags {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                os.write_string(13, v)?;
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.launch_option_type {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.primary_controller_type {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                os.write_string(17, v)?;
            }
            if let Some(v) = self.total_steam_controller_count {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.total_non_steam_controller_count {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.controller_workshop_file_id {
                os.write_uint64(20, v)?;
            }
            if let Some(v) = self.launch_source {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.vr_hmd_runtime {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                crate::rt::write_message_field_with_cached_size(23, v, os)?;
            }
            if let Some(v) = self.controller_connection_type {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.game_os_platform {
                os.write_int32(25, v)?;
            }
            if let Some(v) = self.game_build_id {
                os.write_uint32(26, v)?;
            }
            if let Some(v) = self.compat_tool_id {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.compat_tool_cmd.as_ref() {
                os.write_string(28, v)?;
            }
            if let Some(v) = self.compat_tool_build_id {
                os.write_uint32(29, v)?;
            }
            if let Some(v) = self.beta_name.as_ref() {
                os.write_string(30, v)?;
            }
            if let Some(v) = self.dlc_context {
                os.write_uint32(31, v)?;
            }
            for v in &self.process_id_list {
                crate::rt::write_message_field_with_cached_size(32, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GamePlayed {
            GamePlayed::new()
        }

        fn clear(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
            self.game_id = ::std::option::Option::None;
            self.deprecated_game_ip_address = ::std::option::Option::None;
            self.game_port = ::std::option::Option::None;
            self.is_secure = ::std::option::Option::None;
            self.token = ::std::option::Option::None;
            self.game_extra_info = ::std::option::Option::None;
            self.game_data_blob = ::std::option::Option::None;
            self.process_id = ::std::option::Option::None;
            self.streaming_provider_id = ::std::option::Option::None;
            self.game_flags = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.vr_hmd_vendor = ::std::option::Option::None;
            self.vr_hmd_model = ::std::option::Option::None;
            self.launch_option_type = ::std::option::Option::None;
            self.primary_controller_type = ::std::option::Option::None;
            self.primary_steam_controller_serial = ::std::option::Option::None;
            self.total_steam_controller_count = ::std::option::Option::None;
            self.total_non_steam_controller_count = ::std::option::Option::None;
            self.controller_workshop_file_id = ::std::option::Option::None;
            self.launch_source = ::std::option::Option::None;
            self.vr_hmd_runtime = ::std::option::Option::None;
            self.game_ip_address.clear();
            self.controller_connection_type = ::std::option::Option::None;
            self.game_os_platform = ::std::option::Option::None;
            self.game_build_id = ::std::option::Option::None;
            self.compat_tool_id = ::std::option::Option::None;
            self.compat_tool_cmd = ::std::option::Option::None;
            self.compat_tool_build_id = ::std::option::Option::None;
            self.beta_name = ::std::option::Option::None;
            self.dlc_context = ::std::option::Option::None;
            self.process_id_list.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GamePlayed {
            static instance: GamePlayed = GamePlayed {
                steam_id_gs: ::std::option::Option::None,
                game_id: ::std::option::Option::None,
                deprecated_game_ip_address: ::std::option::Option::None,
                game_port: ::std::option::Option::None,
                is_secure: ::std::option::Option::None,
                token: ::std::option::Option::None,
                game_extra_info: ::std::option::Option::None,
                game_data_blob: ::std::option::Option::None,
                process_id: ::std::option::Option::None,
                streaming_provider_id: ::std::option::Option::None,
                game_flags: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                vr_hmd_vendor: ::std::option::Option::None,
                vr_hmd_model: ::std::option::Option::None,
                launch_option_type: ::std::option::Option::None,
                primary_controller_type: ::std::option::Option::None,
                primary_steam_controller_serial: ::std::option::Option::None,
                total_steam_controller_count: ::std::option::Option::None,
                total_non_steam_controller_count: ::std::option::Option::None,
                controller_workshop_file_id: ::std::option::Option::None,
                launch_source: ::std::option::Option::None,
                vr_hmd_runtime: ::std::option::Option::None,
                game_ip_address: crate::MessageField::none(),
                controller_connection_type: ::std::option::Option::None,
                game_os_platform: ::std::option::Option::None,
                game_build_id: ::std::option::Option::None,
                compat_tool_id: ::std::option::Option::None,
                compat_tool_cmd: ::std::option::Option::None,
                compat_tool_build_id: ::std::option::Option::None,
                beta_name: ::std::option::Option::None,
                dlc_context: ::std::option::Option::None,
                process_id_list: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for GamePlayed {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGamesPlayed.GamePlayed").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GamePlayed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for GamePlayed {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGSApprove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSApprove {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSApprove.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSApprove.owner_steam_id)
    pub owner_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSApprove.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSApprove {
    fn default() -> &'a CMsgGSApprove {
        <CMsgGSApprove as crate::Message>::default_instance()
    }
}

impl CMsgGSApprove {
    pub fn new() -> CMsgGSApprove {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 2;

    pub fn owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSApprove| { &m.steam_id },
            |m: &mut CMsgGSApprove| { &mut m.steam_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_steam_id",
            |m: &CMsgGSApprove| { &m.owner_steam_id },
            |m: &mut CMsgGSApprove| { &mut m.owner_steam_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSApprove>(
            "CMsgGSApprove",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSApprove {
    const NAME: &'static str = "CMsgGSApprove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSApprove {
        CMsgGSApprove::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSApprove {
        static instance: CMsgGSApprove = CMsgGSApprove {
            steam_id: ::std::option::Option::None,
            owner_steam_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSApprove {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSApprove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSApprove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSApprove {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSDeny)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSDeny {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSDeny.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSDeny.edeny_reason)
    pub edeny_reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSDeny.deny_string)
    pub deny_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSDeny.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSDeny {
    fn default() -> &'a CMsgGSDeny {
        <CMsgGSDeny as crate::Message>::default_instance()
    }
}

impl CMsgGSDeny {
    pub fn new() -> CMsgGSDeny {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    // optional string deny_string = 3;

    pub fn deny_string(&self) -> &str {
        match self.deny_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deny_string(&mut self) {
        self.deny_string = ::std::option::Option::None;
    }

    pub fn has_deny_string(&self) -> bool {
        self.deny_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny_string(&mut self, v: ::std::string::String) {
        self.deny_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny_string(&mut self) -> &mut ::std::string::String {
        if self.deny_string.is_none() {
            self.deny_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deny_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_deny_string(&mut self) -> ::std::string::String {
        self.deny_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSDeny| { &m.steam_id },
            |m: &mut CMsgGSDeny| { &mut m.steam_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edeny_reason",
            |m: &CMsgGSDeny| { &m.edeny_reason },
            |m: &mut CMsgGSDeny| { &mut m.edeny_reason },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deny_string",
            |m: &CMsgGSDeny| { &m.deny_string },
            |m: &mut CMsgGSDeny| { &mut m.deny_string },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSDeny>(
            "CMsgGSDeny",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSDeny {
    const NAME: &'static str = "CMsgGSDeny";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.deny_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.edeny_reason {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.deny_string.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deny_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSDeny {
        CMsgGSDeny::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.deny_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSDeny {
        static instance: CMsgGSDeny = CMsgGSDeny {
            steam_id: ::std::option::Option::None,
            edeny_reason: ::std::option::Option::None,
            deny_string: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSDeny {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSDeny").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSDeny {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSDeny {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSKick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSKick {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSKick.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSKick.edeny_reason)
    pub edeny_reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSKick.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSKick {
    fn default() -> &'a CMsgGSKick {
        <CMsgGSKick as crate::Message>::default_instance()
    }
}

impl CMsgGSKick {
    pub fn new() -> CMsgGSKick {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSKick| { &m.steam_id },
            |m: &mut CMsgGSKick| { &mut m.steam_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edeny_reason",
            |m: &CMsgGSKick| { &m.edeny_reason },
            |m: &mut CMsgGSKick| { &mut m.edeny_reason },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSKick>(
            "CMsgGSKick",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSKick {
    const NAME: &'static str = "CMsgGSKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.edeny_reason {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSKick {
        CMsgGSKick::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSKick {
        static instance: CMsgGSKick = CMsgGSKick {
            steam_id: ::std::option::Option::None,
            edeny_reason: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSKick {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSKick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSKick {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthList.tokens_left)
    pub tokens_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.last_request_seq)
    pub last_request_seq: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.last_request_seq_from_server)
    pub last_request_seq_from_server: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.tickets)
    pub tickets: ::std::vec::Vec<super::steammessages_base::CMsgAuthTicket>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.app_ids)
    pub app_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.message_sequence)
    pub message_sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.filtered)
    pub filtered: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthList {
    fn default() -> &'a CMsgClientAuthList {
        <CMsgClientAuthList as crate::Message>::default_instance()
    }
}

impl CMsgClientAuthList {
    pub fn new() -> CMsgClientAuthList {
        ::std::default::Default::default()
    }

    // optional uint32 tokens_left = 1;

    pub fn tokens_left(&self) -> u32 {
        self.tokens_left.unwrap_or(0)
    }

    pub fn clear_tokens_left(&mut self) {
        self.tokens_left = ::std::option::Option::None;
    }

    pub fn has_tokens_left(&self) -> bool {
        self.tokens_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens_left(&mut self, v: u32) {
        self.tokens_left = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq = 2;

    pub fn last_request_seq(&self) -> u32 {
        self.last_request_seq.unwrap_or(0)
    }

    pub fn clear_last_request_seq(&mut self) {
        self.last_request_seq = ::std::option::Option::None;
    }

    pub fn has_last_request_seq(&self) -> bool {
        self.last_request_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq(&mut self, v: u32) {
        self.last_request_seq = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq_from_server = 3;

    pub fn last_request_seq_from_server(&self) -> u32 {
        self.last_request_seq_from_server.unwrap_or(0)
    }

    pub fn clear_last_request_seq_from_server(&mut self) {
        self.last_request_seq_from_server = ::std::option::Option::None;
    }

    pub fn has_last_request_seq_from_server(&self) -> bool {
        self.last_request_seq_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq_from_server(&mut self, v: u32) {
        self.last_request_seq_from_server = ::std::option::Option::Some(v);
    }

    // repeated .CMsgAuthTicket tickets = 4;

    pub fn tickets(&self) -> &[super::steammessages_base::CMsgAuthTicket] {
        &self.tickets
    }

    pub fn clear_tickets(&mut self) {
        self.tickets.clear();
    }

    // Param is passed by value, moved
    pub fn set_tickets(&mut self, v: ::std::vec::Vec<super::steammessages_base::CMsgAuthTicket>) {
        self.tickets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tickets(&mut self) -> &mut ::std::vec::Vec<super::steammessages_base::CMsgAuthTicket> {
        &mut self.tickets
    }

    // Take field
    pub fn take_tickets(&mut self) -> ::std::vec::Vec<super::steammessages_base::CMsgAuthTicket> {
        ::std::mem::replace(&mut self.tickets, ::std::vec::Vec::new())
    }

    // repeated uint32 app_ids = 5;

    pub fn app_ids(&self) -> &[u32] {
        &self.app_ids
    }

    pub fn clear_app_ids(&mut self) {
        self.app_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.app_ids
    }

    // Take field
    pub fn take_app_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_ids, ::std::vec::Vec::new())
    }

    // optional uint32 message_sequence = 6;

    pub fn message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }

    // optional bool filtered = 7;

    pub fn filtered(&self) -> bool {
        self.filtered.unwrap_or(false)
    }

    pub fn clear_filtered(&mut self) {
        self.filtered = ::std::option::Option::None;
    }

    pub fn has_filtered(&self) -> bool {
        self.filtered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filtered(&mut self, v: bool) {
        self.filtered = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tokens_left",
            |m: &CMsgClientAuthList| { &m.tokens_left },
            |m: &mut CMsgClientAuthList| { &mut m.tokens_left },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_request_seq",
            |m: &CMsgClientAuthList| { &m.last_request_seq },
            |m: &mut CMsgClientAuthList| { &mut m.last_request_seq },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_request_seq_from_server",
            |m: &CMsgClientAuthList| { &m.last_request_seq_from_server },
            |m: &mut CMsgClientAuthList| { &mut m.last_request_seq_from_server },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tickets",
            |m: &CMsgClientAuthList| { &m.tickets },
            |m: &mut CMsgClientAuthList| { &mut m.tickets },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_ids",
            |m: &CMsgClientAuthList| { &m.app_ids },
            |m: &mut CMsgClientAuthList| { &mut m.app_ids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_sequence",
            |m: &CMsgClientAuthList| { &m.message_sequence },
            |m: &mut CMsgClientAuthList| { &mut m.message_sequence },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filtered",
            |m: &CMsgClientAuthList| { &m.filtered },
            |m: &mut CMsgClientAuthList| { &mut m.filtered },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthList>(
            "CMsgClientAuthList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAuthList {
    const NAME: &'static str = "CMsgClientAuthList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tokens_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_request_seq = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.last_request_seq_from_server = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.tickets.push(is.read_message()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.app_ids)?;
                },
                40 => {
                    self.app_ids.push(is.read_uint32()?);
                },
                48 => {
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.filtered = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tokens_left {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_request_seq {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.last_request_seq_from_server {
            my_size += crate::rt::uint32_size(3, v);
        }
        for value in &self.tickets {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.app_ids {
            my_size += crate::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.message_sequence {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.filtered {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.tokens_left {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_request_seq {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_request_seq_from_server {
            os.write_uint32(3, v)?;
        }
        for v in &self.tickets {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.app_ids {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.filtered {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthList {
        CMsgClientAuthList::new()
    }

    fn clear(&mut self) {
        self.tokens_left = ::std::option::Option::None;
        self.last_request_seq = ::std::option::Option::None;
        self.last_request_seq_from_server = ::std::option::Option::None;
        self.tickets.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.filtered = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthList {
        static instance: CMsgClientAuthList = CMsgClientAuthList {
            tokens_left: ::std::option::Option::None,
            last_request_seq: ::std::option::Option::None,
            last_request_seq_from_server: ::std::option::Option::None,
            tickets: ::std::vec::Vec::new(),
            app_ids: ::std::vec::Vec::new(),
            message_sequence: ::std::option::Option::None,
            filtered: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAuthList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAuthList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthListAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthListAck {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.ticket_crc)
    pub ticket_crc: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.app_ids)
    pub app_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.message_sequence)
    pub message_sequence: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthListAck.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthListAck {
    fn default() -> &'a CMsgClientAuthListAck {
        <CMsgClientAuthListAck as crate::Message>::default_instance()
    }
}

impl CMsgClientAuthListAck {
    pub fn new() -> CMsgClientAuthListAck {
        ::std::default::Default::default()
    }

    // repeated uint32 ticket_crc = 1;

    pub fn ticket_crc(&self) -> &[u32] {
        &self.ticket_crc
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: ::std::vec::Vec<u32>) {
        self.ticket_crc = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ticket_crc(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ticket_crc
    }

    // Take field
    pub fn take_ticket_crc(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ticket_crc, ::std::vec::Vec::new())
    }

    // repeated uint32 app_ids = 2;

    pub fn app_ids(&self) -> &[u32] {
        &self.app_ids
    }

    pub fn clear_app_ids(&mut self) {
        self.app_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.app_ids
    }

    // Take field
    pub fn take_app_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_ids, ::std::vec::Vec::new())
    }

    // optional uint32 message_sequence = 3;

    pub fn message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ticket_crc",
            |m: &CMsgClientAuthListAck| { &m.ticket_crc },
            |m: &mut CMsgClientAuthListAck| { &mut m.ticket_crc },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_ids",
            |m: &CMsgClientAuthListAck| { &m.app_ids },
            |m: &mut CMsgClientAuthListAck| { &mut m.app_ids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_sequence",
            |m: &CMsgClientAuthListAck| { &m.message_sequence },
            |m: &mut CMsgClientAuthListAck| { &mut m.message_sequence },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthListAck>(
            "CMsgClientAuthListAck",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAuthListAck {
    const NAME: &'static str = "CMsgClientAuthListAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.ticket_crc)?;
                },
                8 => {
                    self.ticket_crc.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.app_ids)?;
                },
                16 => {
                    self.app_ids.push(is.read_uint32()?);
                },
                24 => {
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ticket_crc {
            my_size += crate::rt::uint32_size(1, *value);
        };
        for value in &self.app_ids {
            my_size += crate::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.message_sequence {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.ticket_crc {
            os.write_uint32(1, *v)?;
        };
        for v in &self.app_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthListAck {
        CMsgClientAuthListAck::new()
    }

    fn clear(&mut self) {
        self.ticket_crc.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthListAck {
        static instance: CMsgClientAuthListAck = CMsgClientAuthListAck {
            ticket_crc: ::std::vec::Vec::new(),
            app_ids: ::std::vec::Vec::new(),
            message_sequence: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAuthListAck {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthListAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthListAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAuthListAck {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLicenseList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLicenseList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLicenseList.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLicenseList.licenses)
    pub licenses: ::std::vec::Vec<cmsg_client_license_list::License>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLicenseList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLicenseList {
    fn default() -> &'a CMsgClientLicenseList {
        <CMsgClientLicenseList as crate::Message>::default_instance()
    }
}

impl CMsgClientLicenseList {
    pub fn new() -> CMsgClientLicenseList {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientLicenseList.License licenses = 2;

    pub fn licenses(&self) -> &[cmsg_client_license_list::License] {
        &self.licenses
    }

    pub fn clear_licenses(&mut self) {
        self.licenses.clear();
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: ::std::vec::Vec<cmsg_client_license_list::License>) {
        self.licenses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_licenses(&mut self) -> &mut ::std::vec::Vec<cmsg_client_license_list::License> {
        &mut self.licenses
    }

    // Take field
    pub fn take_licenses(&mut self) -> ::std::vec::Vec<cmsg_client_license_list::License> {
        ::std::mem::replace(&mut self.licenses, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientLicenseList| { &m.eresult },
            |m: &mut CMsgClientLicenseList| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "licenses",
            |m: &CMsgClientLicenseList| { &m.licenses },
            |m: &mut CMsgClientLicenseList| { &mut m.licenses },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLicenseList>(
            "CMsgClientLicenseList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientLicenseList {
    const NAME: &'static str = "CMsgClientLicenseList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.licenses.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.licenses {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLicenseList {
        CMsgClientLicenseList::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.licenses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLicenseList {
        static instance: CMsgClientLicenseList = CMsgClientLicenseList {
            eresult: ::std::option::Option::None,
            licenses: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientLicenseList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLicenseList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLicenseList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientLicenseList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientLicenseList`
pub mod cmsg_client_license_list {
    // @@protoc_insertion_point(message:CMsgClientLicenseList.License)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct License {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.package_id)
        pub package_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.time_created)
        pub time_created: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.time_next_process)
        pub time_next_process: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.minute_limit)
        pub minute_limit: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.minutes_used)
        pub minutes_used: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.payment_method)
        pub payment_method: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.purchase_country_code)
        pub purchase_country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.license_type)
        pub license_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.territory_code)
        pub territory_code: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.change_number)
        pub change_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.initial_period)
        pub initial_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.initial_time_unit)
        pub initial_time_unit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.renewal_period)
        pub renewal_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.renewal_time_unit)
        pub renewal_time_unit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.access_token)
        pub access_token: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.master_package_id)
        pub master_package_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientLicenseList.License.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a License {
        fn default() -> &'a License {
            <License as crate::Message>::default_instance()
        }
    }

    impl License {
        pub fn new() -> License {
            ::std::default::Default::default()
        }

        // optional uint32 package_id = 1;

        pub fn package_id(&self) -> u32 {
            self.package_id.unwrap_or(0)
        }

        pub fn clear_package_id(&mut self) {
            self.package_id = ::std::option::Option::None;
        }

        pub fn has_package_id(&self) -> bool {
            self.package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_id(&mut self, v: u32) {
            self.package_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_created = 2;

        pub fn time_created(&self) -> u32 {
            self.time_created.unwrap_or(0)
        }

        pub fn clear_time_created(&mut self) {
            self.time_created = ::std::option::Option::None;
        }

        pub fn has_time_created(&self) -> bool {
            self.time_created.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_created(&mut self, v: u32) {
            self.time_created = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_next_process = 3;

        pub fn time_next_process(&self) -> u32 {
            self.time_next_process.unwrap_or(0)
        }

        pub fn clear_time_next_process(&mut self) {
            self.time_next_process = ::std::option::Option::None;
        }

        pub fn has_time_next_process(&self) -> bool {
            self.time_next_process.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_next_process(&mut self, v: u32) {
            self.time_next_process = ::std::option::Option::Some(v);
        }

        // optional int32 minute_limit = 4;

        pub fn minute_limit(&self) -> i32 {
            self.minute_limit.unwrap_or(0)
        }

        pub fn clear_minute_limit(&mut self) {
            self.minute_limit = ::std::option::Option::None;
        }

        pub fn has_minute_limit(&self) -> bool {
            self.minute_limit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minute_limit(&mut self, v: i32) {
            self.minute_limit = ::std::option::Option::Some(v);
        }

        // optional int32 minutes_used = 5;

        pub fn minutes_used(&self) -> i32 {
            self.minutes_used.unwrap_or(0)
        }

        pub fn clear_minutes_used(&mut self) {
            self.minutes_used = ::std::option::Option::None;
        }

        pub fn has_minutes_used(&self) -> bool {
            self.minutes_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_used(&mut self, v: i32) {
            self.minutes_used = ::std::option::Option::Some(v);
        }

        // optional uint32 payment_method = 6;

        pub fn payment_method(&self) -> u32 {
            self.payment_method.unwrap_or(0)
        }

        pub fn clear_payment_method(&mut self) {
            self.payment_method = ::std::option::Option::None;
        }

        pub fn has_payment_method(&self) -> bool {
            self.payment_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payment_method(&mut self, v: u32) {
            self.payment_method = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 7;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional string purchase_country_code = 8;

        pub fn purchase_country_code(&self) -> &str {
            match self.purchase_country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_purchase_country_code(&mut self) {
            self.purchase_country_code = ::std::option::Option::None;
        }

        pub fn has_purchase_country_code(&self) -> bool {
            self.purchase_country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_purchase_country_code(&mut self, v: ::std::string::String) {
            self.purchase_country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_purchase_country_code(&mut self) -> &mut ::std::string::String {
            if self.purchase_country_code.is_none() {
                self.purchase_country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.purchase_country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_purchase_country_code(&mut self) -> ::std::string::String {
            self.purchase_country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 license_type = 9;

        pub fn license_type(&self) -> u32 {
            self.license_type.unwrap_or(0)
        }

        pub fn clear_license_type(&mut self) {
            self.license_type = ::std::option::Option::None;
        }

        pub fn has_license_type(&self) -> bool {
            self.license_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_license_type(&mut self, v: u32) {
            self.license_type = ::std::option::Option::Some(v);
        }

        // optional int32 territory_code = 10;

        pub fn territory_code(&self) -> i32 {
            self.territory_code.unwrap_or(0)
        }

        pub fn clear_territory_code(&mut self) {
            self.territory_code = ::std::option::Option::None;
        }

        pub fn has_territory_code(&self) -> bool {
            self.territory_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_territory_code(&mut self, v: i32) {
            self.territory_code = ::std::option::Option::Some(v);
        }

        // optional int32 change_number = 11;

        pub fn change_number(&self) -> i32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: i32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_period = 13;

        pub fn initial_period(&self) -> u32 {
            self.initial_period.unwrap_or(0)
        }

        pub fn clear_initial_period(&mut self) {
            self.initial_period = ::std::option::Option::None;
        }

        pub fn has_initial_period(&self) -> bool {
            self.initial_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_period(&mut self, v: u32) {
            self.initial_period = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_time_unit = 14;

        pub fn initial_time_unit(&self) -> u32 {
            self.initial_time_unit.unwrap_or(0)
        }

        pub fn clear_initial_time_unit(&mut self) {
            self.initial_time_unit = ::std::option::Option::None;
        }

        pub fn has_initial_time_unit(&self) -> bool {
            self.initial_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_time_unit(&mut self, v: u32) {
            self.initial_time_unit = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_period = 15;

        pub fn renewal_period(&self) -> u32 {
            self.renewal_period.unwrap_or(0)
        }

        pub fn clear_renewal_period(&mut self) {
            self.renewal_period = ::std::option::Option::None;
        }

        pub fn has_renewal_period(&self) -> bool {
            self.renewal_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_period(&mut self, v: u32) {
            self.renewal_period = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_time_unit = 16;

        pub fn renewal_time_unit(&self) -> u32 {
            self.renewal_time_unit.unwrap_or(0)
        }

        pub fn clear_renewal_time_unit(&mut self) {
            self.renewal_time_unit = ::std::option::Option::None;
        }

        pub fn has_renewal_time_unit(&self) -> bool {
            self.renewal_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_time_unit(&mut self, v: u32) {
            self.renewal_time_unit = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 17;

        pub fn access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        // optional uint32 master_package_id = 18;

        pub fn master_package_id(&self) -> u32 {
            self.master_package_id.unwrap_or(0)
        }

        pub fn clear_master_package_id(&mut self) {
            self.master_package_id = ::std::option::Option::None;
        }

        pub fn has_master_package_id(&self) -> bool {
            self.master_package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_master_package_id(&mut self, v: u32) {
            self.master_package_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(18);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "package_id",
                |m: &License| { &m.package_id },
                |m: &mut License| { &mut m.package_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_created",
                |m: &License| { &m.time_created },
                |m: &mut License| { &mut m.time_created },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_next_process",
                |m: &License| { &m.time_next_process },
                |m: &mut License| { &mut m.time_next_process },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "minute_limit",
                |m: &License| { &m.minute_limit },
                |m: &mut License| { &mut m.minute_limit },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "minutes_used",
                |m: &License| { &m.minutes_used },
                |m: &mut License| { &mut m.minutes_used },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "payment_method",
                |m: &License| { &m.payment_method },
                |m: &mut License| { &mut m.payment_method },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &License| { &m.flags },
                |m: &mut License| { &mut m.flags },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "purchase_country_code",
                |m: &License| { &m.purchase_country_code },
                |m: &mut License| { &mut m.purchase_country_code },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "license_type",
                |m: &License| { &m.license_type },
                |m: &mut License| { &mut m.license_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "territory_code",
                |m: &License| { &m.territory_code },
                |m: &mut License| { &mut m.territory_code },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &License| { &m.change_number },
                |m: &mut License| { &mut m.change_number },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &License| { &m.owner_id },
                |m: &mut License| { &mut m.owner_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "initial_period",
                |m: &License| { &m.initial_period },
                |m: &mut License| { &mut m.initial_period },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "initial_time_unit",
                |m: &License| { &m.initial_time_unit },
                |m: &mut License| { &mut m.initial_time_unit },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "renewal_period",
                |m: &License| { &m.renewal_period },
                |m: &mut License| { &mut m.renewal_period },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "renewal_time_unit",
                |m: &License| { &m.renewal_time_unit },
                |m: &mut License| { &mut m.renewal_time_unit },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "access_token",
                |m: &License| { &m.access_token },
                |m: &mut License| { &mut m.access_token },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "master_package_id",
                |m: &License| { &m.master_package_id },
                |m: &mut License| { &mut m.master_package_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<License>(
                "CMsgClientLicenseList.License",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for License {
        const NAME: &'static str = "License";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.time_created = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    29 => {
                        self.time_next_process = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    32 => {
                        self.minute_limit = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.minutes_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.payment_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.purchase_country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.license_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.territory_code = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.change_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.initial_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.initial_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.renewal_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.renewal_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    144 => {
                        self.master_package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.package_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.time_created {
                my_size += 1 + 4;
            }
            if let Some(v) = self.time_next_process {
                my_size += 1 + 4;
            }
            if let Some(v) = self.minute_limit {
                my_size += crate::rt::int32_size(4, v);
            }
            if let Some(v) = self.minutes_used {
                my_size += crate::rt::int32_size(5, v);
            }
            if let Some(v) = self.payment_method {
                my_size += crate::rt::uint32_size(6, v);
            }
            if let Some(v) = self.flags {
                my_size += crate::rt::uint32_size(7, v);
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                my_size += crate::rt::string_size(8, &v);
            }
            if let Some(v) = self.license_type {
                my_size += crate::rt::uint32_size(9, v);
            }
            if let Some(v) = self.territory_code {
                my_size += crate::rt::int32_size(10, v);
            }
            if let Some(v) = self.change_number {
                my_size += crate::rt::int32_size(11, v);
            }
            if let Some(v) = self.owner_id {
                my_size += crate::rt::uint32_size(12, v);
            }
            if let Some(v) = self.initial_period {
                my_size += crate::rt::uint32_size(13, v);
            }
            if let Some(v) = self.initial_time_unit {
                my_size += crate::rt::uint32_size(14, v);
            }
            if let Some(v) = self.renewal_period {
                my_size += crate::rt::uint32_size(15, v);
            }
            if let Some(v) = self.renewal_time_unit {
                my_size += crate::rt::uint32_size(16, v);
            }
            if let Some(v) = self.access_token {
                my_size += crate::rt::uint64_size(17, v);
            }
            if let Some(v) = self.master_package_id {
                my_size += crate::rt::uint32_size(18, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.package_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.time_created {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.time_next_process {
                os.write_fixed32(3, v)?;
            }
            if let Some(v) = self.minute_limit {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.minutes_used {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.payment_method {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.license_type {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.territory_code {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.initial_period {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.initial_time_unit {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.renewal_period {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.renewal_time_unit {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(17, v)?;
            }
            if let Some(v) = self.master_package_id {
                os.write_uint32(18, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> License {
            License::new()
        }

        fn clear(&mut self) {
            self.package_id = ::std::option::Option::None;
            self.time_created = ::std::option::Option::None;
            self.time_next_process = ::std::option::Option::None;
            self.minute_limit = ::std::option::Option::None;
            self.minutes_used = ::std::option::Option::None;
            self.payment_method = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.purchase_country_code = ::std::option::Option::None;
            self.license_type = ::std::option::Option::None;
            self.territory_code = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.initial_period = ::std::option::Option::None;
            self.initial_time_unit = ::std::option::Option::None;
            self.renewal_period = ::std::option::Option::None;
            self.renewal_time_unit = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.master_package_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static License {
            static instance: License = License {
                package_id: ::std::option::Option::None,
                time_created: ::std::option::Option::None,
                time_next_process: ::std::option::Option::None,
                minute_limit: ::std::option::Option::None,
                minutes_used: ::std::option::Option::None,
                payment_method: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                purchase_country_code: ::std::option::Option::None,
                license_type: ::std::option::Option::None,
                territory_code: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                initial_period: ::std::option::Option::None,
                initial_time_unit: ::std::option::Option::None,
                renewal_period: ::std::option::Option::None,
                renewal_time_unit: ::std::option::Option::None,
                access_token: ::std::option::Option::None,
                master_package_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for License {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientLicenseList.License").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for License {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for License {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientIsLimitedAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientIsLimitedAccount {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_limited_account)
    pub bis_limited_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_community_banned)
    pub bis_community_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_locked_account)
    pub bis_locked_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_limited_account_allowed_to_invite_friends)
    pub bis_limited_account_allowed_to_invite_friends: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientIsLimitedAccount.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientIsLimitedAccount {
    fn default() -> &'a CMsgClientIsLimitedAccount {
        <CMsgClientIsLimitedAccount as crate::Message>::default_instance()
    }
}

impl CMsgClientIsLimitedAccount {
    pub fn new() -> CMsgClientIsLimitedAccount {
        ::std::default::Default::default()
    }

    // optional bool bis_limited_account = 1;

    pub fn bis_limited_account(&self) -> bool {
        self.bis_limited_account.unwrap_or(false)
    }

    pub fn clear_bis_limited_account(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account(&self) -> bool {
        self.bis_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account(&mut self, v: bool) {
        self.bis_limited_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_community_banned = 2;

    pub fn bis_community_banned(&self) -> bool {
        self.bis_community_banned.unwrap_or(false)
    }

    pub fn clear_bis_community_banned(&mut self) {
        self.bis_community_banned = ::std::option::Option::None;
    }

    pub fn has_bis_community_banned(&self) -> bool {
        self.bis_community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_community_banned(&mut self, v: bool) {
        self.bis_community_banned = ::std::option::Option::Some(v);
    }

    // optional bool bis_locked_account = 3;

    pub fn bis_locked_account(&self) -> bool {
        self.bis_locked_account.unwrap_or(false)
    }

    pub fn clear_bis_locked_account(&mut self) {
        self.bis_locked_account = ::std::option::Option::None;
    }

    pub fn has_bis_locked_account(&self) -> bool {
        self.bis_locked_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_locked_account(&mut self, v: bool) {
        self.bis_locked_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_limited_account_allowed_to_invite_friends = 4;

    pub fn bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.unwrap_or(false)
    }

    pub fn clear_bis_limited_account_allowed_to_invite_friends(&mut self) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account_allowed_to_invite_friends(&mut self, v: bool) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_limited_account",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_community_banned",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_community_banned },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_community_banned },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_locked_account",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_locked_account },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_locked_account },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_limited_account_allowed_to_invite_friends",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account_allowed_to_invite_friends },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account_allowed_to_invite_friends },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientIsLimitedAccount>(
            "CMsgClientIsLimitedAccount",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientIsLimitedAccount {
    const NAME: &'static str = "CMsgClientIsLimitedAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bis_limited_account = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bis_community_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.bis_locked_account = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bis_limited_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_community_banned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_locked_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.bis_limited_account {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bis_community_banned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bis_locked_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientIsLimitedAccount {
        CMsgClientIsLimitedAccount::new()
    }

    fn clear(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
        self.bis_community_banned = ::std::option::Option::None;
        self.bis_locked_account = ::std::option::Option::None;
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientIsLimitedAccount {
        static instance: CMsgClientIsLimitedAccount = CMsgClientIsLimitedAccount {
            bis_limited_account: ::std::option::Option::None,
            bis_community_banned: ::std::option::Option::None,
            bis_locked_account: ::std::option::Option::None,
            bis_limited_account_allowed_to_invite_friends: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientIsLimitedAccount {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientIsLimitedAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientIsLimitedAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientIsLimitedAccount {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestedClientStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestedClientStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.stats_to_send)
    pub stats_to_send: ::std::vec::Vec<cmsg_client_requested_client_stats::StatsToSend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestedClientStats.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestedClientStats {
    fn default() -> &'a CMsgClientRequestedClientStats {
        <CMsgClientRequestedClientStats as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestedClientStats {
    pub fn new() -> CMsgClientRequestedClientStats {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientRequestedClientStats.StatsToSend stats_to_send = 1;

    pub fn stats_to_send(&self) -> &[cmsg_client_requested_client_stats::StatsToSend] {
        &self.stats_to_send
    }

    pub fn clear_stats_to_send(&mut self) {
        self.stats_to_send.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_to_send(&mut self, v: ::std::vec::Vec<cmsg_client_requested_client_stats::StatsToSend>) {
        self.stats_to_send = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_to_send(&mut self) -> &mut ::std::vec::Vec<cmsg_client_requested_client_stats::StatsToSend> {
        &mut self.stats_to_send
    }

    // Take field
    pub fn take_stats_to_send(&mut self) -> ::std::vec::Vec<cmsg_client_requested_client_stats::StatsToSend> {
        ::std::mem::replace(&mut self.stats_to_send, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats_to_send",
            |m: &CMsgClientRequestedClientStats| { &m.stats_to_send },
            |m: &mut CMsgClientRequestedClientStats| { &mut m.stats_to_send },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestedClientStats>(
            "CMsgClientRequestedClientStats",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestedClientStats {
    const NAME: &'static str = "CMsgClientRequestedClientStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stats_to_send.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats_to_send {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.stats_to_send {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestedClientStats {
        CMsgClientRequestedClientStats::new()
    }

    fn clear(&mut self) {
        self.stats_to_send.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestedClientStats {
        static instance: CMsgClientRequestedClientStats = CMsgClientRequestedClientStats {
            stats_to_send: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestedClientStats {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestedClientStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestedClientStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestedClientStats {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientRequestedClientStats`
pub mod cmsg_client_requested_client_stats {
    // @@protoc_insertion_point(message:CMsgClientRequestedClientStats.StatsToSend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatsToSend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.StatsToSend.client_stat)
        pub client_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.StatsToSend.stat_aggregate_method)
        pub stat_aggregate_method: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientRequestedClientStats.StatsToSend.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsToSend {
        fn default() -> &'a StatsToSend {
            <StatsToSend as crate::Message>::default_instance()
        }
    }

    impl StatsToSend {
        pub fn new() -> StatsToSend {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_aggregate_method = 2;

        pub fn stat_aggregate_method(&self) -> u32 {
            self.stat_aggregate_method.unwrap_or(0)
        }

        pub fn clear_stat_aggregate_method(&mut self) {
            self.stat_aggregate_method = ::std::option::Option::None;
        }

        pub fn has_stat_aggregate_method(&self) -> bool {
            self.stat_aggregate_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_aggregate_method(&mut self, v: u32) {
            self.stat_aggregate_method = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "client_stat",
                |m: &StatsToSend| { &m.client_stat },
                |m: &mut StatsToSend| { &mut m.client_stat },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_aggregate_method",
                |m: &StatsToSend| { &m.stat_aggregate_method },
                |m: &mut StatsToSend| { &mut m.stat_aggregate_method },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<StatsToSend>(
                "CMsgClientRequestedClientStats.StatsToSend",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for StatsToSend {
        const NAME: &'static str = "StatsToSend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_aggregate_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_aggregate_method {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_aggregate_method {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsToSend {
            StatsToSend::new()
        }

        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.stat_aggregate_method = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsToSend {
            static instance: StatsToSend = StatsToSend {
                client_stat: ::std::option::Option::None,
                stat_aggregate_method: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for StatsToSend {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientRequestedClientStats.StatsToSend").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatsToSend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for StatsToSend {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientStat2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStat2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStat2.stat_detail)
    pub stat_detail: ::std::vec::Vec<cmsg_client_stat2::StatDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStat2.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStat2 {
    fn default() -> &'a CMsgClientStat2 {
        <CMsgClientStat2 as crate::Message>::default_instance()
    }
}

impl CMsgClientStat2 {
    pub fn new() -> CMsgClientStat2 {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientStat2.StatDetail stat_detail = 1;

    pub fn stat_detail(&self) -> &[cmsg_client_stat2::StatDetail] {
        &self.stat_detail
    }

    pub fn clear_stat_detail(&mut self) {
        self.stat_detail.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_detail(&mut self, v: ::std::vec::Vec<cmsg_client_stat2::StatDetail>) {
        self.stat_detail = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_detail(&mut self) -> &mut ::std::vec::Vec<cmsg_client_stat2::StatDetail> {
        &mut self.stat_detail
    }

    // Take field
    pub fn take_stat_detail(&mut self) -> ::std::vec::Vec<cmsg_client_stat2::StatDetail> {
        ::std::mem::replace(&mut self.stat_detail, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_detail",
            |m: &CMsgClientStat2| { &m.stat_detail },
            |m: &mut CMsgClientStat2| { &mut m.stat_detail },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStat2>(
            "CMsgClientStat2",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientStat2 {
    const NAME: &'static str = "CMsgClientStat2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stat_detail.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stat_detail {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.stat_detail {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStat2 {
        CMsgClientStat2::new()
    }

    fn clear(&mut self) {
        self.stat_detail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStat2 {
        static instance: CMsgClientStat2 = CMsgClientStat2 {
            stat_detail: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientStat2 {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStat2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStat2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientStat2 {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientStat2`
pub mod cmsg_client_stat2 {
    // @@protoc_insertion_point(message:CMsgClientStat2.StatDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatDetail {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.client_stat)
        pub client_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.ll_value)
        pub ll_value: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.time_of_day)
        pub time_of_day: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.cell_id)
        pub cell_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.depot_id)
        pub depot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.app_id)
        pub app_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientStat2.StatDetail.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatDetail {
        fn default() -> &'a StatDetail {
            <StatDetail as crate::Message>::default_instance()
        }
    }

    impl StatDetail {
        pub fn new() -> StatDetail {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional int64 ll_value = 2;

        pub fn ll_value(&self) -> i64 {
            self.ll_value.unwrap_or(0)
        }

        pub fn clear_ll_value(&mut self) {
            self.ll_value = ::std::option::Option::None;
        }

        pub fn has_ll_value(&self) -> bool {
            self.ll_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ll_value(&mut self, v: i64) {
            self.ll_value = ::std::option::Option::Some(v);
        }

        // optional uint32 time_of_day = 3;

        pub fn time_of_day(&self) -> u32 {
            self.time_of_day.unwrap_or(0)
        }

        pub fn clear_time_of_day(&mut self) {
            self.time_of_day = ::std::option::Option::None;
        }

        pub fn has_time_of_day(&self) -> bool {
            self.time_of_day.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_of_day(&mut self, v: u32) {
            self.time_of_day = ::std::option::Option::Some(v);
        }

        // optional uint32 cell_id = 4;

        pub fn cell_id(&self) -> u32 {
            self.cell_id.unwrap_or(0)
        }

        pub fn clear_cell_id(&mut self) {
            self.cell_id = ::std::option::Option::None;
        }

        pub fn has_cell_id(&self) -> bool {
            self.cell_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cell_id(&mut self, v: u32) {
            self.cell_id = ::std::option::Option::Some(v);
        }

        // optional uint32 depot_id = 5;

        pub fn depot_id(&self) -> u32 {
            self.depot_id.unwrap_or(0)
        }

        pub fn clear_depot_id(&mut self) {
            self.depot_id = ::std::option::Option::None;
        }

        pub fn has_depot_id(&self) -> bool {
            self.depot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_depot_id(&mut self, v: u32) {
            self.depot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 6;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "client_stat",
                |m: &StatDetail| { &m.client_stat },
                |m: &mut StatDetail| { &mut m.client_stat },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ll_value",
                |m: &StatDetail| { &m.ll_value },
                |m: &mut StatDetail| { &mut m.ll_value },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_of_day",
                |m: &StatDetail| { &m.time_of_day },
                |m: &mut StatDetail| { &mut m.time_of_day },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "cell_id",
                |m: &StatDetail| { &m.cell_id },
                |m: &mut StatDetail| { &mut m.cell_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "depot_id",
                |m: &StatDetail| { &m.depot_id },
                |m: &mut StatDetail| { &mut m.depot_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &StatDetail| { &m.app_id },
                |m: &mut StatDetail| { &mut m.app_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<StatDetail>(
                "CMsgClientStat2.StatDetail",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for StatDetail {
        const NAME: &'static str = "StatDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ll_value = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.time_of_day = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ll_value {
                my_size += crate::rt::int64_size(2, v);
            }
            if let Some(v) = self.time_of_day {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.cell_id {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.depot_id {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.app_id {
                my_size += crate::rt::uint32_size(6, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ll_value {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.time_of_day {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.cell_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.depot_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatDetail {
            StatDetail::new()
        }

        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.ll_value = ::std::option::Option::None;
            self.time_of_day = ::std::option::Option::None;
            self.cell_id = ::std::option::Option::None;
            self.depot_id = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatDetail {
            static instance: StatDetail = StatDetail {
                client_stat: ::std::option::Option::None,
                ll_value: ::std::option::Option::None,
                time_of_day: ::std::option::Option::None,
                cell_id: ::std::option::Option::None,
                depot_id: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for StatDetail {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientStat2.StatDetail").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for StatDetail {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientInviteToGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInviteToGame {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.connect_string)
    pub connect_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.remote_play)
    pub remote_play: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInviteToGame.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInviteToGame {
    fn default() -> &'a CMsgClientInviteToGame {
        <CMsgClientInviteToGame as crate::Message>::default_instance()
    }
}

impl CMsgClientInviteToGame {
    pub fn new() -> CMsgClientInviteToGame {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional string connect_string = 3;

    pub fn connect_string(&self) -> &str {
        match self.connect_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect_string(&mut self) {
        self.connect_string = ::std::option::Option::None;
    }

    pub fn has_connect_string(&self) -> bool {
        self.connect_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_string(&mut self, v: ::std::string::String) {
        self.connect_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_string(&mut self) -> &mut ::std::string::String {
        if self.connect_string.is_none() {
            self.connect_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_string(&mut self) -> ::std::string::String {
        self.connect_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_play = 4;

    pub fn remote_play(&self) -> &str {
        match self.remote_play.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remote_play(&mut self) {
        self.remote_play = ::std::option::Option::None;
    }

    pub fn has_remote_play(&self) -> bool {
        self.remote_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_play(&mut self, v: ::std::string::String) {
        self.remote_play = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_play(&mut self) -> &mut ::std::string::String {
        if self.remote_play.is_none() {
            self.remote_play = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remote_play.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_play(&mut self) -> ::std::string::String {
        self.remote_play.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_dest",
            |m: &CMsgClientInviteToGame| { &m.steam_id_dest },
            |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_dest },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_src",
            |m: &CMsgClientInviteToGame| { &m.steam_id_src },
            |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_src },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect_string",
            |m: &CMsgClientInviteToGame| { &m.connect_string },
            |m: &mut CMsgClientInviteToGame| { &mut m.connect_string },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "remote_play",
            |m: &CMsgClientInviteToGame| { &m.remote_play },
            |m: &mut CMsgClientInviteToGame| { &mut m.remote_play },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientInviteToGame>(
            "CMsgClientInviteToGame",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientInviteToGame {
    const NAME: &'static str = "CMsgClientInviteToGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.connect_string = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.remote_play = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.connect_string.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.remote_play.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.connect_string.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.remote_play.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInviteToGame {
        CMsgClientInviteToGame::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.connect_string = ::std::option::Option::None;
        self.remote_play = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInviteToGame {
        static instance: CMsgClientInviteToGame = CMsgClientInviteToGame {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            connect_string: ::std::option::Option::None,
            remote_play: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientInviteToGame {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientInviteToGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientInviteToGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientInviteToGame {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientChatInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_invited)
    pub steam_id_invited: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_chat)
    pub steam_id_chat: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_patron)
    pub steam_id_patron: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.chatroom_type)
    pub chatroom_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_friend_chat)
    pub steam_id_friend_chat: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatInvite.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatInvite {
    fn default() -> &'a CMsgClientChatInvite {
        <CMsgClientChatInvite as crate::Message>::default_instance()
    }
}

impl CMsgClientChatInvite {
    pub fn new() -> CMsgClientChatInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_invited = 1;

    pub fn steam_id_invited(&self) -> u64 {
        self.steam_id_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_invited(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_invited(&self) -> bool {
        self.steam_id_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_invited(&mut self, v: u64) {
        self.steam_id_invited = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_chat = 2;

    pub fn steam_id_chat(&self) -> u64 {
        self.steam_id_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_chat(&mut self) {
        self.steam_id_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_chat(&self) -> bool {
        self.steam_id_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_chat(&mut self, v: u64) {
        self.steam_id_chat = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_patron = 3;

    pub fn steam_id_patron(&self) -> u64 {
        self.steam_id_patron.unwrap_or(0)
    }

    pub fn clear_steam_id_patron(&mut self) {
        self.steam_id_patron = ::std::option::Option::None;
    }

    pub fn has_steam_id_patron(&self) -> bool {
        self.steam_id_patron.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_patron(&mut self, v: u64) {
        self.steam_id_patron = ::std::option::Option::Some(v);
    }

    // optional int32 chatroom_type = 4;

    pub fn chatroom_type(&self) -> i32 {
        self.chatroom_type.unwrap_or(0)
    }

    pub fn clear_chatroom_type(&mut self) {
        self.chatroom_type = ::std::option::Option::None;
    }

    pub fn has_chatroom_type(&self) -> bool {
        self.chatroom_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatroom_type(&mut self, v: i32) {
        self.chatroom_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_friend_chat = 5;

    pub fn steam_id_friend_chat(&self) -> u64 {
        self.steam_id_friend_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_friend_chat(&mut self) {
        self.steam_id_friend_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_friend_chat(&self) -> bool {
        self.steam_id_friend_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_friend_chat(&mut self, v: u64) {
        self.steam_id_friend_chat = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 6;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 game_id = 7;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_invited",
            |m: &CMsgClientChatInvite| { &m.steam_id_invited },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_invited },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_chat",
            |m: &CMsgClientChatInvite| { &m.steam_id_chat },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_chat },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_patron",
            |m: &CMsgClientChatInvite| { &m.steam_id_patron },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_patron },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chatroom_type",
            |m: &CMsgClientChatInvite| { &m.chatroom_type },
            |m: &mut CMsgClientChatInvite| { &mut m.chatroom_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_friend_chat",
            |m: &CMsgClientChatInvite| { &m.steam_id_friend_chat },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_friend_chat },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CMsgClientChatInvite| { &m.chat_name },
            |m: &mut CMsgClientChatInvite| { &mut m.chat_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientChatInvite| { &m.game_id },
            |m: &mut CMsgClientChatInvite| { &mut m.game_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatInvite>(
            "CMsgClientChatInvite",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientChatInvite {
    const NAME: &'static str = "CMsgClientChatInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_patron = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.chatroom_type = ::std::option::Option::Some(is.read_int32()?);
                },
                41 => {
                    self.steam_id_friend_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                57 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_invited {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_chat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_patron {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chatroom_type {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.steam_id_friend_chat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_invited {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_chat {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_patron {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.chatroom_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.steam_id_friend_chat {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatInvite {
        CMsgClientChatInvite::new()
    }

    fn clear(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
        self.steam_id_chat = ::std::option::Option::None;
        self.steam_id_patron = ::std::option::Option::None;
        self.chatroom_type = ::std::option::Option::None;
        self.steam_id_friend_chat = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatInvite {
        static instance: CMsgClientChatInvite = CMsgClientChatInvite {
            steam_id_invited: ::std::option::Option::None,
            steam_id_chat: ::std::option::Option::None,
            steam_id_patron: ::std::option::Option::None,
            chatroom_type: ::std::option::Option::None,
            steam_id_friend_chat: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientChatInvite {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientChatInvite {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientConnectionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientConnectionStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientConnectionStats.stats_logon)
    pub stats_logon: crate::MessageField<cmsg_client_connection_stats::Stats_Logon>,
    // @@protoc_insertion_point(field:CMsgClientConnectionStats.stats_vconn)
    pub stats_vconn: crate::MessageField<cmsg_client_connection_stats::Stats_VConn>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats {
    fn default() -> &'a CMsgClientConnectionStats {
        <CMsgClientConnectionStats as crate::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats {
    pub fn new() -> CMsgClientConnectionStats {
        ::std::default::Default::default()
    }

    // optional .CMsgClientConnectionStats.Stats_Logon stats_logon = 1;

    pub fn stats_logon(&self) -> &cmsg_client_connection_stats::Stats_Logon {
        self.stats_logon.as_ref().unwrap_or_else(|| <cmsg_client_connection_stats::Stats_Logon as crate::Message>::default_instance())
    }

    pub fn clear_stats_logon(&mut self) {
        self.stats_logon.clear();
    }

    pub fn has_stats_logon(&self) -> bool {
        self.stats_logon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_logon(&mut self, v: cmsg_client_connection_stats::Stats_Logon) {
        self.stats_logon = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_logon(&mut self) -> &mut cmsg_client_connection_stats::Stats_Logon {
        self.stats_logon.mut_or_insert_default()
    }

    // Take field
    pub fn take_stats_logon(&mut self) -> cmsg_client_connection_stats::Stats_Logon {
        self.stats_logon.take().unwrap_or_else(|| cmsg_client_connection_stats::Stats_Logon::new())
    }

    // optional .CMsgClientConnectionStats.Stats_VConn stats_vconn = 2;

    pub fn stats_vconn(&self) -> &cmsg_client_connection_stats::Stats_VConn {
        self.stats_vconn.as_ref().unwrap_or_else(|| <cmsg_client_connection_stats::Stats_VConn as crate::Message>::default_instance())
    }

    pub fn clear_stats_vconn(&mut self) {
        self.stats_vconn.clear();
    }

    pub fn has_stats_vconn(&self) -> bool {
        self.stats_vconn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_vconn(&mut self, v: cmsg_client_connection_stats::Stats_VConn) {
        self.stats_vconn = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_vconn(&mut self) -> &mut cmsg_client_connection_stats::Stats_VConn {
        self.stats_vconn.mut_or_insert_default()
    }

    // Take field
    pub fn take_stats_vconn(&mut self) -> cmsg_client_connection_stats::Stats_VConn {
        self.stats_vconn.take().unwrap_or_else(|| cmsg_client_connection_stats::Stats_VConn::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_connection_stats::Stats_Logon>(
            "stats_logon",
            |m: &CMsgClientConnectionStats| { &m.stats_logon },
            |m: &mut CMsgClientConnectionStats| { &mut m.stats_logon },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_connection_stats::Stats_VConn>(
            "stats_vconn",
            |m: &CMsgClientConnectionStats| { &m.stats_vconn },
            |m: &mut CMsgClientConnectionStats| { &mut m.stats_vconn },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientConnectionStats>(
            "CMsgClientConnectionStats",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientConnectionStats {
    const NAME: &'static str = "CMsgClientConnectionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.stats_logon)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.stats_vconn)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats_logon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.stats_logon.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientConnectionStats {
        CMsgClientConnectionStats::new()
    }

    fn clear(&mut self) {
        self.stats_logon.clear();
        self.stats_vconn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientConnectionStats {
        static instance: CMsgClientConnectionStats = CMsgClientConnectionStats {
            stats_logon: crate::MessageField::none(),
            stats_vconn: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientConnectionStats {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientConnectionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientConnectionStats {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientConnectionStats`
pub mod cmsg_client_connection_stats {
    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_Logon)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_Logon {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_attempts)
        pub connect_attempts: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_successes)
        pub connect_successes: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_failures)
        pub connect_failures: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connections_dropped)
        pub connections_dropped: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.seconds_running)
        pub seconds_running: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.msec_tologonthistime)
        pub msec_tologonthistime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.count_bad_cms)
        pub count_bad_cms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_udp_connectivity)
        pub no_udp_connectivity: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_tcp_connectivity)
        pub no_tcp_connectivity: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_websocket_443_connectivity)
        pub no_websocket_443_connectivity: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_websocket_non_443_connectivity)
        pub no_websocket_non_443_connectivity: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_Logon.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_Logon {
        fn default() -> &'a Stats_Logon {
            <Stats_Logon as crate::Message>::default_instance()
        }
    }

    impl Stats_Logon {
        pub fn new() -> Stats_Logon {
            ::std::default::Default::default()
        }

        // optional int32 connect_attempts = 1;

        pub fn connect_attempts(&self) -> i32 {
            self.connect_attempts.unwrap_or(0)
        }

        pub fn clear_connect_attempts(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
        }

        pub fn has_connect_attempts(&self) -> bool {
            self.connect_attempts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_attempts(&mut self, v: i32) {
            self.connect_attempts = ::std::option::Option::Some(v);
        }

        // optional int32 connect_successes = 2;

        pub fn connect_successes(&self) -> i32 {
            self.connect_successes.unwrap_or(0)
        }

        pub fn clear_connect_successes(&mut self) {
            self.connect_successes = ::std::option::Option::None;
        }

        pub fn has_connect_successes(&self) -> bool {
            self.connect_successes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_successes(&mut self, v: i32) {
            self.connect_successes = ::std::option::Option::Some(v);
        }

        // optional int32 connect_failures = 3;

        pub fn connect_failures(&self) -> i32 {
            self.connect_failures.unwrap_or(0)
        }

        pub fn clear_connect_failures(&mut self) {
            self.connect_failures = ::std::option::Option::None;
        }

        pub fn has_connect_failures(&self) -> bool {
            self.connect_failures.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_failures(&mut self, v: i32) {
            self.connect_failures = ::std::option::Option::Some(v);
        }

        // optional int32 connections_dropped = 4;

        pub fn connections_dropped(&self) -> i32 {
            self.connections_dropped.unwrap_or(0)
        }

        pub fn clear_connections_dropped(&mut self) {
            self.connections_dropped = ::std::option::Option::None;
        }

        pub fn has_connections_dropped(&self) -> bool {
            self.connections_dropped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_dropped(&mut self, v: i32) {
            self.connections_dropped = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_running = 5;

        pub fn seconds_running(&self) -> u32 {
            self.seconds_running.unwrap_or(0)
        }

        pub fn clear_seconds_running(&mut self) {
            self.seconds_running = ::std::option::Option::None;
        }

        pub fn has_seconds_running(&self) -> bool {
            self.seconds_running.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_running(&mut self, v: u32) {
            self.seconds_running = ::std::option::Option::Some(v);
        }

        // optional uint32 msec_tologonthistime = 6;

        pub fn msec_tologonthistime(&self) -> u32 {
            self.msec_tologonthistime.unwrap_or(0)
        }

        pub fn clear_msec_tologonthistime(&mut self) {
            self.msec_tologonthistime = ::std::option::Option::None;
        }

        pub fn has_msec_tologonthistime(&self) -> bool {
            self.msec_tologonthistime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msec_tologonthistime(&mut self, v: u32) {
            self.msec_tologonthistime = ::std::option::Option::Some(v);
        }

        // optional uint32 count_bad_cms = 7;

        pub fn count_bad_cms(&self) -> u32 {
            self.count_bad_cms.unwrap_or(0)
        }

        pub fn clear_count_bad_cms(&mut self) {
            self.count_bad_cms = ::std::option::Option::None;
        }

        pub fn has_count_bad_cms(&self) -> bool {
            self.count_bad_cms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count_bad_cms(&mut self, v: u32) {
            self.count_bad_cms = ::std::option::Option::Some(v);
        }

        // optional bool no_udp_connectivity = 8;

        pub fn no_udp_connectivity(&self) -> bool {
            self.no_udp_connectivity.unwrap_or(false)
        }

        pub fn clear_no_udp_connectivity(&mut self) {
            self.no_udp_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_udp_connectivity(&self) -> bool {
            self.no_udp_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_udp_connectivity(&mut self, v: bool) {
            self.no_udp_connectivity = ::std::option::Option::Some(v);
        }

        // optional bool no_tcp_connectivity = 9;

        pub fn no_tcp_connectivity(&self) -> bool {
            self.no_tcp_connectivity.unwrap_or(false)
        }

        pub fn clear_no_tcp_connectivity(&mut self) {
            self.no_tcp_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_tcp_connectivity(&self) -> bool {
            self.no_tcp_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_tcp_connectivity(&mut self, v: bool) {
            self.no_tcp_connectivity = ::std::option::Option::Some(v);
        }

        // optional bool no_websocket_443_connectivity = 10;

        pub fn no_websocket_443_connectivity(&self) -> bool {
            self.no_websocket_443_connectivity.unwrap_or(false)
        }

        pub fn clear_no_websocket_443_connectivity(&mut self) {
            self.no_websocket_443_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_websocket_443_connectivity(&self) -> bool {
            self.no_websocket_443_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_websocket_443_connectivity(&mut self, v: bool) {
            self.no_websocket_443_connectivity = ::std::option::Option::Some(v);
        }

        // optional bool no_websocket_non_443_connectivity = 11;

        pub fn no_websocket_non_443_connectivity(&self) -> bool {
            self.no_websocket_non_443_connectivity.unwrap_or(false)
        }

        pub fn clear_no_websocket_non_443_connectivity(&mut self) {
            self.no_websocket_non_443_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_websocket_non_443_connectivity(&self) -> bool {
            self.no_websocket_non_443_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_websocket_non_443_connectivity(&mut self, v: bool) {
            self.no_websocket_non_443_connectivity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_attempts",
                |m: &Stats_Logon| { &m.connect_attempts },
                |m: &mut Stats_Logon| { &mut m.connect_attempts },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_successes",
                |m: &Stats_Logon| { &m.connect_successes },
                |m: &mut Stats_Logon| { &mut m.connect_successes },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_failures",
                |m: &Stats_Logon| { &m.connect_failures },
                |m: &mut Stats_Logon| { &mut m.connect_failures },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "connections_dropped",
                |m: &Stats_Logon| { &m.connections_dropped },
                |m: &mut Stats_Logon| { &mut m.connections_dropped },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "seconds_running",
                |m: &Stats_Logon| { &m.seconds_running },
                |m: &mut Stats_Logon| { &mut m.seconds_running },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "msec_tologonthistime",
                |m: &Stats_Logon| { &m.msec_tologonthistime },
                |m: &mut Stats_Logon| { &mut m.msec_tologonthistime },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count_bad_cms",
                |m: &Stats_Logon| { &m.count_bad_cms },
                |m: &mut Stats_Logon| { &mut m.count_bad_cms },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "no_udp_connectivity",
                |m: &Stats_Logon| { &m.no_udp_connectivity },
                |m: &mut Stats_Logon| { &mut m.no_udp_connectivity },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "no_tcp_connectivity",
                |m: &Stats_Logon| { &m.no_tcp_connectivity },
                |m: &mut Stats_Logon| { &mut m.no_tcp_connectivity },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "no_websocket_443_connectivity",
                |m: &Stats_Logon| { &m.no_websocket_443_connectivity },
                |m: &mut Stats_Logon| { &mut m.no_websocket_443_connectivity },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "no_websocket_non_443_connectivity",
                |m: &Stats_Logon| { &m.no_websocket_non_443_connectivity },
                |m: &mut Stats_Logon| { &mut m.no_websocket_non_443_connectivity },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Stats_Logon>(
                "CMsgClientConnectionStats.Stats_Logon",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Stats_Logon {
        const NAME: &'static str = "Stats_Logon";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.connect_attempts = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.connect_successes = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.connect_failures = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.connections_dropped = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.seconds_running = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.msec_tologonthistime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.count_bad_cms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.no_udp_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.no_tcp_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.no_websocket_443_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.no_websocket_non_443_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connect_attempts {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.connect_successes {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.connect_failures {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.connections_dropped {
                my_size += crate::rt::int32_size(4, v);
            }
            if let Some(v) = self.seconds_running {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.msec_tologonthistime {
                my_size += crate::rt::uint32_size(6, v);
            }
            if let Some(v) = self.count_bad_cms {
                my_size += crate::rt::uint32_size(7, v);
            }
            if let Some(v) = self.no_udp_connectivity {
                my_size += 1 + 1;
            }
            if let Some(v) = self.no_tcp_connectivity {
                my_size += 1 + 1;
            }
            if let Some(v) = self.no_websocket_443_connectivity {
                my_size += 1 + 1;
            }
            if let Some(v) = self.no_websocket_non_443_connectivity {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.connect_attempts {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.connect_successes {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.connect_failures {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.connections_dropped {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.seconds_running {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.msec_tologonthistime {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.count_bad_cms {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.no_udp_connectivity {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.no_tcp_connectivity {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.no_websocket_443_connectivity {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.no_websocket_non_443_connectivity {
                os.write_bool(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_Logon {
            Stats_Logon::new()
        }

        fn clear(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
            self.connect_successes = ::std::option::Option::None;
            self.connect_failures = ::std::option::Option::None;
            self.connections_dropped = ::std::option::Option::None;
            self.seconds_running = ::std::option::Option::None;
            self.msec_tologonthistime = ::std::option::Option::None;
            self.count_bad_cms = ::std::option::Option::None;
            self.no_udp_connectivity = ::std::option::Option::None;
            self.no_tcp_connectivity = ::std::option::Option::None;
            self.no_websocket_443_connectivity = ::std::option::Option::None;
            self.no_websocket_non_443_connectivity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_Logon {
            static instance: Stats_Logon = Stats_Logon {
                connect_attempts: ::std::option::Option::None,
                connect_successes: ::std::option::Option::None,
                connect_failures: ::std::option::Option::None,
                connections_dropped: ::std::option::Option::None,
                seconds_running: ::std::option::Option::None,
                msec_tologonthistime: ::std::option::Option::None,
                count_bad_cms: ::std::option::Option::None,
                no_udp_connectivity: ::std::option::Option::None,
                no_tcp_connectivity: ::std::option::Option::None,
                no_websocket_443_connectivity: ::std::option::Option::None,
                no_websocket_non_443_connectivity: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Stats_Logon {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats.Stats_Logon").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_Logon {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Stats_Logon {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_UDP)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_UDP {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_sent)
        pub pkts_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.bytes_sent)
        pub bytes_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_recv)
        pub pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_processed)
        pub pkts_processed: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.bytes_recv)
        pub bytes_recv: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_UDP.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_UDP {
        fn default() -> &'a Stats_UDP {
            <Stats_UDP as crate::Message>::default_instance()
        }
    }

    impl Stats_UDP {
        pub fn new() -> Stats_UDP {
            ::std::default::Default::default()
        }

        // optional uint64 pkts_sent = 1;

        pub fn pkts_sent(&self) -> u64 {
            self.pkts_sent.unwrap_or(0)
        }

        pub fn clear_pkts_sent(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
        }

        pub fn has_pkts_sent(&self) -> bool {
            self.pkts_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_sent(&mut self, v: u64) {
            self.pkts_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_sent = 2;

        pub fn bytes_sent(&self) -> u64 {
            self.bytes_sent.unwrap_or(0)
        }

        pub fn clear_bytes_sent(&mut self) {
            self.bytes_sent = ::std::option::Option::None;
        }

        pub fn has_bytes_sent(&self) -> bool {
            self.bytes_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_sent(&mut self, v: u64) {
            self.bytes_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_recv = 3;

        pub fn pkts_recv(&self) -> u64 {
            self.pkts_recv.unwrap_or(0)
        }

        pub fn clear_pkts_recv(&mut self) {
            self.pkts_recv = ::std::option::Option::None;
        }

        pub fn has_pkts_recv(&self) -> bool {
            self.pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_recv(&mut self, v: u64) {
            self.pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_processed = 4;

        pub fn pkts_processed(&self) -> u64 {
            self.pkts_processed.unwrap_or(0)
        }

        pub fn clear_pkts_processed(&mut self) {
            self.pkts_processed = ::std::option::Option::None;
        }

        pub fn has_pkts_processed(&self) -> bool {
            self.pkts_processed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_processed(&mut self, v: u64) {
            self.pkts_processed = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_recv = 5;

        pub fn bytes_recv(&self) -> u64 {
            self.bytes_recv.unwrap_or(0)
        }

        pub fn clear_bytes_recv(&mut self) {
            self.bytes_recv = ::std::option::Option::None;
        }

        pub fn has_bytes_recv(&self) -> bool {
            self.bytes_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_recv(&mut self, v: u64) {
            self.bytes_recv = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_sent",
                |m: &Stats_UDP| { &m.pkts_sent },
                |m: &mut Stats_UDP| { &mut m.pkts_sent },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_sent",
                |m: &Stats_UDP| { &m.bytes_sent },
                |m: &mut Stats_UDP| { &mut m.bytes_sent },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_recv",
                |m: &Stats_UDP| { &m.pkts_recv },
                |m: &mut Stats_UDP| { &mut m.pkts_recv },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_processed",
                |m: &Stats_UDP| { &m.pkts_processed },
                |m: &mut Stats_UDP| { &mut m.pkts_processed },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_recv",
                |m: &Stats_UDP| { &m.bytes_recv },
                |m: &mut Stats_UDP| { &mut m.bytes_recv },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Stats_UDP>(
                "CMsgClientConnectionStats.Stats_UDP",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Stats_UDP {
        const NAME: &'static str = "Stats_UDP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.pkts_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.bytes_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.pkts_processed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.bytes_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pkts_sent {
                my_size += crate::rt::uint64_size(1, v);
            }
            if let Some(v) = self.bytes_sent {
                my_size += crate::rt::uint64_size(2, v);
            }
            if let Some(v) = self.pkts_recv {
                my_size += crate::rt::uint64_size(3, v);
            }
            if let Some(v) = self.pkts_processed {
                my_size += crate::rt::uint64_size(4, v);
            }
            if let Some(v) = self.bytes_recv {
                my_size += crate::rt::uint64_size(5, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.pkts_sent {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.bytes_sent {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.pkts_recv {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.pkts_processed {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.bytes_recv {
                os.write_uint64(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_UDP {
            Stats_UDP::new()
        }

        fn clear(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
            self.bytes_sent = ::std::option::Option::None;
            self.pkts_recv = ::std::option::Option::None;
            self.pkts_processed = ::std::option::Option::None;
            self.bytes_recv = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_UDP {
            static instance: Stats_UDP = Stats_UDP {
                pkts_sent: ::std::option::Option::None,
                bytes_sent: ::std::option::Option::None,
                pkts_recv: ::std::option::Option::None,
                pkts_processed: ::std::option::Option::None,
                bytes_recv: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Stats_UDP {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats.Stats_UDP").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_UDP {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Stats_UDP {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_VConn)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_VConn {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.connections_udp)
        pub connections_udp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.connections_tcp)
        pub connections_tcp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.stats_udp)
        pub stats_udp: crate::MessageField<Stats_UDP>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.pkts_abandoned)
        pub pkts_abandoned: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.conn_req_received)
        pub conn_req_received: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.pkts_resent)
        pub pkts_resent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_sent)
        pub msgs_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_sent_failed)
        pub msgs_sent_failed: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_recv)
        pub msgs_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.datagrams_sent)
        pub datagrams_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.datagrams_recv)
        pub datagrams_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.bad_pkts_recv)
        pub bad_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.unknown_conn_pkts_recv)
        pub unknown_conn_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.missed_pkts_recv)
        pub missed_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.dup_pkts_recv)
        pub dup_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.failed_connect_challenges)
        pub failed_connect_challenges: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_avg_latency)
        pub micro_sec_avg_latency: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_min_latency)
        pub micro_sec_min_latency: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_max_latency)
        pub micro_sec_max_latency: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_VConn.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_VConn {
        fn default() -> &'a Stats_VConn {
            <Stats_VConn as crate::Message>::default_instance()
        }
    }

    impl Stats_VConn {
        pub fn new() -> Stats_VConn {
            ::std::default::Default::default()
        }

        // optional uint32 connections_udp = 1;

        pub fn connections_udp(&self) -> u32 {
            self.connections_udp.unwrap_or(0)
        }

        pub fn clear_connections_udp(&mut self) {
            self.connections_udp = ::std::option::Option::None;
        }

        pub fn has_connections_udp(&self) -> bool {
            self.connections_udp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_udp(&mut self, v: u32) {
            self.connections_udp = ::std::option::Option::Some(v);
        }

        // optional uint32 connections_tcp = 2;

        pub fn connections_tcp(&self) -> u32 {
            self.connections_tcp.unwrap_or(0)
        }

        pub fn clear_connections_tcp(&mut self) {
            self.connections_tcp = ::std::option::Option::None;
        }

        pub fn has_connections_tcp(&self) -> bool {
            self.connections_tcp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_tcp(&mut self, v: u32) {
            self.connections_tcp = ::std::option::Option::Some(v);
        }

        // optional .CMsgClientConnectionStats.Stats_UDP stats_udp = 3;

        pub fn stats_udp(&self) -> &Stats_UDP {
            self.stats_udp.as_ref().unwrap_or_else(|| <Stats_UDP as crate::Message>::default_instance())
        }

        pub fn clear_stats_udp(&mut self) {
            self.stats_udp.clear();
        }

        pub fn has_stats_udp(&self) -> bool {
            self.stats_udp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stats_udp(&mut self, v: Stats_UDP) {
            self.stats_udp = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_stats_udp(&mut self) -> &mut Stats_UDP {
            self.stats_udp.mut_or_insert_default()
        }

        // Take field
        pub fn take_stats_udp(&mut self) -> Stats_UDP {
            self.stats_udp.take().unwrap_or_else(|| Stats_UDP::new())
        }

        // optional uint64 pkts_abandoned = 4;

        pub fn pkts_abandoned(&self) -> u64 {
            self.pkts_abandoned.unwrap_or(0)
        }

        pub fn clear_pkts_abandoned(&mut self) {
            self.pkts_abandoned = ::std::option::Option::None;
        }

        pub fn has_pkts_abandoned(&self) -> bool {
            self.pkts_abandoned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_abandoned(&mut self, v: u64) {
            self.pkts_abandoned = ::std::option::Option::Some(v);
        }

        // optional uint64 conn_req_received = 5;

        pub fn conn_req_received(&self) -> u64 {
            self.conn_req_received.unwrap_or(0)
        }

        pub fn clear_conn_req_received(&mut self) {
            self.conn_req_received = ::std::option::Option::None;
        }

        pub fn has_conn_req_received(&self) -> bool {
            self.conn_req_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_conn_req_received(&mut self, v: u64) {
            self.conn_req_received = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_resent = 6;

        pub fn pkts_resent(&self) -> u64 {
            self.pkts_resent.unwrap_or(0)
        }

        pub fn clear_pkts_resent(&mut self) {
            self.pkts_resent = ::std::option::Option::None;
        }

        pub fn has_pkts_resent(&self) -> bool {
            self.pkts_resent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_resent(&mut self, v: u64) {
            self.pkts_resent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent = 7;

        pub fn msgs_sent(&self) -> u64 {
            self.msgs_sent.unwrap_or(0)
        }

        pub fn clear_msgs_sent(&mut self) {
            self.msgs_sent = ::std::option::Option::None;
        }

        pub fn has_msgs_sent(&self) -> bool {
            self.msgs_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent(&mut self, v: u64) {
            self.msgs_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent_failed = 8;

        pub fn msgs_sent_failed(&self) -> u64 {
            self.msgs_sent_failed.unwrap_or(0)
        }

        pub fn clear_msgs_sent_failed(&mut self) {
            self.msgs_sent_failed = ::std::option::Option::None;
        }

        pub fn has_msgs_sent_failed(&self) -> bool {
            self.msgs_sent_failed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent_failed(&mut self, v: u64) {
            self.msgs_sent_failed = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_recv = 9;

        pub fn msgs_recv(&self) -> u64 {
            self.msgs_recv.unwrap_or(0)
        }

        pub fn clear_msgs_recv(&mut self) {
            self.msgs_recv = ::std::option::Option::None;
        }

        pub fn has_msgs_recv(&self) -> bool {
            self.msgs_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_recv(&mut self, v: u64) {
            self.msgs_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_sent = 10;

        pub fn datagrams_sent(&self) -> u64 {
            self.datagrams_sent.unwrap_or(0)
        }

        pub fn clear_datagrams_sent(&mut self) {
            self.datagrams_sent = ::std::option::Option::None;
        }

        pub fn has_datagrams_sent(&self) -> bool {
            self.datagrams_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_sent(&mut self, v: u64) {
            self.datagrams_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_recv = 11;

        pub fn datagrams_recv(&self) -> u64 {
            self.datagrams_recv.unwrap_or(0)
        }

        pub fn clear_datagrams_recv(&mut self) {
            self.datagrams_recv = ::std::option::Option::None;
        }

        pub fn has_datagrams_recv(&self) -> bool {
            self.datagrams_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_recv(&mut self, v: u64) {
            self.datagrams_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 bad_pkts_recv = 12;

        pub fn bad_pkts_recv(&self) -> u64 {
            self.bad_pkts_recv.unwrap_or(0)
        }

        pub fn clear_bad_pkts_recv(&mut self) {
            self.bad_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_bad_pkts_recv(&self) -> bool {
            self.bad_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bad_pkts_recv(&mut self, v: u64) {
            self.bad_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 unknown_conn_pkts_recv = 13;

        pub fn unknown_conn_pkts_recv(&self) -> u64 {
            self.unknown_conn_pkts_recv.unwrap_or(0)
        }

        pub fn clear_unknown_conn_pkts_recv(&mut self) {
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_unknown_conn_pkts_recv(&self) -> bool {
            self.unknown_conn_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unknown_conn_pkts_recv(&mut self, v: u64) {
            self.unknown_conn_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 missed_pkts_recv = 14;

        pub fn missed_pkts_recv(&self) -> u64 {
            self.missed_pkts_recv.unwrap_or(0)
        }

        pub fn clear_missed_pkts_recv(&mut self) {
            self.missed_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_missed_pkts_recv(&self) -> bool {
            self.missed_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missed_pkts_recv(&mut self, v: u64) {
            self.missed_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 dup_pkts_recv = 15;

        pub fn dup_pkts_recv(&self) -> u64 {
            self.dup_pkts_recv.unwrap_or(0)
        }

        pub fn clear_dup_pkts_recv(&mut self) {
            self.dup_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_dup_pkts_recv(&self) -> bool {
            self.dup_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dup_pkts_recv(&mut self, v: u64) {
            self.dup_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 failed_connect_challenges = 16;

        pub fn failed_connect_challenges(&self) -> u64 {
            self.failed_connect_challenges.unwrap_or(0)
        }

        pub fn clear_failed_connect_challenges(&mut self) {
            self.failed_connect_challenges = ::std::option::Option::None;
        }

        pub fn has_failed_connect_challenges(&self) -> bool {
            self.failed_connect_challenges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_failed_connect_challenges(&mut self, v: u64) {
            self.failed_connect_challenges = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_avg_latency = 17;

        pub fn micro_sec_avg_latency(&self) -> u32 {
            self.micro_sec_avg_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_avg_latency(&mut self) {
            self.micro_sec_avg_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_avg_latency(&self) -> bool {
            self.micro_sec_avg_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_avg_latency(&mut self, v: u32) {
            self.micro_sec_avg_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_min_latency = 18;

        pub fn micro_sec_min_latency(&self) -> u32 {
            self.micro_sec_min_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_min_latency(&mut self) {
            self.micro_sec_min_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_min_latency(&self) -> bool {
            self.micro_sec_min_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_min_latency(&mut self, v: u32) {
            self.micro_sec_min_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_max_latency = 19;

        pub fn micro_sec_max_latency(&self) -> u32 {
            self.micro_sec_max_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_max_latency(&mut self) {
            self.micro_sec_max_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_max_latency(&self) -> bool {
            self.micro_sec_max_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_max_latency(&mut self, v: u32) {
            self.micro_sec_max_latency = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(19);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "connections_udp",
                |m: &Stats_VConn| { &m.connections_udp },
                |m: &mut Stats_VConn| { &mut m.connections_udp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "connections_tcp",
                |m: &Stats_VConn| { &m.connections_tcp },
                |m: &mut Stats_VConn| { &mut m.connections_tcp },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, Stats_UDP>(
                "stats_udp",
                |m: &Stats_VConn| { &m.stats_udp },
                |m: &mut Stats_VConn| { &mut m.stats_udp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_abandoned",
                |m: &Stats_VConn| { &m.pkts_abandoned },
                |m: &mut Stats_VConn| { &mut m.pkts_abandoned },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "conn_req_received",
                |m: &Stats_VConn| { &m.conn_req_received },
                |m: &mut Stats_VConn| { &mut m.conn_req_received },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_resent",
                |m: &Stats_VConn| { &m.pkts_resent },
                |m: &mut Stats_VConn| { &mut m.pkts_resent },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "msgs_sent",
                |m: &Stats_VConn| { &m.msgs_sent },
                |m: &mut Stats_VConn| { &mut m.msgs_sent },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "msgs_sent_failed",
                |m: &Stats_VConn| { &m.msgs_sent_failed },
                |m: &mut Stats_VConn| { &mut m.msgs_sent_failed },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "msgs_recv",
                |m: &Stats_VConn| { &m.msgs_recv },
                |m: &mut Stats_VConn| { &mut m.msgs_recv },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "datagrams_sent",
                |m: &Stats_VConn| { &m.datagrams_sent },
                |m: &mut Stats_VConn| { &mut m.datagrams_sent },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "datagrams_recv",
                |m: &Stats_VConn| { &m.datagrams_recv },
                |m: &mut Stats_VConn| { &mut m.datagrams_recv },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bad_pkts_recv",
                |m: &Stats_VConn| { &m.bad_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.bad_pkts_recv },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "unknown_conn_pkts_recv",
                |m: &Stats_VConn| { &m.unknown_conn_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.unknown_conn_pkts_recv },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "missed_pkts_recv",
                |m: &Stats_VConn| { &m.missed_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.missed_pkts_recv },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "dup_pkts_recv",
                |m: &Stats_VConn| { &m.dup_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.dup_pkts_recv },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "failed_connect_challenges",
                |m: &Stats_VConn| { &m.failed_connect_challenges },
                |m: &mut Stats_VConn| { &mut m.failed_connect_challenges },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "micro_sec_avg_latency",
                |m: &Stats_VConn| { &m.micro_sec_avg_latency },
                |m: &mut Stats_VConn| { &mut m.micro_sec_avg_latency },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "micro_sec_min_latency",
                |m: &Stats_VConn| { &m.micro_sec_min_latency },
                |m: &mut Stats_VConn| { &mut m.micro_sec_min_latency },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "micro_sec_max_latency",
                |m: &Stats_VConn| { &m.micro_sec_max_latency },
                |m: &mut Stats_VConn| { &mut m.micro_sec_max_latency },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Stats_VConn>(
                "CMsgClientConnectionStats.Stats_VConn",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Stats_VConn {
        const NAME: &'static str = "Stats_VConn";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.connections_udp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.connections_tcp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.stats_udp)?;
                    },
                    32 => {
                        self.pkts_abandoned = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.conn_req_received = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.pkts_resent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.msgs_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.msgs_sent_failed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.msgs_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    80 => {
                        self.datagrams_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    88 => {
                        self.datagrams_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    96 => {
                        self.bad_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    104 => {
                        self.unknown_conn_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    112 => {
                        self.missed_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    120 => {
                        self.dup_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    128 => {
                        self.failed_connect_challenges = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    136 => {
                        self.micro_sec_avg_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.micro_sec_min_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.micro_sec_max_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connections_udp {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.connections_tcp {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.stats_udp.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.pkts_abandoned {
                my_size += crate::rt::uint64_size(4, v);
            }
            if let Some(v) = self.conn_req_received {
                my_size += crate::rt::uint64_size(5, v);
            }
            if let Some(v) = self.pkts_resent {
                my_size += crate::rt::uint64_size(6, v);
            }
            if let Some(v) = self.msgs_sent {
                my_size += crate::rt::uint64_size(7, v);
            }
            if let Some(v) = self.msgs_sent_failed {
                my_size += crate::rt::uint64_size(8, v);
            }
            if let Some(v) = self.msgs_recv {
                my_size += crate::rt::uint64_size(9, v);
            }
            if let Some(v) = self.datagrams_sent {
                my_size += crate::rt::uint64_size(10, v);
            }
            if let Some(v) = self.datagrams_recv {
                my_size += crate::rt::uint64_size(11, v);
            }
            if let Some(v) = self.bad_pkts_recv {
                my_size += crate::rt::uint64_size(12, v);
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                my_size += crate::rt::uint64_size(13, v);
            }
            if let Some(v) = self.missed_pkts_recv {
                my_size += crate::rt::uint64_size(14, v);
            }
            if let Some(v) = self.dup_pkts_recv {
                my_size += crate::rt::uint64_size(15, v);
            }
            if let Some(v) = self.failed_connect_challenges {
                my_size += crate::rt::uint64_size(16, v);
            }
            if let Some(v) = self.micro_sec_avg_latency {
                my_size += crate::rt::uint32_size(17, v);
            }
            if let Some(v) = self.micro_sec_min_latency {
                my_size += crate::rt::uint32_size(18, v);
            }
            if let Some(v) = self.micro_sec_max_latency {
                my_size += crate::rt::uint32_size(19, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.connections_udp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.connections_tcp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.stats_udp.as_ref() {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.pkts_abandoned {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.conn_req_received {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.pkts_resent {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.msgs_sent {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.msgs_sent_failed {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.msgs_recv {
                os.write_uint64(9, v)?;
            }
            if let Some(v) = self.datagrams_sent {
                os.write_uint64(10, v)?;
            }
            if let Some(v) = self.datagrams_recv {
                os.write_uint64(11, v)?;
            }
            if let Some(v) = self.bad_pkts_recv {
                os.write_uint64(12, v)?;
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                os.write_uint64(13, v)?;
            }
            if let Some(v) = self.missed_pkts_recv {
                os.write_uint64(14, v)?;
            }
            if let Some(v) = self.dup_pkts_recv {
                os.write_uint64(15, v)?;
            }
            if let Some(v) = self.failed_connect_challenges {
                os.write_uint64(16, v)?;
            }
            if let Some(v) = self.micro_sec_avg_latency {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.micro_sec_min_latency {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.micro_sec_max_latency {
                os.write_uint32(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_VConn {
            Stats_VConn::new()
        }

        fn clear(&mut self) {
            self.connections_udp = ::std::option::Option::None;
            self.connections_tcp = ::std::option::Option::None;
            self.stats_udp.clear();
            self.pkts_abandoned = ::std::option::Option::None;
            self.conn_req_received = ::std::option::Option::None;
            self.pkts_resent = ::std::option::Option::None;
            self.msgs_sent = ::std::option::Option::None;
            self.msgs_sent_failed = ::std::option::Option::None;
            self.msgs_recv = ::std::option::Option::None;
            self.datagrams_sent = ::std::option::Option::None;
            self.datagrams_recv = ::std::option::Option::None;
            self.bad_pkts_recv = ::std::option::Option::None;
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
            self.missed_pkts_recv = ::std::option::Option::None;
            self.dup_pkts_recv = ::std::option::Option::None;
            self.failed_connect_challenges = ::std::option::Option::None;
            self.micro_sec_avg_latency = ::std::option::Option::None;
            self.micro_sec_min_latency = ::std::option::Option::None;
            self.micro_sec_max_latency = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_VConn {
            static instance: Stats_VConn = Stats_VConn {
                connections_udp: ::std::option::Option::None,
                connections_tcp: ::std::option::Option::None,
                stats_udp: crate::MessageField::none(),
                pkts_abandoned: ::std::option::Option::None,
                conn_req_received: ::std::option::Option::None,
                pkts_resent: ::std::option::Option::None,
                msgs_sent: ::std::option::Option::None,
                msgs_sent_failed: ::std::option::Option::None,
                msgs_recv: ::std::option::Option::None,
                datagrams_sent: ::std::option::Option::None,
                datagrams_recv: ::std::option::Option::None,
                bad_pkts_recv: ::std::option::Option::None,
                unknown_conn_pkts_recv: ::std::option::Option::None,
                missed_pkts_recv: ::std::option::Option::None,
                dup_pkts_recv: ::std::option::Option::None,
                failed_connect_challenges: ::std::option::Option::None,
                micro_sec_avg_latency: ::std::option::Option::None,
                micro_sec_min_latency: ::std::option::Option::None,
                micro_sec_max_latency: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Stats_VConn {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats.Stats_VConn").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_VConn {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Stats_VConn {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientServersAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServersAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServersAvailable.server_types_available)
    pub server_types_available: ::std::vec::Vec<cmsg_client_servers_available::Server_Types_Available>,
    // @@protoc_insertion_point(field:CMsgClientServersAvailable.server_type_for_auth_services)
    pub server_type_for_auth_services: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServersAvailable.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServersAvailable {
    fn default() -> &'a CMsgClientServersAvailable {
        <CMsgClientServersAvailable as crate::Message>::default_instance()
    }
}

impl CMsgClientServersAvailable {
    pub fn new() -> CMsgClientServersAvailable {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientServersAvailable.Server_Types_Available server_types_available = 1;

    pub fn server_types_available(&self) -> &[cmsg_client_servers_available::Server_Types_Available] {
        &self.server_types_available
    }

    pub fn clear_server_types_available(&mut self) {
        self.server_types_available.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_types_available(&mut self, v: ::std::vec::Vec<cmsg_client_servers_available::Server_Types_Available>) {
        self.server_types_available = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_types_available(&mut self) -> &mut ::std::vec::Vec<cmsg_client_servers_available::Server_Types_Available> {
        &mut self.server_types_available
    }

    // Take field
    pub fn take_server_types_available(&mut self) -> ::std::vec::Vec<cmsg_client_servers_available::Server_Types_Available> {
        ::std::mem::replace(&mut self.server_types_available, ::std::vec::Vec::new())
    }

    // optional uint32 server_type_for_auth_services = 2;

    pub fn server_type_for_auth_services(&self) -> u32 {
        self.server_type_for_auth_services.unwrap_or(0)
    }

    pub fn clear_server_type_for_auth_services(&mut self) {
        self.server_type_for_auth_services = ::std::option::Option::None;
    }

    pub fn has_server_type_for_auth_services(&self) -> bool {
        self.server_type_for_auth_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type_for_auth_services(&mut self, v: u32) {
        self.server_type_for_auth_services = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "server_types_available",
            |m: &CMsgClientServersAvailable| { &m.server_types_available },
            |m: &mut CMsgClientServersAvailable| { &mut m.server_types_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_type_for_auth_services",
            |m: &CMsgClientServersAvailable| { &m.server_type_for_auth_services },
            |m: &mut CMsgClientServersAvailable| { &mut m.server_type_for_auth_services },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServersAvailable>(
            "CMsgClientServersAvailable",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientServersAvailable {
    const NAME: &'static str = "CMsgClientServersAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_types_available.push(is.read_message()?);
                },
                16 => {
                    self.server_type_for_auth_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.server_types_available {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_type_for_auth_services {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.server_types_available {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.server_type_for_auth_services {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServersAvailable {
        CMsgClientServersAvailable::new()
    }

    fn clear(&mut self) {
        self.server_types_available.clear();
        self.server_type_for_auth_services = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServersAvailable {
        static instance: CMsgClientServersAvailable = CMsgClientServersAvailable {
            server_types_available: ::std::vec::Vec::new(),
            server_type_for_auth_services: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientServersAvailable {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServersAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServersAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientServersAvailable {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientServersAvailable`
pub mod cmsg_client_servers_available {
    // @@protoc_insertion_point(message:CMsgClientServersAvailable.Server_Types_Available)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Server_Types_Available {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientServersAvailable.Server_Types_Available.server)
        pub server: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientServersAvailable.Server_Types_Available.changed)
        pub changed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientServersAvailable.Server_Types_Available.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server_Types_Available {
        fn default() -> &'a Server_Types_Available {
            <Server_Types_Available as crate::Message>::default_instance()
        }
    }

    impl Server_Types_Available {
        pub fn new() -> Server_Types_Available {
            ::std::default::Default::default()
        }

        // optional uint32 server = 1;

        pub fn server(&self) -> u32 {
            self.server.unwrap_or(0)
        }

        pub fn clear_server(&mut self) {
            self.server = ::std::option::Option::None;
        }

        pub fn has_server(&self) -> bool {
            self.server.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server(&mut self, v: u32) {
            self.server = ::std::option::Option::Some(v);
        }

        // optional bool changed = 2;

        pub fn changed(&self) -> bool {
            self.changed.unwrap_or(false)
        }

        pub fn clear_changed(&mut self) {
            self.changed = ::std::option::Option::None;
        }

        pub fn has_changed(&self) -> bool {
            self.changed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changed(&mut self, v: bool) {
            self.changed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "server",
                |m: &Server_Types_Available| { &m.server },
                |m: &mut Server_Types_Available| { &mut m.server },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "changed",
                |m: &Server_Types_Available| { &m.changed },
                |m: &mut Server_Types_Available| { &mut m.changed },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Server_Types_Available>(
                "CMsgClientServersAvailable.Server_Types_Available",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Server_Types_Available {
        const NAME: &'static str = "Server_Types_Available";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.changed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.changed {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.server {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.changed {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server_Types_Available {
            Server_Types_Available::new()
        }

        fn clear(&mut self) {
            self.server = ::std::option::Option::None;
            self.changed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server_Types_Available {
            static instance: Server_Types_Available = Server_Types_Available {
                server: ::std::option::Option::None,
                changed: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Server_Types_Available {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientServersAvailable.Server_Types_Available").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Server_Types_Available {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Server_Types_Available {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientReportOverlayDetourFailure)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReportOverlayDetourFailure {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReportOverlayDetourFailure.failure_strings)
    pub failure_strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReportOverlayDetourFailure.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReportOverlayDetourFailure {
    fn default() -> &'a CMsgClientReportOverlayDetourFailure {
        <CMsgClientReportOverlayDetourFailure as crate::Message>::default_instance()
    }
}

impl CMsgClientReportOverlayDetourFailure {
    pub fn new() -> CMsgClientReportOverlayDetourFailure {
        ::std::default::Default::default()
    }

    // repeated string failure_strings = 1;

    pub fn failure_strings(&self) -> &[::std::string::String] {
        &self.failure_strings
    }

    pub fn clear_failure_strings(&mut self) {
        self.failure_strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_failure_strings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.failure_strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failure_strings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.failure_strings
    }

    // Take field
    pub fn take_failure_strings(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.failure_strings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failure_strings",
            |m: &CMsgClientReportOverlayDetourFailure| { &m.failure_strings },
            |m: &mut CMsgClientReportOverlayDetourFailure| { &mut m.failure_strings },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientReportOverlayDetourFailure>(
            "CMsgClientReportOverlayDetourFailure",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientReportOverlayDetourFailure {
    const NAME: &'static str = "CMsgClientReportOverlayDetourFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.failure_strings.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.failure_strings {
            my_size += crate::rt::string_size(1, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.failure_strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReportOverlayDetourFailure {
        CMsgClientReportOverlayDetourFailure::new()
    }

    fn clear(&mut self) {
        self.failure_strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReportOverlayDetourFailure {
        static instance: CMsgClientReportOverlayDetourFailure = CMsgClientReportOverlayDetourFailure {
            failure_strings: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientReportOverlayDetourFailure {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientReportOverlayDetourFailure").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientReportOverlayDetourFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientReportOverlayDetourFailure {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestEncryptedAppTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestEncryptedAppTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicket.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicket.userdata)
    pub userdata: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestEncryptedAppTicket.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicket {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicket {
        <CMsgClientRequestEncryptedAppTicket as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicket {
    pub fn new() -> CMsgClientRequestEncryptedAppTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes userdata = 2;

    pub fn userdata(&self) -> &[u8] {
        match self.userdata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_userdata(&mut self) {
        self.userdata = ::std::option::Option::None;
    }

    pub fn has_userdata(&self) -> bool {
        self.userdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userdata(&mut self, v: ::bytes::Bytes) {
        self.userdata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userdata(&mut self) -> &mut ::bytes::Bytes {
        if self.userdata.is_none() {
            self.userdata = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.userdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_userdata(&mut self) -> ::bytes::Bytes {
        self.userdata.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientRequestEncryptedAppTicket| { &m.app_id },
            |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "userdata",
            |m: &CMsgClientRequestEncryptedAppTicket| { &m.userdata },
            |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.userdata },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestEncryptedAppTicket>(
            "CMsgClientRequestEncryptedAppTicket",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestEncryptedAppTicket {
    const NAME: &'static str = "CMsgClientRequestEncryptedAppTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.userdata = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.userdata.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.userdata.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestEncryptedAppTicket {
        CMsgClientRequestEncryptedAppTicket::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.userdata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicket {
        static instance: CMsgClientRequestEncryptedAppTicket = CMsgClientRequestEncryptedAppTicket {
            app_id: ::std::option::Option::None,
            userdata: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestEncryptedAppTicket {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestEncryptedAppTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestEncryptedAppTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicket {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestEncryptedAppTicketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestEncryptedAppTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.encrypted_app_ticket)
    pub encrypted_app_ticket: crate::MessageField<super::encrypted_app_ticket::EncryptedAppTicket>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestEncryptedAppTicketResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicketResponse {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicketResponse {
        <CMsgClientRequestEncryptedAppTicketResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicketResponse {
    pub fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional .EncryptedAppTicket encrypted_app_ticket = 3;

    pub fn encrypted_app_ticket(&self) -> &super::encrypted_app_ticket::EncryptedAppTicket {
        self.encrypted_app_ticket.as_ref().unwrap_or_else(|| <super::encrypted_app_ticket::EncryptedAppTicket as crate::Message>::default_instance())
    }

    pub fn clear_encrypted_app_ticket(&mut self) {
        self.encrypted_app_ticket.clear();
    }

    pub fn has_encrypted_app_ticket(&self) -> bool {
        self.encrypted_app_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_app_ticket(&mut self, v: super::encrypted_app_ticket::EncryptedAppTicket) {
        self.encrypted_app_ticket = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_app_ticket(&mut self) -> &mut super::encrypted_app_ticket::EncryptedAppTicket {
        self.encrypted_app_ticket.mut_or_insert_default()
    }

    // Take field
    pub fn take_encrypted_app_ticket(&mut self) -> super::encrypted_app_ticket::EncryptedAppTicket {
        self.encrypted_app_ticket.take().unwrap_or_else(|| super::encrypted_app_ticket::EncryptedAppTicket::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.app_id },
            |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.eresult },
            |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::encrypted_app_ticket::EncryptedAppTicket>(
            "encrypted_app_ticket",
            |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.encrypted_app_ticket },
            |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.encrypted_app_ticket },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestEncryptedAppTicketResponse>(
            "CMsgClientRequestEncryptedAppTicketResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestEncryptedAppTicketResponse {
    const NAME: &'static str = "CMsgClientRequestEncryptedAppTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.encrypted_app_ticket)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        CMsgClientRequestEncryptedAppTicketResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.encrypted_app_ticket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicketResponse {
        static instance: CMsgClientRequestEncryptedAppTicketResponse = CMsgClientRequestEncryptedAppTicketResponse {
            app_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            encrypted_app_ticket: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestEncryptedAppTicketResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestEncryptedAppTicketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestEncryptedAppTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicketResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientWalletInfoUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWalletInfoUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.has_wallet)
    pub has_wallet: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance)
    pub balance: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance_delayed)
    pub balance_delayed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance64)
    pub balance64: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance64_delayed)
    pub balance64_delayed: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.realm)
    pub realm: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWalletInfoUpdate.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWalletInfoUpdate {
    fn default() -> &'a CMsgClientWalletInfoUpdate {
        <CMsgClientWalletInfoUpdate as crate::Message>::default_instance()
    }
}

impl CMsgClientWalletInfoUpdate {
    pub fn new() -> CMsgClientWalletInfoUpdate {
        ::std::default::Default::default()
    }

    // optional bool has_wallet = 1;

    pub fn has_wallet(&self) -> bool {
        self.has_wallet.unwrap_or(false)
    }

    pub fn clear_has_wallet(&mut self) {
        self.has_wallet = ::std::option::Option::None;
    }

    pub fn has_has_wallet(&self) -> bool {
        self.has_wallet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_wallet(&mut self, v: bool) {
        self.has_wallet = ::std::option::Option::Some(v);
    }

    // optional int32 balance = 2;

    pub fn balance(&self) -> i32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional int32 balance_delayed = 4;

    pub fn balance_delayed(&self) -> i32 {
        self.balance_delayed.unwrap_or(0)
    }

    pub fn clear_balance_delayed(&mut self) {
        self.balance_delayed = ::std::option::Option::None;
    }

    pub fn has_balance_delayed(&self) -> bool {
        self.balance_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_delayed(&mut self, v: i32) {
        self.balance_delayed = ::std::option::Option::Some(v);
    }

    // optional int64 balance64 = 5;

    pub fn balance64(&self) -> i64 {
        self.balance64.unwrap_or(0)
    }

    pub fn clear_balance64(&mut self) {
        self.balance64 = ::std::option::Option::None;
    }

    pub fn has_balance64(&self) -> bool {
        self.balance64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64(&mut self, v: i64) {
        self.balance64 = ::std::option::Option::Some(v);
    }

    // optional int64 balance64_delayed = 6;

    pub fn balance64_delayed(&self) -> i64 {
        self.balance64_delayed.unwrap_or(0)
    }

    pub fn clear_balance64_delayed(&mut self) {
        self.balance64_delayed = ::std::option::Option::None;
    }

    pub fn has_balance64_delayed(&self) -> bool {
        self.balance64_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64_delayed(&mut self, v: i64) {
        self.balance64_delayed = ::std::option::Option::Some(v);
    }

    // optional int32 realm = 7;

    pub fn realm(&self) -> i32 {
        self.realm.unwrap_or(0)
    }

    pub fn clear_realm(&mut self) {
        self.realm = ::std::option::Option::None;
    }

    pub fn has_realm(&self) -> bool {
        self.realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realm(&mut self, v: i32) {
        self.realm = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_wallet",
            |m: &CMsgClientWalletInfoUpdate| { &m.has_wallet },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.has_wallet },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgClientWalletInfoUpdate| { &m.currency },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.currency },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_delayed",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance_delayed },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance_delayed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance64",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance64 },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance64_delayed",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance64_delayed },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64_delayed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "realm",
            |m: &CMsgClientWalletInfoUpdate| { &m.realm },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.realm },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWalletInfoUpdate>(
            "CMsgClientWalletInfoUpdate",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientWalletInfoUpdate {
    const NAME: &'static str = "CMsgClientWalletInfoUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_wallet = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.balance = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.balance_delayed = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.balance64 = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.balance64_delayed = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.realm = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_wallet {
            my_size += 1 + 1;
        }
        if let Some(v) = self.balance {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.balance_delayed {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.balance64 {
            my_size += crate::rt::int64_size(5, v);
        }
        if let Some(v) = self.balance64_delayed {
            my_size += crate::rt::int64_size(6, v);
        }
        if let Some(v) = self.realm {
            my_size += crate::rt::int32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.has_wallet {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.balance_delayed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.balance64 {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.balance64_delayed {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.realm {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWalletInfoUpdate {
        CMsgClientWalletInfoUpdate::new()
    }

    fn clear(&mut self) {
        self.has_wallet = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance_delayed = ::std::option::Option::None;
        self.balance64 = ::std::option::Option::None;
        self.balance64_delayed = ::std::option::Option::None;
        self.realm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWalletInfoUpdate {
        static instance: CMsgClientWalletInfoUpdate = CMsgClientWalletInfoUpdate {
            has_wallet: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance_delayed: ::std::option::Option::None,
            balance64: ::std::option::Option::None,
            balance64_delayed: ::std::option::Option::None,
            realm: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientWalletInfoUpdate {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWalletInfoUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWalletInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientWalletInfoUpdate {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAMGetClanOfficers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetClanOfficers {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficers.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetClanOfficers.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficers {
    fn default() -> &'a CMsgClientAMGetClanOfficers {
        <CMsgClientAMGetClanOfficers as crate::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficers {
    pub fn new() -> CMsgClientAMGetClanOfficers {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_clan",
            |m: &CMsgClientAMGetClanOfficers| { &m.steamid_clan },
            |m: &mut CMsgClientAMGetClanOfficers| { &mut m.steamid_clan },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetClanOfficers>(
            "CMsgClientAMGetClanOfficers",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAMGetClanOfficers {
    const NAME: &'static str = "CMsgClientAMGetClanOfficers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetClanOfficers {
        CMsgClientAMGetClanOfficers::new()
    }

    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficers {
        static instance: CMsgClientAMGetClanOfficers = CMsgClientAMGetClanOfficers {
            steamid_clan: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAMGetClanOfficers {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetClanOfficers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetClanOfficers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAMGetClanOfficers {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAMGetClanOfficersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetClanOfficersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.officer_count)
    pub officer_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetClanOfficersResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficersResponse {
    fn default() -> &'a CMsgClientAMGetClanOfficersResponse {
        <CMsgClientAMGetClanOfficersResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficersResponse {
    pub fn new() -> CMsgClientAMGetClanOfficersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_clan = 2;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional int32 officer_count = 3;

    pub fn officer_count(&self) -> i32 {
        self.officer_count.unwrap_or(0)
    }

    pub fn clear_officer_count(&mut self) {
        self.officer_count = ::std::option::Option::None;
    }

    pub fn has_officer_count(&self) -> bool {
        self.officer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_officer_count(&mut self, v: i32) {
        self.officer_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAMGetClanOfficersResponse| { &m.eresult },
            |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_clan",
            |m: &CMsgClientAMGetClanOfficersResponse| { &m.steamid_clan },
            |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.steamid_clan },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "officer_count",
            |m: &CMsgClientAMGetClanOfficersResponse| { &m.officer_count },
            |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.officer_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetClanOfficersResponse>(
            "CMsgClientAMGetClanOfficersResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAMGetClanOfficersResponse {
    const NAME: &'static str = "CMsgClientAMGetClanOfficersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.officer_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.officer_count {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.officer_count {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetClanOfficersResponse {
        CMsgClientAMGetClanOfficersResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_clan = ::std::option::Option::None;
        self.officer_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficersResponse {
        static instance: CMsgClientAMGetClanOfficersResponse = CMsgClientAMGetClanOfficersResponse {
            eresult: ::std::option::Option::None,
            steamid_clan: ::std::option::Option::None,
            officer_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAMGetClanOfficersResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetClanOfficersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetClanOfficersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAMGetClanOfficersResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetPersonaNameHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.id_count)
    pub id_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.Ids)
    pub Ids: ::std::vec::Vec<cmsg_client_amget_persona_name_history::IdInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistory.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistory {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistory {
        <CMsgClientAMGetPersonaNameHistory as crate::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistory {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory {
        ::std::default::Default::default()
    }

    // optional int32 id_count = 1;

    pub fn id_count(&self) -> i32 {
        self.id_count.unwrap_or(0)
    }

    pub fn clear_id_count(&mut self) {
        self.id_count = ::std::option::Option::None;
    }

    pub fn has_id_count(&self) -> bool {
        self.id_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_count(&mut self, v: i32) {
        self.id_count = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientAMGetPersonaNameHistory.IdInstance Ids = 2;

    pub fn Ids(&self) -> &[cmsg_client_amget_persona_name_history::IdInstance] {
        &self.Ids
    }

    pub fn clear_Ids(&mut self) {
        self.Ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ids(&mut self, v: ::std::vec::Vec<cmsg_client_amget_persona_name_history::IdInstance>) {
        self.Ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Ids(&mut self) -> &mut ::std::vec::Vec<cmsg_client_amget_persona_name_history::IdInstance> {
        &mut self.Ids
    }

    // Take field
    pub fn take_Ids(&mut self) -> ::std::vec::Vec<cmsg_client_amget_persona_name_history::IdInstance> {
        ::std::mem::replace(&mut self.Ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "id_count",
            |m: &CMsgClientAMGetPersonaNameHistory| { &m.id_count },
            |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.id_count },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Ids",
            |m: &CMsgClientAMGetPersonaNameHistory| { &m.Ids },
            |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.Ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetPersonaNameHistory>(
            "CMsgClientAMGetPersonaNameHistory",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAMGetPersonaNameHistory {
    const NAME: &'static str = "CMsgClientAMGetPersonaNameHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id_count = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.Ids.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id_count {
            my_size += crate::rt::int32_size(1, v);
        }
        for value in &self.Ids {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.id_count {
            os.write_int32(1, v)?;
        }
        for v in &self.Ids {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetPersonaNameHistory {
        CMsgClientAMGetPersonaNameHistory::new()
    }

    fn clear(&mut self) {
        self.id_count = ::std::option::Option::None;
        self.Ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory {
        static instance: CMsgClientAMGetPersonaNameHistory = CMsgClientAMGetPersonaNameHistory {
            id_count: ::std::option::Option::None,
            Ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAMGetPersonaNameHistory {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetPersonaNameHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistory {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistory`
pub mod cmsg_client_amget_persona_name_history {
    // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistory.IdInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct IdInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.IdInstance.steamid)
        pub steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistory.IdInstance.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IdInstance {
        fn default() -> &'a IdInstance {
            <IdInstance as crate::Message>::default_instance()
        }
    }

    impl IdInstance {
        pub fn new() -> IdInstance {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &IdInstance| { &m.steamid },
                |m: &mut IdInstance| { &mut m.steamid },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<IdInstance>(
                "CMsgClientAMGetPersonaNameHistory.IdInstance",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for IdInstance {
        const NAME: &'static str = "IdInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IdInstance {
            IdInstance::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IdInstance {
            static instance: IdInstance = IdInstance {
                steamid: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for IdInstance {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistory.IdInstance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IdInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for IdInstance {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.responses)
    pub responses: ::std::vec::Vec<cmsg_client_amget_persona_name_history_response::NameTableInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistoryResponse {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistoryResponse {
        <CMsgClientAMGetPersonaNameHistoryResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistoryResponse {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance responses = 2;

    pub fn responses(&self) -> &[cmsg_client_amget_persona_name_history_response::NameTableInstance] {
        &self.responses
    }

    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::std::vec::Vec<cmsg_client_amget_persona_name_history_response::NameTableInstance>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::std::vec::Vec<cmsg_client_amget_persona_name_history_response::NameTableInstance> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::std::vec::Vec<cmsg_client_amget_persona_name_history_response::NameTableInstance> {
        ::std::mem::replace(&mut self.responses, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "responses",
            |m: &CMsgClientAMGetPersonaNameHistoryResponse| { &m.responses },
            |m: &mut CMsgClientAMGetPersonaNameHistoryResponse| { &mut m.responses },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetPersonaNameHistoryResponse>(
            "CMsgClientAMGetPersonaNameHistoryResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAMGetPersonaNameHistoryResponse {
    const NAME: &'static str = "CMsgClientAMGetPersonaNameHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.responses.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.responses {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        CMsgClientAMGetPersonaNameHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.responses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse {
        static instance: CMsgClientAMGetPersonaNameHistoryResponse = CMsgClientAMGetPersonaNameHistoryResponse {
            responses: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAMGetPersonaNameHistoryResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetPersonaNameHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistoryResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistoryResponse`
pub mod cmsg_client_amget_persona_name_history_response {
    // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NameTableInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.eresult)
        pub eresult: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.names)
        pub names: ::std::vec::Vec<name_table_instance::NameInstance>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NameTableInstance {
        fn default() -> &'a NameTableInstance {
            <NameTableInstance as crate::Message>::default_instance()
        }
    }

    impl NameTableInstance {
        pub fn new() -> NameTableInstance {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid = 2;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // repeated .CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance names = 3;

        pub fn names(&self) -> &[name_table_instance::NameInstance] {
            &self.names
        }

        pub fn clear_names(&mut self) {
            self.names.clear();
        }

        // Param is passed by value, moved
        pub fn set_names(&mut self, v: ::std::vec::Vec<name_table_instance::NameInstance>) {
            self.names = v;
        }

        // Mutable pointer to the field.
        pub fn mut_names(&mut self) -> &mut ::std::vec::Vec<name_table_instance::NameInstance> {
            &mut self.names
        }

        // Take field
        pub fn take_names(&mut self) -> ::std::vec::Vec<name_table_instance::NameInstance> {
            ::std::mem::replace(&mut self.names, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "eresult",
                |m: &NameTableInstance| { &m.eresult },
                |m: &mut NameTableInstance| { &mut m.eresult },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &NameTableInstance| { &m.steamid },
                |m: &mut NameTableInstance| { &mut m.steamid },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "names",
                |m: &NameTableInstance| { &m.names },
                |m: &mut NameTableInstance| { &mut m.names },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<NameTableInstance>(
                "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for NameTableInstance {
        const NAME: &'static str = "NameTableInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    17 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    26 => {
                        self.names.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            for value in &self.names {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.steamid {
                os.write_fixed64(2, v)?;
            }
            for v in &self.names {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NameTableInstance {
            NameTableInstance::new()
        }

        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.steamid = ::std::option::Option::None;
            self.names.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NameTableInstance {
            static instance: NameTableInstance = NameTableInstance {
                eresult: ::std::option::Option::None,
                steamid: ::std::option::Option::None,
                names: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for NameTableInstance {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NameTableInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for NameTableInstance {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `NameTableInstance`
    pub mod name_table_instance {
        // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct NameInstance {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.name_since)
            pub name_since: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.name)
            pub name: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a NameInstance {
            fn default() -> &'a NameInstance {
                <NameInstance as crate::Message>::default_instance()
            }
        }

        impl NameInstance {
            pub fn new() -> NameInstance {
                ::std::default::Default::default()
            }

            // optional fixed32 name_since = 1;

            pub fn name_since(&self) -> u32 {
                self.name_since.unwrap_or(0)
            }

            pub fn clear_name_since(&mut self) {
                self.name_since = ::std::option::Option::None;
            }

            pub fn has_name_since(&self) -> bool {
                self.name_since.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name_since(&mut self, v: u32) {
                self.name_since = ::std::option::Option::Some(v);
            }

            // optional string name = 2;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name_since",
                    |m: &NameInstance| { &m.name_since },
                    |m: &mut NameInstance| { &mut m.name_since },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name",
                    |m: &NameInstance| { &m.name },
                    |m: &mut NameInstance| { &mut m.name },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<NameInstance>(
                    "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for NameInstance {
            const NAME: &'static str = "NameInstance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.name_since = ::std::option::Option::Some(is.read_fixed32()?);
                        },
                        18 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name_since {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.name.as_ref() {
                    my_size += crate::rt::string_size(2, &v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.name_since {
                    os.write_fixed32(1, v)?;
                }
                if let Some(v) = self.name.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> NameInstance {
                NameInstance::new()
            }

            fn clear(&mut self) {
                self.name_since = ::std::option::Option::None;
                self.name = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static NameInstance {
                static instance: NameInstance = NameInstance {
                    name_since: ::std::option::Option::None,
                    name: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for NameInstance {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for NameInstance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for NameInstance {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientDeregisterWithServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeregisterWithServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeregisterWithServer.eservertype)
    pub eservertype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDeregisterWithServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeregisterWithServer.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeregisterWithServer {
    fn default() -> &'a CMsgClientDeregisterWithServer {
        <CMsgClientDeregisterWithServer as crate::Message>::default_instance()
    }
}

impl CMsgClientDeregisterWithServer {
    pub fn new() -> CMsgClientDeregisterWithServer {
        ::std::default::Default::default()
    }

    // optional uint32 eservertype = 1;

    pub fn eservertype(&self) -> u32 {
        self.eservertype.unwrap_or(0)
    }

    pub fn clear_eservertype(&mut self) {
        self.eservertype = ::std::option::Option::None;
    }

    pub fn has_eservertype(&self) -> bool {
        self.eservertype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eservertype(&mut self, v: u32) {
        self.eservertype = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eservertype",
            |m: &CMsgClientDeregisterWithServer| { &m.eservertype },
            |m: &mut CMsgClientDeregisterWithServer| { &mut m.eservertype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientDeregisterWithServer| { &m.app_id },
            |m: &mut CMsgClientDeregisterWithServer| { &mut m.app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeregisterWithServer>(
            "CMsgClientDeregisterWithServer",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDeregisterWithServer {
    const NAME: &'static str = "CMsgClientDeregisterWithServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eservertype = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eservertype {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eservertype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeregisterWithServer {
        CMsgClientDeregisterWithServer::new()
    }

    fn clear(&mut self) {
        self.eservertype = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeregisterWithServer {
        static instance: CMsgClientDeregisterWithServer = CMsgClientDeregisterWithServer {
            eservertype: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDeregisterWithServer {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeregisterWithServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeregisterWithServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDeregisterWithServer {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientClanState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientClanState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientClanState.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientClanState.clan_account_flags)
    pub clan_account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientClanState.name_info)
    pub name_info: crate::MessageField<cmsg_client_clan_state::NameInfo>,
    // @@protoc_insertion_point(field:CMsgClientClanState.user_counts)
    pub user_counts: crate::MessageField<cmsg_client_clan_state::UserCounts>,
    // @@protoc_insertion_point(field:CMsgClientClanState.events)
    pub events: ::std::vec::Vec<cmsg_client_clan_state::Event>,
    // @@protoc_insertion_point(field:CMsgClientClanState.announcements)
    pub announcements: ::std::vec::Vec<cmsg_client_clan_state::Event>,
    // @@protoc_insertion_point(field:CMsgClientClanState.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientClanState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState {
    fn default() -> &'a CMsgClientClanState {
        <CMsgClientClanState as crate::Message>::default_instance()
    }
}

impl CMsgClientClanState {
    pub fn new() -> CMsgClientClanState {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 clan_account_flags = 3;

    pub fn clan_account_flags(&self) -> u32 {
        self.clan_account_flags.unwrap_or(0)
    }

    pub fn clear_clan_account_flags(&mut self) {
        self.clan_account_flags = ::std::option::Option::None;
    }

    pub fn has_clan_account_flags(&self) -> bool {
        self.clan_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_account_flags(&mut self, v: u32) {
        self.clan_account_flags = ::std::option::Option::Some(v);
    }

    // optional .CMsgClientClanState.NameInfo name_info = 4;

    pub fn name_info(&self) -> &cmsg_client_clan_state::NameInfo {
        self.name_info.as_ref().unwrap_or_else(|| <cmsg_client_clan_state::NameInfo as crate::Message>::default_instance())
    }

    pub fn clear_name_info(&mut self) {
        self.name_info.clear();
    }

    pub fn has_name_info(&self) -> bool {
        self.name_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_info(&mut self, v: cmsg_client_clan_state::NameInfo) {
        self.name_info = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_info(&mut self) -> &mut cmsg_client_clan_state::NameInfo {
        self.name_info.mut_or_insert_default()
    }

    // Take field
    pub fn take_name_info(&mut self) -> cmsg_client_clan_state::NameInfo {
        self.name_info.take().unwrap_or_else(|| cmsg_client_clan_state::NameInfo::new())
    }

    // optional .CMsgClientClanState.UserCounts user_counts = 5;

    pub fn user_counts(&self) -> &cmsg_client_clan_state::UserCounts {
        self.user_counts.as_ref().unwrap_or_else(|| <cmsg_client_clan_state::UserCounts as crate::Message>::default_instance())
    }

    pub fn clear_user_counts(&mut self) {
        self.user_counts.clear();
    }

    pub fn has_user_counts(&self) -> bool {
        self.user_counts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_counts(&mut self, v: cmsg_client_clan_state::UserCounts) {
        self.user_counts = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_counts(&mut self) -> &mut cmsg_client_clan_state::UserCounts {
        self.user_counts.mut_or_insert_default()
    }

    // Take field
    pub fn take_user_counts(&mut self) -> cmsg_client_clan_state::UserCounts {
        self.user_counts.take().unwrap_or_else(|| cmsg_client_clan_state::UserCounts::new())
    }

    // repeated .CMsgClientClanState.Event events = 6;

    pub fn events(&self) -> &[cmsg_client_clan_state::Event] {
        &self.events
    }

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::std::vec::Vec<cmsg_client_clan_state::Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::std::vec::Vec<cmsg_client_clan_state::Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::std::vec::Vec<cmsg_client_clan_state::Event> {
        ::std::mem::replace(&mut self.events, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientClanState.Event announcements = 7;

    pub fn announcements(&self) -> &[cmsg_client_clan_state::Event] {
        &self.announcements
    }

    pub fn clear_announcements(&mut self) {
        self.announcements.clear();
    }

    // Param is passed by value, moved
    pub fn set_announcements(&mut self, v: ::std::vec::Vec<cmsg_client_clan_state::Event>) {
        self.announcements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_announcements(&mut self) -> &mut ::std::vec::Vec<cmsg_client_clan_state::Event> {
        &mut self.announcements
    }

    // Take field
    pub fn take_announcements(&mut self) -> ::std::vec::Vec<cmsg_client_clan_state::Event> {
        ::std::mem::replace(&mut self.announcements, ::std::vec::Vec::new())
    }

    // optional bool chat_room_private = 8;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_clan",
            |m: &CMsgClientClanState| { &m.steamid_clan },
            |m: &mut CMsgClientClanState| { &mut m.steamid_clan },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clan_account_flags",
            |m: &CMsgClientClanState| { &m.clan_account_flags },
            |m: &mut CMsgClientClanState| { &mut m.clan_account_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_clan_state::NameInfo>(
            "name_info",
            |m: &CMsgClientClanState| { &m.name_info },
            |m: &mut CMsgClientClanState| { &mut m.name_info },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_clan_state::UserCounts>(
            "user_counts",
            |m: &CMsgClientClanState| { &m.user_counts },
            |m: &mut CMsgClientClanState| { &mut m.user_counts },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &CMsgClientClanState| { &m.events },
            |m: &mut CMsgClientClanState| { &mut m.events },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "announcements",
            |m: &CMsgClientClanState| { &m.announcements },
            |m: &mut CMsgClientClanState| { &mut m.announcements },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_private",
            |m: &CMsgClientClanState| { &m.chat_room_private },
            |m: &mut CMsgClientClanState| { &mut m.chat_room_private },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientClanState>(
            "CMsgClientClanState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientClanState {
    const NAME: &'static str = "CMsgClientClanState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.clan_account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.name_info)?;
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.user_counts)?;
                },
                50 => {
                    self.events.push(is.read_message()?);
                },
                58 => {
                    self.announcements.push(is.read_message()?);
                },
                64 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.clan_account_flags {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.name_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.announcements {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_account_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name_info.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.user_counts.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.events {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.announcements {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.chat_room_private {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientClanState {
        CMsgClientClanState::new()
    }

    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.clan_account_flags = ::std::option::Option::None;
        self.name_info.clear();
        self.user_counts.clear();
        self.events.clear();
        self.announcements.clear();
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientClanState {
        static instance: CMsgClientClanState = CMsgClientClanState {
            steamid_clan: ::std::option::Option::None,
            clan_account_flags: ::std::option::Option::None,
            name_info: crate::MessageField::none(),
            user_counts: crate::MessageField::none(),
            events: ::std::vec::Vec::new(),
            announcements: ::std::vec::Vec::new(),
            chat_room_private: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientClanState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientClanState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientClanState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientClanState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientClanState`
pub mod cmsg_client_clan_state {
    // @@protoc_insertion_point(message:CMsgClientClanState.NameInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NameInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.NameInfo.clan_name)
        pub clan_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientClanState.NameInfo.sha_avatar)
        pub sha_avatar: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.NameInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NameInfo {
        fn default() -> &'a NameInfo {
            <NameInfo as crate::Message>::default_instance()
        }
    }

    impl NameInfo {
        pub fn new() -> NameInfo {
            ::std::default::Default::default()
        }

        // optional string clan_name = 1;

        pub fn clan_name(&self) -> &str {
            match self.clan_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_name(&mut self) {
            self.clan_name = ::std::option::Option::None;
        }

        pub fn has_clan_name(&self) -> bool {
            self.clan_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_name(&mut self, v: ::std::string::String) {
            self.clan_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_name(&mut self) -> &mut ::std::string::String {
            if self.clan_name.is_none() {
                self.clan_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.clan_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_name(&mut self) -> ::std::string::String {
            self.clan_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes sha_avatar = 2;

        pub fn sha_avatar(&self) -> &[u8] {
            match self.sha_avatar.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_avatar(&mut self) {
            self.sha_avatar = ::std::option::Option::None;
        }

        pub fn has_sha_avatar(&self) -> bool {
            self.sha_avatar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_avatar(&mut self, v: ::bytes::Bytes) {
            self.sha_avatar = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_avatar(&mut self) -> &mut ::bytes::Bytes {
            if self.sha_avatar.is_none() {
                self.sha_avatar = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.sha_avatar.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_avatar(&mut self) -> ::bytes::Bytes {
            self.sha_avatar.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "clan_name",
                |m: &NameInfo| { &m.clan_name },
                |m: &mut NameInfo| { &mut m.clan_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha_avatar",
                |m: &NameInfo| { &m.sha_avatar },
                |m: &mut NameInfo| { &mut m.sha_avatar },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<NameInfo>(
                "CMsgClientClanState.NameInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for NameInfo {
        const NAME: &'static str = "NameInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.clan_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.sha_avatar = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.clan_name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                my_size += crate::rt::bytes_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.clan_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NameInfo {
            NameInfo::new()
        }

        fn clear(&mut self) {
            self.clan_name = ::std::option::Option::None;
            self.sha_avatar = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NameInfo {
            static instance: NameInfo = NameInfo {
                clan_name: ::std::option::Option::None,
                sha_avatar: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for NameInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientClanState.NameInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NameInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for NameInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientClanState.UserCounts)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserCounts {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.members)
        pub members: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.online)
        pub online: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.chatting)
        pub chatting: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.in_game)
        pub in_game: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.chat_room_members)
        pub chat_room_members: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.UserCounts.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserCounts {
        fn default() -> &'a UserCounts {
            <UserCounts as crate::Message>::default_instance()
        }
    }

    impl UserCounts {
        pub fn new() -> UserCounts {
            ::std::default::Default::default()
        }

        // optional uint32 members = 1;

        pub fn members(&self) -> u32 {
            self.members.unwrap_or(0)
        }

        pub fn clear_members(&mut self) {
            self.members = ::std::option::Option::None;
        }

        pub fn has_members(&self) -> bool {
            self.members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_members(&mut self, v: u32) {
            self.members = ::std::option::Option::Some(v);
        }

        // optional uint32 online = 2;

        pub fn online(&self) -> u32 {
            self.online.unwrap_or(0)
        }

        pub fn clear_online(&mut self) {
            self.online = ::std::option::Option::None;
        }

        pub fn has_online(&self) -> bool {
            self.online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online(&mut self, v: u32) {
            self.online = ::std::option::Option::Some(v);
        }

        // optional uint32 chatting = 3;

        pub fn chatting(&self) -> u32 {
            self.chatting.unwrap_or(0)
        }

        pub fn clear_chatting(&mut self) {
            self.chatting = ::std::option::Option::None;
        }

        pub fn has_chatting(&self) -> bool {
            self.chatting.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chatting(&mut self, v: u32) {
            self.chatting = ::std::option::Option::Some(v);
        }

        // optional uint32 in_game = 4;

        pub fn in_game(&self) -> u32 {
            self.in_game.unwrap_or(0)
        }

        pub fn clear_in_game(&mut self) {
            self.in_game = ::std::option::Option::None;
        }

        pub fn has_in_game(&self) -> bool {
            self.in_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_game(&mut self, v: u32) {
            self.in_game = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_room_members = 5;

        pub fn chat_room_members(&self) -> u32 {
            self.chat_room_members.unwrap_or(0)
        }

        pub fn clear_chat_room_members(&mut self) {
            self.chat_room_members = ::std::option::Option::None;
        }

        pub fn has_chat_room_members(&self) -> bool {
            self.chat_room_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_room_members(&mut self, v: u32) {
            self.chat_room_members = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "members",
                |m: &UserCounts| { &m.members },
                |m: &mut UserCounts| { &mut m.members },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "online",
                |m: &UserCounts| { &m.online },
                |m: &mut UserCounts| { &mut m.online },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chatting",
                |m: &UserCounts| { &m.chatting },
                |m: &mut UserCounts| { &mut m.chatting },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "in_game",
                |m: &UserCounts| { &m.in_game },
                |m: &mut UserCounts| { &mut m.in_game },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_room_members",
                |m: &UserCounts| { &m.chat_room_members },
                |m: &mut UserCounts| { &mut m.chat_room_members },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<UserCounts>(
                "CMsgClientClanState.UserCounts",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for UserCounts {
        const NAME: &'static str = "UserCounts";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.online = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.chatting = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.in_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.chat_room_members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.members {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.online {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.chatting {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.in_game {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.chat_room_members {
                my_size += crate::rt::uint32_size(5, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.members {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.online {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.chatting {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.in_game {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.chat_room_members {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserCounts {
            UserCounts::new()
        }

        fn clear(&mut self) {
            self.members = ::std::option::Option::None;
            self.online = ::std::option::Option::None;
            self.chatting = ::std::option::Option::None;
            self.in_game = ::std::option::Option::None;
            self.chat_room_members = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserCounts {
            static instance: UserCounts = UserCounts {
                members: ::std::option::Option::None,
                online: ::std::option::Option::None,
                chatting: ::std::option::Option::None,
                in_game: ::std::option::Option::None,
                chat_room_members: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for UserCounts {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientClanState.UserCounts").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserCounts {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for UserCounts {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientClanState.Event)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Event {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.gid)
        pub gid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.event_time)
        pub event_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.headline)
        pub headline: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.just_posted)
        pub just_posted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.Event.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Event {
        fn default() -> &'a Event {
            <Event as crate::Message>::default_instance()
        }
    }

    impl Event {
        pub fn new() -> Event {
            ::std::default::Default::default()
        }

        // optional fixed64 gid = 1;

        pub fn gid(&self) -> u64 {
            self.gid.unwrap_or(0)
        }

        pub fn clear_gid(&mut self) {
            self.gid = ::std::option::Option::None;
        }

        pub fn has_gid(&self) -> bool {
            self.gid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gid(&mut self, v: u64) {
            self.gid = ::std::option::Option::Some(v);
        }

        // optional uint32 event_time = 2;

        pub fn event_time(&self) -> u32 {
            self.event_time.unwrap_or(0)
        }

        pub fn clear_event_time(&mut self) {
            self.event_time = ::std::option::Option::None;
        }

        pub fn has_event_time(&self) -> bool {
            self.event_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_time(&mut self, v: u32) {
            self.event_time = ::std::option::Option::Some(v);
        }

        // optional string headline = 3;

        pub fn headline(&self) -> &str {
            match self.headline.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_headline(&mut self) {
            self.headline = ::std::option::Option::None;
        }

        pub fn has_headline(&self) -> bool {
            self.headline.is_some()
        }

        // Param is passed by value, moved
        pub fn set_headline(&mut self, v: ::std::string::String) {
            self.headline = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_headline(&mut self) -> &mut ::std::string::String {
            if self.headline.is_none() {
                self.headline = ::std::option::Option::Some(::std::string::String::new());
            }
            self.headline.as_mut().unwrap()
        }

        // Take field
        pub fn take_headline(&mut self) -> ::std::string::String {
            self.headline.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 game_id = 4;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional bool just_posted = 5;

        pub fn just_posted(&self) -> bool {
            self.just_posted.unwrap_or(false)
        }

        pub fn clear_just_posted(&mut self) {
            self.just_posted = ::std::option::Option::None;
        }

        pub fn has_just_posted(&self) -> bool {
            self.just_posted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_just_posted(&mut self, v: bool) {
            self.just_posted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "gid",
                |m: &Event| { &m.gid },
                |m: &mut Event| { &mut m.gid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_time",
                |m: &Event| { &m.event_time },
                |m: &mut Event| { &mut m.event_time },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "headline",
                |m: &Event| { &m.headline },
                |m: &mut Event| { &mut m.headline },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_id",
                |m: &Event| { &m.game_id },
                |m: &mut Event| { &mut m.game_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "just_posted",
                |m: &Event| { &m.just_posted },
                |m: &mut Event| { &mut m.just_posted },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
                "CMsgClientClanState.Event",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Event {
        const NAME: &'static str = "Event";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.event_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.headline = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.just_posted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.event_time {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.headline.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.game_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.just_posted {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.gid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.event_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.headline.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.just_posted {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Event {
            Event::new()
        }

        fn clear(&mut self) {
            self.gid = ::std::option::Option::None;
            self.event_time = ::std::option::Option::None;
            self.headline = ::std::option::Option::None;
            self.game_id = ::std::option::Option::None;
            self.just_posted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Event {
            static instance: Event = Event {
                gid: ::std::option::Option::None,
                event_time: ::std::option::Option::None,
                headline: ::std::option::Option::None,
                game_id: ::std::option::Option::None,
                just_posted: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Event {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientClanState.Event").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Event {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Event {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20steammessages_clientserver.proto\x1a\x18steammessages_base.proto\
    \x1a\x1aencrypted_app_ticket.proto\"\x95\x01\n\"CMsgClientRegisterAuthTi\
    cketWithCM\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\x0fprotocolVer\
    sion\x12\x16\n\x06ticket\x18\x03\x20\x01(\x0cR\x06ticket\x12,\n\x12clien\
    t_instance_id\x18\x04\x20\x01(\x04R\x10clientInstanceId\"\xbb\x02\n\x1cC\
    MsgClientTicketAuthComplete\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\
    \x07steamId\x12\x17\n\x07game_id\x18\x02\x20\x01(\x06R\x06gameId\x12\x16\
    \n\x06estate\x18\x03\x20\x01(\rR\x06estate\x124\n\x16eauth_session_respo\
    nse\x18\x04\x20\x01(\rR\x14eauthSessionResponse\x12+\n\x11DEPRECATED_tic\
    ket\x18\x05\x20\x01(\x0cR\x10DEPRECATEDTicket\x12\x1d\n\nticket_crc\x18\
    \x06\x20\x01(\rR\tticketCrc\x12'\n\x0fticket_sequence\x18\x07\x20\x01(\r\
    R\x0eticketSequence\x12$\n\x0eowner_steam_id\x18\x08\x20\x01(\x06R\x0cow\
    nerSteamId\"\xc7\x01\n\x10CMsgClientCMList\x12!\n\x0ccm_addresses\x18\
    \x01\x20\x03(\rR\x0bcmAddresses\x12\x19\n\x08cm_ports\x18\x02\x20\x03(\r\
    R\x07cmPorts\x124\n\x16cm_websocket_addresses\x18\x03\x20\x03(\tR\x14cmW\
    ebsocketAddresses\x12?\n\x1cpercent_default_to_websocket\x18\x04\x20\x01\
    (\rR\x19percentDefaultToWebsocket\"\xf1\x01\n\x1bCMsgClientP2PConnection\
    Info\x12\"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\x0bsteamIdDest\x12\x20\
    \n\x0csteam_id_src\x18\x02\x20\x01(\x06R\nsteamIdSrc\x12\x15\n\x06app_id\
    \x18\x03\x20\x01(\rR\x05appId\x12\x1c\n\tcandidate\x18\x04\x20\x01(\x0cR\
    \tcandidate\x127\n\x18legacy_connection_id_src\x18\x05\x20\x01(\x06R\x15\
    legacyConnectionIdSrc\x12\x1e\n\nrendezvous\x18\x06\x20\x01(\x0cR\nrende\
    zvous\"\xa2\x02\n\x1fCMsgClientP2PConnectionFailInfo\x12\"\n\rsteam_id_d\
    est\x18\x01\x20\x01(\x06R\x0bsteamIdDest\x12\x20\n\x0csteam_id_src\x18\
    \x02\x20\x01(\x06R\nsteamIdSrc\x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\
    \x05appId\x12,\n\x12ep2p_session_error\x18\x04\x20\x01(\rR\x10ep2pSessio\
    nError\x12,\n\x12connection_id_dest\x18\x05\x20\x01(\x06R\x10connectionI\
    dDest\x12!\n\x0cclose_reason\x18\x07\x20\x01(\rR\x0bcloseReason\x12#\n\r\
    close_message\x18\x08\x20\x01(\tR\x0ccloseMessage\"S\n\x1fCMsgClientNetw\
    orkingCertRequest\x12\x19\n\x08key_data\x18\x02\x20\x01(\x0cR\x07keyData\
    \x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\"r\n\x1dCMsgClientNetw\
    orkingCertReply\x12\x12\n\x04cert\x18\x04\x20\x01(\x0cR\x04cert\x12\x1a\
    \n\tca_key_id\x18\x05\x20\x01(\x06R\x07caKeyId\x12!\n\x0cca_signature\
    \x18\x06\x20\x01(\x0cR\x0bcaSignature\">\n%CMsgClientNetworkingMobileCer\
    tRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\"H\n#CMsgClien\
    tNetworkingMobileCertReply\x12!\n\x0cencoded_cert\x18\x01\x20\x01(\tR\
    \x0bencodedCert\"8\n\x1fCMsgClientGetAppOwnershipTicket\x12\x15\n\x06app\
    _id\x18\x01\x20\x01(\rR\x05appId\"u\n'CMsgClientGetAppOwnershipTicketRes\
    ponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\x12\x15\
    \n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\x16\n\x06ticket\x18\x03\
    \x20\x01(\x0cR\x06ticket\".\n\x16CMsgClientSessionToken\x12\x14\n\x05tok\
    en\x18\x01\x20\x01(\x04R\x05token\"f\n\x1bCMsgClientGameConnectTokens\
    \x12/\n\x12max_tokens_to_keep\x18\x01\x20\x01(\r:\x0210R\x0fmaxTokensToK\
    eep\x12\x16\n\x06tokens\x18\x02\x20\x03(\x0cR\x06tokens\"\x8f\x0e\n\x15C\
    MsgClientGamesPlayed\x12D\n\x0cgames_played\x18\x01\x20\x03(\x0b2!.CMsgC\
    lientGamesPlayed.GamePlayedR\x0bgamesPlayed\x12$\n\x0eclient_os_type\x18\
    \x02\x20\x01(\rR\x0cclientOsType\x122\n\x15cloud_gaming_platform\x18\x03\
    \x20\x01(\rR\x13cloudGamingPlatform\x127\n\x17recent_reauthentication\
    \x18\x04\x20\x01(\x08R\x16recentReauthentication\x1a\x80\x01\n\x0bProces\
    sInfo\x12\x1d\n\nprocess_id\x18\x01\x20\x01(\rR\tprocessId\x12*\n\x11pro\
    cess_id_parent\x18\x02\x20\x01(\rR\x0fprocessIdParent\x12&\n\x0fparent_i\
    s_steam\x18\x03\x20\x01(\x08R\rparentIsSteam\x1a\x99\x0b\n\nGamePlayed\
    \x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\x01(\x04R\tsteamIdGs\x12\x17\n\x07\
    game_id\x18\x02\x20\x01(\x06R\x06gameId\x12;\n\x1adeprecated_game_ip_add\
    ress\x18\x03\x20\x01(\rR\x17deprecatedGameIpAddress\x12\x1b\n\tgame_port\
    \x18\x04\x20\x01(\rR\x08gamePort\x12\x1b\n\tis_secure\x18\x05\x20\x01(\
    \x08R\x08isSecure\x12\x14\n\x05token\x18\x06\x20\x01(\x0cR\x05token\x12&\
    \n\x0fgame_extra_info\x18\x07\x20\x01(\tR\rgameExtraInfo\x12$\n\x0egame_\
    data_blob\x18\x08\x20\x01(\x0cR\x0cgameDataBlob\x12\x1d\n\nprocess_id\
    \x18\t\x20\x01(\rR\tprocessId\x122\n\x15streaming_provider_id\x18\n\x20\
    \x01(\rR\x13streamingProviderId\x12\x1d\n\ngame_flags\x18\x0b\x20\x01(\r\
    R\tgameFlags\x12\x19\n\x08owner_id\x18\x0c\x20\x01(\rR\x07ownerId\x12\"\
    \n\rvr_hmd_vendor\x18\r\x20\x01(\tR\x0bvrHmdVendor\x12\x20\n\x0cvr_hmd_m\
    odel\x18\x0e\x20\x01(\tR\nvrHmdModel\x12/\n\x12launch_option_type\x18\
    \x0f\x20\x01(\r:\x010R\x10launchOptionType\x12:\n\x17primary_controller_\
    type\x18\x10\x20\x01(\x05:\x02-1R\x15primaryControllerType\x12E\n\x1fpri\
    mary_steam_controller_serial\x18\x11\x20\x01(\tR\x1cprimarySteamControll\
    erSerial\x12B\n\x1ctotal_steam_controller_count\x18\x12\x20\x01(\r:\x010\
    R\x19totalSteamControllerCount\x12I\n\x20total_non_steam_controller_coun\
    t\x18\x13\x20\x01(\r:\x010R\x1ctotalNonSteamControllerCount\x12@\n\x1bco\
    ntroller_workshop_file_id\x18\x14\x20\x01(\x04:\x010R\x18controllerWorks\
    hopFileId\x12&\n\rlaunch_source\x18\x15\x20\x01(\r:\x010R\x0claunchSourc\
    e\x12$\n\x0evr_hmd_runtime\x18\x16\x20\x01(\rR\x0cvrHmdRuntime\x126\n\
    \x0fgame_ip_address\x18\x17\x20\x01(\x0b2\x0e.CMsgIPAddressR\rgameIpAddr\
    ess\x12?\n\x1acontroller_connection_type\x18\x18\x20\x01(\r:\x010R\x18co\
    ntrollerConnectionType\x12(\n\x10game_os_platform\x18\x19\x20\x01(\x05R\
    \x0egameOsPlatform\x12\"\n\rgame_build_id\x18\x1a\x20\x01(\rR\x0bgameBui\
    ldId\x12'\n\x0ecompat_tool_id\x18\x1b\x20\x01(\r:\x010R\x0ccompatToolId\
    \x12&\n\x0fcompat_tool_cmd\x18\x1c\x20\x01(\tR\rcompatToolCmd\x12/\n\x14\
    compat_tool_build_id\x18\x1d\x20\x01(\rR\x11compatToolBuildId\x12\x1b\n\
    \tbeta_name\x18\x1e\x20\x01(\tR\x08betaName\x12\x1f\n\x0bdlc_context\x18\
    \x1f\x20\x01(\rR\ndlcContext\x12J\n\x0fprocess_id_list\x18\x20\x20\x03(\
    \x0b2\".CMsgClientGamesPlayed.ProcessInfoR\rprocessIdList\"P\n\rCMsgGSAp\
    prove\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12$\n\x0eo\
    wner_steam_id\x18\x02\x20\x01(\x06R\x0cownerSteamId\"k\n\nCMsgGSDeny\x12\
    \x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0cedeny_reas\
    on\x18\x02\x20\x01(\x05R\x0bedenyReason\x12\x1f\n\x0bdeny_string\x18\x03\
    \x20\x01(\tR\ndenyString\"J\n\nCMsgGSKick\x12\x19\n\x08steam_id\x18\x01\
    \x20\x01(\x06R\x07steamId\x12!\n\x0cedeny_reason\x18\x02\x20\x01(\x05R\
    \x0bedenyReason\"\xaa\x02\n\x12CMsgClientAuthList\x12\x1f\n\x0btokens_le\
    ft\x18\x01\x20\x01(\rR\ntokensLeft\x12(\n\x10last_request_seq\x18\x02\
    \x20\x01(\rR\x0elastRequestSeq\x12>\n\x1clast_request_seq_from_server\
    \x18\x03\x20\x01(\rR\x18lastRequestSeqFromServer\x12)\n\x07tickets\x18\
    \x04\x20\x03(\x0b2\x0f.CMsgAuthTicketR\x07tickets\x12\x17\n\x07app_ids\
    \x18\x05\x20\x03(\rR\x06appIds\x12)\n\x10message_sequence\x18\x06\x20\
    \x01(\rR\x0fmessageSequence\x12\x1a\n\x08filtered\x18\x07\x20\x01(\x08R\
    \x08filtered\"z\n\x15CMsgClientAuthListAck\x12\x1d\n\nticket_crc\x18\x01\
    \x20\x03(\rR\tticketCrc\x12\x17\n\x07app_ids\x18\x02\x20\x03(\rR\x06appI\
    ds\x12)\n\x10message_sequence\x18\x03\x20\x01(\rR\x0fmessageSequence\"\
    \xa0\x06\n\x15CMsgClientLicenseList\x12\x1b\n\x07eresult\x18\x01\x20\x01\
    (\x05:\x012R\x07eresult\x12:\n\x08licenses\x18\x02\x20\x03(\x0b2\x1e.CMs\
    gClientLicenseList.LicenseR\x08licenses\x1a\xad\x05\n\x07License\x12\x1d\
    \n\npackage_id\x18\x01\x20\x01(\rR\tpackageId\x12!\n\x0ctime_created\x18\
    \x02\x20\x01(\x07R\x0btimeCreated\x12*\n\x11time_next_process\x18\x03\
    \x20\x01(\x07R\x0ftimeNextProcess\x12!\n\x0cminute_limit\x18\x04\x20\x01\
    (\x05R\x0bminuteLimit\x12!\n\x0cminutes_used\x18\x05\x20\x01(\x05R\x0bmi\
    nutesUsed\x12%\n\x0epayment_method\x18\x06\x20\x01(\rR\rpaymentMethod\
    \x12\x14\n\x05flags\x18\x07\x20\x01(\rR\x05flags\x122\n\x15purchase_coun\
    try_code\x18\x08\x20\x01(\tR\x13purchaseCountryCode\x12!\n\x0clicense_ty\
    pe\x18\t\x20\x01(\rR\x0blicenseType\x12%\n\x0eterritory_code\x18\n\x20\
    \x01(\x05R\rterritoryCode\x12#\n\rchange_number\x18\x0b\x20\x01(\x05R\
    \x0cchangeNumber\x12\x19\n\x08owner_id\x18\x0c\x20\x01(\rR\x07ownerId\
    \x12%\n\x0einitial_period\x18\r\x20\x01(\rR\rinitialPeriod\x12*\n\x11ini\
    tial_time_unit\x18\x0e\x20\x01(\rR\x0finitialTimeUnit\x12%\n\x0erenewal_\
    period\x18\x0f\x20\x01(\rR\rrenewalPeriod\x12*\n\x11renewal_time_unit\
    \x18\x10\x20\x01(\rR\x0frenewalTimeUnit\x12!\n\x0caccess_token\x18\x11\
    \x20\x01(\x04R\x0baccessToken\x12*\n\x11master_package_id\x18\x12\x20\
    \x01(\rR\x0fmasterPackageId\"\x8c\x02\n\x1aCMsgClientIsLimitedAccount\
    \x12.\n\x13bis_limited_account\x18\x01\x20\x01(\x08R\x11bisLimitedAccoun\
    t\x120\n\x14bis_community_banned\x18\x02\x20\x01(\x08R\x12bisCommunityBa\
    nned\x12,\n\x12bis_locked_account\x18\x03\x20\x01(\x08R\x10bisLockedAcco\
    unt\x12^\n-bis_limited_account_allowed_to_invite_friends\x18\x04\x20\x01\
    (\x08R'bisLimitedAccountAllowedToInviteFriends\"\xd5\x01\n\x1eCMsgClient\
    RequestedClientStats\x12O\n\rstats_to_send\x18\x01\x20\x03(\x0b2+.CMsgCl\
    ientRequestedClientStats.StatsToSendR\x0bstatsToSend\x1ab\n\x0bStatsToSe\
    nd\x12\x1f\n\x0bclient_stat\x18\x01\x20\x01(\rR\nclientStat\x122\n\x15st\
    at_aggregate_method\x18\x02\x20\x01(\rR\x13statAggregateMethod\"\x85\x02\
    \n\x0fCMsgClientStat2\x12<\n\x0bstat_detail\x18\x01\x20\x03(\x0b2\x1b.CM\
    sgClientStat2.StatDetailR\nstatDetail\x1a\xb3\x01\n\nStatDetail\x12\x1f\
    \n\x0bclient_stat\x18\x01\x20\x01(\rR\nclientStat\x12\x19\n\x08ll_value\
    \x18\x02\x20\x01(\x03R\x07llValue\x12\x1e\n\x0btime_of_day\x18\x03\x20\
    \x01(\rR\ttimeOfDay\x12\x17\n\x07cell_id\x18\x04\x20\x01(\rR\x06cellId\
    \x12\x19\n\x08depot_id\x18\x05\x20\x01(\rR\x07depotId\x12\x15\n\x06app_i\
    d\x18\x06\x20\x01(\rR\x05appId\"\xa6\x01\n\x16CMsgClientInviteToGame\x12\
    \"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\x0bsteamIdDest\x12\x20\n\x0cst\
    eam_id_src\x18\x02\x20\x01(\x06R\nsteamIdSrc\x12%\n\x0econnect_string\
    \x18\x03\x20\x01(\tR\rconnectString\x12\x1f\n\x0bremote_play\x18\x04\x20\
    \x01(\tR\nremotePlay\"\x98\x02\n\x14CMsgClientChatInvite\x12(\n\x10steam\
    _id_invited\x18\x01\x20\x01(\x06R\x0esteamIdInvited\x12\"\n\rsteam_id_ch\
    at\x18\x02\x20\x01(\x06R\x0bsteamIdChat\x12&\n\x0fsteam_id_patron\x18\
    \x03\x20\x01(\x06R\rsteamIdPatron\x12#\n\rchatroom_type\x18\x04\x20\x01(\
    \x05R\x0cchatroomType\x12/\n\x14steam_id_friend_chat\x18\x05\x20\x01(\
    \x06R\x11steamIdFriendChat\x12\x1b\n\tchat_name\x18\x06\x20\x01(\tR\x08c\
    hatName\x12\x17\n\x07game_id\x18\x07\x20\x01(\x06R\x06gameId\"\xd2\r\n\
    \x19CMsgClientConnectionStats\x12G\n\x0bstats_logon\x18\x01\x20\x01(\x0b\
    2&.CMsgClientConnectionStats.Stats_LogonR\nstatsLogon\x12G\n\x0bstats_vc\
    onn\x18\x02\x20\x01(\x0b2&.CMsgClientConnectionStats.Stats_VConnR\nstats\
    Vconn\x1a\xae\x04\n\x0bStats_Logon\x12)\n\x10connect_attempts\x18\x01\
    \x20\x01(\x05R\x0fconnectAttempts\x12+\n\x11connect_successes\x18\x02\
    \x20\x01(\x05R\x10connectSuccesses\x12)\n\x10connect_failures\x18\x03\
    \x20\x01(\x05R\x0fconnectFailures\x12/\n\x13connections_dropped\x18\x04\
    \x20\x01(\x05R\x12connectionsDropped\x12'\n\x0fseconds_running\x18\x05\
    \x20\x01(\rR\x0esecondsRunning\x121\n\x14msec_tologonthistime\x18\x06\
    \x20\x01(\rR\x13msecTologonthistime\x12\"\n\rcount_bad_cms\x18\x07\x20\
    \x01(\rR\x0bcountBadCms\x12.\n\x13no_udp_connectivity\x18\x08\x20\x01(\
    \x08R\x11noUdpConnectivity\x12.\n\x13no_tcp_connectivity\x18\t\x20\x01(\
    \x08R\x11noTcpConnectivity\x12A\n\x1dno_websocket_443_connectivity\x18\n\
    \x20\x01(\x08R\x1anoWebsocket443Connectivity\x12H\n!no_websocket_non_443\
    _connectivity\x18\x0b\x20\x01(\x08R\x1dnoWebsocketNon443Connectivity\x1a\
    \xaa\x01\n\tStats_UDP\x12\x1b\n\tpkts_sent\x18\x01\x20\x01(\x04R\x08pkts\
    Sent\x12\x1d\n\nbytes_sent\x18\x02\x20\x01(\x04R\tbytesSent\x12\x1b\n\tp\
    kts_recv\x18\x03\x20\x01(\x04R\x08pktsRecv\x12%\n\x0epkts_processed\x18\
    \x04\x20\x01(\x04R\rpktsProcessed\x12\x1d\n\nbytes_recv\x18\x05\x20\x01(\
    \x04R\tbytesRecv\x1a\xc4\x06\n\x0bStats_VConn\x12'\n\x0fconnections_udp\
    \x18\x01\x20\x01(\rR\x0econnectionsUdp\x12'\n\x0fconnections_tcp\x18\x02\
    \x20\x01(\rR\x0econnectionsTcp\x12A\n\tstats_udp\x18\x03\x20\x01(\x0b2$.\
    CMsgClientConnectionStats.Stats_UDPR\x08statsUdp\x12%\n\x0epkts_abandone\
    d\x18\x04\x20\x01(\x04R\rpktsAbandoned\x12*\n\x11conn_req_received\x18\
    \x05\x20\x01(\x04R\x0fconnReqReceived\x12\x1f\n\x0bpkts_resent\x18\x06\
    \x20\x01(\x04R\npktsResent\x12\x1b\n\tmsgs_sent\x18\x07\x20\x01(\x04R\
    \x08msgsSent\x12(\n\x10msgs_sent_failed\x18\x08\x20\x01(\x04R\x0emsgsSen\
    tFailed\x12\x1b\n\tmsgs_recv\x18\t\x20\x01(\x04R\x08msgsRecv\x12%\n\x0ed\
    atagrams_sent\x18\n\x20\x01(\x04R\rdatagramsSent\x12%\n\x0edatagrams_rec\
    v\x18\x0b\x20\x01(\x04R\rdatagramsRecv\x12\"\n\rbad_pkts_recv\x18\x0c\
    \x20\x01(\x04R\x0bbadPktsRecv\x123\n\x16unknown_conn_pkts_recv\x18\r\x20\
    \x01(\x04R\x13unknownConnPktsRecv\x12(\n\x10missed_pkts_recv\x18\x0e\x20\
    \x01(\x04R\x0emissedPktsRecv\x12\"\n\rdup_pkts_recv\x18\x0f\x20\x01(\x04\
    R\x0bdupPktsRecv\x12:\n\x19failed_connect_challenges\x18\x10\x20\x01(\
    \x04R\x17failedConnectChallenges\x121\n\x15micro_sec_avg_latency\x18\x11\
    \x20\x01(\rR\x12microSecAvgLatency\x121\n\x15micro_sec_min_latency\x18\
    \x12\x20\x01(\rR\x12microSecMinLatency\x121\n\x15micro_sec_max_latency\
    \x18\x13\x20\x01(\rR\x12microSecMaxLatency\"\x94\x02\n\x1aCMsgClientServ\
    ersAvailable\x12h\n\x16server_types_available\x18\x01\x20\x03(\x0b22.CMs\
    gClientServersAvailable.Server_Types_AvailableR\x14serverTypesAvailable\
    \x12@\n\x1dserver_type_for_auth_services\x18\x02\x20\x01(\rR\x19serverTy\
    peForAuthServices\x1aJ\n\x16Server_Types_Available\x12\x16\n\x06server\
    \x18\x01\x20\x01(\rR\x06server\x12\x18\n\x07changed\x18\x02\x20\x01(\x08\
    R\x07changed\"O\n$CMsgClientReportOverlayDetourFailure\x12'\n\x0ffailure\
    _strings\x18\x01\x20\x03(\tR\x0efailureStrings\"X\n#CMsgClientRequestEnc\
    ryptedAppTicket\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1a\
    \n\x08userdata\x18\x02\x20\x01(\x0cR\x08userdata\"\xa8\x01\n+CMsgClientR\
    equestEncryptedAppTicketResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12\x1b\n\x07eresult\x18\x02\x20\x01(\x05:\x012R\x07eresult\
    \x12E\n\x14encrypted_app_ticket\x18\x03\x20\x01(\x0b2\x13.EncryptedAppTi\
    cketR\x12encryptedAppTicket\"\x87\x02\n\x1aCMsgClientWalletInfoUpdate\
    \x12\x1d\n\nhas_wallet\x18\x01\x20\x01(\x08R\thasWallet\x12\x18\n\x07bal\
    ance\x18\x02\x20\x01(\x05R\x07balance\x12\x1a\n\x08currency\x18\x03\x20\
    \x01(\x05R\x08currency\x12'\n\x0fbalance_delayed\x18\x04\x20\x01(\x05R\
    \x0ebalanceDelayed\x12\"\n\tbalance64\x18\x05\x20\x01(\x03R\tbalance64B\
    \x04\xa0\xb6\x18\x01\x121\n\x11balance64_delayed\x18\x06\x20\x01(\x03R\
    \x10balance64DelayedB\x04\xa0\xb6\x18\x01\x12\x14\n\x05realm\x18\x07\x20\
    \x01(\x05R\x05realm\"@\n\x1bCMsgClientAMGetClanOfficers\x12!\n\x0csteami\
    d_clan\x18\x01\x20\x01(\x06R\x0bsteamidClan\"\x8a\x01\n#CMsgClientAMGetC\
    lanOfficersResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07\
    eresult\x12!\n\x0csteamid_clan\x18\x02\x20\x01(\x06R\x0bsteamidClan\x12#\
    \n\rofficer_count\x18\x03\x20\x01(\x05R\x0cofficerCount\"\xa7\x01\n!CMsg\
    ClientAMGetPersonaNameHistory\x12\x19\n\x08id_count\x18\x01\x20\x01(\x05\
    R\x07idCount\x12?\n\x03Ids\x18\x02\x20\x03(\x0b2-.CMsgClientAMGetPersona\
    NameHistory.IdInstanceR\x03Ids\x1a&\n\nIdInstance\x12\x18\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamid\"\xf8\x02\n)CMsgClientAMGetPersonaName\
    HistoryResponse\x12Z\n\tresponses\x18\x02\x20\x03(\x0b2<.CMsgClientAMGet\
    PersonaNameHistoryResponse.NameTableInstanceR\tresponses\x1a\xee\x01\n\
    \x11NameTableInstance\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\x12_\n\
    \x05names\x18\x03\x20\x03(\x0b2I.CMsgClientAMGetPersonaNameHistoryRespon\
    se.NameTableInstance.NameInstanceR\x05names\x1aA\n\x0cNameInstance\x12\
    \x1d\n\nname_since\x18\x01\x20\x01(\x07R\tnameSince\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\"Y\n\x1eCMsgClientDeregisterWithServer\x12\
    \x20\n\x0beservertype\x18\x01\x20\x01(\rR\x0beservertype\x12\x15\n\x06ap\
    p_id\x18\x02\x20\x01(\rR\x05appId\"\x81\x06\n\x13CMsgClientClanState\x12\
    !\n\x0csteamid_clan\x18\x01\x20\x01(\x06R\x0bsteamidClan\x12,\n\x12clan_\
    account_flags\x18\x03\x20\x01(\rR\x10clanAccountFlags\x12:\n\tname_info\
    \x18\x04\x20\x01(\x0b2\x1d.CMsgClientClanState.NameInfoR\x08nameInfo\x12\
    @\n\x0buser_counts\x18\x05\x20\x01(\x0b2\x1f.CMsgClientClanState.UserCou\
    ntsR\nuserCounts\x122\n\x06events\x18\x06\x20\x03(\x0b2\x1a.CMsgClientCl\
    anState.EventR\x06events\x12@\n\rannouncements\x18\x07\x20\x03(\x0b2\x1a\
    .CMsgClientClanState.EventR\rannouncements\x12*\n\x11chat_room_private\
    \x18\x08\x20\x01(\x08R\x0fchatRoomPrivate\x1aF\n\x08NameInfo\x12\x1b\n\t\
    clan_name\x18\x01\x20\x01(\tR\x08clanName\x12\x1d\n\nsha_avatar\x18\x02\
    \x20\x01(\x0cR\tshaAvatar\x1a\x9f\x01\n\nUserCounts\x12\x18\n\x07members\
    \x18\x01\x20\x01(\rR\x07members\x12\x16\n\x06online\x18\x02\x20\x01(\rR\
    \x06online\x12\x1a\n\x08chatting\x18\x03\x20\x01(\rR\x08chatting\x12\x17\
    \n\x07in_game\x18\x04\x20\x01(\rR\x06inGame\x12*\n\x11chat_room_members\
    \x18\x05\x20\x01(\rR\x0fchatRoomMembers\x1a\x8e\x01\n\x05Event\x12\x10\n\
    \x03gid\x18\x01\x20\x01(\x06R\x03gid\x12\x1d\n\nevent_time\x18\x02\x20\
    \x01(\rR\teventTime\x12\x1a\n\x08headline\x18\x03\x20\x01(\tR\x08headlin\
    e\x12\x17\n\x07game_id\x18\x04\x20\x01(\x06R\x06gameId\x12\x1f\n\x0bjust\
    _posted\x18\x05\x20\x01(\x08R\njustPostedB\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::encrypted_app_ticket::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(52);
            messages.push(CMsgClientRegisterAuthTicketWithCM::generated_message_descriptor_data());
            messages.push(CMsgClientTicketAuthComplete::generated_message_descriptor_data());
            messages.push(CMsgClientCMList::generated_message_descriptor_data());
            messages.push(CMsgClientP2PConnectionInfo::generated_message_descriptor_data());
            messages.push(CMsgClientP2PConnectionFailInfo::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingCertRequest::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingCertReply::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingMobileCertRequest::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingMobileCertReply::generated_message_descriptor_data());
            messages.push(CMsgClientGetAppOwnershipTicket::generated_message_descriptor_data());
            messages.push(CMsgClientGetAppOwnershipTicketResponse::generated_message_descriptor_data());
            messages.push(CMsgClientSessionToken::generated_message_descriptor_data());
            messages.push(CMsgClientGameConnectTokens::generated_message_descriptor_data());
            messages.push(CMsgClientGamesPlayed::generated_message_descriptor_data());
            messages.push(CMsgGSApprove::generated_message_descriptor_data());
            messages.push(CMsgGSDeny::generated_message_descriptor_data());
            messages.push(CMsgGSKick::generated_message_descriptor_data());
            messages.push(CMsgClientAuthList::generated_message_descriptor_data());
            messages.push(CMsgClientAuthListAck::generated_message_descriptor_data());
            messages.push(CMsgClientLicenseList::generated_message_descriptor_data());
            messages.push(CMsgClientIsLimitedAccount::generated_message_descriptor_data());
            messages.push(CMsgClientRequestedClientStats::generated_message_descriptor_data());
            messages.push(CMsgClientStat2::generated_message_descriptor_data());
            messages.push(CMsgClientInviteToGame::generated_message_descriptor_data());
            messages.push(CMsgClientChatInvite::generated_message_descriptor_data());
            messages.push(CMsgClientConnectionStats::generated_message_descriptor_data());
            messages.push(CMsgClientServersAvailable::generated_message_descriptor_data());
            messages.push(CMsgClientReportOverlayDetourFailure::generated_message_descriptor_data());
            messages.push(CMsgClientRequestEncryptedAppTicket::generated_message_descriptor_data());
            messages.push(CMsgClientRequestEncryptedAppTicketResponse::generated_message_descriptor_data());
            messages.push(CMsgClientWalletInfoUpdate::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetClanOfficers::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetClanOfficersResponse::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetPersonaNameHistory::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetPersonaNameHistoryResponse::generated_message_descriptor_data());
            messages.push(CMsgClientDeregisterWithServer::generated_message_descriptor_data());
            messages.push(CMsgClientClanState::generated_message_descriptor_data());
            messages.push(cmsg_client_games_played::ProcessInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_games_played::GamePlayed::generated_message_descriptor_data());
            messages.push(cmsg_client_license_list::License::generated_message_descriptor_data());
            messages.push(cmsg_client_requested_client_stats::StatsToSend::generated_message_descriptor_data());
            messages.push(cmsg_client_stat2::StatDetail::generated_message_descriptor_data());
            messages.push(cmsg_client_connection_stats::Stats_Logon::generated_message_descriptor_data());
            messages.push(cmsg_client_connection_stats::Stats_UDP::generated_message_descriptor_data());
            messages.push(cmsg_client_connection_stats::Stats_VConn::generated_message_descriptor_data());
            messages.push(cmsg_client_servers_available::Server_Types_Available::generated_message_descriptor_data());
            messages.push(cmsg_client_amget_persona_name_history::IdInstance::generated_message_descriptor_data());
            messages.push(cmsg_client_amget_persona_name_history_response::NameTableInstance::generated_message_descriptor_data());
            messages.push(cmsg_client_amget_persona_name_history_response::name_table_instance::NameInstance::generated_message_descriptor_data());
            messages.push(cmsg_client_clan_state::NameInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_clan_state::UserCounts::generated_message_descriptor_data());
            messages.push(cmsg_client_clan_state::Event::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
