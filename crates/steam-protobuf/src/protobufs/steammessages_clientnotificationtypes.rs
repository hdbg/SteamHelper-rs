// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientnotificationtypes.proto`

// @@protoc_insertion_point(message:CClientNotificationCloudSyncFailure)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationCloudSyncFailure {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationCloudSyncFailure.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationCloudSyncFailure.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationCloudSyncFailure {
    fn default() -> &'a CClientNotificationCloudSyncFailure {
        <CClientNotificationCloudSyncFailure as crate::Message>::default_instance()
    }
}

impl CClientNotificationCloudSyncFailure {
    pub fn new() -> CClientNotificationCloudSyncFailure {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientNotificationCloudSyncFailure| { &m.appid },
            |m: &mut CClientNotificationCloudSyncFailure| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationCloudSyncFailure>(
            "CClientNotificationCloudSyncFailure",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationCloudSyncFailure {
    const NAME: &'static str = "CClientNotificationCloudSyncFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationCloudSyncFailure {
        CClientNotificationCloudSyncFailure::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationCloudSyncFailure {
        static instance: CClientNotificationCloudSyncFailure = CClientNotificationCloudSyncFailure {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationCloudSyncFailure {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationCloudSyncFailure").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationCloudSyncFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationCloudSyncFailure {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationCloudSyncConflict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationCloudSyncConflict {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationCloudSyncConflict.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationCloudSyncConflict.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationCloudSyncConflict {
    fn default() -> &'a CClientNotificationCloudSyncConflict {
        <CClientNotificationCloudSyncConflict as crate::Message>::default_instance()
    }
}

impl CClientNotificationCloudSyncConflict {
    pub fn new() -> CClientNotificationCloudSyncConflict {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientNotificationCloudSyncConflict| { &m.appid },
            |m: &mut CClientNotificationCloudSyncConflict| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationCloudSyncConflict>(
            "CClientNotificationCloudSyncConflict",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationCloudSyncConflict {
    const NAME: &'static str = "CClientNotificationCloudSyncConflict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationCloudSyncConflict {
        CClientNotificationCloudSyncConflict::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationCloudSyncConflict {
        static instance: CClientNotificationCloudSyncConflict = CClientNotificationCloudSyncConflict {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationCloudSyncConflict {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationCloudSyncConflict").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationCloudSyncConflict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationCloudSyncConflict {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationScreenshot.screenshot_handle)
    pub screenshot_handle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationScreenshot.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationScreenshot.local_url)
    pub local_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationScreenshot.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationScreenshot {
    fn default() -> &'a CClientNotificationScreenshot {
        <CClientNotificationScreenshot as crate::Message>::default_instance()
    }
}

impl CClientNotificationScreenshot {
    pub fn new() -> CClientNotificationScreenshot {
        ::std::default::Default::default()
    }

    // optional string screenshot_handle = 1;

    pub fn screenshot_handle(&self) -> &str {
        match self.screenshot_handle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_screenshot_handle(&mut self) {
        self.screenshot_handle = ::std::option::Option::None;
    }

    pub fn has_screenshot_handle(&self) -> bool {
        self.screenshot_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot_handle(&mut self, v: ::std::string::String) {
        self.screenshot_handle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot_handle(&mut self) -> &mut ::std::string::String {
        if self.screenshot_handle.is_none() {
            self.screenshot_handle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.screenshot_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot_handle(&mut self) -> ::std::string::String {
        self.screenshot_handle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 2;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string local_url = 3;

    pub fn local_url(&self) -> &str {
        match self.local_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_local_url(&mut self) {
        self.local_url = ::std::option::Option::None;
    }

    pub fn has_local_url(&self) -> bool {
        self.local_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_url(&mut self, v: ::std::string::String) {
        self.local_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_url(&mut self) -> &mut ::std::string::String {
        if self.local_url.is_none() {
            self.local_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.local_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_url(&mut self) -> ::std::string::String {
        self.local_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshot_handle",
            |m: &CClientNotificationScreenshot| { &m.screenshot_handle },
            |m: &mut CClientNotificationScreenshot| { &mut m.screenshot_handle },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CClientNotificationScreenshot| { &m.description },
            |m: &mut CClientNotificationScreenshot| { &mut m.description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_url",
            |m: &CClientNotificationScreenshot| { &m.local_url },
            |m: &mut CClientNotificationScreenshot| { &mut m.local_url },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationScreenshot>(
            "CClientNotificationScreenshot",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationScreenshot {
    const NAME: &'static str = "CClientNotificationScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.screenshot_handle = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.local_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshot_handle.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.local_url.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.screenshot_handle.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.local_url.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationScreenshot {
        CClientNotificationScreenshot::new()
    }

    fn clear(&mut self) {
        self.screenshot_handle = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.local_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationScreenshot {
        static instance: CClientNotificationScreenshot = CClientNotificationScreenshot {
            screenshot_handle: ::std::option::Option::None,
            description: ::std::option::Option::None,
            local_url: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationScreenshot {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationScreenshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationScreenshot {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationDownloadCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationDownloadCompleted {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationDownloadCompleted.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationDownloadCompleted.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationDownloadCompleted {
    fn default() -> &'a CClientNotificationDownloadCompleted {
        <CClientNotificationDownloadCompleted as crate::Message>::default_instance()
    }
}

impl CClientNotificationDownloadCompleted {
    pub fn new() -> CClientNotificationDownloadCompleted {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientNotificationDownloadCompleted| { &m.appid },
            |m: &mut CClientNotificationDownloadCompleted| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationDownloadCompleted>(
            "CClientNotificationDownloadCompleted",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationDownloadCompleted {
    const NAME: &'static str = "CClientNotificationDownloadCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationDownloadCompleted {
        CClientNotificationDownloadCompleted::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationDownloadCompleted {
        static instance: CClientNotificationDownloadCompleted = CClientNotificationDownloadCompleted {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationDownloadCompleted {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationDownloadCompleted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationDownloadCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationDownloadCompleted {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFriendInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendInvite {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendInvite.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendInvite.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendInvite {
    fn default() -> &'a CClientNotificationFriendInvite {
        <CClientNotificationFriendInvite as crate::Message>::default_instance()
    }
}

impl CClientNotificationFriendInvite {
    pub fn new() -> CClientNotificationFriendInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClientNotificationFriendInvite| { &m.steamid },
            |m: &mut CClientNotificationFriendInvite| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFriendInvite>(
            "CClientNotificationFriendInvite",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFriendInvite {
    const NAME: &'static str = "CClientNotificationFriendInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendInvite {
        CClientNotificationFriendInvite::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendInvite {
        static instance: CClientNotificationFriendInvite = CClientNotificationFriendInvite {
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFriendInvite {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFriendInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFriendInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFriendInvite {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFriendInviteRollup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendInviteRollup {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendInviteRollup.new_invite_count)
    pub new_invite_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendInviteRollup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendInviteRollup {
    fn default() -> &'a CClientNotificationFriendInviteRollup {
        <CClientNotificationFriendInviteRollup as crate::Message>::default_instance()
    }
}

impl CClientNotificationFriendInviteRollup {
    pub fn new() -> CClientNotificationFriendInviteRollup {
        ::std::default::Default::default()
    }

    // optional uint32 new_invite_count = 1;

    pub fn new_invite_count(&self) -> u32 {
        self.new_invite_count.unwrap_or(0)
    }

    pub fn clear_new_invite_count(&mut self) {
        self.new_invite_count = ::std::option::Option::None;
    }

    pub fn has_new_invite_count(&self) -> bool {
        self.new_invite_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_invite_count(&mut self, v: u32) {
        self.new_invite_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_invite_count",
            |m: &CClientNotificationFriendInviteRollup| { &m.new_invite_count },
            |m: &mut CClientNotificationFriendInviteRollup| { &mut m.new_invite_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFriendInviteRollup>(
            "CClientNotificationFriendInviteRollup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFriendInviteRollup {
    const NAME: &'static str = "CClientNotificationFriendInviteRollup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_invite_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_invite_count {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.new_invite_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendInviteRollup {
        CClientNotificationFriendInviteRollup::new()
    }

    fn clear(&mut self) {
        self.new_invite_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendInviteRollup {
        static instance: CClientNotificationFriendInviteRollup = CClientNotificationFriendInviteRollup {
            new_invite_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFriendInviteRollup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFriendInviteRollup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFriendInviteRollup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFriendInviteRollup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFriendInGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendInGame {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendInGame.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientNotificationFriendInGame.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendInGame.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendInGame {
    fn default() -> &'a CClientNotificationFriendInGame {
        <CClientNotificationFriendInGame as crate::Message>::default_instance()
    }
}

impl CClientNotificationFriendInGame {
    pub fn new() -> CClientNotificationFriendInGame {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClientNotificationFriendInGame| { &m.steamid },
            |m: &mut CClientNotificationFriendInGame| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &CClientNotificationFriendInGame| { &m.game_name },
            |m: &mut CClientNotificationFriendInGame| { &mut m.game_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFriendInGame>(
            "CClientNotificationFriendInGame",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFriendInGame {
    const NAME: &'static str = "CClientNotificationFriendInGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendInGame {
        CClientNotificationFriendInGame::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendInGame {
        static instance: CClientNotificationFriendInGame = CClientNotificationFriendInGame {
            steamid: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFriendInGame {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFriendInGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFriendInGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFriendInGame {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFriendOnline)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendOnline {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendOnline.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendOnline.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendOnline {
    fn default() -> &'a CClientNotificationFriendOnline {
        <CClientNotificationFriendOnline as crate::Message>::default_instance()
    }
}

impl CClientNotificationFriendOnline {
    pub fn new() -> CClientNotificationFriendOnline {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClientNotificationFriendOnline| { &m.steamid },
            |m: &mut CClientNotificationFriendOnline| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFriendOnline>(
            "CClientNotificationFriendOnline",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFriendOnline {
    const NAME: &'static str = "CClientNotificationFriendOnline";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendOnline {
        CClientNotificationFriendOnline::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendOnline {
        static instance: CClientNotificationFriendOnline = CClientNotificationFriendOnline {
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFriendOnline {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFriendOnline").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFriendOnline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFriendOnline {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationAchievement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationAchievement {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationAchievement.achievement_id)
    pub achievement_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.image_url)
    pub image_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.achieved)
    pub achieved: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.rtime_unlocked)
    pub rtime_unlocked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.min_progress)
    pub min_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.current_progress)
    pub current_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.max_progress)
    pub max_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.global_achieved_pct)
    pub global_achieved_pct: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationAchievement.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationAchievement {
    fn default() -> &'a CClientNotificationAchievement {
        <CClientNotificationAchievement as crate::Message>::default_instance()
    }
}

impl CClientNotificationAchievement {
    pub fn new() -> CClientNotificationAchievement {
        ::std::default::Default::default()
    }

    // optional string achievement_id = 1;

    pub fn achievement_id(&self) -> &str {
        match self.achievement_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_achievement_id(&mut self) {
        self.achievement_id = ::std::option::Option::None;
    }

    pub fn has_achievement_id(&self) -> bool {
        self.achievement_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement_id(&mut self, v: ::std::string::String) {
        self.achievement_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement_id(&mut self) -> &mut ::std::string::String {
        if self.achievement_id.is_none() {
            self.achievement_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.achievement_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement_id(&mut self) -> ::std::string::String {
        self.achievement_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image_url = 5;

    pub fn image_url(&self) -> &str {
        match self.image_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image_url(&mut self) {
        self.image_url = ::std::option::Option::None;
    }

    pub fn has_image_url(&self) -> bool {
        self.image_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_url(&mut self, v: ::std::string::String) {
        self.image_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
        if self.image_url.is_none() {
            self.image_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_url(&mut self) -> ::std::string::String {
        self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool achieved = 6;

    pub fn achieved(&self) -> bool {
        self.achieved.unwrap_or(false)
    }

    pub fn clear_achieved(&mut self) {
        self.achieved = ::std::option::Option::None;
    }

    pub fn has_achieved(&self) -> bool {
        self.achieved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achieved(&mut self, v: bool) {
        self.achieved = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_unlocked = 7;

    pub fn rtime_unlocked(&self) -> u32 {
        self.rtime_unlocked.unwrap_or(0)
    }

    pub fn clear_rtime_unlocked(&mut self) {
        self.rtime_unlocked = ::std::option::Option::None;
    }

    pub fn has_rtime_unlocked(&self) -> bool {
        self.rtime_unlocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_unlocked(&mut self, v: u32) {
        self.rtime_unlocked = ::std::option::Option::Some(v);
    }

    // optional float min_progress = 8;

    pub fn min_progress(&self) -> f32 {
        self.min_progress.unwrap_or(0.)
    }

    pub fn clear_min_progress(&mut self) {
        self.min_progress = ::std::option::Option::None;
    }

    pub fn has_min_progress(&self) -> bool {
        self.min_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_progress(&mut self, v: f32) {
        self.min_progress = ::std::option::Option::Some(v);
    }

    // optional float current_progress = 9;

    pub fn current_progress(&self) -> f32 {
        self.current_progress.unwrap_or(0.)
    }

    pub fn clear_current_progress(&mut self) {
        self.current_progress = ::std::option::Option::None;
    }

    pub fn has_current_progress(&self) -> bool {
        self.current_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_progress(&mut self, v: f32) {
        self.current_progress = ::std::option::Option::Some(v);
    }

    // optional float max_progress = 10;

    pub fn max_progress(&self) -> f32 {
        self.max_progress.unwrap_or(0.)
    }

    pub fn clear_max_progress(&mut self) {
        self.max_progress = ::std::option::Option::None;
    }

    pub fn has_max_progress(&self) -> bool {
        self.max_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_progress(&mut self, v: f32) {
        self.max_progress = ::std::option::Option::Some(v);
    }

    // optional float global_achieved_pct = 11;

    pub fn global_achieved_pct(&self) -> f32 {
        self.global_achieved_pct.unwrap_or(0.)
    }

    pub fn clear_global_achieved_pct(&mut self) {
        self.global_achieved_pct = ::std::option::Option::None;
    }

    pub fn has_global_achieved_pct(&self) -> bool {
        self.global_achieved_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_achieved_pct(&mut self, v: f32) {
        self.global_achieved_pct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "achievement_id",
            |m: &CClientNotificationAchievement| { &m.achievement_id },
            |m: &mut CClientNotificationAchievement| { &mut m.achievement_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientNotificationAchievement| { &m.appid },
            |m: &mut CClientNotificationAchievement| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CClientNotificationAchievement| { &m.name },
            |m: &mut CClientNotificationAchievement| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CClientNotificationAchievement| { &m.description },
            |m: &mut CClientNotificationAchievement| { &mut m.description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_url",
            |m: &CClientNotificationAchievement| { &m.image_url },
            |m: &mut CClientNotificationAchievement| { &mut m.image_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "achieved",
            |m: &CClientNotificationAchievement| { &m.achieved },
            |m: &mut CClientNotificationAchievement| { &mut m.achieved },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_unlocked",
            |m: &CClientNotificationAchievement| { &m.rtime_unlocked },
            |m: &mut CClientNotificationAchievement| { &mut m.rtime_unlocked },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_progress",
            |m: &CClientNotificationAchievement| { &m.min_progress },
            |m: &mut CClientNotificationAchievement| { &mut m.min_progress },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_progress",
            |m: &CClientNotificationAchievement| { &m.current_progress },
            |m: &mut CClientNotificationAchievement| { &mut m.current_progress },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_progress",
            |m: &CClientNotificationAchievement| { &m.max_progress },
            |m: &mut CClientNotificationAchievement| { &mut m.max_progress },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "global_achieved_pct",
            |m: &CClientNotificationAchievement| { &m.global_achieved_pct },
            |m: &mut CClientNotificationAchievement| { &mut m.global_achieved_pct },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationAchievement>(
            "CClientNotificationAchievement",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationAchievement {
    const NAME: &'static str = "CClientNotificationAchievement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.achievement_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.image_url = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.achieved = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.rtime_unlocked = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.min_progress = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.current_progress = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.max_progress = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.global_achieved_pct = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement_id.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.image_url.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.achieved {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rtime_unlocked {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.min_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.current_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.global_achieved_pct {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.achievement_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.image_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.achieved {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.rtime_unlocked {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.min_progress {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.current_progress {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.max_progress {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.global_achieved_pct {
            os.write_float(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationAchievement {
        CClientNotificationAchievement::new()
    }

    fn clear(&mut self) {
        self.achievement_id = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.image_url = ::std::option::Option::None;
        self.achieved = ::std::option::Option::None;
        self.rtime_unlocked = ::std::option::Option::None;
        self.min_progress = ::std::option::Option::None;
        self.current_progress = ::std::option::Option::None;
        self.max_progress = ::std::option::Option::None;
        self.global_achieved_pct = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationAchievement {
        static instance: CClientNotificationAchievement = CClientNotificationAchievement {
            achievement_id: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            description: ::std::option::Option::None,
            image_url: ::std::option::Option::None,
            achieved: ::std::option::Option::None,
            rtime_unlocked: ::std::option::Option::None,
            min_progress: ::std::option::Option::None,
            current_progress: ::std::option::Option::None,
            max_progress: ::std::option::Option::None,
            global_achieved_pct: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationAchievement {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationAchievement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationAchievement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationAchievement {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationLowBattery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationLowBattery {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationLowBattery.pct_remaining)
    pub pct_remaining: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationLowBattery.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationLowBattery {
    fn default() -> &'a CClientNotificationLowBattery {
        <CClientNotificationLowBattery as crate::Message>::default_instance()
    }
}

impl CClientNotificationLowBattery {
    pub fn new() -> CClientNotificationLowBattery {
        ::std::default::Default::default()
    }

    // optional float pct_remaining = 1;

    pub fn pct_remaining(&self) -> f32 {
        self.pct_remaining.unwrap_or(0.)
    }

    pub fn clear_pct_remaining(&mut self) {
        self.pct_remaining = ::std::option::Option::None;
    }

    pub fn has_pct_remaining(&self) -> bool {
        self.pct_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pct_remaining(&mut self, v: f32) {
        self.pct_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pct_remaining",
            |m: &CClientNotificationLowBattery| { &m.pct_remaining },
            |m: &mut CClientNotificationLowBattery| { &mut m.pct_remaining },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationLowBattery>(
            "CClientNotificationLowBattery",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationLowBattery {
    const NAME: &'static str = "CClientNotificationLowBattery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.pct_remaining = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pct_remaining {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.pct_remaining {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationLowBattery {
        CClientNotificationLowBattery::new()
    }

    fn clear(&mut self) {
        self.pct_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationLowBattery {
        static instance: CClientNotificationLowBattery = CClientNotificationLowBattery {
            pct_remaining: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationLowBattery {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationLowBattery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationLowBattery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationLowBattery {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationSystemUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationSystemUpdate {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationSystemUpdate.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<ESystemUpdateNotificationType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationSystemUpdate.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationSystemUpdate {
    fn default() -> &'a CClientNotificationSystemUpdate {
        <CClientNotificationSystemUpdate as crate::Message>::default_instance()
    }
}

impl CClientNotificationSystemUpdate {
    pub fn new() -> CClientNotificationSystemUpdate {
        ::std::default::Default::default()
    }

    // optional .ESystemUpdateNotificationType type = 1;

    pub fn type_(&self) -> ESystemUpdateNotificationType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid),
            None => ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESystemUpdateNotificationType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CClientNotificationSystemUpdate| { &m.type_ },
            |m: &mut CClientNotificationSystemUpdate| { &mut m.type_ },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationSystemUpdate>(
            "CClientNotificationSystemUpdate",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationSystemUpdate {
    const NAME: &'static str = "CClientNotificationSystemUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationSystemUpdate {
        CClientNotificationSystemUpdate::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationSystemUpdate {
        static instance: CClientNotificationSystemUpdate = CClientNotificationSystemUpdate {
            type_: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationSystemUpdate {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationSystemUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationSystemUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationSystemUpdate {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFriendMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendMessage {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.tag)
    pub tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.steamid)
    pub steamid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.notificationid)
    pub notificationid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.response_steamurl)
    pub response_steamurl: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendMessage.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendMessage {
    fn default() -> &'a CClientNotificationFriendMessage {
        <CClientNotificationFriendMessage as crate::Message>::default_instance()
    }
}

impl CClientNotificationFriendMessage {
    pub fn new() -> CClientNotificationFriendMessage {
        ::std::default::Default::default()
    }

    // optional string tag = 1;

    pub fn tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string steamid = 2;

    pub fn steamid(&self) -> &str {
        match self.steamid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: ::std::string::String) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamid(&mut self) -> &mut ::std::string::String {
        if self.steamid.is_none() {
            self.steamid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.steamid.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamid(&mut self) -> ::std::string::String {
        self.steamid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 4;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 5;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 notificationid = 6;

    pub fn notificationid(&self) -> u32 {
        self.notificationid.unwrap_or(0)
    }

    pub fn clear_notificationid(&mut self) {
        self.notificationid = ::std::option::Option::None;
    }

    pub fn has_notificationid(&self) -> bool {
        self.notificationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notificationid(&mut self, v: u32) {
        self.notificationid = ::std::option::Option::Some(v);
    }

    // optional string response_steamurl = 7;

    pub fn response_steamurl(&self) -> &str {
        match self.response_steamurl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_response_steamurl(&mut self) {
        self.response_steamurl = ::std::option::Option::None;
    }

    pub fn has_response_steamurl(&self) -> bool {
        self.response_steamurl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_steamurl(&mut self, v: ::std::string::String) {
        self.response_steamurl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_steamurl(&mut self) -> &mut ::std::string::String {
        if self.response_steamurl.is_none() {
            self.response_steamurl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.response_steamurl.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_steamurl(&mut self) -> ::std::string::String {
        self.response_steamurl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &CClientNotificationFriendMessage| { &m.tag },
            |m: &mut CClientNotificationFriendMessage| { &mut m.tag },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClientNotificationFriendMessage| { &m.steamid },
            |m: &mut CClientNotificationFriendMessage| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CClientNotificationFriendMessage| { &m.title },
            |m: &mut CClientNotificationFriendMessage| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CClientNotificationFriendMessage| { &m.body },
            |m: &mut CClientNotificationFriendMessage| { &mut m.body },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CClientNotificationFriendMessage| { &m.icon },
            |m: &mut CClientNotificationFriendMessage| { &mut m.icon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "notificationid",
            |m: &CClientNotificationFriendMessage| { &m.notificationid },
            |m: &mut CClientNotificationFriendMessage| { &mut m.notificationid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_steamurl",
            |m: &CClientNotificationFriendMessage| { &m.response_steamurl },
            |m: &mut CClientNotificationFriendMessage| { &mut m.response_steamurl },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFriendMessage>(
            "CClientNotificationFriendMessage",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFriendMessage {
    const NAME: &'static str = "CClientNotificationFriendMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.steamid = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.notificationid = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.response_steamurl = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.notificationid {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.response_steamurl.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.tag.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.notificationid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.response_steamurl.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendMessage {
        CClientNotificationFriendMessage::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.notificationid = ::std::option::Option::None;
        self.response_steamurl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendMessage {
        static instance: CClientNotificationFriendMessage = CClientNotificationFriendMessage {
            tag: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            body: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            notificationid: ::std::option::Option::None,
            response_steamurl: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFriendMessage {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFriendMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFriendMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFriendMessage {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationGroupChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationGroupChatMessage {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.tag)
    pub tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.steamid_sender)
    pub steamid_sender: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.chat_group_id)
    pub chat_group_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.chat_id)
    pub chat_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.rawbody)
    pub rawbody: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.notificationid)
    pub notificationid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationGroupChatMessage.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationGroupChatMessage {
    fn default() -> &'a CClientNotificationGroupChatMessage {
        <CClientNotificationGroupChatMessage as crate::Message>::default_instance()
    }
}

impl CClientNotificationGroupChatMessage {
    pub fn new() -> CClientNotificationGroupChatMessage {
        ::std::default::Default::default()
    }

    // optional string tag = 1;

    pub fn tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string steamid_sender = 2;

    pub fn steamid_sender(&self) -> &str {
        match self.steamid_sender.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: ::std::string::String) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamid_sender(&mut self) -> &mut ::std::string::String {
        if self.steamid_sender.is_none() {
            self.steamid_sender = ::std::option::Option::Some(::std::string::String::new());
        }
        self.steamid_sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamid_sender(&mut self) -> ::std::string::String {
        self.steamid_sender.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_group_id = 3;

    pub fn chat_group_id(&self) -> &str {
        match self.chat_group_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: ::std::string::String) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_id(&mut self) -> &mut ::std::string::String {
        if self.chat_group_id.is_none() {
            self.chat_group_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_id(&mut self) -> ::std::string::String {
        self.chat_group_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_id = 4;

    pub fn chat_id(&self) -> &str {
        match self.chat_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: ::std::string::String) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_id(&mut self) -> &mut ::std::string::String {
        if self.chat_id.is_none() {
            self.chat_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_id(&mut self) -> ::std::string::String {
        self.chat_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 6;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rawbody = 7;

    pub fn rawbody(&self) -> &str {
        match self.rawbody.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rawbody(&mut self) {
        self.rawbody = ::std::option::Option::None;
    }

    pub fn has_rawbody(&self) -> bool {
        self.rawbody.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawbody(&mut self, v: ::std::string::String) {
        self.rawbody = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawbody(&mut self) -> &mut ::std::string::String {
        if self.rawbody.is_none() {
            self.rawbody = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rawbody.as_mut().unwrap()
    }

    // Take field
    pub fn take_rawbody(&mut self) -> ::std::string::String {
        self.rawbody.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 8;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 notificationid = 9;

    pub fn notificationid(&self) -> u32 {
        self.notificationid.unwrap_or(0)
    }

    pub fn clear_notificationid(&mut self) {
        self.notificationid = ::std::option::Option::None;
    }

    pub fn has_notificationid(&self) -> bool {
        self.notificationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notificationid(&mut self, v: u32) {
        self.notificationid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &CClientNotificationGroupChatMessage| { &m.tag },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.tag },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_sender",
            |m: &CClientNotificationGroupChatMessage| { &m.steamid_sender },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.steamid_sender },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CClientNotificationGroupChatMessage| { &m.chat_group_id },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CClientNotificationGroupChatMessage| { &m.chat_id },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CClientNotificationGroupChatMessage| { &m.title },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CClientNotificationGroupChatMessage| { &m.body },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.body },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rawbody",
            |m: &CClientNotificationGroupChatMessage| { &m.rawbody },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.rawbody },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CClientNotificationGroupChatMessage| { &m.icon },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.icon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "notificationid",
            |m: &CClientNotificationGroupChatMessage| { &m.notificationid },
            |m: &mut CClientNotificationGroupChatMessage| { &mut m.notificationid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationGroupChatMessage>(
            "CClientNotificationGroupChatMessage",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationGroupChatMessage {
    const NAME: &'static str = "CClientNotificationGroupChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.chat_id = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.rawbody = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.notificationid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid_sender.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_group_id.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.chat_id.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.rawbody.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.notificationid {
            my_size += crate::rt::uint32_size(9, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.tag.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid_sender.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat_group_id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.chat_id.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.rawbody.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.notificationid {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationGroupChatMessage {
        CClientNotificationGroupChatMessage::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.steamid_sender = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.rawbody = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.notificationid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationGroupChatMessage {
        static instance: CClientNotificationGroupChatMessage = CClientNotificationGroupChatMessage {
            tag: ::std::option::Option::None,
            steamid_sender: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            body: ::std::option::Option::None,
            rawbody: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            notificationid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationGroupChatMessage {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationGroupChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationGroupChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationGroupChatMessage {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFamilySharingDeviceAuthorizationChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFamilySharingDeviceAuthorizationChanged {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingDeviceAuthorizationChanged.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingDeviceAuthorizationChanged.authorized)
    pub authorized: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFamilySharingDeviceAuthorizationChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFamilySharingDeviceAuthorizationChanged {
    fn default() -> &'a CClientNotificationFamilySharingDeviceAuthorizationChanged {
        <CClientNotificationFamilySharingDeviceAuthorizationChanged as crate::Message>::default_instance()
    }
}

impl CClientNotificationFamilySharingDeviceAuthorizationChanged {
    pub fn new() -> CClientNotificationFamilySharingDeviceAuthorizationChanged {
        ::std::default::Default::default()
    }

    // optional uint32 accountid_owner = 1;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional bool authorized = 2;

    pub fn authorized(&self) -> bool {
        self.authorized.unwrap_or(false)
    }

    pub fn clear_authorized(&mut self) {
        self.authorized = ::std::option::Option::None;
    }

    pub fn has_authorized(&self) -> bool {
        self.authorized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized(&mut self, v: bool) {
        self.authorized = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_owner",
            |m: &CClientNotificationFamilySharingDeviceAuthorizationChanged| { &m.accountid_owner },
            |m: &mut CClientNotificationFamilySharingDeviceAuthorizationChanged| { &mut m.accountid_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "authorized",
            |m: &CClientNotificationFamilySharingDeviceAuthorizationChanged| { &m.authorized },
            |m: &mut CClientNotificationFamilySharingDeviceAuthorizationChanged| { &mut m.authorized },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFamilySharingDeviceAuthorizationChanged>(
            "CClientNotificationFamilySharingDeviceAuthorizationChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFamilySharingDeviceAuthorizationChanged {
    const NAME: &'static str = "CClientNotificationFamilySharingDeviceAuthorizationChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.authorized = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid_owner {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.authorized {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.accountid_owner {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.authorized {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFamilySharingDeviceAuthorizationChanged {
        CClientNotificationFamilySharingDeviceAuthorizationChanged::new()
    }

    fn clear(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
        self.authorized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFamilySharingDeviceAuthorizationChanged {
        static instance: CClientNotificationFamilySharingDeviceAuthorizationChanged = CClientNotificationFamilySharingDeviceAuthorizationChanged {
            accountid_owner: ::std::option::Option::None,
            authorized: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFamilySharingDeviceAuthorizationChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFamilySharingDeviceAuthorizationChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFamilySharingDeviceAuthorizationChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFamilySharingDeviceAuthorizationChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFamilySharingStopPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFamilySharingStopPlaying {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingStopPlaying.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingStopPlaying.seconds_remaining)
    pub seconds_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingStopPlaying.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFamilySharingStopPlaying.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFamilySharingStopPlaying {
    fn default() -> &'a CClientNotificationFamilySharingStopPlaying {
        <CClientNotificationFamilySharingStopPlaying as crate::Message>::default_instance()
    }
}

impl CClientNotificationFamilySharingStopPlaying {
    pub fn new() -> CClientNotificationFamilySharingStopPlaying {
        ::std::default::Default::default()
    }

    // optional uint32 accountid_owner = 1;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_remaining = 2;

    pub fn seconds_remaining(&self) -> u32 {
        self.seconds_remaining.unwrap_or(0)
    }

    pub fn clear_seconds_remaining(&mut self) {
        self.seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_seconds_remaining(&self) -> bool {
        self.seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_remaining(&mut self, v: u32) {
        self.seconds_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 3;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_owner",
            |m: &CClientNotificationFamilySharingStopPlaying| { &m.accountid_owner },
            |m: &mut CClientNotificationFamilySharingStopPlaying| { &mut m.accountid_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_remaining",
            |m: &CClientNotificationFamilySharingStopPlaying| { &m.seconds_remaining },
            |m: &mut CClientNotificationFamilySharingStopPlaying| { &mut m.seconds_remaining },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientNotificationFamilySharingStopPlaying| { &m.appid },
            |m: &mut CClientNotificationFamilySharingStopPlaying| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFamilySharingStopPlaying>(
            "CClientNotificationFamilySharingStopPlaying",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFamilySharingStopPlaying {
    const NAME: &'static str = "CClientNotificationFamilySharingStopPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.seconds_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid_owner {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.seconds_remaining {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.accountid_owner {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seconds_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFamilySharingStopPlaying {
        CClientNotificationFamilySharingStopPlaying::new()
    }

    fn clear(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
        self.seconds_remaining = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFamilySharingStopPlaying {
        static instance: CClientNotificationFamilySharingStopPlaying = CClientNotificationFamilySharingStopPlaying {
            accountid_owner: ::std::option::Option::None,
            seconds_remaining: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFamilySharingStopPlaying {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFamilySharingStopPlaying").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFamilySharingStopPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFamilySharingStopPlaying {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationFamilySharingLibraryAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFamilySharingLibraryAvailable {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingLibraryAvailable.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFamilySharingLibraryAvailable.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFamilySharingLibraryAvailable {
    fn default() -> &'a CClientNotificationFamilySharingLibraryAvailable {
        <CClientNotificationFamilySharingLibraryAvailable as crate::Message>::default_instance()
    }
}

impl CClientNotificationFamilySharingLibraryAvailable {
    pub fn new() -> CClientNotificationFamilySharingLibraryAvailable {
        ::std::default::Default::default()
    }

    // optional uint32 accountid_owner = 1;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_owner",
            |m: &CClientNotificationFamilySharingLibraryAvailable| { &m.accountid_owner },
            |m: &mut CClientNotificationFamilySharingLibraryAvailable| { &mut m.accountid_owner },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationFamilySharingLibraryAvailable>(
            "CClientNotificationFamilySharingLibraryAvailable",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationFamilySharingLibraryAvailable {
    const NAME: &'static str = "CClientNotificationFamilySharingLibraryAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid_owner {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.accountid_owner {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFamilySharingLibraryAvailable {
        CClientNotificationFamilySharingLibraryAvailable::new()
    }

    fn clear(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFamilySharingLibraryAvailable {
        static instance: CClientNotificationFamilySharingLibraryAvailable = CClientNotificationFamilySharingLibraryAvailable {
            accountid_owner: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationFamilySharingLibraryAvailable {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationFamilySharingLibraryAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationFamilySharingLibraryAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationFamilySharingLibraryAvailable {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationIncomingVoiceChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationIncomingVoiceChat {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationIncomingVoiceChat.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationIncomingVoiceChat.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationIncomingVoiceChat {
    fn default() -> &'a CClientNotificationIncomingVoiceChat {
        <CClientNotificationIncomingVoiceChat as crate::Message>::default_instance()
    }
}

impl CClientNotificationIncomingVoiceChat {
    pub fn new() -> CClientNotificationIncomingVoiceChat {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClientNotificationIncomingVoiceChat| { &m.steamid },
            |m: &mut CClientNotificationIncomingVoiceChat| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationIncomingVoiceChat>(
            "CClientNotificationIncomingVoiceChat",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationIncomingVoiceChat {
    const NAME: &'static str = "CClientNotificationIncomingVoiceChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationIncomingVoiceChat {
        CClientNotificationIncomingVoiceChat::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationIncomingVoiceChat {
        static instance: CClientNotificationIncomingVoiceChat = CClientNotificationIncomingVoiceChat {
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationIncomingVoiceChat {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationIncomingVoiceChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationIncomingVoiceChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationIncomingVoiceChat {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationClaimSteamDeckRewards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationClaimSteamDeckRewards {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationClaimSteamDeckRewards.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationClaimSteamDeckRewards {
    fn default() -> &'a CClientNotificationClaimSteamDeckRewards {
        <CClientNotificationClaimSteamDeckRewards as crate::Message>::default_instance()
    }
}

impl CClientNotificationClaimSteamDeckRewards {
    pub fn new() -> CClientNotificationClaimSteamDeckRewards {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationClaimSteamDeckRewards>(
            "CClientNotificationClaimSteamDeckRewards",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationClaimSteamDeckRewards {
    const NAME: &'static str = "CClientNotificationClaimSteamDeckRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationClaimSteamDeckRewards {
        CClientNotificationClaimSteamDeckRewards::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationClaimSteamDeckRewards {
        static instance: CClientNotificationClaimSteamDeckRewards = CClientNotificationClaimSteamDeckRewards {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationClaimSteamDeckRewards {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationClaimSteamDeckRewards").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationClaimSteamDeckRewards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationClaimSteamDeckRewards {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationGiftReceived)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationGiftReceived {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationGiftReceived.sender_name)
    pub sender_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationGiftReceived.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationGiftReceived {
    fn default() -> &'a CClientNotificationGiftReceived {
        <CClientNotificationGiftReceived as crate::Message>::default_instance()
    }
}

impl CClientNotificationGiftReceived {
    pub fn new() -> CClientNotificationGiftReceived {
        ::std::default::Default::default()
    }

    // optional string sender_name = 1;

    pub fn sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sender_name(&mut self) {
        self.sender_name = ::std::option::Option::None;
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_name",
            |m: &CClientNotificationGiftReceived| { &m.sender_name },
            |m: &mut CClientNotificationGiftReceived| { &mut m.sender_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationGiftReceived>(
            "CClientNotificationGiftReceived",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationGiftReceived {
    const NAME: &'static str = "CClientNotificationGiftReceived";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sender_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sender_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.sender_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationGiftReceived {
        CClientNotificationGiftReceived::new()
    }

    fn clear(&mut self) {
        self.sender_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationGiftReceived {
        static instance: CClientNotificationGiftReceived = CClientNotificationGiftReceived {
            sender_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationGiftReceived {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationGiftReceived").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationGiftReceived {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationGiftReceived {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationItemAnnouncement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationItemAnnouncement {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationItemAnnouncement.new_item_count)
    pub new_item_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationItemAnnouncement.new_backpack_items)
    pub new_backpack_items: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationItemAnnouncement.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationItemAnnouncement {
    fn default() -> &'a CClientNotificationItemAnnouncement {
        <CClientNotificationItemAnnouncement as crate::Message>::default_instance()
    }
}

impl CClientNotificationItemAnnouncement {
    pub fn new() -> CClientNotificationItemAnnouncement {
        ::std::default::Default::default()
    }

    // optional uint32 new_item_count = 1;

    pub fn new_item_count(&self) -> u32 {
        self.new_item_count.unwrap_or(0)
    }

    pub fn clear_new_item_count(&mut self) {
        self.new_item_count = ::std::option::Option::None;
    }

    pub fn has_new_item_count(&self) -> bool {
        self.new_item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_item_count(&mut self, v: u32) {
        self.new_item_count = ::std::option::Option::Some(v);
    }

    // optional bool new_backpack_items = 2;

    pub fn new_backpack_items(&self) -> bool {
        self.new_backpack_items.unwrap_or(false)
    }

    pub fn clear_new_backpack_items(&mut self) {
        self.new_backpack_items = ::std::option::Option::None;
    }

    pub fn has_new_backpack_items(&self) -> bool {
        self.new_backpack_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_backpack_items(&mut self, v: bool) {
        self.new_backpack_items = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_item_count",
            |m: &CClientNotificationItemAnnouncement| { &m.new_item_count },
            |m: &mut CClientNotificationItemAnnouncement| { &mut m.new_item_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_backpack_items",
            |m: &CClientNotificationItemAnnouncement| { &m.new_backpack_items },
            |m: &mut CClientNotificationItemAnnouncement| { &mut m.new_backpack_items },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationItemAnnouncement>(
            "CClientNotificationItemAnnouncement",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationItemAnnouncement {
    const NAME: &'static str = "CClientNotificationItemAnnouncement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.new_backpack_items = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_item_count {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.new_backpack_items {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.new_item_count {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_backpack_items {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationItemAnnouncement {
        CClientNotificationItemAnnouncement::new()
    }

    fn clear(&mut self) {
        self.new_item_count = ::std::option::Option::None;
        self.new_backpack_items = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationItemAnnouncement {
        static instance: CClientNotificationItemAnnouncement = CClientNotificationItemAnnouncement {
            new_item_count: ::std::option::Option::None,
            new_backpack_items: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationItemAnnouncement {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationItemAnnouncement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationItemAnnouncement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationItemAnnouncement {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationHardwareSurveyPending)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationHardwareSurveyPending {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationHardwareSurveyPending.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationHardwareSurveyPending {
    fn default() -> &'a CClientNotificationHardwareSurveyPending {
        <CClientNotificationHardwareSurveyPending as crate::Message>::default_instance()
    }
}

impl CClientNotificationHardwareSurveyPending {
    pub fn new() -> CClientNotificationHardwareSurveyPending {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationHardwareSurveyPending>(
            "CClientNotificationHardwareSurveyPending",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationHardwareSurveyPending {
    const NAME: &'static str = "CClientNotificationHardwareSurveyPending";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationHardwareSurveyPending {
        CClientNotificationHardwareSurveyPending::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationHardwareSurveyPending {
        static instance: CClientNotificationHardwareSurveyPending = CClientNotificationHardwareSurveyPending {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationHardwareSurveyPending {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationHardwareSurveyPending").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationHardwareSurveyPending {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationHardwareSurveyPending {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationLowDiskSpace)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationLowDiskSpace {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationLowDiskSpace.folder_index)
    pub folder_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationLowDiskSpace.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationLowDiskSpace {
    fn default() -> &'a CClientNotificationLowDiskSpace {
        <CClientNotificationLowDiskSpace as crate::Message>::default_instance()
    }
}

impl CClientNotificationLowDiskSpace {
    pub fn new() -> CClientNotificationLowDiskSpace {
        ::std::default::Default::default()
    }

    // optional uint32 folder_index = 1;

    pub fn folder_index(&self) -> u32 {
        self.folder_index.unwrap_or(0)
    }

    pub fn clear_folder_index(&mut self) {
        self.folder_index = ::std::option::Option::None;
    }

    pub fn has_folder_index(&self) -> bool {
        self.folder_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_folder_index(&mut self, v: u32) {
        self.folder_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "folder_index",
            |m: &CClientNotificationLowDiskSpace| { &m.folder_index },
            |m: &mut CClientNotificationLowDiskSpace| { &mut m.folder_index },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationLowDiskSpace>(
            "CClientNotificationLowDiskSpace",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationLowDiskSpace {
    const NAME: &'static str = "CClientNotificationLowDiskSpace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.folder_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.folder_index {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.folder_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationLowDiskSpace {
        CClientNotificationLowDiskSpace::new()
    }

    fn clear(&mut self) {
        self.folder_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationLowDiskSpace {
        static instance: CClientNotificationLowDiskSpace = CClientNotificationLowDiskSpace {
            folder_index: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationLowDiskSpace {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationLowDiskSpace").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationLowDiskSpace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationLowDiskSpace {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationBatteryTemperature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationBatteryTemperature {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationBatteryTemperature.temperature)
    pub temperature: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationBatteryTemperature.notification_type)
    pub notification_type: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationBatteryTemperature.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationBatteryTemperature {
    fn default() -> &'a CClientNotificationBatteryTemperature {
        <CClientNotificationBatteryTemperature as crate::Message>::default_instance()
    }
}

impl CClientNotificationBatteryTemperature {
    pub fn new() -> CClientNotificationBatteryTemperature {
        ::std::default::Default::default()
    }

    // optional uint32 temperature = 1;

    pub fn temperature(&self) -> u32 {
        self.temperature.unwrap_or(0)
    }

    pub fn clear_temperature(&mut self) {
        self.temperature = ::std::option::Option::None;
    }

    pub fn has_temperature(&self) -> bool {
        self.temperature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: u32) {
        self.temperature = ::std::option::Option::Some(v);
    }

    // optional string notification_type = 2;

    pub fn notification_type(&self) -> &str {
        match self.notification_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_type(&mut self) {
        self.notification_type = ::std::option::Option::None;
    }

    pub fn has_notification_type(&self) -> bool {
        self.notification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_type(&mut self, v: ::std::string::String) {
        self.notification_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_type(&mut self) -> &mut ::std::string::String {
        if self.notification_type.is_none() {
            self.notification_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_type(&mut self) -> ::std::string::String {
        self.notification_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "temperature",
            |m: &CClientNotificationBatteryTemperature| { &m.temperature },
            |m: &mut CClientNotificationBatteryTemperature| { &mut m.temperature },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_type",
            |m: &CClientNotificationBatteryTemperature| { &m.notification_type },
            |m: &mut CClientNotificationBatteryTemperature| { &mut m.notification_type },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationBatteryTemperature>(
            "CClientNotificationBatteryTemperature",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationBatteryTemperature {
    const NAME: &'static str = "CClientNotificationBatteryTemperature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.temperature = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.notification_type = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.temperature {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.notification_type.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.temperature {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.notification_type.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationBatteryTemperature {
        CClientNotificationBatteryTemperature::new()
    }

    fn clear(&mut self) {
        self.temperature = ::std::option::Option::None;
        self.notification_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationBatteryTemperature {
        static instance: CClientNotificationBatteryTemperature = CClientNotificationBatteryTemperature {
            temperature: ::std::option::Option::None,
            notification_type: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationBatteryTemperature {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationBatteryTemperature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationBatteryTemperature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationBatteryTemperature {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationDockUnsupportedFirmware)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationDockUnsupportedFirmware {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationDockUnsupportedFirmware.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationDockUnsupportedFirmware {
    fn default() -> &'a CClientNotificationDockUnsupportedFirmware {
        <CClientNotificationDockUnsupportedFirmware as crate::Message>::default_instance()
    }
}

impl CClientNotificationDockUnsupportedFirmware {
    pub fn new() -> CClientNotificationDockUnsupportedFirmware {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationDockUnsupportedFirmware>(
            "CClientNotificationDockUnsupportedFirmware",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationDockUnsupportedFirmware {
    const NAME: &'static str = "CClientNotificationDockUnsupportedFirmware";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationDockUnsupportedFirmware {
        CClientNotificationDockUnsupportedFirmware::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationDockUnsupportedFirmware {
        static instance: CClientNotificationDockUnsupportedFirmware = CClientNotificationDockUnsupportedFirmware {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationDockUnsupportedFirmware {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationDockUnsupportedFirmware").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationDockUnsupportedFirmware {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationDockUnsupportedFirmware {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationPeerContentUpload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationPeerContentUpload {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationPeerContentUpload.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationPeerContentUpload.peer_name)
    pub peer_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationPeerContentUpload.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationPeerContentUpload {
    fn default() -> &'a CClientNotificationPeerContentUpload {
        <CClientNotificationPeerContentUpload as crate::Message>::default_instance()
    }
}

impl CClientNotificationPeerContentUpload {
    pub fn new() -> CClientNotificationPeerContentUpload {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string peer_name = 2;

    pub fn peer_name(&self) -> &str {
        match self.peer_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_peer_name(&mut self) {
        self.peer_name = ::std::option::Option::None;
    }

    pub fn has_peer_name(&self) -> bool {
        self.peer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_name(&mut self, v: ::std::string::String) {
        self.peer_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_name(&mut self) -> &mut ::std::string::String {
        if self.peer_name.is_none() {
            self.peer_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.peer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_name(&mut self) -> ::std::string::String {
        self.peer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientNotificationPeerContentUpload| { &m.appid },
            |m: &mut CClientNotificationPeerContentUpload| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "peer_name",
            |m: &CClientNotificationPeerContentUpload| { &m.peer_name },
            |m: &mut CClientNotificationPeerContentUpload| { &mut m.peer_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationPeerContentUpload>(
            "CClientNotificationPeerContentUpload",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationPeerContentUpload {
    const NAME: &'static str = "CClientNotificationPeerContentUpload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.peer_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.peer_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.peer_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationPeerContentUpload {
        CClientNotificationPeerContentUpload::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.peer_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationPeerContentUpload {
        static instance: CClientNotificationPeerContentUpload = CClientNotificationPeerContentUpload {
            appid: ::std::option::Option::None,
            peer_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationPeerContentUpload {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationPeerContentUpload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationPeerContentUpload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationPeerContentUpload {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationCannotReadControllerGuideButton)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationCannotReadControllerGuideButton {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationCannotReadControllerGuideButton.controller_index)
    pub controller_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationCannotReadControllerGuideButton.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationCannotReadControllerGuideButton {
    fn default() -> &'a CClientNotificationCannotReadControllerGuideButton {
        <CClientNotificationCannotReadControllerGuideButton as crate::Message>::default_instance()
    }
}

impl CClientNotificationCannotReadControllerGuideButton {
    pub fn new() -> CClientNotificationCannotReadControllerGuideButton {
        ::std::default::Default::default()
    }

    // optional int32 controller_index = 1;

    pub fn controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_index",
            |m: &CClientNotificationCannotReadControllerGuideButton| { &m.controller_index },
            |m: &mut CClientNotificationCannotReadControllerGuideButton| { &mut m.controller_index },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationCannotReadControllerGuideButton>(
            "CClientNotificationCannotReadControllerGuideButton",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationCannotReadControllerGuideButton {
    const NAME: &'static str = "CClientNotificationCannotReadControllerGuideButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationCannotReadControllerGuideButton {
        CClientNotificationCannotReadControllerGuideButton::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationCannotReadControllerGuideButton {
        static instance: CClientNotificationCannotReadControllerGuideButton = CClientNotificationCannotReadControllerGuideButton {
            controller_index: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationCannotReadControllerGuideButton {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationCannotReadControllerGuideButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationCannotReadControllerGuideButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationCannotReadControllerGuideButton {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationOverlaySplashScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationOverlaySplashScreen {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationOverlaySplashScreen.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationOverlaySplashScreen {
    fn default() -> &'a CClientNotificationOverlaySplashScreen {
        <CClientNotificationOverlaySplashScreen as crate::Message>::default_instance()
    }
}

impl CClientNotificationOverlaySplashScreen {
    pub fn new() -> CClientNotificationOverlaySplashScreen {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationOverlaySplashScreen>(
            "CClientNotificationOverlaySplashScreen",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationOverlaySplashScreen {
    const NAME: &'static str = "CClientNotificationOverlaySplashScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationOverlaySplashScreen {
        CClientNotificationOverlaySplashScreen::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationOverlaySplashScreen {
        static instance: CClientNotificationOverlaySplashScreen = CClientNotificationOverlaySplashScreen {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationOverlaySplashScreen {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationOverlaySplashScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationOverlaySplashScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationOverlaySplashScreen {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationBroadcastAvailableToWatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationBroadcastAvailableToWatch {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationBroadcastAvailableToWatch.broadcast_permission)
    pub broadcast_permission: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationBroadcastAvailableToWatch.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationBroadcastAvailableToWatch {
    fn default() -> &'a CClientNotificationBroadcastAvailableToWatch {
        <CClientNotificationBroadcastAvailableToWatch as crate::Message>::default_instance()
    }
}

impl CClientNotificationBroadcastAvailableToWatch {
    pub fn new() -> CClientNotificationBroadcastAvailableToWatch {
        ::std::default::Default::default()
    }

    // optional int32 broadcast_permission = 1;

    pub fn broadcast_permission(&self) -> i32 {
        self.broadcast_permission.unwrap_or(0)
    }

    pub fn clear_broadcast_permission(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_permission(&self) -> bool {
        self.broadcast_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permission(&mut self, v: i32) {
        self.broadcast_permission = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_permission",
            |m: &CClientNotificationBroadcastAvailableToWatch| { &m.broadcast_permission },
            |m: &mut CClientNotificationBroadcastAvailableToWatch| { &mut m.broadcast_permission },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationBroadcastAvailableToWatch>(
            "CClientNotificationBroadcastAvailableToWatch",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationBroadcastAvailableToWatch {
    const NAME: &'static str = "CClientNotificationBroadcastAvailableToWatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_permission = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_permission {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_permission {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationBroadcastAvailableToWatch {
        CClientNotificationBroadcastAvailableToWatch::new()
    }

    fn clear(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationBroadcastAvailableToWatch {
        static instance: CClientNotificationBroadcastAvailableToWatch = CClientNotificationBroadcastAvailableToWatch {
            broadcast_permission: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationBroadcastAvailableToWatch {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationBroadcastAvailableToWatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationBroadcastAvailableToWatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationBroadcastAvailableToWatch {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationTimedTrialRemaining)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationTimedTrialRemaining {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.offline)
    pub offline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.allowed_seconds)
    pub allowed_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.played_seconds)
    pub played_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationTimedTrialRemaining.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationTimedTrialRemaining {
    fn default() -> &'a CClientNotificationTimedTrialRemaining {
        <CClientNotificationTimedTrialRemaining as crate::Message>::default_instance()
    }
}

impl CClientNotificationTimedTrialRemaining {
    pub fn new() -> CClientNotificationTimedTrialRemaining {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool offline = 3;

    pub fn offline(&self) -> bool {
        self.offline.unwrap_or(false)
    }

    pub fn clear_offline(&mut self) {
        self.offline = ::std::option::Option::None;
    }

    pub fn has_offline(&self) -> bool {
        self.offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline(&mut self, v: bool) {
        self.offline = ::std::option::Option::Some(v);
    }

    // optional uint32 allowed_seconds = 4;

    pub fn allowed_seconds(&self) -> u32 {
        self.allowed_seconds.unwrap_or(0)
    }

    pub fn clear_allowed_seconds(&mut self) {
        self.allowed_seconds = ::std::option::Option::None;
    }

    pub fn has_allowed_seconds(&self) -> bool {
        self.allowed_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_seconds(&mut self, v: u32) {
        self.allowed_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 played_seconds = 5;

    pub fn played_seconds(&self) -> u32 {
        self.played_seconds.unwrap_or(0)
    }

    pub fn clear_played_seconds(&mut self) {
        self.played_seconds = ::std::option::Option::None;
    }

    pub fn has_played_seconds(&self) -> bool {
        self.played_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_played_seconds(&mut self, v: u32) {
        self.played_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientNotificationTimedTrialRemaining| { &m.appid },
            |m: &mut CClientNotificationTimedTrialRemaining| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CClientNotificationTimedTrialRemaining| { &m.icon },
            |m: &mut CClientNotificationTimedTrialRemaining| { &mut m.icon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offline",
            |m: &CClientNotificationTimedTrialRemaining| { &m.offline },
            |m: &mut CClientNotificationTimedTrialRemaining| { &mut m.offline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allowed_seconds",
            |m: &CClientNotificationTimedTrialRemaining| { &m.allowed_seconds },
            |m: &mut CClientNotificationTimedTrialRemaining| { &mut m.allowed_seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "played_seconds",
            |m: &CClientNotificationTimedTrialRemaining| { &m.played_seconds },
            |m: &mut CClientNotificationTimedTrialRemaining| { &mut m.played_seconds },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationTimedTrialRemaining>(
            "CClientNotificationTimedTrialRemaining",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationTimedTrialRemaining {
    const NAME: &'static str = "CClientNotificationTimedTrialRemaining";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.offline = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.allowed_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.played_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.offline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allowed_seconds {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.played_seconds {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.offline {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.allowed_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.played_seconds {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationTimedTrialRemaining {
        CClientNotificationTimedTrialRemaining::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.offline = ::std::option::Option::None;
        self.allowed_seconds = ::std::option::Option::None;
        self.played_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationTimedTrialRemaining {
        static instance: CClientNotificationTimedTrialRemaining = CClientNotificationTimedTrialRemaining {
            appid: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            offline: ::std::option::Option::None,
            allowed_seconds: ::std::option::Option::None,
            played_seconds: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationTimedTrialRemaining {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationTimedTrialRemaining").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationTimedTrialRemaining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationTimedTrialRemaining {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationLoginRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationLoginRefresh {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationLoginRefresh.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationLoginRefresh {
    fn default() -> &'a CClientNotificationLoginRefresh {
        <CClientNotificationLoginRefresh as crate::Message>::default_instance()
    }
}

impl CClientNotificationLoginRefresh {
    pub fn new() -> CClientNotificationLoginRefresh {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationLoginRefresh>(
            "CClientNotificationLoginRefresh",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationLoginRefresh {
    const NAME: &'static str = "CClientNotificationLoginRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationLoginRefresh {
        CClientNotificationLoginRefresh::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationLoginRefresh {
        static instance: CClientNotificationLoginRefresh = CClientNotificationLoginRefresh {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationLoginRefresh {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationLoginRefresh").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationLoginRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationLoginRefresh {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationTimerExpired)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationTimerExpired {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationTimerExpired.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationTimerExpired {
    fn default() -> &'a CClientNotificationTimerExpired {
        <CClientNotificationTimerExpired as crate::Message>::default_instance()
    }
}

impl CClientNotificationTimerExpired {
    pub fn new() -> CClientNotificationTimerExpired {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationTimerExpired>(
            "CClientNotificationTimerExpired",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationTimerExpired {
    const NAME: &'static str = "CClientNotificationTimerExpired";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationTimerExpired {
        CClientNotificationTimerExpired::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationTimerExpired {
        static instance: CClientNotificationTimerExpired = CClientNotificationTimerExpired {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationTimerExpired {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationTimerExpired").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationTimerExpired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationTimerExpired {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationSteamInputActionSetChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationSteamInputActionSetChanged {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationSteamInputActionSetChanged.controller_index)
    pub controller_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CClientNotificationSteamInputActionSetChanged.action_set_name)
    pub action_set_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationSteamInputActionSetChanged.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationSteamInputActionSetChanged {
    fn default() -> &'a CClientNotificationSteamInputActionSetChanged {
        <CClientNotificationSteamInputActionSetChanged as crate::Message>::default_instance()
    }
}

impl CClientNotificationSteamInputActionSetChanged {
    pub fn new() -> CClientNotificationSteamInputActionSetChanged {
        ::std::default::Default::default()
    }

    // optional int32 controller_index = 1;

    pub fn controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional string action_set_name = 2;

    pub fn action_set_name(&self) -> &str {
        match self.action_set_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_action_set_name(&mut self) {
        self.action_set_name = ::std::option::Option::None;
    }

    pub fn has_action_set_name(&self) -> bool {
        self.action_set_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_set_name(&mut self, v: ::std::string::String) {
        self.action_set_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_set_name(&mut self) -> &mut ::std::string::String {
        if self.action_set_name.is_none() {
            self.action_set_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.action_set_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_set_name(&mut self) -> ::std::string::String {
        self.action_set_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_index",
            |m: &CClientNotificationSteamInputActionSetChanged| { &m.controller_index },
            |m: &mut CClientNotificationSteamInputActionSetChanged| { &mut m.controller_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "action_set_name",
            |m: &CClientNotificationSteamInputActionSetChanged| { &m.action_set_name },
            |m: &mut CClientNotificationSteamInputActionSetChanged| { &mut m.action_set_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationSteamInputActionSetChanged>(
            "CClientNotificationSteamInputActionSetChanged",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationSteamInputActionSetChanged {
    const NAME: &'static str = "CClientNotificationSteamInputActionSetChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.action_set_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.action_set_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.action_set_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationSteamInputActionSetChanged {
        CClientNotificationSteamInputActionSetChanged::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.action_set_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationSteamInputActionSetChanged {
        static instance: CClientNotificationSteamInputActionSetChanged = CClientNotificationSteamInputActionSetChanged {
            controller_index: ::std::option::Option::None,
            action_set_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationSteamInputActionSetChanged {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationSteamInputActionSetChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationSteamInputActionSetChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationSteamInputActionSetChanged {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationRemoteClientConnection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationRemoteClientConnection {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationRemoteClientConnection.machine)
    pub machine: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationRemoteClientConnection.connected)
    pub connected: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationRemoteClientConnection.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationRemoteClientConnection {
    fn default() -> &'a CClientNotificationRemoteClientConnection {
        <CClientNotificationRemoteClientConnection as crate::Message>::default_instance()
    }
}

impl CClientNotificationRemoteClientConnection {
    pub fn new() -> CClientNotificationRemoteClientConnection {
        ::std::default::Default::default()
    }

    // optional string machine = 1;

    pub fn machine(&self) -> &str {
        match self.machine.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine(&mut self) {
        self.machine = ::std::option::Option::None;
    }

    pub fn has_machine(&self) -> bool {
        self.machine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine(&mut self, v: ::std::string::String) {
        self.machine = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine(&mut self) -> &mut ::std::string::String {
        if self.machine.is_none() {
            self.machine = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine(&mut self) -> ::std::string::String {
        self.machine.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool connected = 2;

    pub fn connected(&self) -> bool {
        self.connected.unwrap_or(false)
    }

    pub fn clear_connected(&mut self) {
        self.connected = ::std::option::Option::None;
    }

    pub fn has_connected(&self) -> bool {
        self.connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: bool) {
        self.connected = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine",
            |m: &CClientNotificationRemoteClientConnection| { &m.machine },
            |m: &mut CClientNotificationRemoteClientConnection| { &mut m.machine },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connected",
            |m: &CClientNotificationRemoteClientConnection| { &m.connected },
            |m: &mut CClientNotificationRemoteClientConnection| { &mut m.connected },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationRemoteClientConnection>(
            "CClientNotificationRemoteClientConnection",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationRemoteClientConnection {
    const NAME: &'static str = "CClientNotificationRemoteClientConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.machine = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.connected = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.machine.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.connected {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.machine.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.connected {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationRemoteClientConnection {
        CClientNotificationRemoteClientConnection::new()
    }

    fn clear(&mut self) {
        self.machine = ::std::option::Option::None;
        self.connected = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationRemoteClientConnection {
        static instance: CClientNotificationRemoteClientConnection = CClientNotificationRemoteClientConnection {
            machine: ::std::option::Option::None,
            connected: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationRemoteClientConnection {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationRemoteClientConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationRemoteClientConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationRemoteClientConnection {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationRemoteClientStartStream)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationRemoteClientStartStream {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationRemoteClientStartStream.machine)
    pub machine: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationRemoteClientStartStream.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationRemoteClientStartStream.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationRemoteClientStartStream {
    fn default() -> &'a CClientNotificationRemoteClientStartStream {
        <CClientNotificationRemoteClientStartStream as crate::Message>::default_instance()
    }
}

impl CClientNotificationRemoteClientStartStream {
    pub fn new() -> CClientNotificationRemoteClientStartStream {
        ::std::default::Default::default()
    }

    // optional string machine = 1;

    pub fn machine(&self) -> &str {
        match self.machine.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine(&mut self) {
        self.machine = ::std::option::Option::None;
    }

    pub fn has_machine(&self) -> bool {
        self.machine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine(&mut self, v: ::std::string::String) {
        self.machine = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine(&mut self) -> &mut ::std::string::String {
        if self.machine.is_none() {
            self.machine = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine(&mut self) -> ::std::string::String {
        self.machine.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine",
            |m: &CClientNotificationRemoteClientStartStream| { &m.machine },
            |m: &mut CClientNotificationRemoteClientStartStream| { &mut m.machine },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &CClientNotificationRemoteClientStartStream| { &m.game_name },
            |m: &mut CClientNotificationRemoteClientStartStream| { &mut m.game_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationRemoteClientStartStream>(
            "CClientNotificationRemoteClientStartStream",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationRemoteClientStartStream {
    const NAME: &'static str = "CClientNotificationRemoteClientStartStream";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.machine = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.machine.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.machine.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationRemoteClientStartStream {
        CClientNotificationRemoteClientStartStream::new()
    }

    fn clear(&mut self) {
        self.machine = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationRemoteClientStartStream {
        static instance: CClientNotificationRemoteClientStartStream = CClientNotificationRemoteClientStartStream {
            machine: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationRemoteClientStartStream {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationRemoteClientStartStream").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationRemoteClientStartStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationRemoteClientStartStream {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationStreamingClientConnection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationStreamingClientConnection {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationStreamingClientConnection.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationStreamingClientConnection.machine)
    pub machine: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationStreamingClientConnection.connected)
    pub connected: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationStreamingClientConnection.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationStreamingClientConnection {
    fn default() -> &'a CClientNotificationStreamingClientConnection {
        <CClientNotificationStreamingClientConnection as crate::Message>::default_instance()
    }
}

impl CClientNotificationStreamingClientConnection {
    pub fn new() -> CClientNotificationStreamingClientConnection {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine = 2;

    pub fn machine(&self) -> &str {
        match self.machine.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine(&mut self) {
        self.machine = ::std::option::Option::None;
    }

    pub fn has_machine(&self) -> bool {
        self.machine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine(&mut self, v: ::std::string::String) {
        self.machine = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine(&mut self) -> &mut ::std::string::String {
        if self.machine.is_none() {
            self.machine = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine(&mut self) -> ::std::string::String {
        self.machine.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool connected = 3;

    pub fn connected(&self) -> bool {
        self.connected.unwrap_or(false)
    }

    pub fn clear_connected(&mut self) {
        self.connected = ::std::option::Option::None;
    }

    pub fn has_connected(&self) -> bool {
        self.connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: bool) {
        self.connected = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &CClientNotificationStreamingClientConnection| { &m.hostname },
            |m: &mut CClientNotificationStreamingClientConnection| { &mut m.hostname },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine",
            |m: &CClientNotificationStreamingClientConnection| { &m.machine },
            |m: &mut CClientNotificationStreamingClientConnection| { &mut m.machine },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connected",
            |m: &CClientNotificationStreamingClientConnection| { &m.connected },
            |m: &mut CClientNotificationStreamingClientConnection| { &mut m.connected },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationStreamingClientConnection>(
            "CClientNotificationStreamingClientConnection",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationStreamingClientConnection {
    const NAME: &'static str = "CClientNotificationStreamingClientConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.machine = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.connected = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hostname.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.machine.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.connected {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.machine.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.connected {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationStreamingClientConnection {
        CClientNotificationStreamingClientConnection::new()
    }

    fn clear(&mut self) {
        self.hostname = ::std::option::Option::None;
        self.machine = ::std::option::Option::None;
        self.connected = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationStreamingClientConnection {
        static instance: CClientNotificationStreamingClientConnection = CClientNotificationStreamingClientConnection {
            hostname: ::std::option::Option::None,
            machine: ::std::option::Option::None,
            connected: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationStreamingClientConnection {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationStreamingClientConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationStreamingClientConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationStreamingClientConnection {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientNotificationPlaytimeWarning)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationPlaytimeWarning {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationPlaytimeWarning.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationPlaytimeWarning.playtime_remaining)
    pub playtime_remaining: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationPlaytimeWarning.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationPlaytimeWarning {
    fn default() -> &'a CClientNotificationPlaytimeWarning {
        <CClientNotificationPlaytimeWarning as crate::Message>::default_instance()
    }
}

impl CClientNotificationPlaytimeWarning {
    pub fn new() -> CClientNotificationPlaytimeWarning {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 playtime_remaining = 2;

    pub fn playtime_remaining(&self) -> u32 {
        self.playtime_remaining.unwrap_or(0)
    }

    pub fn clear_playtime_remaining(&mut self) {
        self.playtime_remaining = ::std::option::Option::None;
    }

    pub fn has_playtime_remaining(&self) -> bool {
        self.playtime_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_remaining(&mut self, v: u32) {
        self.playtime_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CClientNotificationPlaytimeWarning| { &m.type_ },
            |m: &mut CClientNotificationPlaytimeWarning| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "playtime_remaining",
            |m: &CClientNotificationPlaytimeWarning| { &m.playtime_remaining },
            |m: &mut CClientNotificationPlaytimeWarning| { &mut m.playtime_remaining },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientNotificationPlaytimeWarning>(
            "CClientNotificationPlaytimeWarning",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientNotificationPlaytimeWarning {
    const NAME: &'static str = "CClientNotificationPlaytimeWarning";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.playtime_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.playtime_remaining {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.playtime_remaining {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationPlaytimeWarning {
        CClientNotificationPlaytimeWarning::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.playtime_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationPlaytimeWarning {
        static instance: CClientNotificationPlaytimeWarning = CClientNotificationPlaytimeWarning {
            type_: ::std::option::Option::None,
            playtime_remaining: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientNotificationPlaytimeWarning {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientNotificationPlaytimeWarning").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientNotificationPlaytimeWarning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientNotificationPlaytimeWarning {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EClientNotificationType)
pub enum EClientNotificationType {
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Invalid)
    k_EClientNotificationType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_DownloadCompleted)
    k_EClientNotificationType_DownloadCompleted = 1,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendInvite)
    k_EClientNotificationType_FriendInvite = 2,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendInGame)
    k_EClientNotificationType_FriendInGame = 3,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendOnline)
    k_EClientNotificationType_FriendOnline = 4,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Achievement)
    k_EClientNotificationType_Achievement = 5,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_LowBattery)
    k_EClientNotificationType_LowBattery = 6,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_SystemUpdate)
    k_EClientNotificationType_SystemUpdate = 7,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendMessage)
    k_EClientNotificationType_FriendMessage = 8,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_GroupChatMessage)
    k_EClientNotificationType_GroupChatMessage = 9,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendInviteRollup)
    k_EClientNotificationType_FriendInviteRollup = 10,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged)
    k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged = 11,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilySharingStopPlaying)
    k_EClientNotificationType_FamilySharingStopPlaying = 12,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilySharingLibraryAvailable)
    k_EClientNotificationType_FamilySharingLibraryAvailable = 13,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Screenshot)
    k_EClientNotificationType_Screenshot = 14,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_CloudSyncFailure)
    k_EClientNotificationType_CloudSyncFailure = 15,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_CloudSyncConflict)
    k_EClientNotificationType_CloudSyncConflict = 16,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_IncomingVoiceChat)
    k_EClientNotificationType_IncomingVoiceChat = 17,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ClaimSteamDeckRewards)
    k_EClientNotificationType_ClaimSteamDeckRewards = 18,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_GiftReceived)
    k_EClientNotificationType_GiftReceived = 19,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ItemAnnouncement)
    k_EClientNotificationType_ItemAnnouncement = 20,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_HardwareSurvey)
    k_EClientNotificationType_HardwareSurvey = 21,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_LowDiskSpace)
    k_EClientNotificationType_LowDiskSpace = 22,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_BatteryTemperature)
    k_EClientNotificationType_BatteryTemperature = 23,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_DockUnsupportedFirmware)
    k_EClientNotificationType_DockUnsupportedFirmware = 24,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_PeerContentUpload)
    k_EClientNotificationType_PeerContentUpload = 25,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_CannotReadControllerGuideButton)
    k_EClientNotificationType_CannotReadControllerGuideButton = 26,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Comment)
    k_EClientNotificationType_Comment = 27,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Wishlist)
    k_EClientNotificationType_Wishlist = 28,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_TradeOffer)
    k_EClientNotificationType_TradeOffer = 29,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_AsyncGame)
    k_EClientNotificationType_AsyncGame = 30,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_General)
    k_EClientNotificationType_General = 31,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_HelpRequest)
    k_EClientNotificationType_HelpRequest = 32,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_OverlaySplashScreen)
    k_EClientNotificationType_OverlaySplashScreen = 33,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_BroadcastAvailableToWatch)
    k_EClientNotificationType_BroadcastAvailableToWatch = 34,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_TimedTrialRemaining)
    k_EClientNotificationType_TimedTrialRemaining = 35,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_LoginRefresh)
    k_EClientNotificationType_LoginRefresh = 36,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_MajorSale)
    k_EClientNotificationType_MajorSale = 37,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_TimerExpired)
    k_EClientNotificationType_TimerExpired = 38,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ModeratorMsg)
    k_EClientNotificationType_ModeratorMsg = 39,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_SteamInputActionSetChanged)
    k_EClientNotificationType_SteamInputActionSetChanged = 40,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_RemoteClientConnection)
    k_EClientNotificationType_RemoteClientConnection = 41,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_RemoteClientStartStream)
    k_EClientNotificationType_RemoteClientStartStream = 42,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_StreamingClientConnection)
    k_EClientNotificationType_StreamingClientConnection = 43,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilyInvite)
    k_EClientNotificationType_FamilyInvite = 44,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_PlaytimeWarning)
    k_EClientNotificationType_PlaytimeWarning = 45,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilyPurchaseRequest)
    k_EClientNotificationType_FamilyPurchaseRequest = 46,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilyPurchaseRequestResponse)
    k_EClientNotificationType_FamilyPurchaseRequestResponse = 47,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ParentalFeatureRequest)
    k_EClientNotificationType_ParentalFeatureRequest = 48,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ParentalPlaytimeRequest)
    k_EClientNotificationType_ParentalPlaytimeRequest = 49,
}

impl crate::Enum for EClientNotificationType {
    const NAME: &'static str = "EClientNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EClientNotificationType> {
        match value {
            0 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Invalid),
            1 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DownloadCompleted),
            2 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInvite),
            3 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInGame),
            4 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendOnline),
            5 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Achievement),
            6 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowBattery),
            7 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SystemUpdate),
            8 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendMessage),
            9 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GroupChatMessage),
            10 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInviteRollup),
            11 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged),
            12 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingStopPlaying),
            13 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingLibraryAvailable),
            14 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Screenshot),
            15 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncFailure),
            16 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncConflict),
            17 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_IncomingVoiceChat),
            18 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ClaimSteamDeckRewards),
            19 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GiftReceived),
            20 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ItemAnnouncement),
            21 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HardwareSurvey),
            22 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowDiskSpace),
            23 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BatteryTemperature),
            24 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DockUnsupportedFirmware),
            25 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_PeerContentUpload),
            26 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CannotReadControllerGuideButton),
            27 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Comment),
            28 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Wishlist),
            29 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TradeOffer),
            30 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_AsyncGame),
            31 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_General),
            32 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HelpRequest),
            33 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_OverlaySplashScreen),
            34 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BroadcastAvailableToWatch),
            35 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimedTrialRemaining),
            36 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LoginRefresh),
            37 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_MajorSale),
            38 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimerExpired),
            39 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ModeratorMsg),
            40 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SteamInputActionSetChanged),
            41 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_RemoteClientConnection),
            42 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_RemoteClientStartStream),
            43 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_StreamingClientConnection),
            44 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilyInvite),
            45 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_PlaytimeWarning),
            46 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilyPurchaseRequest),
            47 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilyPurchaseRequestResponse),
            48 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ParentalFeatureRequest),
            49 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ParentalPlaytimeRequest),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EClientNotificationType> {
        match str {
            "k_EClientNotificationType_Invalid" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Invalid),
            "k_EClientNotificationType_DownloadCompleted" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DownloadCompleted),
            "k_EClientNotificationType_FriendInvite" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInvite),
            "k_EClientNotificationType_FriendInGame" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInGame),
            "k_EClientNotificationType_FriendOnline" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendOnline),
            "k_EClientNotificationType_Achievement" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Achievement),
            "k_EClientNotificationType_LowBattery" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowBattery),
            "k_EClientNotificationType_SystemUpdate" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SystemUpdate),
            "k_EClientNotificationType_FriendMessage" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendMessage),
            "k_EClientNotificationType_GroupChatMessage" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GroupChatMessage),
            "k_EClientNotificationType_FriendInviteRollup" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInviteRollup),
            "k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged),
            "k_EClientNotificationType_FamilySharingStopPlaying" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingStopPlaying),
            "k_EClientNotificationType_FamilySharingLibraryAvailable" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingLibraryAvailable),
            "k_EClientNotificationType_Screenshot" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Screenshot),
            "k_EClientNotificationType_CloudSyncFailure" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncFailure),
            "k_EClientNotificationType_CloudSyncConflict" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncConflict),
            "k_EClientNotificationType_IncomingVoiceChat" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_IncomingVoiceChat),
            "k_EClientNotificationType_ClaimSteamDeckRewards" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ClaimSteamDeckRewards),
            "k_EClientNotificationType_GiftReceived" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GiftReceived),
            "k_EClientNotificationType_ItemAnnouncement" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ItemAnnouncement),
            "k_EClientNotificationType_HardwareSurvey" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HardwareSurvey),
            "k_EClientNotificationType_LowDiskSpace" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowDiskSpace),
            "k_EClientNotificationType_BatteryTemperature" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BatteryTemperature),
            "k_EClientNotificationType_DockUnsupportedFirmware" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DockUnsupportedFirmware),
            "k_EClientNotificationType_PeerContentUpload" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_PeerContentUpload),
            "k_EClientNotificationType_CannotReadControllerGuideButton" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CannotReadControllerGuideButton),
            "k_EClientNotificationType_Comment" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Comment),
            "k_EClientNotificationType_Wishlist" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Wishlist),
            "k_EClientNotificationType_TradeOffer" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TradeOffer),
            "k_EClientNotificationType_AsyncGame" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_AsyncGame),
            "k_EClientNotificationType_General" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_General),
            "k_EClientNotificationType_HelpRequest" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HelpRequest),
            "k_EClientNotificationType_OverlaySplashScreen" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_OverlaySplashScreen),
            "k_EClientNotificationType_BroadcastAvailableToWatch" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BroadcastAvailableToWatch),
            "k_EClientNotificationType_TimedTrialRemaining" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimedTrialRemaining),
            "k_EClientNotificationType_LoginRefresh" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LoginRefresh),
            "k_EClientNotificationType_MajorSale" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_MajorSale),
            "k_EClientNotificationType_TimerExpired" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimerExpired),
            "k_EClientNotificationType_ModeratorMsg" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ModeratorMsg),
            "k_EClientNotificationType_SteamInputActionSetChanged" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SteamInputActionSetChanged),
            "k_EClientNotificationType_RemoteClientConnection" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_RemoteClientConnection),
            "k_EClientNotificationType_RemoteClientStartStream" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_RemoteClientStartStream),
            "k_EClientNotificationType_StreamingClientConnection" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_StreamingClientConnection),
            "k_EClientNotificationType_FamilyInvite" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilyInvite),
            "k_EClientNotificationType_PlaytimeWarning" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_PlaytimeWarning),
            "k_EClientNotificationType_FamilyPurchaseRequest" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilyPurchaseRequest),
            "k_EClientNotificationType_FamilyPurchaseRequestResponse" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilyPurchaseRequestResponse),
            "k_EClientNotificationType_ParentalFeatureRequest" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ParentalFeatureRequest),
            "k_EClientNotificationType_ParentalPlaytimeRequest" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ParentalPlaytimeRequest),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EClientNotificationType] = &[
        EClientNotificationType::k_EClientNotificationType_Invalid,
        EClientNotificationType::k_EClientNotificationType_DownloadCompleted,
        EClientNotificationType::k_EClientNotificationType_FriendInvite,
        EClientNotificationType::k_EClientNotificationType_FriendInGame,
        EClientNotificationType::k_EClientNotificationType_FriendOnline,
        EClientNotificationType::k_EClientNotificationType_Achievement,
        EClientNotificationType::k_EClientNotificationType_LowBattery,
        EClientNotificationType::k_EClientNotificationType_SystemUpdate,
        EClientNotificationType::k_EClientNotificationType_FriendMessage,
        EClientNotificationType::k_EClientNotificationType_GroupChatMessage,
        EClientNotificationType::k_EClientNotificationType_FriendInviteRollup,
        EClientNotificationType::k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged,
        EClientNotificationType::k_EClientNotificationType_FamilySharingStopPlaying,
        EClientNotificationType::k_EClientNotificationType_FamilySharingLibraryAvailable,
        EClientNotificationType::k_EClientNotificationType_Screenshot,
        EClientNotificationType::k_EClientNotificationType_CloudSyncFailure,
        EClientNotificationType::k_EClientNotificationType_CloudSyncConflict,
        EClientNotificationType::k_EClientNotificationType_IncomingVoiceChat,
        EClientNotificationType::k_EClientNotificationType_ClaimSteamDeckRewards,
        EClientNotificationType::k_EClientNotificationType_GiftReceived,
        EClientNotificationType::k_EClientNotificationType_ItemAnnouncement,
        EClientNotificationType::k_EClientNotificationType_HardwareSurvey,
        EClientNotificationType::k_EClientNotificationType_LowDiskSpace,
        EClientNotificationType::k_EClientNotificationType_BatteryTemperature,
        EClientNotificationType::k_EClientNotificationType_DockUnsupportedFirmware,
        EClientNotificationType::k_EClientNotificationType_PeerContentUpload,
        EClientNotificationType::k_EClientNotificationType_CannotReadControllerGuideButton,
        EClientNotificationType::k_EClientNotificationType_Comment,
        EClientNotificationType::k_EClientNotificationType_Wishlist,
        EClientNotificationType::k_EClientNotificationType_TradeOffer,
        EClientNotificationType::k_EClientNotificationType_AsyncGame,
        EClientNotificationType::k_EClientNotificationType_General,
        EClientNotificationType::k_EClientNotificationType_HelpRequest,
        EClientNotificationType::k_EClientNotificationType_OverlaySplashScreen,
        EClientNotificationType::k_EClientNotificationType_BroadcastAvailableToWatch,
        EClientNotificationType::k_EClientNotificationType_TimedTrialRemaining,
        EClientNotificationType::k_EClientNotificationType_LoginRefresh,
        EClientNotificationType::k_EClientNotificationType_MajorSale,
        EClientNotificationType::k_EClientNotificationType_TimerExpired,
        EClientNotificationType::k_EClientNotificationType_ModeratorMsg,
        EClientNotificationType::k_EClientNotificationType_SteamInputActionSetChanged,
        EClientNotificationType::k_EClientNotificationType_RemoteClientConnection,
        EClientNotificationType::k_EClientNotificationType_RemoteClientStartStream,
        EClientNotificationType::k_EClientNotificationType_StreamingClientConnection,
        EClientNotificationType::k_EClientNotificationType_FamilyInvite,
        EClientNotificationType::k_EClientNotificationType_PlaytimeWarning,
        EClientNotificationType::k_EClientNotificationType_FamilyPurchaseRequest,
        EClientNotificationType::k_EClientNotificationType_FamilyPurchaseRequestResponse,
        EClientNotificationType::k_EClientNotificationType_ParentalFeatureRequest,
        EClientNotificationType::k_EClientNotificationType_ParentalPlaytimeRequest,
    ];
}

impl crate::EnumFull for EClientNotificationType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EClientNotificationType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EClientNotificationType {
    fn default() -> Self {
        EClientNotificationType::k_EClientNotificationType_Invalid
    }
}

impl EClientNotificationType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EClientNotificationType>("EClientNotificationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemUpdateNotificationType)
pub enum ESystemUpdateNotificationType {
    // @@protoc_insertion_point(enum_value:ESystemUpdateNotificationType.k_ESystemUpdateNotificationType_Invalid)
    k_ESystemUpdateNotificationType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemUpdateNotificationType.k_ESystemUpdateNotificationType_Available)
    k_ESystemUpdateNotificationType_Available = 1,
    // @@protoc_insertion_point(enum_value:ESystemUpdateNotificationType.k_ESystemUpdateNotificationType_NeedsRestart)
    k_ESystemUpdateNotificationType_NeedsRestart = 2,
}

impl crate::Enum for ESystemUpdateNotificationType {
    const NAME: &'static str = "ESystemUpdateNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemUpdateNotificationType> {
        match value {
            0 => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid),
            1 => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Available),
            2 => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_NeedsRestart),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemUpdateNotificationType> {
        match str {
            "k_ESystemUpdateNotificationType_Invalid" => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid),
            "k_ESystemUpdateNotificationType_Available" => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Available),
            "k_ESystemUpdateNotificationType_NeedsRestart" => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_NeedsRestart),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemUpdateNotificationType] = &[
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid,
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Available,
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_NeedsRestart,
    ];
}

impl crate::EnumFull for ESystemUpdateNotificationType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemUpdateNotificationType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemUpdateNotificationType {
    fn default() -> Self {
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid
    }
}

impl ESystemUpdateNotificationType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemUpdateNotificationType>("ESystemUpdateNotificationType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n+steammessages_clientnotificationtypes.proto\";\n#CClientNotificationC\
    loudSyncFailure\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"<\n$CCl\
    ientNotificationCloudSyncConflict\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\"\x8b\x01\n\x1dCClientNotificationScreenshot\x12+\n\x11screens\
    hot_handle\x18\x01\x20\x01(\tR\x10screenshotHandle\x12\x20\n\x0bdescript\
    ion\x18\x02\x20\x01(\tR\x0bdescription\x12\x1b\n\tlocal_url\x18\x03\x20\
    \x01(\tR\x08localUrl\"<\n$CClientNotificationDownloadCompleted\x12\x14\n\
    \x05appid\x18\x01\x20\x01(\rR\x05appid\";\n\x1fCClientNotificationFriend\
    Invite\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"Q\n%CClien\
    tNotificationFriendInviteRollup\x12(\n\x10new_invite_count\x18\x01\x20\
    \x01(\rR\x0enewInviteCount\"X\n\x1fCClientNotificationFriendInGame\x12\
    \x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1b\n\tgame_name\
    \x18\x02\x20\x01(\tR\x08gameName\";\n\x1fCClientNotificationFriendOnline\
    \x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\x94\x03\n\x1eCC\
    lientNotificationAchievement\x12%\n\x0eachievement_id\x18\x01\x20\x01(\t\
    R\rachievementId\x12\x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12\x12\
    \n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x04\
    \x20\x01(\tR\x0bdescription\x12\x1b\n\timage_url\x18\x05\x20\x01(\tR\x08\
    imageUrl\x12\x1a\n\x08achieved\x18\x06\x20\x01(\x08R\x08achieved\x12%\n\
    \x0ertime_unlocked\x18\x07\x20\x01(\rR\rrtimeUnlocked\x12!\n\x0cmin_prog\
    ress\x18\x08\x20\x01(\x02R\x0bminProgress\x12)\n\x10current_progress\x18\
    \t\x20\x01(\x02R\x0fcurrentProgress\x12!\n\x0cmax_progress\x18\n\x20\x01\
    (\x02R\x0bmaxProgress\x12.\n\x13global_achieved_pct\x18\x0b\x20\x01(\x02\
    R\x11globalAchievedPct\"D\n\x1dCClientNotificationLowBattery\x12#\n\rpct\
    _remaining\x18\x01\x20\x01(\x02R\x0cpctRemaining\"~\n\x1fCClientNotifica\
    tionSystemUpdate\x12[\n\x04type\x18\x01\x20\x01(\x0e2\x1e.ESystemUpdateN\
    otificationType:'k_ESystemUpdateNotificationType_InvalidR\x04type\"\xe1\
    \x01\n\x20CClientNotificationFriendMessage\x12\x10\n\x03tag\x18\x01\x20\
    \x01(\tR\x03tag\x12\x18\n\x07steamid\x18\x02\x20\x01(\tR\x07steamid\x12\
    \x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x12\n\x04body\x18\x04\
    \x20\x01(\tR\x04body\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12&\
    \n\x0enotificationid\x18\x06\x20\x01(\rR\x0enotificationid\x12+\n\x11res\
    ponse_steamurl\x18\x07\x20\x01(\tR\x10responseSteamurl\"\x9b\x02\n#CClie\
    ntNotificationGroupChatMessage\x12\x10\n\x03tag\x18\x01\x20\x01(\tR\x03t\
    ag\x12%\n\x0esteamid_sender\x18\x02\x20\x01(\tR\rsteamidSender\x12\"\n\r\
    chat_group_id\x18\x03\x20\x01(\tR\x0bchatGroupId\x12\x17\n\x07chat_id\
    \x18\x04\x20\x01(\tR\x06chatId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\
    \x05title\x12\x12\n\x04body\x18\x06\x20\x01(\tR\x04body\x12\x18\n\x07raw\
    body\x18\x07\x20\x01(\tR\x07rawbody\x12\x12\n\x04icon\x18\x08\x20\x01(\t\
    R\x04icon\x12&\n\x0enotificationid\x18\t\x20\x01(\rR\x0enotificationid\"\
    \x85\x01\n:CClientNotificationFamilySharingDeviceAuthorizationChanged\
    \x12'\n\x0faccountid_owner\x18\x01\x20\x01(\rR\x0eaccountidOwner\x12\x1e\
    \n\nauthorized\x18\x02\x20\x01(\x08R\nauthorized\"\x99\x01\n+CClientNoti\
    ficationFamilySharingStopPlaying\x12'\n\x0faccountid_owner\x18\x01\x20\
    \x01(\rR\x0eaccountidOwner\x12+\n\x11seconds_remaining\x18\x02\x20\x01(\
    \rR\x10secondsRemaining\x12\x14\n\x05appid\x18\x03\x20\x01(\rR\x05appid\
    \"[\n0CClientNotificationFamilySharingLibraryAvailable\x12'\n\x0faccount\
    id_owner\x18\x01\x20\x01(\rR\x0eaccountidOwner\"@\n$CClientNotificationI\
    ncomingVoiceChat\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\
    *\n(CClientNotificationClaimSteamDeckRewards\"B\n\x1fCClientNotification\
    GiftReceived\x12\x1f\n\x0bsender_name\x18\x01\x20\x01(\tR\nsenderName\"y\
    \n#CClientNotificationItemAnnouncement\x12$\n\x0enew_item_count\x18\x01\
    \x20\x01(\rR\x0cnewItemCount\x12,\n\x12new_backpack_items\x18\x02\x20\
    \x01(\x08R\x10newBackpackItems\"*\n(CClientNotificationHardwareSurveyPen\
    ding\"D\n\x1fCClientNotificationLowDiskSpace\x12!\n\x0cfolder_index\x18\
    \x01\x20\x01(\rR\x0bfolderIndex\"v\n%CClientNotificationBatteryTemperatu\
    re\x12\x20\n\x0btemperature\x18\x01\x20\x01(\rR\x0btemperature\x12+\n\
    \x11notification_type\x18\x02\x20\x01(\tR\x10notificationType\",\n*CClie\
    ntNotificationDockUnsupportedFirmware\"Y\n$CClientNotificationPeerConten\
    tUpload\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1b\n\tpeer_\
    name\x18\x02\x20\x01(\tR\x08peerName\"_\n2CClientNotificationCannotReadC\
    ontrollerGuideButton\x12)\n\x10controller_index\x18\x01\x20\x01(\x05R\
    \x0fcontrollerIndex\"(\n&CClientNotificationOverlaySplashScreen\"a\n,CCl\
    ientNotificationBroadcastAvailableToWatch\x121\n\x14broadcast_permission\
    \x18\x01\x20\x01(\x05R\x13broadcastPermission\"\xbc\x01\n&CClientNotific\
    ationTimedTrialRemaining\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12\x12\n\x04icon\x18\x02\x20\x01(\tR\x04icon\x12\x18\n\x07offline\x18\
    \x03\x20\x01(\x08R\x07offline\x12'\n\x0fallowed_seconds\x18\x04\x20\x01(\
    \rR\x0eallowedSeconds\x12%\n\x0eplayed_seconds\x18\x05\x20\x01(\rR\rplay\
    edSeconds\"!\n\x1fCClientNotificationLoginRefresh\"!\n\x1fCClientNotific\
    ationTimerExpired\"\x82\x01\n-CClientNotificationSteamInputActionSetChan\
    ged\x12)\n\x10controller_index\x18\x01\x20\x01(\x05R\x0fcontrollerIndex\
    \x12&\n\x0faction_set_name\x18\x02\x20\x01(\tR\ractionSetName\"c\n)CClie\
    ntNotificationRemoteClientConnection\x12\x18\n\x07machine\x18\x01\x20\
    \x01(\tR\x07machine\x12\x1c\n\tconnected\x18\x02\x20\x01(\x08R\tconnecte\
    d\"c\n*CClientNotificationRemoteClientStartStream\x12\x18\n\x07machine\
    \x18\x01\x20\x01(\tR\x07machine\x12\x1b\n\tgame_name\x18\x02\x20\x01(\tR\
    \x08gameName\"\x82\x01\n,CClientNotificationStreamingClientConnection\
    \x12\x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostname\x12\x18\n\x07mach\
    ine\x18\x02\x20\x01(\tR\x07machine\x12\x1c\n\tconnected\x18\x03\x20\x01(\
    \x08R\tconnected\"g\n\"CClientNotificationPlaytimeWarning\x12\x12\n\x04t\
    ype\x18\x01\x20\x01(\tR\x04type\x12-\n\x12playtime_remaining\x18\x02\x20\
    \x01(\rR\x11playtimeRemaining*\x9b\x13\n\x17EClientNotificationType\x12%\
    \n!k_EClientNotificationType_Invalid\x10\0\x12/\n+k_EClientNotificationT\
    ype_DownloadCompleted\x10\x01\x12*\n&k_EClientNotificationType_FriendInv\
    ite\x10\x02\x12*\n&k_EClientNotificationType_FriendInGame\x10\x03\x12*\n\
    &k_EClientNotificationType_FriendOnline\x10\x04\x12)\n%k_EClientNotifica\
    tionType_Achievement\x10\x05\x12(\n$k_EClientNotificationType_LowBattery\
    \x10\x06\x12*\n&k_EClientNotificationType_SystemUpdate\x10\x07\x12+\n'k_\
    EClientNotificationType_FriendMessage\x10\x08\x12.\n*k_EClientNotificati\
    onType_GroupChatMessage\x10\t\x120\n,k_EClientNotificationType_FriendInv\
    iteRollup\x10\n\x12E\nAk_EClientNotificationType_FamilySharingDeviceAuth\
    orizationChanged\x10\x0b\x126\n2k_EClientNotificationType_FamilySharingS\
    topPlaying\x10\x0c\x12;\n7k_EClientNotificationType_FamilySharingLibrary\
    Available\x10\r\x12(\n$k_EClientNotificationType_Screenshot\x10\x0e\x12.\
    \n*k_EClientNotificationType_CloudSyncFailure\x10\x0f\x12/\n+k_EClientNo\
    tificationType_CloudSyncConflict\x10\x10\x12/\n+k_EClientNotificationTyp\
    e_IncomingVoiceChat\x10\x11\x123\n/k_EClientNotificationType_ClaimSteamD\
    eckRewards\x10\x12\x12*\n&k_EClientNotificationType_GiftReceived\x10\x13\
    \x12.\n*k_EClientNotificationType_ItemAnnouncement\x10\x14\x12,\n(k_ECli\
    entNotificationType_HardwareSurvey\x10\x15\x12*\n&k_EClientNotificationT\
    ype_LowDiskSpace\x10\x16\x120\n,k_EClientNotificationType_BatteryTempera\
    ture\x10\x17\x125\n1k_EClientNotificationType_DockUnsupportedFirmware\
    \x10\x18\x12/\n+k_EClientNotificationType_PeerContentUpload\x10\x19\x12=\
    \n9k_EClientNotificationType_CannotReadControllerGuideButton\x10\x1a\x12\
    %\n!k_EClientNotificationType_Comment\x10\x1b\x12&\n\"k_EClientNotificat\
    ionType_Wishlist\x10\x1c\x12(\n$k_EClientNotificationType_TradeOffer\x10\
    \x1d\x12'\n#k_EClientNotificationType_AsyncGame\x10\x1e\x12%\n!k_EClient\
    NotificationType_General\x10\x1f\x12)\n%k_EClientNotificationType_HelpRe\
    quest\x10\x20\x121\n-k_EClientNotificationType_OverlaySplashScreen\x10!\
    \x127\n3k_EClientNotificationType_BroadcastAvailableToWatch\x10\"\x121\n\
    -k_EClientNotificationType_TimedTrialRemaining\x10#\x12*\n&k_EClientNoti\
    ficationType_LoginRefresh\x10$\x12'\n#k_EClientNotificationType_MajorSal\
    e\x10%\x12*\n&k_EClientNotificationType_TimerExpired\x10&\x12*\n&k_EClie\
    ntNotificationType_ModeratorMsg\x10'\x128\n4k_EClientNotificationType_St\
    eamInputActionSetChanged\x10(\x124\n0k_EClientNotificationType_RemoteCli\
    entConnection\x10)\x125\n1k_EClientNotificationType_RemoteClientStartStr\
    eam\x10*\x127\n3k_EClientNotificationType_StreamingClientConnection\x10+\
    \x12*\n&k_EClientNotificationType_FamilyInvite\x10,\x12-\n)k_EClientNoti\
    ficationType_PlaytimeWarning\x10-\x123\n/k_EClientNotificationType_Famil\
    yPurchaseRequest\x10.\x12;\n7k_EClientNotificationType_FamilyPurchaseReq\
    uestResponse\x10/\x124\n0k_EClientNotificationType_ParentalFeatureReques\
    t\x100\x125\n1k_EClientNotificationType_ParentalPlaytimeRequest\x101*\
    \xad\x01\n\x1dESystemUpdateNotificationType\x12+\n'k_ESystemUpdateNotifi\
    cationType_Invalid\x10\0\x12-\n)k_ESystemUpdateNotificationType_Availabl\
    e\x10\x01\x120\n,k_ESystemUpdateNotificationType_NeedsRestart\x10\x02B\
    \x05H\x01\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(36);
            messages.push(CClientNotificationCloudSyncFailure::generated_message_descriptor_data());
            messages.push(CClientNotificationCloudSyncConflict::generated_message_descriptor_data());
            messages.push(CClientNotificationScreenshot::generated_message_descriptor_data());
            messages.push(CClientNotificationDownloadCompleted::generated_message_descriptor_data());
            messages.push(CClientNotificationFriendInvite::generated_message_descriptor_data());
            messages.push(CClientNotificationFriendInviteRollup::generated_message_descriptor_data());
            messages.push(CClientNotificationFriendInGame::generated_message_descriptor_data());
            messages.push(CClientNotificationFriendOnline::generated_message_descriptor_data());
            messages.push(CClientNotificationAchievement::generated_message_descriptor_data());
            messages.push(CClientNotificationLowBattery::generated_message_descriptor_data());
            messages.push(CClientNotificationSystemUpdate::generated_message_descriptor_data());
            messages.push(CClientNotificationFriendMessage::generated_message_descriptor_data());
            messages.push(CClientNotificationGroupChatMessage::generated_message_descriptor_data());
            messages.push(CClientNotificationFamilySharingDeviceAuthorizationChanged::generated_message_descriptor_data());
            messages.push(CClientNotificationFamilySharingStopPlaying::generated_message_descriptor_data());
            messages.push(CClientNotificationFamilySharingLibraryAvailable::generated_message_descriptor_data());
            messages.push(CClientNotificationIncomingVoiceChat::generated_message_descriptor_data());
            messages.push(CClientNotificationClaimSteamDeckRewards::generated_message_descriptor_data());
            messages.push(CClientNotificationGiftReceived::generated_message_descriptor_data());
            messages.push(CClientNotificationItemAnnouncement::generated_message_descriptor_data());
            messages.push(CClientNotificationHardwareSurveyPending::generated_message_descriptor_data());
            messages.push(CClientNotificationLowDiskSpace::generated_message_descriptor_data());
            messages.push(CClientNotificationBatteryTemperature::generated_message_descriptor_data());
            messages.push(CClientNotificationDockUnsupportedFirmware::generated_message_descriptor_data());
            messages.push(CClientNotificationPeerContentUpload::generated_message_descriptor_data());
            messages.push(CClientNotificationCannotReadControllerGuideButton::generated_message_descriptor_data());
            messages.push(CClientNotificationOverlaySplashScreen::generated_message_descriptor_data());
            messages.push(CClientNotificationBroadcastAvailableToWatch::generated_message_descriptor_data());
            messages.push(CClientNotificationTimedTrialRemaining::generated_message_descriptor_data());
            messages.push(CClientNotificationLoginRefresh::generated_message_descriptor_data());
            messages.push(CClientNotificationTimerExpired::generated_message_descriptor_data());
            messages.push(CClientNotificationSteamInputActionSetChanged::generated_message_descriptor_data());
            messages.push(CClientNotificationRemoteClientConnection::generated_message_descriptor_data());
            messages.push(CClientNotificationRemoteClientStartStream::generated_message_descriptor_data());
            messages.push(CClientNotificationStreamingClientConnection::generated_message_descriptor_data());
            messages.push(CClientNotificationPlaytimeWarning::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(EClientNotificationType::generated_enum_descriptor_data());
            enums.push(ESystemUpdateNotificationType::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
