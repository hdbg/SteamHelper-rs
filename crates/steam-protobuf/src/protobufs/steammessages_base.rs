// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_base.proto`

// @@protoc_insertion_point(message:CMsgIPAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIPAddress {
    // message oneof groups
    pub ip: ::std::option::Option<cmsg_ipaddress::Ip>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPAddress.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddress {
    fn default() -> &'a CMsgIPAddress {
        <CMsgIPAddress as crate::Message>::default_instance()
    }
}

impl CMsgIPAddress {
    pub fn new() -> CMsgIPAddress {
        ::std::default::Default::default()
    }

    // optional fixed32 v4 = 1;

    pub fn v4(&self) -> u32 {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_v4(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v4(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v4(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(v))
    }

    // optional bytes v6 = 2;

    pub fn v6(&self) -> &[u8] {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_v6(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v6(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v6(&mut self, v: ::bytes::Bytes) {
        self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_v6(&mut self) -> &mut ::bytes::Bytes {
        if let ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(_)) = self.ip {
        } else {
            self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(::bytes::Bytes::new()));
        }
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_v6(&mut self) -> ::bytes::Bytes {
        if self.has_v6() {
            match self.ip.take() {
                ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::bytes::Bytes::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "v4",
            CMsgIPAddress::has_v4,
            CMsgIPAddress::v4,
            CMsgIPAddress::set_v4,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "v6",
            CMsgIPAddress::has_v6,
            CMsgIPAddress::v6,
            CMsgIPAddress::set_v6,
        ));
        oneofs.push(cmsg_ipaddress::Ip::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIPAddress>(
            "CMsgIPAddress",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgIPAddress {
    const NAME: &'static str = "CMsgIPAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(is.read_fixed32()?));
                },
                18 => {
                    self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(is.read_tokio_bytes()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &cmsg_ipaddress::Ip::V4(v) => {
                    my_size += 1 + 4;
                },
                &cmsg_ipaddress::Ip::V6(ref v) => {
                    my_size += crate::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &cmsg_ipaddress::Ip::V4(v) => {
                    os.write_fixed32(1, v)?;
                },
                &cmsg_ipaddress::Ip::V6(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPAddress {
        CMsgIPAddress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPAddress {
        static instance: CMsgIPAddress = CMsgIPAddress {
            ip: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgIPAddress {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIPAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgIPAddress {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgIPAddress`
pub mod cmsg_ipaddress {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgIPAddress.ip)
    pub enum Ip {
        // @@protoc_insertion_point(oneof_field:CMsgIPAddress.v4)
        V4(u32),
        // @@protoc_insertion_point(oneof_field:CMsgIPAddress.v6)
        V6(::bytes::Bytes),
    }

    impl crate::Oneof for Ip {
    }

    impl crate::OneofFull for Ip {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::CMsgIPAddress as crate::MessageFull>::descriptor().oneof_by_name("ip").unwrap()).clone()
        }
    }

    impl Ip {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Ip>("ip")
        }
    }
}

// @@protoc_insertion_point(message:CMsgIPAddressBucket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIPAddressBucket {
    // message fields
    // @@protoc_insertion_point(field:CMsgIPAddressBucket.original_ip_address)
    pub original_ip_address: crate::MessageField<CMsgIPAddress>,
    // @@protoc_insertion_point(field:CMsgIPAddressBucket.bucket)
    pub bucket: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPAddressBucket.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddressBucket {
    fn default() -> &'a CMsgIPAddressBucket {
        <CMsgIPAddressBucket as crate::Message>::default_instance()
    }
}

impl CMsgIPAddressBucket {
    pub fn new() -> CMsgIPAddressBucket {
        ::std::default::Default::default()
    }

    // optional .CMsgIPAddress original_ip_address = 1;

    pub fn original_ip_address(&self) -> &CMsgIPAddress {
        self.original_ip_address.as_ref().unwrap_or_else(|| <CMsgIPAddress as crate::Message>::default_instance())
    }

    pub fn clear_original_ip_address(&mut self) {
        self.original_ip_address.clear();
    }

    pub fn has_original_ip_address(&self) -> bool {
        self.original_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_ip_address(&mut self, v: CMsgIPAddress) {
        self.original_ip_address = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_ip_address(&mut self) -> &mut CMsgIPAddress {
        self.original_ip_address.mut_or_insert_default()
    }

    // Take field
    pub fn take_original_ip_address(&mut self) -> CMsgIPAddress {
        self.original_ip_address.take().unwrap_or_else(|| CMsgIPAddress::new())
    }

    // optional fixed64 bucket = 2;

    pub fn bucket(&self) -> u64 {
        self.bucket.unwrap_or(0)
    }

    pub fn clear_bucket(&mut self) {
        self.bucket = ::std::option::Option::None;
    }

    pub fn has_bucket(&self) -> bool {
        self.bucket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: u64) {
        self.bucket = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgIPAddress>(
            "original_ip_address",
            |m: &CMsgIPAddressBucket| { &m.original_ip_address },
            |m: &mut CMsgIPAddressBucket| { &mut m.original_ip_address },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bucket",
            |m: &CMsgIPAddressBucket| { &m.bucket },
            |m: &mut CMsgIPAddressBucket| { &mut m.bucket },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIPAddressBucket>(
            "CMsgIPAddressBucket",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgIPAddressBucket {
    const NAME: &'static str = "CMsgIPAddressBucket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.original_ip_address)?;
                },
                17 => {
                    self.bucket = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_ip_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bucket {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.original_ip_address.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bucket {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPAddressBucket {
        CMsgIPAddressBucket::new()
    }

    fn clear(&mut self) {
        self.original_ip_address.clear();
        self.bucket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPAddressBucket {
        static instance: CMsgIPAddressBucket = CMsgIPAddressBucket {
            original_ip_address: crate::MessageField::none(),
            bucket: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgIPAddressBucket {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIPAddressBucket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIPAddressBucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgIPAddressBucket {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCRoutingProtoBufHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRoutingProtoBufHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRoutingProtoBufHeader.dst_gcid_queue)
    pub dst_gcid_queue: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCRoutingProtoBufHeader.dst_gc_dir_index)
    pub dst_gc_dir_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRoutingProtoBufHeader.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRoutingProtoBufHeader {
    fn default() -> &'a CMsgGCRoutingProtoBufHeader {
        <CMsgGCRoutingProtoBufHeader as crate::Message>::default_instance()
    }
}

impl CMsgGCRoutingProtoBufHeader {
    pub fn new() -> CMsgGCRoutingProtoBufHeader {
        ::std::default::Default::default()
    }

    // optional uint64 dst_gcid_queue = 1;

    pub fn dst_gcid_queue(&self) -> u64 {
        self.dst_gcid_queue.unwrap_or(0)
    }

    pub fn clear_dst_gcid_queue(&mut self) {
        self.dst_gcid_queue = ::std::option::Option::None;
    }

    pub fn has_dst_gcid_queue(&self) -> bool {
        self.dst_gcid_queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_gcid_queue(&mut self, v: u64) {
        self.dst_gcid_queue = ::std::option::Option::Some(v);
    }

    // optional uint32 dst_gc_dir_index = 2;

    pub fn dst_gc_dir_index(&self) -> u32 {
        self.dst_gc_dir_index.unwrap_or(0)
    }

    pub fn clear_dst_gc_dir_index(&mut self) {
        self.dst_gc_dir_index = ::std::option::Option::None;
    }

    pub fn has_dst_gc_dir_index(&self) -> bool {
        self.dst_gc_dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_gc_dir_index(&mut self, v: u32) {
        self.dst_gc_dir_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_gcid_queue",
            |m: &CMsgGCRoutingProtoBufHeader| { &m.dst_gcid_queue },
            |m: &mut CMsgGCRoutingProtoBufHeader| { &mut m.dst_gcid_queue },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_gc_dir_index",
            |m: &CMsgGCRoutingProtoBufHeader| { &m.dst_gc_dir_index },
            |m: &mut CMsgGCRoutingProtoBufHeader| { &mut m.dst_gc_dir_index },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRoutingProtoBufHeader>(
            "CMsgGCRoutingProtoBufHeader",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGCRoutingProtoBufHeader {
    const NAME: &'static str = "CMsgGCRoutingProtoBufHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dst_gcid_queue = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.dst_gc_dir_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dst_gcid_queue {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.dst_gc_dir_index {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.dst_gcid_queue {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.dst_gc_dir_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRoutingProtoBufHeader {
        CMsgGCRoutingProtoBufHeader::new()
    }

    fn clear(&mut self) {
        self.dst_gcid_queue = ::std::option::Option::None;
        self.dst_gc_dir_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRoutingProtoBufHeader {
        static instance: CMsgGCRoutingProtoBufHeader = CMsgGCRoutingProtoBufHeader {
            dst_gcid_queue: ::std::option::Option::None,
            dst_gc_dir_index: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGCRoutingProtoBufHeader {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRoutingProtoBufHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRoutingProtoBufHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGCRoutingProtoBufHeader {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgProtoBufHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtoBufHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.client_sessionid)
    pub client_sessionid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.routing_appid)
    pub routing_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.jobid_source)
    pub jobid_source: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.jobid_target)
    pub jobid_target: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.target_job_name)
    pub target_job_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.seq_num)
    pub seq_num: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.auth_account_flags)
    pub auth_account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.token_source)
    pub token_source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.admin_spoofing_user)
    pub admin_spoofing_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.transport_error)
    pub transport_error: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.messageid)
    pub messageid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.publisher_group_id)
    pub publisher_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.sysid)
    pub sysid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.trace_tag)
    pub trace_tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.webapi_key_id)
    pub webapi_key_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.is_from_external_source)
    pub is_from_external_source: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.forward_to_sysid)
    pub forward_to_sysid: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.cm_sysid)
    pub cm_sysid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.launcher_type)
    pub launcher_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.realm)
    pub realm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.timeout_ms)
    pub timeout_ms: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.debug_source)
    pub debug_source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.debug_source_string_index)
    pub debug_source_string_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.token_id)
    pub token_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.routing_gc)
    pub routing_gc: crate::MessageField<CMsgGCRoutingProtoBufHeader>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.session_disposition)
    pub session_disposition: ::std::option::Option<crate::EnumOrUnknown<cmsg_proto_buf_header::ESessionDisposition>>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.wg_token)
    pub wg_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.webui_auth_key)
    pub webui_auth_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.exclude_client_sessionids)
    pub exclude_client_sessionids: ::std::vec::Vec<i32>,
    // message oneof groups
    pub ip_addr: ::std::option::Option<cmsg_proto_buf_header::Ip_addr>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtoBufHeader.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtoBufHeader {
    fn default() -> &'a CMsgProtoBufHeader {
        <CMsgProtoBufHeader as crate::Message>::default_instance()
    }
}

impl CMsgProtoBufHeader {
    pub fn new() -> CMsgProtoBufHeader {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 client_sessionid = 2;

    pub fn client_sessionid(&self) -> i32 {
        self.client_sessionid.unwrap_or(0)
    }

    pub fn clear_client_sessionid(&mut self) {
        self.client_sessionid = ::std::option::Option::None;
    }

    pub fn has_client_sessionid(&self) -> bool {
        self.client_sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_sessionid(&mut self, v: i32) {
        self.client_sessionid = ::std::option::Option::Some(v);
    }

    // optional uint32 routing_appid = 3;

    pub fn routing_appid(&self) -> u32 {
        self.routing_appid.unwrap_or(0)
    }

    pub fn clear_routing_appid(&mut self) {
        self.routing_appid = ::std::option::Option::None;
    }

    pub fn has_routing_appid(&self) -> bool {
        self.routing_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_appid(&mut self, v: u32) {
        self.routing_appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_source = 10;

    pub fn jobid_source(&self) -> u64 {
        self.jobid_source.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_jobid_source(&mut self) {
        self.jobid_source = ::std::option::Option::None;
    }

    pub fn has_jobid_source(&self) -> bool {
        self.jobid_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_source(&mut self, v: u64) {
        self.jobid_source = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_target = 11;

    pub fn jobid_target(&self) -> u64 {
        self.jobid_target.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_jobid_target(&mut self) {
        self.jobid_target = ::std::option::Option::None;
    }

    pub fn has_jobid_target(&self) -> bool {
        self.jobid_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_target(&mut self, v: u64) {
        self.jobid_target = ::std::option::Option::Some(v);
    }

    // optional string target_job_name = 12;

    pub fn target_job_name(&self) -> &str {
        match self.target_job_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target_job_name(&mut self) {
        self.target_job_name = ::std::option::Option::None;
    }

    pub fn has_target_job_name(&self) -> bool {
        self.target_job_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_job_name(&mut self, v: ::std::string::String) {
        self.target_job_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_job_name(&mut self) -> &mut ::std::string::String {
        if self.target_job_name.is_none() {
            self.target_job_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target_job_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_job_name(&mut self) -> ::std::string::String {
        self.target_job_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 seq_num = 24;

    pub fn seq_num(&self) -> i32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: i32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 13;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string error_message = 14;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 auth_account_flags = 16;

    pub fn auth_account_flags(&self) -> u32 {
        self.auth_account_flags.unwrap_or(0)
    }

    pub fn clear_auth_account_flags(&mut self) {
        self.auth_account_flags = ::std::option::Option::None;
    }

    pub fn has_auth_account_flags(&self) -> bool {
        self.auth_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_account_flags(&mut self, v: u32) {
        self.auth_account_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 token_source = 22;

    pub fn token_source(&self) -> u32 {
        self.token_source.unwrap_or(0)
    }

    pub fn clear_token_source(&mut self) {
        self.token_source = ::std::option::Option::None;
    }

    pub fn has_token_source(&self) -> bool {
        self.token_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_source(&mut self, v: u32) {
        self.token_source = ::std::option::Option::Some(v);
    }

    // optional bool admin_spoofing_user = 23;

    pub fn admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.unwrap_or(false)
    }

    pub fn clear_admin_spoofing_user(&mut self) {
        self.admin_spoofing_user = ::std::option::Option::None;
    }

    pub fn has_admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin_spoofing_user(&mut self, v: bool) {
        self.admin_spoofing_user = ::std::option::Option::Some(v);
    }

    // optional int32 transport_error = 17;

    pub fn transport_error(&self) -> i32 {
        self.transport_error.unwrap_or(1i32)
    }

    pub fn clear_transport_error(&mut self) {
        self.transport_error = ::std::option::Option::None;
    }

    pub fn has_transport_error(&self) -> bool {
        self.transport_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_error(&mut self, v: i32) {
        self.transport_error = ::std::option::Option::Some(v);
    }

    // optional uint64 messageid = 18;

    pub fn messageid(&self) -> u64 {
        self.messageid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_messageid(&mut self) {
        self.messageid = ::std::option::Option::None;
    }

    pub fn has_messageid(&self) -> bool {
        self.messageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageid(&mut self, v: u64) {
        self.messageid = ::std::option::Option::Some(v);
    }

    // optional uint32 publisher_group_id = 19;

    pub fn publisher_group_id(&self) -> u32 {
        self.publisher_group_id.unwrap_or(0)
    }

    pub fn clear_publisher_group_id(&mut self) {
        self.publisher_group_id = ::std::option::Option::None;
    }

    pub fn has_publisher_group_id(&self) -> bool {
        self.publisher_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher_group_id(&mut self, v: u32) {
        self.publisher_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sysid = 20;

    pub fn sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }

    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }

    // optional uint64 trace_tag = 21;

    pub fn trace_tag(&self) -> u64 {
        self.trace_tag.unwrap_or(0)
    }

    pub fn clear_trace_tag(&mut self) {
        self.trace_tag = ::std::option::Option::None;
    }

    pub fn has_trace_tag(&self) -> bool {
        self.trace_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_tag(&mut self, v: u64) {
        self.trace_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 webapi_key_id = 25;

    pub fn webapi_key_id(&self) -> u32 {
        self.webapi_key_id.unwrap_or(0)
    }

    pub fn clear_webapi_key_id(&mut self) {
        self.webapi_key_id = ::std::option::Option::None;
    }

    pub fn has_webapi_key_id(&self) -> bool {
        self.webapi_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webapi_key_id(&mut self, v: u32) {
        self.webapi_key_id = ::std::option::Option::Some(v);
    }

    // optional bool is_from_external_source = 26;

    pub fn is_from_external_source(&self) -> bool {
        self.is_from_external_source.unwrap_or(false)
    }

    pub fn clear_is_from_external_source(&mut self) {
        self.is_from_external_source = ::std::option::Option::None;
    }

    pub fn has_is_from_external_source(&self) -> bool {
        self.is_from_external_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_from_external_source(&mut self, v: bool) {
        self.is_from_external_source = ::std::option::Option::Some(v);
    }

    // repeated uint32 forward_to_sysid = 27;

    pub fn forward_to_sysid(&self) -> &[u32] {
        &self.forward_to_sysid
    }

    pub fn clear_forward_to_sysid(&mut self) {
        self.forward_to_sysid.clear();
    }

    // Param is passed by value, moved
    pub fn set_forward_to_sysid(&mut self, v: ::std::vec::Vec<u32>) {
        self.forward_to_sysid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_forward_to_sysid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.forward_to_sysid
    }

    // Take field
    pub fn take_forward_to_sysid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.forward_to_sysid, ::std::vec::Vec::new())
    }

    // optional uint32 cm_sysid = 28;

    pub fn cm_sysid(&self) -> u32 {
        self.cm_sysid.unwrap_or(0)
    }

    pub fn clear_cm_sysid(&mut self) {
        self.cm_sysid = ::std::option::Option::None;
    }

    pub fn has_cm_sysid(&self) -> bool {
        self.cm_sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_sysid(&mut self, v: u32) {
        self.cm_sysid = ::std::option::Option::Some(v);
    }

    // optional uint32 launcher_type = 31;

    pub fn launcher_type(&self) -> u32 {
        self.launcher_type.unwrap_or(0u32)
    }

    pub fn clear_launcher_type(&mut self) {
        self.launcher_type = ::std::option::Option::None;
    }

    pub fn has_launcher_type(&self) -> bool {
        self.launcher_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher_type(&mut self, v: u32) {
        self.launcher_type = ::std::option::Option::Some(v);
    }

    // optional uint32 realm = 32;

    pub fn realm(&self) -> u32 {
        self.realm.unwrap_or(0u32)
    }

    pub fn clear_realm(&mut self) {
        self.realm = ::std::option::Option::None;
    }

    pub fn has_realm(&self) -> bool {
        self.realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realm(&mut self, v: u32) {
        self.realm = ::std::option::Option::Some(v);
    }

    // optional int32 timeout_ms = 33;

    pub fn timeout_ms(&self) -> i32 {
        self.timeout_ms.unwrap_or(-1i32)
    }

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: i32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }

    // optional string debug_source = 34;

    pub fn debug_source(&self) -> &str {
        match self.debug_source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_source(&mut self) {
        self.debug_source = ::std::option::Option::None;
    }

    pub fn has_debug_source(&self) -> bool {
        self.debug_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_source(&mut self, v: ::std::string::String) {
        self.debug_source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_source(&mut self) -> &mut ::std::string::String {
        if self.debug_source.is_none() {
            self.debug_source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_source(&mut self) -> ::std::string::String {
        self.debug_source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 debug_source_string_index = 35;

    pub fn debug_source_string_index(&self) -> u32 {
        self.debug_source_string_index.unwrap_or(0)
    }

    pub fn clear_debug_source_string_index(&mut self) {
        self.debug_source_string_index = ::std::option::Option::None;
    }

    pub fn has_debug_source_string_index(&self) -> bool {
        self.debug_source_string_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_source_string_index(&mut self, v: u32) {
        self.debug_source_string_index = ::std::option::Option::Some(v);
    }

    // optional uint64 token_id = 36;

    pub fn token_id(&self) -> u64 {
        self.token_id.unwrap_or(0)
    }

    pub fn clear_token_id(&mut self) {
        self.token_id = ::std::option::Option::None;
    }

    pub fn has_token_id(&self) -> bool {
        self.token_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: u64) {
        self.token_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCRoutingProtoBufHeader routing_gc = 37;

    pub fn routing_gc(&self) -> &CMsgGCRoutingProtoBufHeader {
        self.routing_gc.as_ref().unwrap_or_else(|| <CMsgGCRoutingProtoBufHeader as crate::Message>::default_instance())
    }

    pub fn clear_routing_gc(&mut self) {
        self.routing_gc.clear();
    }

    pub fn has_routing_gc(&self) -> bool {
        self.routing_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_gc(&mut self, v: CMsgGCRoutingProtoBufHeader) {
        self.routing_gc = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routing_gc(&mut self) -> &mut CMsgGCRoutingProtoBufHeader {
        self.routing_gc.mut_or_insert_default()
    }

    // Take field
    pub fn take_routing_gc(&mut self) -> CMsgGCRoutingProtoBufHeader {
        self.routing_gc.take().unwrap_or_else(|| CMsgGCRoutingProtoBufHeader::new())
    }

    // optional .CMsgProtoBufHeader.ESessionDisposition session_disposition = 38;

    pub fn session_disposition(&self) -> cmsg_proto_buf_header::ESessionDisposition {
        match self.session_disposition {
            Some(e) => e.enum_value_or(cmsg_proto_buf_header::ESessionDisposition::k_ESessionDispositionNormal),
            None => cmsg_proto_buf_header::ESessionDisposition::k_ESessionDispositionNormal,
        }
    }

    pub fn clear_session_disposition(&mut self) {
        self.session_disposition = ::std::option::Option::None;
    }

    pub fn has_session_disposition(&self) -> bool {
        self.session_disposition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_disposition(&mut self, v: cmsg_proto_buf_header::ESessionDisposition) {
        self.session_disposition = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string wg_token = 39;

    pub fn wg_token(&self) -> &str {
        match self.wg_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_wg_token(&mut self) {
        self.wg_token = ::std::option::Option::None;
    }

    pub fn has_wg_token(&self) -> bool {
        self.wg_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wg_token(&mut self, v: ::std::string::String) {
        self.wg_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wg_token(&mut self) -> &mut ::std::string::String {
        if self.wg_token.is_none() {
            self.wg_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.wg_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_wg_token(&mut self) -> ::std::string::String {
        self.wg_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string webui_auth_key = 40;

    pub fn webui_auth_key(&self) -> &str {
        match self.webui_auth_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_webui_auth_key(&mut self) {
        self.webui_auth_key = ::std::option::Option::None;
    }

    pub fn has_webui_auth_key(&self) -> bool {
        self.webui_auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webui_auth_key(&mut self, v: ::std::string::String) {
        self.webui_auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webui_auth_key(&mut self) -> &mut ::std::string::String {
        if self.webui_auth_key.is_none() {
            self.webui_auth_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.webui_auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_webui_auth_key(&mut self) -> ::std::string::String {
        self.webui_auth_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated int32 exclude_client_sessionids = 41;

    pub fn exclude_client_sessionids(&self) -> &[i32] {
        &self.exclude_client_sessionids
    }

    pub fn clear_exclude_client_sessionids(&mut self) {
        self.exclude_client_sessionids.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclude_client_sessionids(&mut self, v: ::std::vec::Vec<i32>) {
        self.exclude_client_sessionids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclude_client_sessionids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.exclude_client_sessionids
    }

    // Take field
    pub fn take_exclude_client_sessionids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.exclude_client_sessionids, ::std::vec::Vec::new())
    }

    // optional uint32 ip = 15;

    pub fn ip(&self) -> u32 {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(v))
    }

    // optional bytes ip_v6 = 29;

    pub fn ip_v6(&self) -> &[u8] {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_ip_v6(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip_v6(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip_v6(&mut self, v: ::bytes::Bytes) {
        self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ip_v6(&mut self) -> &mut ::bytes::Bytes {
        if let ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(_)) = self.ip_addr {
        } else {
            self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(::bytes::Bytes::new()));
        }
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ip_v6(&mut self) -> ::bytes::Bytes {
        if self.has_ip_v6() {
            match self.ip_addr.take() {
                ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::bytes::Bytes::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(34);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgProtoBufHeader| { &m.steamid },
            |m: &mut CMsgProtoBufHeader| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_sessionid",
            |m: &CMsgProtoBufHeader| { &m.client_sessionid },
            |m: &mut CMsgProtoBufHeader| { &mut m.client_sessionid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "routing_appid",
            |m: &CMsgProtoBufHeader| { &m.routing_appid },
            |m: &mut CMsgProtoBufHeader| { &mut m.routing_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "jobid_source",
            |m: &CMsgProtoBufHeader| { &m.jobid_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.jobid_source },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "jobid_target",
            |m: &CMsgProtoBufHeader| { &m.jobid_target },
            |m: &mut CMsgProtoBufHeader| { &mut m.jobid_target },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_job_name",
            |m: &CMsgProtoBufHeader| { &m.target_job_name },
            |m: &mut CMsgProtoBufHeader| { &mut m.target_job_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num",
            |m: &CMsgProtoBufHeader| { &m.seq_num },
            |m: &mut CMsgProtoBufHeader| { &mut m.seq_num },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgProtoBufHeader| { &m.eresult },
            |m: &mut CMsgProtoBufHeader| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_message",
            |m: &CMsgProtoBufHeader| { &m.error_message },
            |m: &mut CMsgProtoBufHeader| { &mut m.error_message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "auth_account_flags",
            |m: &CMsgProtoBufHeader| { &m.auth_account_flags },
            |m: &mut CMsgProtoBufHeader| { &mut m.auth_account_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token_source",
            |m: &CMsgProtoBufHeader| { &m.token_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.token_source },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "admin_spoofing_user",
            |m: &CMsgProtoBufHeader| { &m.admin_spoofing_user },
            |m: &mut CMsgProtoBufHeader| { &mut m.admin_spoofing_user },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport_error",
            |m: &CMsgProtoBufHeader| { &m.transport_error },
            |m: &mut CMsgProtoBufHeader| { &mut m.transport_error },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageid",
            |m: &CMsgProtoBufHeader| { &m.messageid },
            |m: &mut CMsgProtoBufHeader| { &mut m.messageid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "publisher_group_id",
            |m: &CMsgProtoBufHeader| { &m.publisher_group_id },
            |m: &mut CMsgProtoBufHeader| { &mut m.publisher_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sysid",
            |m: &CMsgProtoBufHeader| { &m.sysid },
            |m: &mut CMsgProtoBufHeader| { &mut m.sysid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "trace_tag",
            |m: &CMsgProtoBufHeader| { &m.trace_tag },
            |m: &mut CMsgProtoBufHeader| { &mut m.trace_tag },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "webapi_key_id",
            |m: &CMsgProtoBufHeader| { &m.webapi_key_id },
            |m: &mut CMsgProtoBufHeader| { &mut m.webapi_key_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_from_external_source",
            |m: &CMsgProtoBufHeader| { &m.is_from_external_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.is_from_external_source },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "forward_to_sysid",
            |m: &CMsgProtoBufHeader| { &m.forward_to_sysid },
            |m: &mut CMsgProtoBufHeader| { &mut m.forward_to_sysid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cm_sysid",
            |m: &CMsgProtoBufHeader| { &m.cm_sysid },
            |m: &mut CMsgProtoBufHeader| { &mut m.cm_sysid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "launcher_type",
            |m: &CMsgProtoBufHeader| { &m.launcher_type },
            |m: &mut CMsgProtoBufHeader| { &mut m.launcher_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "realm",
            |m: &CMsgProtoBufHeader| { &m.realm },
            |m: &mut CMsgProtoBufHeader| { &mut m.realm },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout_ms",
            |m: &CMsgProtoBufHeader| { &m.timeout_ms },
            |m: &mut CMsgProtoBufHeader| { &mut m.timeout_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_source",
            |m: &CMsgProtoBufHeader| { &m.debug_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.debug_source },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_source_string_index",
            |m: &CMsgProtoBufHeader| { &m.debug_source_string_index },
            |m: &mut CMsgProtoBufHeader| { &mut m.debug_source_string_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token_id",
            |m: &CMsgProtoBufHeader| { &m.token_id },
            |m: &mut CMsgProtoBufHeader| { &mut m.token_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCRoutingProtoBufHeader>(
            "routing_gc",
            |m: &CMsgProtoBufHeader| { &m.routing_gc },
            |m: &mut CMsgProtoBufHeader| { &mut m.routing_gc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_disposition",
            |m: &CMsgProtoBufHeader| { &m.session_disposition },
            |m: &mut CMsgProtoBufHeader| { &mut m.session_disposition },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "wg_token",
            |m: &CMsgProtoBufHeader| { &m.wg_token },
            |m: &mut CMsgProtoBufHeader| { &mut m.wg_token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "webui_auth_key",
            |m: &CMsgProtoBufHeader| { &m.webui_auth_key },
            |m: &mut CMsgProtoBufHeader| { &mut m.webui_auth_key },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exclude_client_sessionids",
            |m: &CMsgProtoBufHeader| { &m.exclude_client_sessionids },
            |m: &mut CMsgProtoBufHeader| { &mut m.exclude_client_sessionids },
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "ip",
            CMsgProtoBufHeader::has_ip,
            CMsgProtoBufHeader::ip,
            CMsgProtoBufHeader::set_ip,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "ip_v6",
            CMsgProtoBufHeader::has_ip_v6,
            CMsgProtoBufHeader::ip_v6,
            CMsgProtoBufHeader::set_ip_v6,
        ));
        oneofs.push(cmsg_proto_buf_header::Ip_addr::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProtoBufHeader>(
            "CMsgProtoBufHeader",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgProtoBufHeader {
    const NAME: &'static str = "CMsgProtoBufHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_sessionid = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.routing_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                81 => {
                    self.jobid_source = ::std::option::Option::Some(is.read_fixed64()?);
                },
                89 => {
                    self.jobid_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                98 => {
                    self.target_job_name = ::std::option::Option::Some(is.read_string()?);
                },
                192 => {
                    self.seq_num = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                114 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.auth_account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.token_source = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.admin_spoofing_user = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.transport_error = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.messageid = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.publisher_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.trace_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                200 => {
                    self.webapi_key_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.is_from_external_source = ::std::option::Option::Some(is.read_bool()?);
                },
                218 => {
                    is.read_repeated_packed_uint32_into(&mut self.forward_to_sysid)?;
                },
                216 => {
                    self.forward_to_sysid.push(is.read_uint32()?);
                },
                224 => {
                    self.cm_sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.launcher_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.realm = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.timeout_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                274 => {
                    self.debug_source = ::std::option::Option::Some(is.read_string()?);
                },
                280 => {
                    self.debug_source_string_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.token_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                298 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.routing_gc)?;
                },
                304 => {
                    self.session_disposition = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                314 => {
                    self.wg_token = ::std::option::Option::Some(is.read_string()?);
                },
                322 => {
                    self.webui_auth_key = ::std::option::Option::Some(is.read_string()?);
                },
                330 => {
                    is.read_repeated_packed_int32_into(&mut self.exclude_client_sessionids)?;
                },
                328 => {
                    self.exclude_client_sessionids.push(is.read_int32()?);
                },
                120 => {
                    self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(is.read_uint32()?));
                },
                234 => {
                    self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(is.read_tokio_bytes()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_sessionid {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.routing_appid {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.jobid_source {
            my_size += 1 + 8;
        }
        if let Some(v) = self.jobid_target {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_job_name.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        if let Some(v) = self.seq_num {
            my_size += crate::rt::int32_size(24, v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(13, v);
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += crate::rt::string_size(14, &v);
        }
        if let Some(v) = self.auth_account_flags {
            my_size += crate::rt::uint32_size(16, v);
        }
        if let Some(v) = self.token_source {
            my_size += crate::rt::uint32_size(22, v);
        }
        if let Some(v) = self.admin_spoofing_user {
            my_size += 2 + 1;
        }
        if let Some(v) = self.transport_error {
            my_size += crate::rt::int32_size(17, v);
        }
        if let Some(v) = self.messageid {
            my_size += crate::rt::uint64_size(18, v);
        }
        if let Some(v) = self.publisher_group_id {
            my_size += crate::rt::uint32_size(19, v);
        }
        if let Some(v) = self.sysid {
            my_size += crate::rt::uint32_size(20, v);
        }
        if let Some(v) = self.trace_tag {
            my_size += crate::rt::uint64_size(21, v);
        }
        if let Some(v) = self.webapi_key_id {
            my_size += crate::rt::uint32_size(25, v);
        }
        if let Some(v) = self.is_from_external_source {
            my_size += 2 + 1;
        }
        for value in &self.forward_to_sysid {
            my_size += crate::rt::uint32_size(27, *value);
        };
        if let Some(v) = self.cm_sysid {
            my_size += crate::rt::uint32_size(28, v);
        }
        if let Some(v) = self.launcher_type {
            my_size += crate::rt::uint32_size(31, v);
        }
        if let Some(v) = self.realm {
            my_size += crate::rt::uint32_size(32, v);
        }
        if let Some(v) = self.timeout_ms {
            my_size += crate::rt::int32_size(33, v);
        }
        if let Some(v) = self.debug_source.as_ref() {
            my_size += crate::rt::string_size(34, &v);
        }
        if let Some(v) = self.debug_source_string_index {
            my_size += crate::rt::uint32_size(35, v);
        }
        if let Some(v) = self.token_id {
            my_size += crate::rt::uint64_size(36, v);
        }
        if let Some(v) = self.routing_gc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.session_disposition {
            my_size += crate::rt::int32_size(38, v.value());
        }
        if let Some(v) = self.wg_token.as_ref() {
            my_size += crate::rt::string_size(39, &v);
        }
        if let Some(v) = self.webui_auth_key.as_ref() {
            my_size += crate::rt::string_size(40, &v);
        }
        for value in &self.exclude_client_sessionids {
            my_size += crate::rt::int32_size(41, *value);
        };
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &cmsg_proto_buf_header::Ip_addr::Ip(v) => {
                    my_size += crate::rt::uint32_size(15, v);
                },
                &cmsg_proto_buf_header::Ip_addr::IpV6(ref v) => {
                    my_size += crate::rt::bytes_size(29, &v);
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_sessionid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.routing_appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.jobid_source {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.jobid_target {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.target_job_name.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.auth_account_flags {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.token_source {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.admin_spoofing_user {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.transport_error {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.messageid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.publisher_group_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.trace_tag {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.webapi_key_id {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.is_from_external_source {
            os.write_bool(26, v)?;
        }
        for v in &self.forward_to_sysid {
            os.write_uint32(27, *v)?;
        };
        if let Some(v) = self.cm_sysid {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.launcher_type {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.realm {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.timeout_ms {
            os.write_int32(33, v)?;
        }
        if let Some(v) = self.debug_source.as_ref() {
            os.write_string(34, v)?;
        }
        if let Some(v) = self.debug_source_string_index {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.token_id {
            os.write_uint64(36, v)?;
        }
        if let Some(v) = self.routing_gc.as_ref() {
            crate::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.session_disposition {
            os.write_enum(38, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.wg_token.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.webui_auth_key.as_ref() {
            os.write_string(40, v)?;
        }
        for v in &self.exclude_client_sessionids {
            os.write_int32(41, *v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &cmsg_proto_buf_header::Ip_addr::Ip(v) => {
                    os.write_uint32(15, v)?;
                },
                &cmsg_proto_buf_header::Ip_addr::IpV6(ref v) => {
                    os.write_bytes(29, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtoBufHeader {
        CMsgProtoBufHeader::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_sessionid = ::std::option::Option::None;
        self.routing_appid = ::std::option::Option::None;
        self.jobid_source = ::std::option::Option::None;
        self.jobid_target = ::std::option::Option::None;
        self.target_job_name = ::std::option::Option::None;
        self.seq_num = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.auth_account_flags = ::std::option::Option::None;
        self.token_source = ::std::option::Option::None;
        self.admin_spoofing_user = ::std::option::Option::None;
        self.transport_error = ::std::option::Option::None;
        self.messageid = ::std::option::Option::None;
        self.publisher_group_id = ::std::option::Option::None;
        self.sysid = ::std::option::Option::None;
        self.trace_tag = ::std::option::Option::None;
        self.webapi_key_id = ::std::option::Option::None;
        self.is_from_external_source = ::std::option::Option::None;
        self.forward_to_sysid.clear();
        self.cm_sysid = ::std::option::Option::None;
        self.launcher_type = ::std::option::Option::None;
        self.realm = ::std::option::Option::None;
        self.timeout_ms = ::std::option::Option::None;
        self.debug_source = ::std::option::Option::None;
        self.debug_source_string_index = ::std::option::Option::None;
        self.token_id = ::std::option::Option::None;
        self.routing_gc.clear();
        self.session_disposition = ::std::option::Option::None;
        self.wg_token = ::std::option::Option::None;
        self.webui_auth_key = ::std::option::Option::None;
        self.exclude_client_sessionids.clear();
        self.ip_addr = ::std::option::Option::None;
        self.ip_addr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtoBufHeader {
        static instance: CMsgProtoBufHeader = CMsgProtoBufHeader {
            steamid: ::std::option::Option::None,
            client_sessionid: ::std::option::Option::None,
            routing_appid: ::std::option::Option::None,
            jobid_source: ::std::option::Option::None,
            jobid_target: ::std::option::Option::None,
            target_job_name: ::std::option::Option::None,
            seq_num: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            auth_account_flags: ::std::option::Option::None,
            token_source: ::std::option::Option::None,
            admin_spoofing_user: ::std::option::Option::None,
            transport_error: ::std::option::Option::None,
            messageid: ::std::option::Option::None,
            publisher_group_id: ::std::option::Option::None,
            sysid: ::std::option::Option::None,
            trace_tag: ::std::option::Option::None,
            webapi_key_id: ::std::option::Option::None,
            is_from_external_source: ::std::option::Option::None,
            forward_to_sysid: ::std::vec::Vec::new(),
            cm_sysid: ::std::option::Option::None,
            launcher_type: ::std::option::Option::None,
            realm: ::std::option::Option::None,
            timeout_ms: ::std::option::Option::None,
            debug_source: ::std::option::Option::None,
            debug_source_string_index: ::std::option::Option::None,
            token_id: ::std::option::Option::None,
            routing_gc: crate::MessageField::none(),
            session_disposition: ::std::option::Option::None,
            wg_token: ::std::option::Option::None,
            webui_auth_key: ::std::option::Option::None,
            exclude_client_sessionids: ::std::vec::Vec::new(),
            ip_addr: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgProtoBufHeader {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProtoBufHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProtoBufHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgProtoBufHeader {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgProtoBufHeader`
pub mod cmsg_proto_buf_header {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgProtoBufHeader.ip_addr)
    pub enum Ip_addr {
        // @@protoc_insertion_point(oneof_field:CMsgProtoBufHeader.ip)
        Ip(u32),
        // @@protoc_insertion_point(oneof_field:CMsgProtoBufHeader.ip_v6)
        IpV6(::bytes::Bytes),
    }

    impl crate::Oneof for Ip_addr {
    }

    impl crate::OneofFull for Ip_addr {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::CMsgProtoBufHeader as crate::MessageFull>::descriptor().oneof_by_name("ip_addr").unwrap()).clone()
        }
    }

    impl Ip_addr {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Ip_addr>("ip_addr")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgProtoBufHeader.ESessionDisposition)
    pub enum ESessionDisposition {
        // @@protoc_insertion_point(enum_value:CMsgProtoBufHeader.ESessionDisposition.k_ESessionDispositionNormal)
        k_ESessionDispositionNormal = 0,
        // @@protoc_insertion_point(enum_value:CMsgProtoBufHeader.ESessionDisposition.k_ESessionDispositionDisconnect)
        k_ESessionDispositionDisconnect = 1,
    }

    impl crate::Enum for ESessionDisposition {
        const NAME: &'static str = "ESessionDisposition";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ESessionDisposition> {
            match value {
                0 => ::std::option::Option::Some(ESessionDisposition::k_ESessionDispositionNormal),
                1 => ::std::option::Option::Some(ESessionDisposition::k_ESessionDispositionDisconnect),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ESessionDisposition> {
            match str {
                "k_ESessionDispositionNormal" => ::std::option::Option::Some(ESessionDisposition::k_ESessionDispositionNormal),
                "k_ESessionDispositionDisconnect" => ::std::option::Option::Some(ESessionDisposition::k_ESessionDispositionDisconnect),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ESessionDisposition] = &[
            ESessionDisposition::k_ESessionDispositionNormal,
            ESessionDisposition::k_ESessionDispositionDisconnect,
        ];
    }

    impl crate::EnumFull for ESessionDisposition {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgProtoBufHeader.ESessionDisposition").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ESessionDisposition {
        fn default() -> Self {
            ESessionDisposition::k_ESessionDispositionNormal
        }
    }

    impl ESessionDisposition {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<ESessionDisposition>("CMsgProtoBufHeader.ESessionDisposition")
        }
    }
}

// @@protoc_insertion_point(message:CMsgMulti)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMulti {
    // message fields
    // @@protoc_insertion_point(field:CMsgMulti.size_unzipped)
    pub size_unzipped: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMulti.message_body)
    pub message_body: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMulti.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMulti {
    fn default() -> &'a CMsgMulti {
        <CMsgMulti as crate::Message>::default_instance()
    }
}

impl CMsgMulti {
    pub fn new() -> CMsgMulti {
        ::std::default::Default::default()
    }

    // optional uint32 size_unzipped = 1;

    pub fn size_unzipped(&self) -> u32 {
        self.size_unzipped.unwrap_or(0)
    }

    pub fn clear_size_unzipped(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
    }

    pub fn has_size_unzipped(&self) -> bool {
        self.size_unzipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_unzipped(&mut self, v: u32) {
        self.size_unzipped = ::std::option::Option::Some(v);
    }

    // optional bytes message_body = 2;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::bytes::Bytes) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::bytes::Bytes {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::bytes::Bytes {
        self.message_body.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_unzipped",
            |m: &CMsgMulti| { &m.size_unzipped },
            |m: &mut CMsgMulti| { &mut m.size_unzipped },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_body",
            |m: &CMsgMulti| { &m.message_body },
            |m: &mut CMsgMulti| { &mut m.message_body },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMulti>(
            "CMsgMulti",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMulti {
    const NAME: &'static str = "CMsgMulti";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size_unzipped = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message_body = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size_unzipped {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message_body.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.size_unzipped {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMulti {
        CMsgMulti::new()
    }

    fn clear(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
        self.message_body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMulti {
        static instance: CMsgMulti = CMsgMulti {
            size_unzipped: ::std::option::Option::None,
            message_body: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMulti {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMulti").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMulti {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMulti {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgProtobufWrapped)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtobufWrapped {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtobufWrapped.message_body)
    pub message_body: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtobufWrapped.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtobufWrapped {
    fn default() -> &'a CMsgProtobufWrapped {
        <CMsgProtobufWrapped as crate::Message>::default_instance()
    }
}

impl CMsgProtobufWrapped {
    pub fn new() -> CMsgProtobufWrapped {
        ::std::default::Default::default()
    }

    // optional bytes message_body = 1;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::bytes::Bytes) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::bytes::Bytes {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::bytes::Bytes {
        self.message_body.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_body",
            |m: &CMsgProtobufWrapped| { &m.message_body },
            |m: &mut CMsgProtobufWrapped| { &mut m.message_body },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProtobufWrapped>(
            "CMsgProtobufWrapped",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgProtobufWrapped {
    const NAME: &'static str = "CMsgProtobufWrapped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_body = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_body.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtobufWrapped {
        CMsgProtobufWrapped::new()
    }

    fn clear(&mut self) {
        self.message_body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtobufWrapped {
        static instance: CMsgProtobufWrapped = CMsgProtobufWrapped {
            message_body: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgProtobufWrapped {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProtobufWrapped").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProtobufWrapped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgProtobufWrapped {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAuthTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAuthTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgAuthTicket.estate)
    pub estate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.h_steam_pipe)
    pub h_steam_pipe: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket_crc)
    pub ticket_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket)
    pub ticket: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.server_secret)
    pub server_secret: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket_type)
    pub ticket_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAuthTicket.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAuthTicket {
    fn default() -> &'a CMsgAuthTicket {
        <CMsgAuthTicket as crate::Message>::default_instance()
    }
}

impl CMsgAuthTicket {
    pub fn new() -> CMsgAuthTicket {
        ::std::default::Default::default()
    }

    // optional uint32 estate = 1;

    pub fn estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 4;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 h_steam_pipe = 5;

    pub fn h_steam_pipe(&self) -> u32 {
        self.h_steam_pipe.unwrap_or(0)
    }

    pub fn clear_h_steam_pipe(&mut self) {
        self.h_steam_pipe = ::std::option::Option::None;
    }

    pub fn has_h_steam_pipe(&self) -> bool {
        self.h_steam_pipe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_h_steam_pipe(&mut self, v: u32) {
        self.h_steam_pipe = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_crc = 6;

    pub fn ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 7;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::bytes::Bytes) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::bytes::Bytes {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::bytes::Bytes {
        self.ticket.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes server_secret = 8;

    pub fn server_secret(&self) -> &[u8] {
        match self.server_secret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_server_secret(&mut self) {
        self.server_secret = ::std::option::Option::None;
    }

    pub fn has_server_secret(&self) -> bool {
        self.server_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_secret(&mut self, v: ::bytes::Bytes) {
        self.server_secret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_secret(&mut self) -> &mut ::bytes::Bytes {
        if self.server_secret.is_none() {
            self.server_secret = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.server_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_secret(&mut self) -> ::bytes::Bytes {
        self.server_secret.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 ticket_type = 9;

    pub fn ticket_type(&self) -> u32 {
        self.ticket_type.unwrap_or(0)
    }

    pub fn clear_ticket_type(&mut self) {
        self.ticket_type = ::std::option::Option::None;
    }

    pub fn has_ticket_type(&self) -> bool {
        self.ticket_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_type(&mut self, v: u32) {
        self.ticket_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "estate",
            |m: &CMsgAuthTicket| { &m.estate },
            |m: &mut CMsgAuthTicket| { &mut m.estate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgAuthTicket| { &m.eresult },
            |m: &mut CMsgAuthTicket| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgAuthTicket| { &m.steamid },
            |m: &mut CMsgAuthTicket| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgAuthTicket| { &m.gameid },
            |m: &mut CMsgAuthTicket| { &mut m.gameid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "h_steam_pipe",
            |m: &CMsgAuthTicket| { &m.h_steam_pipe },
            |m: &mut CMsgAuthTicket| { &mut m.h_steam_pipe },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_crc",
            |m: &CMsgAuthTicket| { &m.ticket_crc },
            |m: &mut CMsgAuthTicket| { &mut m.ticket_crc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgAuthTicket| { &m.ticket },
            |m: &mut CMsgAuthTicket| { &mut m.ticket },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_secret",
            |m: &CMsgAuthTicket| { &m.server_secret },
            |m: &mut CMsgAuthTicket| { &mut m.server_secret },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_type",
            |m: &CMsgAuthTicket| { &m.ticket_type },
            |m: &mut CMsgAuthTicket| { &mut m.ticket_type },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAuthTicket>(
            "CMsgAuthTicket",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAuthTicket {
    const NAME: &'static str = "CMsgAuthTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.estate = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.h_steam_pipe = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.ticket_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.ticket = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                66 => {
                    self.server_secret = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                72 => {
                    self.ticket_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.estate {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.h_steam_pipe {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.server_secret.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ticket_type {
            my_size += crate::rt::uint32_size(9, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.estate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.h_steam_pipe {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.server_secret.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.ticket_type {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAuthTicket {
        CMsgAuthTicket::new()
    }

    fn clear(&mut self) {
        self.estate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.h_steam_pipe = ::std::option::Option::None;
        self.ticket_crc = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.server_secret = ::std::option::Option::None;
        self.ticket_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAuthTicket {
        static instance: CMsgAuthTicket = CMsgAuthTicket {
            estate: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            h_steam_pipe: ::std::option::Option::None,
            ticket_crc: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            server_secret: ::std::option::Option::None,
            ticket_type: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAuthTicket {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAuthTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAuthTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAuthTicket {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCDDBAppDetailCommon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCDDBAppDetailCommon {
    // message fields
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.tool)
    pub tool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.demo)
    pub demo: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.media)
    pub media: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.community_visible_stats)
    pub community_visible_stats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.friendly_name)
    pub friendly_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.propagation)
    pub propagation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content)
    pub has_adult_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.is_visible_in_steam_china)
    pub is_visible_in_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.app_type)
    pub app_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content_sex)
    pub has_adult_content_sex: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content_violence)
    pub has_adult_content_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.content_descriptorids)
    pub content_descriptorids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCDDBAppDetailCommon.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCDDBAppDetailCommon {
    fn default() -> &'a CCDDBAppDetailCommon {
        <CCDDBAppDetailCommon as crate::Message>::default_instance()
    }
}

impl CCDDBAppDetailCommon {
    pub fn new() -> CCDDBAppDetailCommon {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 3;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tool = 6;

    pub fn tool(&self) -> bool {
        self.tool.unwrap_or(false)
    }

    pub fn clear_tool(&mut self) {
        self.tool = ::std::option::Option::None;
    }

    pub fn has_tool(&self) -> bool {
        self.tool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool(&mut self, v: bool) {
        self.tool = ::std::option::Option::Some(v);
    }

    // optional bool demo = 7;

    pub fn demo(&self) -> bool {
        self.demo.unwrap_or(false)
    }

    pub fn clear_demo(&mut self) {
        self.demo = ::std::option::Option::None;
    }

    pub fn has_demo(&self) -> bool {
        self.demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo(&mut self, v: bool) {
        self.demo = ::std::option::Option::Some(v);
    }

    // optional bool media = 8;

    pub fn media(&self) -> bool {
        self.media.unwrap_or(false)
    }

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool community_visible_stats = 9;

    pub fn community_visible_stats(&self) -> bool {
        self.community_visible_stats.unwrap_or(false)
    }

    pub fn clear_community_visible_stats(&mut self) {
        self.community_visible_stats = ::std::option::Option::None;
    }

    pub fn has_community_visible_stats(&self) -> bool {
        self.community_visible_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_visible_stats(&mut self, v: bool) {
        self.community_visible_stats = ::std::option::Option::Some(v);
    }

    // optional string friendly_name = 10;

    pub fn friendly_name(&self) -> &str {
        match self.friendly_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_friendly_name(&mut self) {
        self.friendly_name = ::std::option::Option::None;
    }

    pub fn has_friendly_name(&self) -> bool {
        self.friendly_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly_name(&mut self, v: ::std::string::String) {
        self.friendly_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friendly_name(&mut self) -> &mut ::std::string::String {
        if self.friendly_name.is_none() {
            self.friendly_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.friendly_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friendly_name(&mut self) -> ::std::string::String {
        self.friendly_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string propagation = 11;

    pub fn propagation(&self) -> &str {
        match self.propagation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_propagation(&mut self) {
        self.propagation = ::std::option::Option::None;
    }

    pub fn has_propagation(&self) -> bool {
        self.propagation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagation(&mut self, v: ::std::string::String) {
        self.propagation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagation(&mut self) -> &mut ::std::string::String {
        if self.propagation.is_none() {
            self.propagation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.propagation.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagation(&mut self) -> ::std::string::String {
        self.propagation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_adult_content = 12;

    pub fn has_adult_content(&self) -> bool {
        self.has_adult_content.unwrap_or(false)
    }

    pub fn clear_has_adult_content(&mut self) {
        self.has_adult_content = ::std::option::Option::None;
    }

    pub fn has_has_adult_content(&self) -> bool {
        self.has_adult_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content(&mut self, v: bool) {
        self.has_adult_content = ::std::option::Option::Some(v);
    }

    // optional bool is_visible_in_steam_china = 13;

    pub fn is_visible_in_steam_china(&self) -> bool {
        self.is_visible_in_steam_china.unwrap_or(false)
    }

    pub fn clear_is_visible_in_steam_china(&mut self) {
        self.is_visible_in_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_visible_in_steam_china(&self) -> bool {
        self.is_visible_in_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_in_steam_china(&mut self, v: bool) {
        self.is_visible_in_steam_china = ::std::option::Option::Some(v);
    }

    // optional uint32 app_type = 14;

    pub fn app_type(&self) -> u32 {
        self.app_type.unwrap_or(0)
    }

    pub fn clear_app_type(&mut self) {
        self.app_type = ::std::option::Option::None;
    }

    pub fn has_app_type(&self) -> bool {
        self.app_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_type(&mut self, v: u32) {
        self.app_type = ::std::option::Option::Some(v);
    }

    // optional bool has_adult_content_sex = 15;

    pub fn has_adult_content_sex(&self) -> bool {
        self.has_adult_content_sex.unwrap_or(false)
    }

    pub fn clear_has_adult_content_sex(&mut self) {
        self.has_adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_has_adult_content_sex(&self) -> bool {
        self.has_adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content_sex(&mut self, v: bool) {
        self.has_adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional bool has_adult_content_violence = 16;

    pub fn has_adult_content_violence(&self) -> bool {
        self.has_adult_content_violence.unwrap_or(false)
    }

    pub fn clear_has_adult_content_violence(&mut self) {
        self.has_adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_has_adult_content_violence(&self) -> bool {
        self.has_adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content_violence(&mut self, v: bool) {
        self.has_adult_content_violence = ::std::option::Option::Some(v);
    }

    // repeated uint32 content_descriptorids = 17;

    pub fn content_descriptorids(&self) -> &[u32] {
        &self.content_descriptorids
    }

    pub fn clear_content_descriptorids(&mut self) {
        self.content_descriptorids.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_descriptorids(&mut self, v: ::std::vec::Vec<u32>) {
        self.content_descriptorids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_content_descriptorids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.content_descriptorids
    }

    // Take field
    pub fn take_content_descriptorids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.content_descriptorids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CCDDBAppDetailCommon| { &m.appid },
            |m: &mut CCDDBAppDetailCommon| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCDDBAppDetailCommon| { &m.name },
            |m: &mut CCDDBAppDetailCommon| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CCDDBAppDetailCommon| { &m.icon },
            |m: &mut CCDDBAppDetailCommon| { &mut m.icon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool",
            |m: &CCDDBAppDetailCommon| { &m.tool },
            |m: &mut CCDDBAppDetailCommon| { &mut m.tool },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "demo",
            |m: &CCDDBAppDetailCommon| { &m.demo },
            |m: &mut CCDDBAppDetailCommon| { &mut m.demo },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "media",
            |m: &CCDDBAppDetailCommon| { &m.media },
            |m: &mut CCDDBAppDetailCommon| { &mut m.media },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "community_visible_stats",
            |m: &CCDDBAppDetailCommon| { &m.community_visible_stats },
            |m: &mut CCDDBAppDetailCommon| { &mut m.community_visible_stats },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "friendly_name",
            |m: &CCDDBAppDetailCommon| { &m.friendly_name },
            |m: &mut CCDDBAppDetailCommon| { &mut m.friendly_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "propagation",
            |m: &CCDDBAppDetailCommon| { &m.propagation },
            |m: &mut CCDDBAppDetailCommon| { &mut m.propagation },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_adult_content",
            |m: &CCDDBAppDetailCommon| { &m.has_adult_content },
            |m: &mut CCDDBAppDetailCommon| { &mut m.has_adult_content },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_visible_in_steam_china",
            |m: &CCDDBAppDetailCommon| { &m.is_visible_in_steam_china },
            |m: &mut CCDDBAppDetailCommon| { &mut m.is_visible_in_steam_china },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_type",
            |m: &CCDDBAppDetailCommon| { &m.app_type },
            |m: &mut CCDDBAppDetailCommon| { &mut m.app_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_adult_content_sex",
            |m: &CCDDBAppDetailCommon| { &m.has_adult_content_sex },
            |m: &mut CCDDBAppDetailCommon| { &mut m.has_adult_content_sex },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_adult_content_violence",
            |m: &CCDDBAppDetailCommon| { &m.has_adult_content_violence },
            |m: &mut CCDDBAppDetailCommon| { &mut m.has_adult_content_violence },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_descriptorids",
            |m: &CCDDBAppDetailCommon| { &m.content_descriptorids },
            |m: &mut CCDDBAppDetailCommon| { &mut m.content_descriptorids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CCDDBAppDetailCommon>(
            "CCDDBAppDetailCommon",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CCDDBAppDetailCommon {
    const NAME: &'static str = "CCDDBAppDetailCommon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.tool = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.demo = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.media = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.community_visible_stats = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.friendly_name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.propagation = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.has_adult_content = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_visible_in_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.app_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.has_adult_content_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.has_adult_content_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    is.read_repeated_packed_uint32_into(&mut self.content_descriptorids)?;
                },
                136 => {
                    self.content_descriptorids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.tool {
            my_size += 1 + 1;
        }
        if let Some(v) = self.demo {
            my_size += 1 + 1;
        }
        if let Some(v) = self.media {
            my_size += 1 + 1;
        }
        if let Some(v) = self.community_visible_stats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.friendly_name.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        if let Some(v) = self.propagation.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        if let Some(v) = self.has_adult_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_visible_in_steam_china {
            my_size += 1 + 1;
        }
        if let Some(v) = self.app_type {
            my_size += crate::rt::uint32_size(14, v);
        }
        if let Some(v) = self.has_adult_content_sex {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_adult_content_violence {
            my_size += 2 + 1;
        }
        for value in &self.content_descriptorids {
            my_size += crate::rt::uint32_size(17, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.tool {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.demo {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.media {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.community_visible_stats {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.friendly_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.propagation.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.has_adult_content {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_visible_in_steam_china {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.app_type {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.has_adult_content_sex {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.has_adult_content_violence {
            os.write_bool(16, v)?;
        }
        for v in &self.content_descriptorids {
            os.write_uint32(17, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCDDBAppDetailCommon {
        CCDDBAppDetailCommon::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.tool = ::std::option::Option::None;
        self.demo = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.community_visible_stats = ::std::option::Option::None;
        self.friendly_name = ::std::option::Option::None;
        self.propagation = ::std::option::Option::None;
        self.has_adult_content = ::std::option::Option::None;
        self.is_visible_in_steam_china = ::std::option::Option::None;
        self.app_type = ::std::option::Option::None;
        self.has_adult_content_sex = ::std::option::Option::None;
        self.has_adult_content_violence = ::std::option::Option::None;
        self.content_descriptorids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCDDBAppDetailCommon {
        static instance: CCDDBAppDetailCommon = CCDDBAppDetailCommon {
            appid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            tool: ::std::option::Option::None,
            demo: ::std::option::Option::None,
            media: ::std::option::Option::None,
            community_visible_stats: ::std::option::Option::None,
            friendly_name: ::std::option::Option::None,
            propagation: ::std::option::Option::None,
            has_adult_content: ::std::option::Option::None,
            is_visible_in_steam_china: ::std::option::Option::None,
            app_type: ::std::option::Option::None,
            has_adult_content_sex: ::std::option::Option::None,
            has_adult_content_violence: ::std::option::Option::None,
            content_descriptorids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CCDDBAppDetailCommon {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCDDBAppDetailCommon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCDDBAppDetailCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CCDDBAppDetailCommon {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAppRights)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAppRights {
    // message fields
    // @@protoc_insertion_point(field:CMsgAppRights.edit_info)
    pub edit_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.publish)
    pub publish: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_error_data)
    pub view_error_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.download)
    pub download: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.upload_cdkeys)
    pub upload_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.generate_cdkeys)
    pub generate_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_financials)
    pub view_financials: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_ceg)
    pub manage_ceg: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_signing)
    pub manage_signing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_cdkeys)
    pub manage_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.edit_marketing)
    pub edit_marketing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.economy_support)
    pub economy_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.economy_support_supervisor)
    pub economy_support_supervisor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_pricing)
    pub manage_pricing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.broadcast_live)
    pub broadcast_live: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_marketing_traffic)
    pub view_marketing_traffic: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.edit_store_display_content)
    pub edit_store_display_content: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAppRights.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAppRights {
    fn default() -> &'a CMsgAppRights {
        <CMsgAppRights as crate::Message>::default_instance()
    }
}

impl CMsgAppRights {
    pub fn new() -> CMsgAppRights {
        ::std::default::Default::default()
    }

    // optional bool edit_info = 1;

    pub fn edit_info(&self) -> bool {
        self.edit_info.unwrap_or(false)
    }

    pub fn clear_edit_info(&mut self) {
        self.edit_info = ::std::option::Option::None;
    }

    pub fn has_edit_info(&self) -> bool {
        self.edit_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_info(&mut self, v: bool) {
        self.edit_info = ::std::option::Option::Some(v);
    }

    // optional bool publish = 2;

    pub fn publish(&self) -> bool {
        self.publish.unwrap_or(false)
    }

    pub fn clear_publish(&mut self) {
        self.publish = ::std::option::Option::None;
    }

    pub fn has_publish(&self) -> bool {
        self.publish.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: bool) {
        self.publish = ::std::option::Option::Some(v);
    }

    // optional bool view_error_data = 3;

    pub fn view_error_data(&self) -> bool {
        self.view_error_data.unwrap_or(false)
    }

    pub fn clear_view_error_data(&mut self) {
        self.view_error_data = ::std::option::Option::None;
    }

    pub fn has_view_error_data(&self) -> bool {
        self.view_error_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_error_data(&mut self, v: bool) {
        self.view_error_data = ::std::option::Option::Some(v);
    }

    // optional bool download = 4;

    pub fn download(&self) -> bool {
        self.download.unwrap_or(false)
    }

    pub fn clear_download(&mut self) {
        self.download = ::std::option::Option::None;
    }

    pub fn has_download(&self) -> bool {
        self.download.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download(&mut self, v: bool) {
        self.download = ::std::option::Option::Some(v);
    }

    // optional bool upload_cdkeys = 5;

    pub fn upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.unwrap_or(false)
    }

    pub fn clear_upload_cdkeys(&mut self) {
        self.upload_cdkeys = ::std::option::Option::None;
    }

    pub fn has_upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_cdkeys(&mut self, v: bool) {
        self.upload_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool generate_cdkeys = 6;

    pub fn generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.unwrap_or(false)
    }

    pub fn clear_generate_cdkeys(&mut self) {
        self.generate_cdkeys = ::std::option::Option::None;
    }

    pub fn has_generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generate_cdkeys(&mut self, v: bool) {
        self.generate_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool view_financials = 7;

    pub fn view_financials(&self) -> bool {
        self.view_financials.unwrap_or(false)
    }

    pub fn clear_view_financials(&mut self) {
        self.view_financials = ::std::option::Option::None;
    }

    pub fn has_view_financials(&self) -> bool {
        self.view_financials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_financials(&mut self, v: bool) {
        self.view_financials = ::std::option::Option::Some(v);
    }

    // optional bool manage_ceg = 8;

    pub fn manage_ceg(&self) -> bool {
        self.manage_ceg.unwrap_or(false)
    }

    pub fn clear_manage_ceg(&mut self) {
        self.manage_ceg = ::std::option::Option::None;
    }

    pub fn has_manage_ceg(&self) -> bool {
        self.manage_ceg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_ceg(&mut self, v: bool) {
        self.manage_ceg = ::std::option::Option::Some(v);
    }

    // optional bool manage_signing = 9;

    pub fn manage_signing(&self) -> bool {
        self.manage_signing.unwrap_or(false)
    }

    pub fn clear_manage_signing(&mut self) {
        self.manage_signing = ::std::option::Option::None;
    }

    pub fn has_manage_signing(&self) -> bool {
        self.manage_signing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_signing(&mut self, v: bool) {
        self.manage_signing = ::std::option::Option::Some(v);
    }

    // optional bool manage_cdkeys = 10;

    pub fn manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.unwrap_or(false)
    }

    pub fn clear_manage_cdkeys(&mut self) {
        self.manage_cdkeys = ::std::option::Option::None;
    }

    pub fn has_manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_cdkeys(&mut self, v: bool) {
        self.manage_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool edit_marketing = 11;

    pub fn edit_marketing(&self) -> bool {
        self.edit_marketing.unwrap_or(false)
    }

    pub fn clear_edit_marketing(&mut self) {
        self.edit_marketing = ::std::option::Option::None;
    }

    pub fn has_edit_marketing(&self) -> bool {
        self.edit_marketing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_marketing(&mut self, v: bool) {
        self.edit_marketing = ::std::option::Option::Some(v);
    }

    // optional bool economy_support = 12;

    pub fn economy_support(&self) -> bool {
        self.economy_support.unwrap_or(false)
    }

    pub fn clear_economy_support(&mut self) {
        self.economy_support = ::std::option::Option::None;
    }

    pub fn has_economy_support(&self) -> bool {
        self.economy_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support(&mut self, v: bool) {
        self.economy_support = ::std::option::Option::Some(v);
    }

    // optional bool economy_support_supervisor = 13;

    pub fn economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.unwrap_or(false)
    }

    pub fn clear_economy_support_supervisor(&mut self) {
        self.economy_support_supervisor = ::std::option::Option::None;
    }

    pub fn has_economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support_supervisor(&mut self, v: bool) {
        self.economy_support_supervisor = ::std::option::Option::Some(v);
    }

    // optional bool manage_pricing = 14;

    pub fn manage_pricing(&self) -> bool {
        self.manage_pricing.unwrap_or(false)
    }

    pub fn clear_manage_pricing(&mut self) {
        self.manage_pricing = ::std::option::Option::None;
    }

    pub fn has_manage_pricing(&self) -> bool {
        self.manage_pricing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_pricing(&mut self, v: bool) {
        self.manage_pricing = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_live = 15;

    pub fn broadcast_live(&self) -> bool {
        self.broadcast_live.unwrap_or(false)
    }

    pub fn clear_broadcast_live(&mut self) {
        self.broadcast_live = ::std::option::Option::None;
    }

    pub fn has_broadcast_live(&self) -> bool {
        self.broadcast_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_live(&mut self, v: bool) {
        self.broadcast_live = ::std::option::Option::Some(v);
    }

    // optional bool view_marketing_traffic = 16;

    pub fn view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.unwrap_or(false)
    }

    pub fn clear_view_marketing_traffic(&mut self) {
        self.view_marketing_traffic = ::std::option::Option::None;
    }

    pub fn has_view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_marketing_traffic(&mut self, v: bool) {
        self.view_marketing_traffic = ::std::option::Option::Some(v);
    }

    // optional bool edit_store_display_content = 17;

    pub fn edit_store_display_content(&self) -> bool {
        self.edit_store_display_content.unwrap_or(false)
    }

    pub fn clear_edit_store_display_content(&mut self) {
        self.edit_store_display_content = ::std::option::Option::None;
    }

    pub fn has_edit_store_display_content(&self) -> bool {
        self.edit_store_display_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_store_display_content(&mut self, v: bool) {
        self.edit_store_display_content = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edit_info",
            |m: &CMsgAppRights| { &m.edit_info },
            |m: &mut CMsgAppRights| { &mut m.edit_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "publish",
            |m: &CMsgAppRights| { &m.publish },
            |m: &mut CMsgAppRights| { &mut m.publish },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_error_data",
            |m: &CMsgAppRights| { &m.view_error_data },
            |m: &mut CMsgAppRights| { &mut m.view_error_data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download",
            |m: &CMsgAppRights| { &m.download },
            |m: &mut CMsgAppRights| { &mut m.download },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_cdkeys",
            |m: &CMsgAppRights| { &m.upload_cdkeys },
            |m: &mut CMsgAppRights| { &mut m.upload_cdkeys },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "generate_cdkeys",
            |m: &CMsgAppRights| { &m.generate_cdkeys },
            |m: &mut CMsgAppRights| { &mut m.generate_cdkeys },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_financials",
            |m: &CMsgAppRights| { &m.view_financials },
            |m: &mut CMsgAppRights| { &mut m.view_financials },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_ceg",
            |m: &CMsgAppRights| { &m.manage_ceg },
            |m: &mut CMsgAppRights| { &mut m.manage_ceg },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_signing",
            |m: &CMsgAppRights| { &m.manage_signing },
            |m: &mut CMsgAppRights| { &mut m.manage_signing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_cdkeys",
            |m: &CMsgAppRights| { &m.manage_cdkeys },
            |m: &mut CMsgAppRights| { &mut m.manage_cdkeys },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edit_marketing",
            |m: &CMsgAppRights| { &m.edit_marketing },
            |m: &mut CMsgAppRights| { &mut m.edit_marketing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "economy_support",
            |m: &CMsgAppRights| { &m.economy_support },
            |m: &mut CMsgAppRights| { &mut m.economy_support },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "economy_support_supervisor",
            |m: &CMsgAppRights| { &m.economy_support_supervisor },
            |m: &mut CMsgAppRights| { &mut m.economy_support_supervisor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_pricing",
            |m: &CMsgAppRights| { &m.manage_pricing },
            |m: &mut CMsgAppRights| { &mut m.manage_pricing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_live",
            |m: &CMsgAppRights| { &m.broadcast_live },
            |m: &mut CMsgAppRights| { &mut m.broadcast_live },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_marketing_traffic",
            |m: &CMsgAppRights| { &m.view_marketing_traffic },
            |m: &mut CMsgAppRights| { &mut m.view_marketing_traffic },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edit_store_display_content",
            |m: &CMsgAppRights| { &m.edit_store_display_content },
            |m: &mut CMsgAppRights| { &mut m.edit_store_display_content },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAppRights>(
            "CMsgAppRights",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAppRights {
    const NAME: &'static str = "CMsgAppRights";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.edit_info = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.publish = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.view_error_data = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.download = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.upload_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.generate_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.view_financials = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.manage_ceg = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.manage_signing = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.manage_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.edit_marketing = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.economy_support = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.economy_support_supervisor = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.manage_pricing = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.broadcast_live = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.view_marketing_traffic = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.edit_store_display_content = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.edit_info {
            my_size += 1 + 1;
        }
        if let Some(v) = self.publish {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_error_data {
            my_size += 1 + 1;
        }
        if let Some(v) = self.download {
            my_size += 1 + 1;
        }
        if let Some(v) = self.upload_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.generate_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_financials {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_ceg {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_signing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.edit_marketing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.economy_support {
            my_size += 1 + 1;
        }
        if let Some(v) = self.economy_support_supervisor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_pricing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.broadcast_live {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_marketing_traffic {
            my_size += 2 + 1;
        }
        if let Some(v) = self.edit_store_display_content {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.edit_info {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.publish {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.view_error_data {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.download {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.upload_cdkeys {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.generate_cdkeys {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.view_financials {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.manage_ceg {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.manage_signing {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.manage_cdkeys {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.edit_marketing {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.economy_support {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.economy_support_supervisor {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.manage_pricing {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.broadcast_live {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.view_marketing_traffic {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.edit_store_display_content {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAppRights {
        CMsgAppRights::new()
    }

    fn clear(&mut self) {
        self.edit_info = ::std::option::Option::None;
        self.publish = ::std::option::Option::None;
        self.view_error_data = ::std::option::Option::None;
        self.download = ::std::option::Option::None;
        self.upload_cdkeys = ::std::option::Option::None;
        self.generate_cdkeys = ::std::option::Option::None;
        self.view_financials = ::std::option::Option::None;
        self.manage_ceg = ::std::option::Option::None;
        self.manage_signing = ::std::option::Option::None;
        self.manage_cdkeys = ::std::option::Option::None;
        self.edit_marketing = ::std::option::Option::None;
        self.economy_support = ::std::option::Option::None;
        self.economy_support_supervisor = ::std::option::Option::None;
        self.manage_pricing = ::std::option::Option::None;
        self.broadcast_live = ::std::option::Option::None;
        self.view_marketing_traffic = ::std::option::Option::None;
        self.edit_store_display_content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAppRights {
        static instance: CMsgAppRights = CMsgAppRights {
            edit_info: ::std::option::Option::None,
            publish: ::std::option::Option::None,
            view_error_data: ::std::option::Option::None,
            download: ::std::option::Option::None,
            upload_cdkeys: ::std::option::Option::None,
            generate_cdkeys: ::std::option::Option::None,
            view_financials: ::std::option::Option::None,
            manage_ceg: ::std::option::Option::None,
            manage_signing: ::std::option::Option::None,
            manage_cdkeys: ::std::option::Option::None,
            edit_marketing: ::std::option::Option::None,
            economy_support: ::std::option::Option::None,
            economy_support_supervisor: ::std::option::Option::None,
            manage_pricing: ::std::option::Option::None,
            broadcast_live: ::std::option::Option::None,
            view_marketing_traffic: ::std::option::Option::None,
            edit_store_display_content: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAppRights {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAppRights").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAppRights {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAppRights {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCuratorPreferences)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCuratorPreferences {
    // message fields
    // @@protoc_insertion_point(field:CCuratorPreferences.supported_languages)
    pub supported_languages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_windows)
    pub platform_windows: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_mac)
    pub platform_mac: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_linux)
    pub platform_linux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.vr_content)
    pub vr_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.adult_content_violence)
    pub adult_content_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.adult_content_sex)
    pub adult_content_sex: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.timestamp_updated)
    pub timestamp_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.tagids_curated)
    pub tagids_curated: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.tagids_filtered)
    pub tagids_filtered: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.website_title)
    pub website_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.website_url)
    pub website_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.discussion_url)
    pub discussion_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.show_broadcast)
    pub show_broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCuratorPreferences.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCuratorPreferences {
    fn default() -> &'a CCuratorPreferences {
        <CCuratorPreferences as crate::Message>::default_instance()
    }
}

impl CCuratorPreferences {
    pub fn new() -> CCuratorPreferences {
        ::std::default::Default::default()
    }

    // optional uint32 supported_languages = 1;

    pub fn supported_languages(&self) -> u32 {
        self.supported_languages.unwrap_or(0)
    }

    pub fn clear_supported_languages(&mut self) {
        self.supported_languages = ::std::option::Option::None;
    }

    pub fn has_supported_languages(&self) -> bool {
        self.supported_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_languages(&mut self, v: u32) {
        self.supported_languages = ::std::option::Option::Some(v);
    }

    // optional bool platform_windows = 2;

    pub fn platform_windows(&self) -> bool {
        self.platform_windows.unwrap_or(false)
    }

    pub fn clear_platform_windows(&mut self) {
        self.platform_windows = ::std::option::Option::None;
    }

    pub fn has_platform_windows(&self) -> bool {
        self.platform_windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_windows(&mut self, v: bool) {
        self.platform_windows = ::std::option::Option::Some(v);
    }

    // optional bool platform_mac = 3;

    pub fn platform_mac(&self) -> bool {
        self.platform_mac.unwrap_or(false)
    }

    pub fn clear_platform_mac(&mut self) {
        self.platform_mac = ::std::option::Option::None;
    }

    pub fn has_platform_mac(&self) -> bool {
        self.platform_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_mac(&mut self, v: bool) {
        self.platform_mac = ::std::option::Option::Some(v);
    }

    // optional bool platform_linux = 4;

    pub fn platform_linux(&self) -> bool {
        self.platform_linux.unwrap_or(false)
    }

    pub fn clear_platform_linux(&mut self) {
        self.platform_linux = ::std::option::Option::None;
    }

    pub fn has_platform_linux(&self) -> bool {
        self.platform_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_linux(&mut self, v: bool) {
        self.platform_linux = ::std::option::Option::Some(v);
    }

    // optional bool vr_content = 5;

    pub fn vr_content(&self) -> bool {
        self.vr_content.unwrap_or(false)
    }

    pub fn clear_vr_content(&mut self) {
        self.vr_content = ::std::option::Option::None;
    }

    pub fn has_vr_content(&self) -> bool {
        self.vr_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_content(&mut self, v: bool) {
        self.vr_content = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_violence = 6;

    pub fn adult_content_violence(&self) -> bool {
        self.adult_content_violence.unwrap_or(false)
    }

    pub fn clear_adult_content_violence(&mut self) {
        self.adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_adult_content_violence(&self) -> bool {
        self.adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_violence(&mut self, v: bool) {
        self.adult_content_violence = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_sex = 7;

    pub fn adult_content_sex(&self) -> bool {
        self.adult_content_sex.unwrap_or(false)
    }

    pub fn clear_adult_content_sex(&mut self) {
        self.adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_adult_content_sex(&self) -> bool {
        self.adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_sex(&mut self, v: bool) {
        self.adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 8;

    pub fn timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }

    // repeated uint32 tagids_curated = 9;

    pub fn tagids_curated(&self) -> &[u32] {
        &self.tagids_curated
    }

    pub fn clear_tagids_curated(&mut self) {
        self.tagids_curated.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagids_curated(&mut self, v: ::std::vec::Vec<u32>) {
        self.tagids_curated = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagids_curated(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tagids_curated
    }

    // Take field
    pub fn take_tagids_curated(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tagids_curated, ::std::vec::Vec::new())
    }

    // repeated uint32 tagids_filtered = 10;

    pub fn tagids_filtered(&self) -> &[u32] {
        &self.tagids_filtered
    }

    pub fn clear_tagids_filtered(&mut self) {
        self.tagids_filtered.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagids_filtered(&mut self, v: ::std::vec::Vec<u32>) {
        self.tagids_filtered = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagids_filtered(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tagids_filtered
    }

    // Take field
    pub fn take_tagids_filtered(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tagids_filtered, ::std::vec::Vec::new())
    }

    // optional string website_title = 11;

    pub fn website_title(&self) -> &str {
        match self.website_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_website_title(&mut self) {
        self.website_title = ::std::option::Option::None;
    }

    pub fn has_website_title(&self) -> bool {
        self.website_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_title(&mut self, v: ::std::string::String) {
        self.website_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_title(&mut self) -> &mut ::std::string::String {
        if self.website_title.is_none() {
            self.website_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.website_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_title(&mut self) -> ::std::string::String {
        self.website_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string website_url = 12;

    pub fn website_url(&self) -> &str {
        match self.website_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_website_url(&mut self) {
        self.website_url = ::std::option::Option::None;
    }

    pub fn has_website_url(&self) -> bool {
        self.website_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_url(&mut self, v: ::std::string::String) {
        self.website_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_url(&mut self) -> &mut ::std::string::String {
        if self.website_url.is_none() {
            self.website_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.website_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_url(&mut self) -> ::std::string::String {
        self.website_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string discussion_url = 13;

    pub fn discussion_url(&self) -> &str {
        match self.discussion_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_discussion_url(&mut self) {
        self.discussion_url = ::std::option::Option::None;
    }

    pub fn has_discussion_url(&self) -> bool {
        self.discussion_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discussion_url(&mut self, v: ::std::string::String) {
        self.discussion_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discussion_url(&mut self) -> &mut ::std::string::String {
        if self.discussion_url.is_none() {
            self.discussion_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.discussion_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_discussion_url(&mut self) -> ::std::string::String {
        self.discussion_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show_broadcast = 14;

    pub fn show_broadcast(&self) -> bool {
        self.show_broadcast.unwrap_or(false)
    }

    pub fn clear_show_broadcast(&mut self) {
        self.show_broadcast = ::std::option::Option::None;
    }

    pub fn has_show_broadcast(&self) -> bool {
        self.show_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_broadcast(&mut self, v: bool) {
        self.show_broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supported_languages",
            |m: &CCuratorPreferences| { &m.supported_languages },
            |m: &mut CCuratorPreferences| { &mut m.supported_languages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_windows",
            |m: &CCuratorPreferences| { &m.platform_windows },
            |m: &mut CCuratorPreferences| { &mut m.platform_windows },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_mac",
            |m: &CCuratorPreferences| { &m.platform_mac },
            |m: &mut CCuratorPreferences| { &mut m.platform_mac },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_linux",
            |m: &CCuratorPreferences| { &m.platform_linux },
            |m: &mut CCuratorPreferences| { &mut m.platform_linux },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_content",
            |m: &CCuratorPreferences| { &m.vr_content },
            |m: &mut CCuratorPreferences| { &mut m.vr_content },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "adult_content_violence",
            |m: &CCuratorPreferences| { &m.adult_content_violence },
            |m: &mut CCuratorPreferences| { &mut m.adult_content_violence },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "adult_content_sex",
            |m: &CCuratorPreferences| { &m.adult_content_sex },
            |m: &mut CCuratorPreferences| { &mut m.adult_content_sex },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_updated",
            |m: &CCuratorPreferences| { &m.timestamp_updated },
            |m: &mut CCuratorPreferences| { &mut m.timestamp_updated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagids_curated",
            |m: &CCuratorPreferences| { &m.tagids_curated },
            |m: &mut CCuratorPreferences| { &mut m.tagids_curated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagids_filtered",
            |m: &CCuratorPreferences| { &m.tagids_filtered },
            |m: &mut CCuratorPreferences| { &mut m.tagids_filtered },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "website_title",
            |m: &CCuratorPreferences| { &m.website_title },
            |m: &mut CCuratorPreferences| { &mut m.website_title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "website_url",
            |m: &CCuratorPreferences| { &m.website_url },
            |m: &mut CCuratorPreferences| { &mut m.website_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "discussion_url",
            |m: &CCuratorPreferences| { &m.discussion_url },
            |m: &mut CCuratorPreferences| { &mut m.discussion_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_broadcast",
            |m: &CCuratorPreferences| { &m.show_broadcast },
            |m: &mut CCuratorPreferences| { &mut m.show_broadcast },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CCuratorPreferences>(
            "CCuratorPreferences",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CCuratorPreferences {
    const NAME: &'static str = "CCuratorPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.supported_languages = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.platform_windows = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.platform_mac = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.platform_linux = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.vr_content = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.adult_content_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.adult_content_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.timestamp_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids_curated)?;
                },
                72 => {
                    self.tagids_curated.push(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids_filtered)?;
                },
                80 => {
                    self.tagids_filtered.push(is.read_uint32()?);
                },
                90 => {
                    self.website_title = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.website_url = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.discussion_url = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.show_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.supported_languages {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.platform_windows {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_mac {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_linux {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vr_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.adult_content_violence {
            my_size += 1 + 1;
        }
        if let Some(v) = self.adult_content_sex {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += crate::rt::uint32_size(8, v);
        }
        for value in &self.tagids_curated {
            my_size += crate::rt::uint32_size(9, *value);
        };
        for value in &self.tagids_filtered {
            my_size += crate::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.website_title.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        if let Some(v) = self.website_url.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        if let Some(v) = self.discussion_url.as_ref() {
            my_size += crate::rt::string_size(13, &v);
        }
        if let Some(v) = self.show_broadcast {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.supported_languages {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform_windows {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.platform_mac {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.platform_linux {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.vr_content {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.adult_content_violence {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.adult_content_sex {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(8, v)?;
        }
        for v in &self.tagids_curated {
            os.write_uint32(9, *v)?;
        };
        for v in &self.tagids_filtered {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.website_title.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.website_url.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.discussion_url.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.show_broadcast {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCuratorPreferences {
        CCuratorPreferences::new()
    }

    fn clear(&mut self) {
        self.supported_languages = ::std::option::Option::None;
        self.platform_windows = ::std::option::Option::None;
        self.platform_mac = ::std::option::Option::None;
        self.platform_linux = ::std::option::Option::None;
        self.vr_content = ::std::option::Option::None;
        self.adult_content_violence = ::std::option::Option::None;
        self.adult_content_sex = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.tagids_curated.clear();
        self.tagids_filtered.clear();
        self.website_title = ::std::option::Option::None;
        self.website_url = ::std::option::Option::None;
        self.discussion_url = ::std::option::Option::None;
        self.show_broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCuratorPreferences {
        static instance: CCuratorPreferences = CCuratorPreferences {
            supported_languages: ::std::option::Option::None,
            platform_windows: ::std::option::Option::None,
            platform_mac: ::std::option::Option::None,
            platform_linux: ::std::option::Option::None,
            vr_content: ::std::option::Option::None,
            adult_content_violence: ::std::option::Option::None,
            adult_content_sex: ::std::option::Option::None,
            timestamp_updated: ::std::option::Option::None,
            tagids_curated: ::std::vec::Vec::new(),
            tagids_filtered: ::std::vec::Vec::new(),
            website_title: ::std::option::Option::None,
            website_url: ::std::option::Option::None,
            discussion_url: ::std::option::Option::None,
            show_broadcast: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CCuratorPreferences {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCuratorPreferences").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCuratorPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CCuratorPreferences {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CLocalizationToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLocalizationToken {
    // message fields
    // @@protoc_insertion_point(field:CLocalizationToken.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLocalizationToken.localized_string)
    pub localized_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CLocalizationToken.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLocalizationToken {
    fn default() -> &'a CLocalizationToken {
        <CLocalizationToken as crate::Message>::default_instance()
    }
}

impl CLocalizationToken {
    pub fn new() -> CLocalizationToken {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional string localized_string = 2;

    pub fn localized_string(&self) -> &str {
        match self.localized_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localized_string(&mut self) {
        self.localized_string = ::std::option::Option::None;
    }

    pub fn has_localized_string(&self) -> bool {
        self.localized_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localized_string(&mut self, v: ::std::string::String) {
        self.localized_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localized_string(&mut self) -> &mut ::std::string::String {
        if self.localized_string.is_none() {
            self.localized_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localized_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_localized_string(&mut self) -> ::std::string::String {
        self.localized_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CLocalizationToken| { &m.language },
            |m: &mut CLocalizationToken| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "localized_string",
            |m: &CLocalizationToken| { &m.localized_string },
            |m: &mut CLocalizationToken| { &mut m.localized_string },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CLocalizationToken>(
            "CLocalizationToken",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CLocalizationToken {
    const NAME: &'static str = "CLocalizationToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.localized_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.localized_string.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.localized_string.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLocalizationToken {
        CLocalizationToken::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.localized_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLocalizationToken {
        static instance: CLocalizationToken = CLocalizationToken {
            language: ::std::option::Option::None,
            localized_string: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CLocalizationToken {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLocalizationToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLocalizationToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CLocalizationToken {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanEventUserNewsTuple)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanEventUserNewsTuple {
    // message fields
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.event_gid)
    pub event_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.announcement_gid)
    pub announcement_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime_start)
    pub rtime_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime_end)
    pub rtime_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.priority_score)
    pub priority_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.clamp_range_slot)
    pub clamp_range_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime32_last_modified)
    pub rtime32_last_modified: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanEventUserNewsTuple.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanEventUserNewsTuple {
    fn default() -> &'a CClanEventUserNewsTuple {
        <CClanEventUserNewsTuple as crate::Message>::default_instance()
    }
}

impl CClanEventUserNewsTuple {
    pub fn new() -> CClanEventUserNewsTuple {
        ::std::default::Default::default()
    }

    // optional uint32 clanid = 1;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 2;

    pub fn event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }

    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 announcement_gid = 3;

    pub fn announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }

    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_start = 4;

    pub fn rtime_start(&self) -> u32 {
        self.rtime_start.unwrap_or(0)
    }

    pub fn clear_rtime_start(&mut self) {
        self.rtime_start = ::std::option::Option::None;
    }

    pub fn has_rtime_start(&self) -> bool {
        self.rtime_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_start(&mut self, v: u32) {
        self.rtime_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_end = 5;

    pub fn rtime_end(&self) -> u32 {
        self.rtime_end.unwrap_or(0)
    }

    pub fn clear_rtime_end(&mut self) {
        self.rtime_end = ::std::option::Option::None;
    }

    pub fn has_rtime_end(&self) -> bool {
        self.rtime_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_end(&mut self, v: u32) {
        self.rtime_end = ::std::option::Option::Some(v);
    }

    // optional uint32 priority_score = 6;

    pub fn priority_score(&self) -> u32 {
        self.priority_score.unwrap_or(0)
    }

    pub fn clear_priority_score(&mut self) {
        self.priority_score = ::std::option::Option::None;
    }

    pub fn has_priority_score(&self) -> bool {
        self.priority_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_score(&mut self, v: u32) {
        self.priority_score = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 7;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint32 clamp_range_slot = 8;

    pub fn clamp_range_slot(&self) -> u32 {
        self.clamp_range_slot.unwrap_or(0)
    }

    pub fn clear_clamp_range_slot(&mut self) {
        self.clamp_range_slot = ::std::option::Option::None;
    }

    pub fn has_clamp_range_slot(&self) -> bool {
        self.clamp_range_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clamp_range_slot(&mut self, v: u32) {
        self.clamp_range_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 9;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 10;

    pub fn rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }

    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CClanEventUserNewsTuple| { &m.clanid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.clanid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_gid",
            |m: &CClanEventUserNewsTuple| { &m.event_gid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.event_gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "announcement_gid",
            |m: &CClanEventUserNewsTuple| { &m.announcement_gid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.announcement_gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_start",
            |m: &CClanEventUserNewsTuple| { &m.rtime_start },
            |m: &mut CClanEventUserNewsTuple| { &mut m.rtime_start },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_end",
            |m: &CClanEventUserNewsTuple| { &m.rtime_end },
            |m: &mut CClanEventUserNewsTuple| { &mut m.rtime_end },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority_score",
            |m: &CClanEventUserNewsTuple| { &m.priority_score },
            |m: &mut CClanEventUserNewsTuple| { &mut m.priority_score },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CClanEventUserNewsTuple| { &m.type_ },
            |m: &mut CClanEventUserNewsTuple| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clamp_range_slot",
            |m: &CClanEventUserNewsTuple| { &m.clamp_range_slot },
            |m: &mut CClanEventUserNewsTuple| { &mut m.clamp_range_slot },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClanEventUserNewsTuple| { &m.appid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_last_modified",
            |m: &CClanEventUserNewsTuple| { &m.rtime32_last_modified },
            |m: &mut CClanEventUserNewsTuple| { &mut m.rtime32_last_modified },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClanEventUserNewsTuple>(
            "CClanEventUserNewsTuple",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClanEventUserNewsTuple {
    const NAME: &'static str = "CClanEventUserNewsTuple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.announcement_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.rtime_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rtime_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.priority_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.clamp_range_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.rtime32_last_modified = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clanid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.announcement_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.rtime_start {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rtime_end {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.priority_score {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.type_ {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.clamp_range_slot {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += crate::rt::uint32_size(10, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.clanid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.rtime_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtime_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.priority_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.clamp_range_slot {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanEventUserNewsTuple {
        CClanEventUserNewsTuple::new()
    }

    fn clear(&mut self) {
        self.clanid = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.rtime_start = ::std::option::Option::None;
        self.rtime_end = ::std::option::Option::None;
        self.priority_score = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.clamp_range_slot = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanEventUserNewsTuple {
        static instance: CClanEventUserNewsTuple = CClanEventUserNewsTuple {
            clanid: ::std::option::Option::None,
            event_gid: ::std::option::Option::None,
            announcement_gid: ::std::option::Option::None,
            rtime_start: ::std::option::Option::None,
            rtime_end: ::std::option::Option::None,
            priority_score: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            clamp_range_slot: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            rtime32_last_modified: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClanEventUserNewsTuple {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanEventUserNewsTuple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanEventUserNewsTuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClanEventUserNewsTuple {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanMatchEventByRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanMatchEventByRange {
    // message fields
    // @@protoc_insertion_point(field:CClanMatchEventByRange.rtime_before)
    pub rtime_before: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.rtime_after)
    pub rtime_after: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.qualified)
    pub qualified: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.events)
    pub events: ::std::vec::Vec<CClanEventUserNewsTuple>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanMatchEventByRange.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanMatchEventByRange {
    fn default() -> &'a CClanMatchEventByRange {
        <CClanMatchEventByRange as crate::Message>::default_instance()
    }
}

impl CClanMatchEventByRange {
    pub fn new() -> CClanMatchEventByRange {
        ::std::default::Default::default()
    }

    // optional uint32 rtime_before = 1;

    pub fn rtime_before(&self) -> u32 {
        self.rtime_before.unwrap_or(0)
    }

    pub fn clear_rtime_before(&mut self) {
        self.rtime_before = ::std::option::Option::None;
    }

    pub fn has_rtime_before(&self) -> bool {
        self.rtime_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_before(&mut self, v: u32) {
        self.rtime_before = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_after = 2;

    pub fn rtime_after(&self) -> u32 {
        self.rtime_after.unwrap_or(0)
    }

    pub fn clear_rtime_after(&mut self) {
        self.rtime_after = ::std::option::Option::None;
    }

    pub fn has_rtime_after(&self) -> bool {
        self.rtime_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_after(&mut self, v: u32) {
        self.rtime_after = ::std::option::Option::Some(v);
    }

    // optional uint32 qualified = 3;

    pub fn qualified(&self) -> u32 {
        self.qualified.unwrap_or(0)
    }

    pub fn clear_qualified(&mut self) {
        self.qualified = ::std::option::Option::None;
    }

    pub fn has_qualified(&self) -> bool {
        self.qualified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qualified(&mut self, v: u32) {
        self.qualified = ::std::option::Option::Some(v);
    }

    // repeated .CClanEventUserNewsTuple events = 4;

    pub fn events(&self) -> &[CClanEventUserNewsTuple] {
        &self.events
    }

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::std::vec::Vec<CClanEventUserNewsTuple>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::std::vec::Vec<CClanEventUserNewsTuple> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::std::vec::Vec<CClanEventUserNewsTuple> {
        ::std::mem::replace(&mut self.events, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_before",
            |m: &CClanMatchEventByRange| { &m.rtime_before },
            |m: &mut CClanMatchEventByRange| { &mut m.rtime_before },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_after",
            |m: &CClanMatchEventByRange| { &m.rtime_after },
            |m: &mut CClanMatchEventByRange| { &mut m.rtime_after },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "qualified",
            |m: &CClanMatchEventByRange| { &m.qualified },
            |m: &mut CClanMatchEventByRange| { &mut m.qualified },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &CClanMatchEventByRange| { &m.events },
            |m: &mut CClanMatchEventByRange| { &mut m.events },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClanMatchEventByRange>(
            "CClanMatchEventByRange",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClanMatchEventByRange {
    const NAME: &'static str = "CClanMatchEventByRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rtime_before = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rtime_after = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.qualified = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rtime_before {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rtime_after {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.qualified {
            my_size += crate::rt::uint32_size(3, v);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.rtime_before {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rtime_after {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.qualified {
            os.write_uint32(3, v)?;
        }
        for v in &self.events {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanMatchEventByRange {
        CClanMatchEventByRange::new()
    }

    fn clear(&mut self) {
        self.rtime_before = ::std::option::Option::None;
        self.rtime_after = ::std::option::Option::None;
        self.qualified = ::std::option::Option::None;
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanMatchEventByRange {
        static instance: CClanMatchEventByRange = CClanMatchEventByRange {
            rtime_before: ::std::option::Option::None,
            rtime_after: ::std::option::Option::None,
            qualified: ::std::option::Option::None,
            events: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClanMatchEventByRange {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanMatchEventByRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanMatchEventByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClanMatchEventByRange {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCommunity_ClanAnnouncementInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClanAnnouncementInfo {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.clanid)
    pub clanid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posterid)
    pub posterid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posttime)
    pub posttime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.updatetime)
    pub updatetime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.commentcount)
    pub commentcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.event_gid)
    pub event_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.voteupcount)
    pub voteupcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.votedowncount)
    pub votedowncount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.ban_check_result)
    pub ban_check_result: ::std::option::Option<crate::EnumOrUnknown<EBanContentCheckResult>>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClanAnnouncementInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClanAnnouncementInfo {
    fn default() -> &'a CCommunity_ClanAnnouncementInfo {
        <CCommunity_ClanAnnouncementInfo as crate::Message>::default_instance()
    }
}

impl CCommunity_ClanAnnouncementInfo {
    pub fn new() -> CCommunity_ClanAnnouncementInfo {
        ::std::default::Default::default()
    }

    // optional uint64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint64 clanid = 2;

    pub fn clanid(&self) -> u64 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u64) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint64 posterid = 3;

    pub fn posterid(&self) -> u64 {
        self.posterid.unwrap_or(0)
    }

    pub fn clear_posterid(&mut self) {
        self.posterid = ::std::option::Option::None;
    }

    pub fn has_posterid(&self) -> bool {
        self.posterid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posterid(&mut self, v: u64) {
        self.posterid = ::std::option::Option::Some(v);
    }

    // optional string headline = 4;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 posttime = 5;

    pub fn posttime(&self) -> u32 {
        self.posttime.unwrap_or(0)
    }

    pub fn clear_posttime(&mut self) {
        self.posttime = ::std::option::Option::None;
    }

    pub fn has_posttime(&self) -> bool {
        self.posttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttime(&mut self, v: u32) {
        self.posttime = ::std::option::Option::Some(v);
    }

    // optional uint32 updatetime = 6;

    pub fn updatetime(&self) -> u32 {
        self.updatetime.unwrap_or(0)
    }

    pub fn clear_updatetime(&mut self) {
        self.updatetime = ::std::option::Option::None;
    }

    pub fn has_updatetime(&self) -> bool {
        self.updatetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatetime(&mut self, v: u32) {
        self.updatetime = ::std::option::Option::Some(v);
    }

    // optional string body = 7;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 commentcount = 8;

    pub fn commentcount(&self) -> i32 {
        self.commentcount.unwrap_or(0)
    }

    pub fn clear_commentcount(&mut self) {
        self.commentcount = ::std::option::Option::None;
    }

    pub fn has_commentcount(&self) -> bool {
        self.commentcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentcount(&mut self, v: i32) {
        self.commentcount = ::std::option::Option::Some(v);
    }

    // repeated string tags = 9;

    pub fn tags(&self) -> &[::std::string::String] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    // optional int32 language = 10;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 11;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 12;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 13;

    pub fn event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }

    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional int32 voteupcount = 14;

    pub fn voteupcount(&self) -> i32 {
        self.voteupcount.unwrap_or(0)
    }

    pub fn clear_voteupcount(&mut self) {
        self.voteupcount = ::std::option::Option::None;
    }

    pub fn has_voteupcount(&self) -> bool {
        self.voteupcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voteupcount(&mut self, v: i32) {
        self.voteupcount = ::std::option::Option::Some(v);
    }

    // optional int32 votedowncount = 15;

    pub fn votedowncount(&self) -> i32 {
        self.votedowncount.unwrap_or(0)
    }

    pub fn clear_votedowncount(&mut self) {
        self.votedowncount = ::std::option::Option::None;
    }

    pub fn has_votedowncount(&self) -> bool {
        self.votedowncount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votedowncount(&mut self, v: i32) {
        self.votedowncount = ::std::option::Option::Some(v);
    }

    // optional .EBanContentCheckResult ban_check_result = 16;

    pub fn ban_check_result(&self) -> EBanContentCheckResult {
        match self.ban_check_result {
            Some(e) => e.enum_value_or(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            None => EBanContentCheckResult::k_EBanContentCheckResult_NotScanned,
        }
    }

    pub fn clear_ban_check_result(&mut self) {
        self.ban_check_result = ::std::option::Option::None;
    }

    pub fn has_ban_check_result(&self) -> bool {
        self.ban_check_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_check_result(&mut self, v: EBanContentCheckResult) {
        self.ban_check_result = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool banned = 17;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.gid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.clanid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.clanid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "posterid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.posterid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.posterid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "headline",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.headline },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.headline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "posttime",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.posttime },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.posttime },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatetime",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.updatetime },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.updatetime },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.body },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.body },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "commentcount",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.commentcount },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.commentcount },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.tags },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.tags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.language },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.hidden },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.hidden },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "forum_topic_id",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.forum_topic_id },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.forum_topic_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_gid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.event_gid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.event_gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "voteupcount",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.voteupcount },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.voteupcount },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "votedowncount",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.votedowncount },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.votedowncount },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban_check_result",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.ban_check_result },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.ban_check_result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "banned",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.banned },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.banned },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CCommunity_ClanAnnouncementInfo>(
            "CCommunity_ClanAnnouncementInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CCommunity_ClanAnnouncementInfo {
    const NAME: &'static str = "CCommunity_ClanAnnouncementInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.posterid = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.posttime = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.updatetime = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.commentcount = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.tags.push(is.read_string()?);
                },
                80 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                97 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                105 => {
                    self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                112 => {
                    self.voteupcount = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.votedowncount = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.ban_check_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.clanid {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.posterid {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.posttime {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.updatetime {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.commentcount {
            my_size += crate::rt::int32_size(8, v);
        }
        for value in &self.tags {
            my_size += crate::rt::string_size(9, &value);
        };
        if let Some(v) = self.language {
            my_size += crate::rt::int32_size(10, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.voteupcount {
            my_size += crate::rt::int32_size(14, v);
        }
        if let Some(v) = self.votedowncount {
            my_size += crate::rt::int32_size(15, v);
        }
        if let Some(v) = self.ban_check_result {
            my_size += crate::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.banned {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.posterid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.posttime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.updatetime {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.commentcount {
            os.write_int32(8, v)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.language {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(13, v)?;
        }
        if let Some(v) = self.voteupcount {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.votedowncount {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.ban_check_result {
            os.write_enum(16, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.banned {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClanAnnouncementInfo {
        CCommunity_ClanAnnouncementInfo::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.posterid = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.posttime = ::std::option::Option::None;
        self.updatetime = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.commentcount = ::std::option::Option::None;
        self.tags.clear();
        self.language = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.voteupcount = ::std::option::Option::None;
        self.votedowncount = ::std::option::Option::None;
        self.ban_check_result = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClanAnnouncementInfo {
        static instance: CCommunity_ClanAnnouncementInfo = CCommunity_ClanAnnouncementInfo {
            gid: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            posterid: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            posttime: ::std::option::Option::None,
            updatetime: ::std::option::Option::None,
            body: ::std::option::Option::None,
            commentcount: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            language: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            event_gid: ::std::option::Option::None,
            voteupcount: ::std::option::Option::None,
            votedowncount: ::std::option::Option::None,
            ban_check_result: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CCommunity_ClanAnnouncementInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCommunity_ClanAnnouncementInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCommunity_ClanAnnouncementInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CCommunity_ClanAnnouncementInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanEventData {
    // message fields
    // @@protoc_insertion_point(field:CClanEventData.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.clan_steamid)
    pub clan_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.event_type)
    pub event_type: ::std::option::Option<crate::EnumOrUnknown<EProtoClanEventType>>,
    // @@protoc_insertion_point(field:CClanEventData.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.server_address)
    pub server_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.server_password)
    pub server_password: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_start_time)
    pub rtime32_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_end_time)
    pub rtime32_end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.comment_count)
    pub comment_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CClanEventData.creator_steamid)
    pub creator_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.last_update_steamid)
    pub last_update_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.event_notes)
    pub event_notes: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.jsondata)
    pub jsondata: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.announcement_body)
    pub announcement_body: crate::MessageField<CCommunity_ClanAnnouncementInfo>,
    // @@protoc_insertion_point(field:CClanEventData.published)
    pub published: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClanEventData.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_visibility_start)
    pub rtime32_visibility_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_visibility_end)
    pub rtime32_visibility_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.broadcaster_accountid)
    pub broadcaster_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.follower_count)
    pub follower_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.ignore_count)
    pub ignore_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_last_modified)
    pub rtime32_last_modified: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.news_post_gid)
    pub news_post_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.rtime_mod_reviewed)
    pub rtime_mod_reviewed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.featured_app_tagid)
    pub featured_app_tagid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.referenced_appids)
    pub referenced_appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CClanEventData.build_id)
    pub build_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.build_branch)
    pub build_branch: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanEventData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanEventData {
    fn default() -> &'a CClanEventData {
        <CClanEventData as crate::Message>::default_instance()
    }
}

impl CClanEventData {
    pub fn new() -> CClanEventData {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 clan_steamid = 2;

    pub fn clan_steamid(&self) -> u64 {
        self.clan_steamid.unwrap_or(0)
    }

    pub fn clear_clan_steamid(&mut self) {
        self.clan_steamid = ::std::option::Option::None;
    }

    pub fn has_clan_steamid(&self) -> bool {
        self.clan_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_steamid(&mut self, v: u64) {
        self.clan_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_name = 3;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EProtoClanEventType event_type = 4;

    pub fn event_type(&self) -> EProtoClanEventType {
        match self.event_type {
            Some(e) => e.enum_value_or(EProtoClanEventType::k_EClanOtherEvent),
            None => EProtoClanEventType::k_EClanOtherEvent,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: EProtoClanEventType) {
        self.event_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 appid = 5;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string server_address = 6;

    pub fn server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_password = 7;

    pub fn server_password(&self) -> &str {
        match self.server_password.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_password(&mut self) {
        self.server_password = ::std::option::Option::None;
    }

    pub fn has_server_password(&self) -> bool {
        self.server_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_password(&mut self, v: ::std::string::String) {
        self.server_password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_password(&mut self) -> &mut ::std::string::String {
        if self.server_password.is_none() {
            self.server_password = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_password(&mut self) -> ::std::string::String {
        self.server_password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 rtime32_start_time = 8;

    pub fn rtime32_start_time(&self) -> u32 {
        self.rtime32_start_time.unwrap_or(0)
    }

    pub fn clear_rtime32_start_time(&mut self) {
        self.rtime32_start_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_start_time(&self) -> bool {
        self.rtime32_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_start_time(&mut self, v: u32) {
        self.rtime32_start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_end_time = 9;

    pub fn rtime32_end_time(&self) -> u32 {
        self.rtime32_end_time.unwrap_or(0)
    }

    pub fn clear_rtime32_end_time(&mut self) {
        self.rtime32_end_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_end_time(&self) -> bool {
        self.rtime32_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_end_time(&mut self, v: u32) {
        self.rtime32_end_time = ::std::option::Option::Some(v);
    }

    // optional int32 comment_count = 10;

    pub fn comment_count(&self) -> i32 {
        self.comment_count.unwrap_or(0)
    }

    pub fn clear_comment_count(&mut self) {
        self.comment_count = ::std::option::Option::None;
    }

    pub fn has_comment_count(&self) -> bool {
        self.comment_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_count(&mut self, v: i32) {
        self.comment_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steamid = 11;

    pub fn creator_steamid(&self) -> u64 {
        self.creator_steamid.unwrap_or(0)
    }

    pub fn clear_creator_steamid(&mut self) {
        self.creator_steamid = ::std::option::Option::None;
    }

    pub fn has_creator_steamid(&self) -> bool {
        self.creator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steamid(&mut self, v: u64) {
        self.creator_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 last_update_steamid = 12;

    pub fn last_update_steamid(&self) -> u64 {
        self.last_update_steamid.unwrap_or(0)
    }

    pub fn clear_last_update_steamid(&mut self) {
        self.last_update_steamid = ::std::option::Option::None;
    }

    pub fn has_last_update_steamid(&self) -> bool {
        self.last_update_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_update_steamid(&mut self, v: u64) {
        self.last_update_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_notes = 13;

    pub fn event_notes(&self) -> &str {
        match self.event_notes.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_notes(&mut self) {
        self.event_notes = ::std::option::Option::None;
    }

    pub fn has_event_notes(&self) -> bool {
        self.event_notes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_notes(&mut self, v: ::std::string::String) {
        self.event_notes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_notes(&mut self) -> &mut ::std::string::String {
        if self.event_notes.is_none() {
            self.event_notes = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_notes.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_notes(&mut self) -> ::std::string::String {
        self.event_notes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string jsondata = 14;

    pub fn jsondata(&self) -> &str {
        match self.jsondata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_jsondata(&mut self) {
        self.jsondata = ::std::option::Option::None;
    }

    pub fn has_jsondata(&self) -> bool {
        self.jsondata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jsondata(&mut self, v: ::std::string::String) {
        self.jsondata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jsondata(&mut self) -> &mut ::std::string::String {
        if self.jsondata.is_none() {
            self.jsondata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.jsondata.as_mut().unwrap()
    }

    // Take field
    pub fn take_jsondata(&mut self) -> ::std::string::String {
        self.jsondata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CCommunity_ClanAnnouncementInfo announcement_body = 15;

    pub fn announcement_body(&self) -> &CCommunity_ClanAnnouncementInfo {
        self.announcement_body.as_ref().unwrap_or_else(|| <CCommunity_ClanAnnouncementInfo as crate::Message>::default_instance())
    }

    pub fn clear_announcement_body(&mut self) {
        self.announcement_body.clear();
    }

    pub fn has_announcement_body(&self) -> bool {
        self.announcement_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_body(&mut self, v: CCommunity_ClanAnnouncementInfo) {
        self.announcement_body = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_body(&mut self) -> &mut CCommunity_ClanAnnouncementInfo {
        self.announcement_body.mut_or_insert_default()
    }

    // Take field
    pub fn take_announcement_body(&mut self) -> CCommunity_ClanAnnouncementInfo {
        self.announcement_body.take().unwrap_or_else(|| CCommunity_ClanAnnouncementInfo::new())
    }

    // optional bool published = 16;

    pub fn published(&self) -> bool {
        self.published.unwrap_or(false)
    }

    pub fn clear_published(&mut self) {
        self.published = ::std::option::Option::None;
    }

    pub fn has_published(&self) -> bool {
        self.published.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published(&mut self, v: bool) {
        self.published = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 17;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_start = 18;

    pub fn rtime32_visibility_start(&self) -> u32 {
        self.rtime32_visibility_start.unwrap_or(0)
    }

    pub fn clear_rtime32_visibility_start(&mut self) {
        self.rtime32_visibility_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_start(&self) -> bool {
        self.rtime32_visibility_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_start(&mut self, v: u32) {
        self.rtime32_visibility_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_end = 19;

    pub fn rtime32_visibility_end(&self) -> u32 {
        self.rtime32_visibility_end.unwrap_or(0)
    }

    pub fn clear_rtime32_visibility_end(&mut self) {
        self.rtime32_visibility_end = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_end(&self) -> bool {
        self.rtime32_visibility_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_end(&mut self, v: u32) {
        self.rtime32_visibility_end = ::std::option::Option::Some(v);
    }

    // optional uint32 broadcaster_accountid = 20;

    pub fn broadcaster_accountid(&self) -> u32 {
        self.broadcaster_accountid.unwrap_or(0)
    }

    pub fn clear_broadcaster_accountid(&mut self) {
        self.broadcaster_accountid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_accountid(&self) -> bool {
        self.broadcaster_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_accountid(&mut self, v: u32) {
        self.broadcaster_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 follower_count = 21;

    pub fn follower_count(&self) -> u32 {
        self.follower_count.unwrap_or(0)
    }

    pub fn clear_follower_count(&mut self) {
        self.follower_count = ::std::option::Option::None;
    }

    pub fn has_follower_count(&self) -> bool {
        self.follower_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follower_count(&mut self, v: u32) {
        self.follower_count = ::std::option::Option::Some(v);
    }

    // optional uint32 ignore_count = 22;

    pub fn ignore_count(&self) -> u32 {
        self.ignore_count.unwrap_or(0)
    }

    pub fn clear_ignore_count(&mut self) {
        self.ignore_count = ::std::option::Option::None;
    }

    pub fn has_ignore_count(&self) -> bool {
        self.ignore_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_count(&mut self, v: u32) {
        self.ignore_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 23;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 24;

    pub fn rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }

    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }

    // optional fixed64 news_post_gid = 25;

    pub fn news_post_gid(&self) -> u64 {
        self.news_post_gid.unwrap_or(0)
    }

    pub fn clear_news_post_gid(&mut self) {
        self.news_post_gid = ::std::option::Option::None;
    }

    pub fn has_news_post_gid(&self) -> bool {
        self.news_post_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_news_post_gid(&mut self, v: u64) {
        self.news_post_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_mod_reviewed = 26;

    pub fn rtime_mod_reviewed(&self) -> u32 {
        self.rtime_mod_reviewed.unwrap_or(0)
    }

    pub fn clear_rtime_mod_reviewed(&mut self) {
        self.rtime_mod_reviewed = ::std::option::Option::None;
    }

    pub fn has_rtime_mod_reviewed(&self) -> bool {
        self.rtime_mod_reviewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_mod_reviewed(&mut self, v: u32) {
        self.rtime_mod_reviewed = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_app_tagid = 27;

    pub fn featured_app_tagid(&self) -> u32 {
        self.featured_app_tagid.unwrap_or(0)
    }

    pub fn clear_featured_app_tagid(&mut self) {
        self.featured_app_tagid = ::std::option::Option::None;
    }

    pub fn has_featured_app_tagid(&self) -> bool {
        self.featured_app_tagid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_app_tagid(&mut self, v: u32) {
        self.featured_app_tagid = ::std::option::Option::Some(v);
    }

    // repeated uint32 referenced_appids = 28;

    pub fn referenced_appids(&self) -> &[u32] {
        &self.referenced_appids
    }

    pub fn clear_referenced_appids(&mut self) {
        self.referenced_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_referenced_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.referenced_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_referenced_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.referenced_appids
    }

    // Take field
    pub fn take_referenced_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.referenced_appids, ::std::vec::Vec::new())
    }

    // optional uint32 build_id = 29;

    pub fn build_id(&self) -> u32 {
        self.build_id.unwrap_or(0)
    }

    pub fn clear_build_id(&mut self) {
        self.build_id = ::std::option::Option::None;
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: u32) {
        self.build_id = ::std::option::Option::Some(v);
    }

    // optional string build_branch = 30;

    pub fn build_branch(&self) -> &str {
        match self.build_branch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_build_branch(&mut self) {
        self.build_branch = ::std::option::Option::None;
    }

    pub fn has_build_branch(&self) -> bool {
        self.build_branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_branch(&mut self, v: ::std::string::String) {
        self.build_branch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_branch(&mut self) -> &mut ::std::string::String {
        if self.build_branch.is_none() {
            self.build_branch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.build_branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_branch(&mut self) -> ::std::string::String {
        self.build_branch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(30);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CClanEventData| { &m.gid },
            |m: &mut CClanEventData| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clan_steamid",
            |m: &CClanEventData| { &m.clan_steamid },
            |m: &mut CClanEventData| { &mut m.clan_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &CClanEventData| { &m.event_name },
            |m: &mut CClanEventData| { &mut m.event_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CClanEventData| { &m.event_type },
            |m: &mut CClanEventData| { &mut m.event_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClanEventData| { &m.appid },
            |m: &mut CClanEventData| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_address",
            |m: &CClanEventData| { &m.server_address },
            |m: &mut CClanEventData| { &mut m.server_address },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_password",
            |m: &CClanEventData| { &m.server_password },
            |m: &mut CClanEventData| { &mut m.server_password },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_start_time",
            |m: &CClanEventData| { &m.rtime32_start_time },
            |m: &mut CClanEventData| { &mut m.rtime32_start_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_end_time",
            |m: &CClanEventData| { &m.rtime32_end_time },
            |m: &mut CClanEventData| { &mut m.rtime32_end_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment_count",
            |m: &CClanEventData| { &m.comment_count },
            |m: &mut CClanEventData| { &mut m.comment_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "creator_steamid",
            |m: &CClanEventData| { &m.creator_steamid },
            |m: &mut CClanEventData| { &mut m.creator_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_update_steamid",
            |m: &CClanEventData| { &m.last_update_steamid },
            |m: &mut CClanEventData| { &mut m.last_update_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_notes",
            |m: &CClanEventData| { &m.event_notes },
            |m: &mut CClanEventData| { &mut m.event_notes },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "jsondata",
            |m: &CClanEventData| { &m.jsondata },
            |m: &mut CClanEventData| { &mut m.jsondata },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CCommunity_ClanAnnouncementInfo>(
            "announcement_body",
            |m: &CClanEventData| { &m.announcement_body },
            |m: &mut CClanEventData| { &mut m.announcement_body },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "published",
            |m: &CClanEventData| { &m.published },
            |m: &mut CClanEventData| { &mut m.published },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &CClanEventData| { &m.hidden },
            |m: &mut CClanEventData| { &mut m.hidden },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_visibility_start",
            |m: &CClanEventData| { &m.rtime32_visibility_start },
            |m: &mut CClanEventData| { &mut m.rtime32_visibility_start },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_visibility_end",
            |m: &CClanEventData| { &m.rtime32_visibility_end },
            |m: &mut CClanEventData| { &mut m.rtime32_visibility_end },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcaster_accountid",
            |m: &CClanEventData| { &m.broadcaster_accountid },
            |m: &mut CClanEventData| { &mut m.broadcaster_accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "follower_count",
            |m: &CClanEventData| { &m.follower_count },
            |m: &mut CClanEventData| { &mut m.follower_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore_count",
            |m: &CClanEventData| { &m.ignore_count },
            |m: &mut CClanEventData| { &mut m.ignore_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "forum_topic_id",
            |m: &CClanEventData| { &m.forum_topic_id },
            |m: &mut CClanEventData| { &mut m.forum_topic_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_last_modified",
            |m: &CClanEventData| { &m.rtime32_last_modified },
            |m: &mut CClanEventData| { &mut m.rtime32_last_modified },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "news_post_gid",
            |m: &CClanEventData| { &m.news_post_gid },
            |m: &mut CClanEventData| { &mut m.news_post_gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_mod_reviewed",
            |m: &CClanEventData| { &m.rtime_mod_reviewed },
            |m: &mut CClanEventData| { &mut m.rtime_mod_reviewed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "featured_app_tagid",
            |m: &CClanEventData| { &m.featured_app_tagid },
            |m: &mut CClanEventData| { &mut m.featured_app_tagid },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "referenced_appids",
            |m: &CClanEventData| { &m.referenced_appids },
            |m: &mut CClanEventData| { &mut m.referenced_appids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_id",
            |m: &CClanEventData| { &m.build_id },
            |m: &mut CClanEventData| { &mut m.build_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_branch",
            |m: &CClanEventData| { &m.build_branch },
            |m: &mut CClanEventData| { &mut m.build_branch },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClanEventData>(
            "CClanEventData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClanEventData {
    const NAME: &'static str = "CClanEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.clan_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.server_address = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.server_password = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.rtime32_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.rtime32_end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.comment_count = ::std::option::Option::Some(is.read_int32()?);
                },
                89 => {
                    self.creator_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                97 => {
                    self.last_update_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                106 => {
                    self.event_notes = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.jsondata = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.announcement_body)?;
                },
                128 => {
                    self.published = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.rtime32_visibility_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.rtime32_visibility_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.broadcaster_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.follower_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.ignore_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                185 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                192 => {
                    self.rtime32_last_modified = ::std::option::Option::Some(is.read_uint32()?);
                },
                201 => {
                    self.news_post_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                208 => {
                    self.rtime_mod_reviewed = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.featured_app_tagid = ::std::option::Option::Some(is.read_uint32()?);
                },
                226 => {
                    is.read_repeated_packed_uint32_into(&mut self.referenced_appids)?;
                },
                224 => {
                    self.referenced_appids.push(is.read_uint32()?);
                },
                232 => {
                    self.build_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    self.build_branch = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.clan_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_type {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.server_address.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.server_password.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.rtime32_start_time {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.rtime32_end_time {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.comment_count {
            my_size += crate::rt::int32_size(10, v);
        }
        if let Some(v) = self.creator_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.last_update_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_notes.as_ref() {
            my_size += crate::rt::string_size(13, &v);
        }
        if let Some(v) = self.jsondata.as_ref() {
            my_size += crate::rt::string_size(14, &v);
        }
        if let Some(v) = self.announcement_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.published {
            my_size += 2 + 1;
        }
        if let Some(v) = self.hidden {
            my_size += 2 + 1;
        }
        if let Some(v) = self.rtime32_visibility_start {
            my_size += crate::rt::uint32_size(18, v);
        }
        if let Some(v) = self.rtime32_visibility_end {
            my_size += crate::rt::uint32_size(19, v);
        }
        if let Some(v) = self.broadcaster_accountid {
            my_size += crate::rt::uint32_size(20, v);
        }
        if let Some(v) = self.follower_count {
            my_size += crate::rt::uint32_size(21, v);
        }
        if let Some(v) = self.ignore_count {
            my_size += crate::rt::uint32_size(22, v);
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += crate::rt::uint32_size(24, v);
        }
        if let Some(v) = self.news_post_gid {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            my_size += crate::rt::uint32_size(26, v);
        }
        if let Some(v) = self.featured_app_tagid {
            my_size += crate::rt::uint32_size(27, v);
        }
        for value in &self.referenced_appids {
            my_size += crate::rt::uint32_size(28, *value);
        };
        if let Some(v) = self.build_id {
            my_size += crate::rt::uint32_size(29, v);
        }
        if let Some(v) = self.build_branch.as_ref() {
            my_size += crate::rt::string_size(30, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.server_address.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.server_password.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.rtime32_start_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.rtime32_end_time {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.comment_count {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.creator_steamid {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.last_update_steamid {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.event_notes.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.jsondata.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.announcement_body.as_ref() {
            crate::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.published {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.rtime32_visibility_start {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.rtime32_visibility_end {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.broadcaster_accountid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.follower_count {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.ignore_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(23, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.news_post_gid {
            os.write_fixed64(25, v)?;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.featured_app_tagid {
            os.write_uint32(27, v)?;
        }
        for v in &self.referenced_appids {
            os.write_uint32(28, *v)?;
        };
        if let Some(v) = self.build_id {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.build_branch.as_ref() {
            os.write_string(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanEventData {
        CClanEventData::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clan_steamid = ::std::option::Option::None;
        self.event_name = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.server_password = ::std::option::Option::None;
        self.rtime32_start_time = ::std::option::Option::None;
        self.rtime32_end_time = ::std::option::Option::None;
        self.comment_count = ::std::option::Option::None;
        self.creator_steamid = ::std::option::Option::None;
        self.last_update_steamid = ::std::option::Option::None;
        self.event_notes = ::std::option::Option::None;
        self.jsondata = ::std::option::Option::None;
        self.announcement_body.clear();
        self.published = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.rtime32_visibility_start = ::std::option::Option::None;
        self.rtime32_visibility_end = ::std::option::Option::None;
        self.broadcaster_accountid = ::std::option::Option::None;
        self.follower_count = ::std::option::Option::None;
        self.ignore_count = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.news_post_gid = ::std::option::Option::None;
        self.rtime_mod_reviewed = ::std::option::Option::None;
        self.featured_app_tagid = ::std::option::Option::None;
        self.referenced_appids.clear();
        self.build_id = ::std::option::Option::None;
        self.build_branch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanEventData {
        static instance: CClanEventData = CClanEventData {
            gid: ::std::option::Option::None,
            clan_steamid: ::std::option::Option::None,
            event_name: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            server_address: ::std::option::Option::None,
            server_password: ::std::option::Option::None,
            rtime32_start_time: ::std::option::Option::None,
            rtime32_end_time: ::std::option::Option::None,
            comment_count: ::std::option::Option::None,
            creator_steamid: ::std::option::Option::None,
            last_update_steamid: ::std::option::Option::None,
            event_notes: ::std::option::Option::None,
            jsondata: ::std::option::Option::None,
            announcement_body: crate::MessageField::none(),
            published: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            rtime32_visibility_start: ::std::option::Option::None,
            rtime32_visibility_end: ::std::option::Option::None,
            broadcaster_accountid: ::std::option::Option::None,
            follower_count: ::std::option::Option::None,
            ignore_count: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            rtime32_last_modified: ::std::option::Option::None,
            news_post_gid: ::std::option::Option::None,
            rtime_mod_reviewed: ::std::option::Option::None,
            featured_app_tagid: ::std::option::Option::None,
            referenced_appids: ::std::vec::Vec::new(),
            build_id: ::std::option::Option::None,
            build_branch: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClanEventData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanEventData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClanEventData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CBilling_Address)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBilling_Address {
    // message fields
    // @@protoc_insertion_point(field:CBilling_Address.first_name)
    pub first_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.last_name)
    pub last_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.address1)
    pub address1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.address2)
    pub address2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.city)
    pub city: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.us_state)
    pub us_state: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.postcode)
    pub postcode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.zip_plus4)
    pub zip_plus4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBilling_Address.phone)
    pub phone: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBilling_Address.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBilling_Address {
    fn default() -> &'a CBilling_Address {
        <CBilling_Address as crate::Message>::default_instance()
    }
}

impl CBilling_Address {
    pub fn new() -> CBilling_Address {
        ::std::default::Default::default()
    }

    // optional string first_name = 1;

    pub fn first_name(&self) -> &str {
        match self.first_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_first_name(&mut self) {
        self.first_name = ::std::option::Option::None;
    }

    pub fn has_first_name(&self) -> bool {
        self.first_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_name(&mut self, v: ::std::string::String) {
        self.first_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_name(&mut self) -> &mut ::std::string::String {
        if self.first_name.is_none() {
            self.first_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.first_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_name(&mut self) -> ::std::string::String {
        self.first_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string last_name = 2;

    pub fn last_name(&self) -> &str {
        match self.last_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_name(&mut self) {
        self.last_name = ::std::option::Option::None;
    }

    pub fn has_last_name(&self) -> bool {
        self.last_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_name(&mut self, v: ::std::string::String) {
        self.last_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_name(&mut self) -> &mut ::std::string::String {
        if self.last_name.is_none() {
            self.last_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_name(&mut self) -> ::std::string::String {
        self.last_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address1 = 3;

    pub fn address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address1(&mut self) {
        self.address1 = ::std::option::Option::None;
    }

    pub fn has_address1(&self) -> bool {
        self.address1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address1(&mut self, v: ::std::string::String) {
        self.address1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address1(&mut self) -> &mut ::std::string::String {
        if self.address1.is_none() {
            self.address1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address1.as_mut().unwrap()
    }

    // Take field
    pub fn take_address1(&mut self) -> ::std::string::String {
        self.address1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address2 = 4;

    pub fn address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address2(&mut self) {
        self.address2 = ::std::option::Option::None;
    }

    pub fn has_address2(&self) -> bool {
        self.address2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address2(&mut self, v: ::std::string::String) {
        self.address2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address2(&mut self) -> &mut ::std::string::String {
        if self.address2.is_none() {
            self.address2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address2.as_mut().unwrap()
    }

    // Take field
    pub fn take_address2(&mut self) -> ::std::string::String {
        self.address2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city = 5;

    pub fn city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_city(&mut self) {
        self.city = ::std::option::Option::None;
    }

    pub fn has_city(&self) -> bool {
        self.city.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        if self.city.is_none() {
            self.city = ::std::option::Option::Some(::std::string::String::new());
        }
        self.city.as_mut().unwrap()
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        self.city.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string us_state = 6;

    pub fn us_state(&self) -> &str {
        match self.us_state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_us_state(&mut self) {
        self.us_state = ::std::option::Option::None;
    }

    pub fn has_us_state(&self) -> bool {
        self.us_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_us_state(&mut self, v: ::std::string::String) {
        self.us_state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_us_state(&mut self) -> &mut ::std::string::String {
        if self.us_state.is_none() {
            self.us_state = ::std::option::Option::Some(::std::string::String::new());
        }
        self.us_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_us_state(&mut self) -> ::std::string::String {
        self.us_state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_code = 7;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postcode = 8;

    pub fn postcode(&self) -> &str {
        match self.postcode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postcode(&mut self) {
        self.postcode = ::std::option::Option::None;
    }

    pub fn has_postcode(&self) -> bool {
        self.postcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postcode(&mut self, v: ::std::string::String) {
        self.postcode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postcode(&mut self) -> &mut ::std::string::String {
        if self.postcode.is_none() {
            self.postcode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_postcode(&mut self) -> ::std::string::String {
        self.postcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 zip_plus4 = 9;

    pub fn zip_plus4(&self) -> i32 {
        self.zip_plus4.unwrap_or(0)
    }

    pub fn clear_zip_plus4(&mut self) {
        self.zip_plus4 = ::std::option::Option::None;
    }

    pub fn has_zip_plus4(&self) -> bool {
        self.zip_plus4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zip_plus4(&mut self, v: i32) {
        self.zip_plus4 = ::std::option::Option::Some(v);
    }

    // optional string phone = 10;

    pub fn phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phone(&mut self) {
        self.phone = ::std::option::Option::None;
    }

    pub fn has_phone(&self) -> bool {
        self.phone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone(&mut self, v: ::std::string::String) {
        self.phone = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phone(&mut self) -> &mut ::std::string::String {
        if self.phone.is_none() {
            self.phone = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phone.as_mut().unwrap()
    }

    // Take field
    pub fn take_phone(&mut self) -> ::std::string::String {
        self.phone.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_name",
            |m: &CBilling_Address| { &m.first_name },
            |m: &mut CBilling_Address| { &mut m.first_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_name",
            |m: &CBilling_Address| { &m.last_name },
            |m: &mut CBilling_Address| { &mut m.last_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "address1",
            |m: &CBilling_Address| { &m.address1 },
            |m: &mut CBilling_Address| { &mut m.address1 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "address2",
            |m: &CBilling_Address| { &m.address2 },
            |m: &mut CBilling_Address| { &mut m.address2 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "city",
            |m: &CBilling_Address| { &m.city },
            |m: &mut CBilling_Address| { &mut m.city },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "us_state",
            |m: &CBilling_Address| { &m.us_state },
            |m: &mut CBilling_Address| { &mut m.us_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CBilling_Address| { &m.country_code },
            |m: &mut CBilling_Address| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "postcode",
            |m: &CBilling_Address| { &m.postcode },
            |m: &mut CBilling_Address| { &mut m.postcode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "zip_plus4",
            |m: &CBilling_Address| { &m.zip_plus4 },
            |m: &mut CBilling_Address| { &mut m.zip_plus4 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone",
            |m: &CBilling_Address| { &m.phone },
            |m: &mut CBilling_Address| { &mut m.phone },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CBilling_Address>(
            "CBilling_Address",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CBilling_Address {
    const NAME: &'static str = "CBilling_Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.first_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.last_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.address1 = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.address2 = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.city = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.us_state = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.postcode = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.zip_plus4 = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.phone = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.first_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.last_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.address1.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.address2.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.city.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.us_state.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.postcode.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.zip_plus4 {
            my_size += crate::rt::int32_size(9, v);
        }
        if let Some(v) = self.phone.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.first_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.last_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.address1.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.address2.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.city.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.us_state.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.postcode.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.zip_plus4 {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.phone.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBilling_Address {
        CBilling_Address::new()
    }

    fn clear(&mut self) {
        self.first_name = ::std::option::Option::None;
        self.last_name = ::std::option::Option::None;
        self.address1 = ::std::option::Option::None;
        self.address2 = ::std::option::Option::None;
        self.city = ::std::option::Option::None;
        self.us_state = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.postcode = ::std::option::Option::None;
        self.zip_plus4 = ::std::option::Option::None;
        self.phone = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBilling_Address {
        static instance: CBilling_Address = CBilling_Address {
            first_name: ::std::option::Option::None,
            last_name: ::std::option::Option::None,
            address1: ::std::option::Option::None,
            address2: ::std::option::Option::None,
            city: ::std::option::Option::None,
            us_state: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            postcode: ::std::option::Option::None,
            zip_plus4: ::std::option::Option::None,
            phone: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CBilling_Address {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBilling_Address").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBilling_Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CBilling_Address {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CPackageReservationStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPackageReservationStatus {
    // message fields
    // @@protoc_insertion_point(field:CPackageReservationStatus.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.reservation_state)
    pub reservation_state: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.total_queue_size)
    pub total_queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.reservation_country_code)
    pub reservation_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.expired)
    pub expired: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.time_expires)
    pub time_expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.time_reserved)
    pub time_reserved: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.rtime_estimated_notification)
    pub rtime_estimated_notification: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.notificaton_token)
    pub notificaton_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CPackageReservationStatus.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPackageReservationStatus {
    fn default() -> &'a CPackageReservationStatus {
        <CPackageReservationStatus as crate::Message>::default_instance()
    }
}

impl CPackageReservationStatus {
    pub fn new() -> CPackageReservationStatus {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional int32 reservation_state = 2;

    pub fn reservation_state(&self) -> i32 {
        self.reservation_state.unwrap_or(0)
    }

    pub fn clear_reservation_state(&mut self) {
        self.reservation_state = ::std::option::Option::None;
    }

    pub fn has_reservation_state(&self) -> bool {
        self.reservation_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_state(&mut self, v: i32) {
        self.reservation_state = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 total_queue_size = 4;

    pub fn total_queue_size(&self) -> i32 {
        self.total_queue_size.unwrap_or(0)
    }

    pub fn clear_total_queue_size(&mut self) {
        self.total_queue_size = ::std::option::Option::None;
    }

    pub fn has_total_queue_size(&self) -> bool {
        self.total_queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_queue_size(&mut self, v: i32) {
        self.total_queue_size = ::std::option::Option::Some(v);
    }

    // optional string reservation_country_code = 5;

    pub fn reservation_country_code(&self) -> &str {
        match self.reservation_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reservation_country_code(&mut self) {
        self.reservation_country_code = ::std::option::Option::None;
    }

    pub fn has_reservation_country_code(&self) -> bool {
        self.reservation_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_country_code(&mut self, v: ::std::string::String) {
        self.reservation_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation_country_code(&mut self) -> &mut ::std::string::String {
        if self.reservation_country_code.is_none() {
            self.reservation_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reservation_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation_country_code(&mut self) -> ::std::string::String {
        self.reservation_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool expired = 6;

    pub fn expired(&self) -> bool {
        self.expired.unwrap_or(false)
    }

    pub fn clear_expired(&mut self) {
        self.expired = ::std::option::Option::None;
    }

    pub fn has_expired(&self) -> bool {
        self.expired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expired(&mut self, v: bool) {
        self.expired = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 7;

    pub fn time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint32 time_reserved = 8;

    pub fn time_reserved(&self) -> u32 {
        self.time_reserved.unwrap_or(0)
    }

    pub fn clear_time_reserved(&mut self) {
        self.time_reserved = ::std::option::Option::None;
    }

    pub fn has_time_reserved(&self) -> bool {
        self.time_reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_reserved(&mut self, v: u32) {
        self.time_reserved = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_estimated_notification = 9;

    pub fn rtime_estimated_notification(&self) -> u32 {
        self.rtime_estimated_notification.unwrap_or(0)
    }

    pub fn clear_rtime_estimated_notification(&mut self) {
        self.rtime_estimated_notification = ::std::option::Option::None;
    }

    pub fn has_rtime_estimated_notification(&self) -> bool {
        self.rtime_estimated_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_estimated_notification(&mut self, v: u32) {
        self.rtime_estimated_notification = ::std::option::Option::Some(v);
    }

    // optional string notificaton_token = 10;

    pub fn notificaton_token(&self) -> &str {
        match self.notificaton_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notificaton_token(&mut self) {
        self.notificaton_token = ::std::option::Option::None;
    }

    pub fn has_notificaton_token(&self) -> bool {
        self.notificaton_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notificaton_token(&mut self, v: ::std::string::String) {
        self.notificaton_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notificaton_token(&mut self) -> &mut ::std::string::String {
        if self.notificaton_token.is_none() {
            self.notificaton_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notificaton_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_notificaton_token(&mut self) -> ::std::string::String {
        self.notificaton_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packageid",
            |m: &CPackageReservationStatus| { &m.packageid },
            |m: &mut CPackageReservationStatus| { &mut m.packageid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_state",
            |m: &CPackageReservationStatus| { &m.reservation_state },
            |m: &mut CPackageReservationStatus| { &mut m.reservation_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_position",
            |m: &CPackageReservationStatus| { &m.queue_position },
            |m: &mut CPackageReservationStatus| { &mut m.queue_position },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_queue_size",
            |m: &CPackageReservationStatus| { &m.total_queue_size },
            |m: &mut CPackageReservationStatus| { &mut m.total_queue_size },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_country_code",
            |m: &CPackageReservationStatus| { &m.reservation_country_code },
            |m: &mut CPackageReservationStatus| { &mut m.reservation_country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "expired",
            |m: &CPackageReservationStatus| { &m.expired },
            |m: &mut CPackageReservationStatus| { &mut m.expired },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expires",
            |m: &CPackageReservationStatus| { &m.time_expires },
            |m: &mut CPackageReservationStatus| { &mut m.time_expires },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_reserved",
            |m: &CPackageReservationStatus| { &m.time_reserved },
            |m: &mut CPackageReservationStatus| { &mut m.time_reserved },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_estimated_notification",
            |m: &CPackageReservationStatus| { &m.rtime_estimated_notification },
            |m: &mut CPackageReservationStatus| { &mut m.rtime_estimated_notification },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "notificaton_token",
            |m: &CPackageReservationStatus| { &m.notificaton_token },
            |m: &mut CPackageReservationStatus| { &mut m.notificaton_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CPackageReservationStatus>(
            "CPackageReservationStatus",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CPackageReservationStatus {
    const NAME: &'static str = "CPackageReservationStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reservation_state = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.total_queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.reservation_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.expired = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.time_reserved = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.rtime_estimated_notification = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.notificaton_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reservation_state {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.total_queue_size {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.reservation_country_code.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.expired {
            my_size += 1 + 1;
        }
        if let Some(v) = self.time_expires {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.time_reserved {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.rtime_estimated_notification {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.notificaton_token.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reservation_state {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.total_queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.reservation_country_code.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.expired {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.time_reserved {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.rtime_estimated_notification {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.notificaton_token.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPackageReservationStatus {
        CPackageReservationStatus::new()
    }

    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.reservation_state = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.total_queue_size = ::std::option::Option::None;
        self.reservation_country_code = ::std::option::Option::None;
        self.expired = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.time_reserved = ::std::option::Option::None;
        self.rtime_estimated_notification = ::std::option::Option::None;
        self.notificaton_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPackageReservationStatus {
        static instance: CPackageReservationStatus = CPackageReservationStatus {
            packageid: ::std::option::Option::None,
            reservation_state: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            total_queue_size: ::std::option::Option::None,
            reservation_country_code: ::std::option::Option::None,
            expired: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            time_reserved: ::std::option::Option::None,
            rtime_estimated_notification: ::std::option::Option::None,
            notificaton_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CPackageReservationStatus {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPackageReservationStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPackageReservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CPackageReservationStatus {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyValuePair)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyValuePair {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyValuePair.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgKeyValuePair.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyValuePair.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyValuePair {
    fn default() -> &'a CMsgKeyValuePair {
        <CMsgKeyValuePair as crate::Message>::default_instance()
    }
}

impl CMsgKeyValuePair {
    pub fn new() -> CMsgKeyValuePair {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgKeyValuePair| { &m.name },
            |m: &mut CMsgKeyValuePair| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgKeyValuePair| { &m.value },
            |m: &mut CMsgKeyValuePair| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyValuePair>(
            "CMsgKeyValuePair",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgKeyValuePair {
    const NAME: &'static str = "CMsgKeyValuePair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyValuePair {
        CMsgKeyValuePair::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyValuePair {
        static instance: CMsgKeyValuePair = CMsgKeyValuePair {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgKeyValuePair {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyValuePair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgKeyValuePair {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyValueSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyValueSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyValueSet.pairs)
    pub pairs: ::std::vec::Vec<CMsgKeyValuePair>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyValueSet.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyValueSet {
    fn default() -> &'a CMsgKeyValueSet {
        <CMsgKeyValueSet as crate::Message>::default_instance()
    }
}

impl CMsgKeyValueSet {
    pub fn new() -> CMsgKeyValueSet {
        ::std::default::Default::default()
    }

    // repeated .CMsgKeyValuePair pairs = 1;

    pub fn pairs(&self) -> &[CMsgKeyValuePair] {
        &self.pairs
    }

    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::std::vec::Vec<CMsgKeyValuePair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::std::vec::Vec<CMsgKeyValuePair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::std::vec::Vec<CMsgKeyValuePair> {
        ::std::mem::replace(&mut self.pairs, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pairs",
            |m: &CMsgKeyValueSet| { &m.pairs },
            |m: &mut CMsgKeyValueSet| { &mut m.pairs },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyValueSet>(
            "CMsgKeyValueSet",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgKeyValueSet {
    const NAME: &'static str = "CMsgKeyValueSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pairs.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.pairs {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyValueSet {
        CMsgKeyValueSet::new()
    }

    fn clear(&mut self) {
        self.pairs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyValueSet {
        static instance: CMsgKeyValueSet = CMsgKeyValueSet {
            pairs: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgKeyValueSet {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyValueSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyValueSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgKeyValueSet {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UserContentDescriptorPreferences)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserContentDescriptorPreferences {
    // message fields
    // @@protoc_insertion_point(field:UserContentDescriptorPreferences.content_descriptors_to_exclude)
    pub content_descriptors_to_exclude: ::std::vec::Vec<user_content_descriptor_preferences::ContentDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:UserContentDescriptorPreferences.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserContentDescriptorPreferences {
    fn default() -> &'a UserContentDescriptorPreferences {
        <UserContentDescriptorPreferences as crate::Message>::default_instance()
    }
}

impl UserContentDescriptorPreferences {
    pub fn new() -> UserContentDescriptorPreferences {
        ::std::default::Default::default()
    }

    // repeated .UserContentDescriptorPreferences.ContentDescriptor content_descriptors_to_exclude = 1;

    pub fn content_descriptors_to_exclude(&self) -> &[user_content_descriptor_preferences::ContentDescriptor] {
        &self.content_descriptors_to_exclude
    }

    pub fn clear_content_descriptors_to_exclude(&mut self) {
        self.content_descriptors_to_exclude.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_descriptors_to_exclude(&mut self, v: ::std::vec::Vec<user_content_descriptor_preferences::ContentDescriptor>) {
        self.content_descriptors_to_exclude = v;
    }

    // Mutable pointer to the field.
    pub fn mut_content_descriptors_to_exclude(&mut self) -> &mut ::std::vec::Vec<user_content_descriptor_preferences::ContentDescriptor> {
        &mut self.content_descriptors_to_exclude
    }

    // Take field
    pub fn take_content_descriptors_to_exclude(&mut self) -> ::std::vec::Vec<user_content_descriptor_preferences::ContentDescriptor> {
        ::std::mem::replace(&mut self.content_descriptors_to_exclude, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_descriptors_to_exclude",
            |m: &UserContentDescriptorPreferences| { &m.content_descriptors_to_exclude },
            |m: &mut UserContentDescriptorPreferences| { &mut m.content_descriptors_to_exclude },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<UserContentDescriptorPreferences>(
            "UserContentDescriptorPreferences",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for UserContentDescriptorPreferences {
    const NAME: &'static str = "UserContentDescriptorPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.content_descriptors_to_exclude.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.content_descriptors_to_exclude {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.content_descriptors_to_exclude {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserContentDescriptorPreferences {
        UserContentDescriptorPreferences::new()
    }

    fn clear(&mut self) {
        self.content_descriptors_to_exclude.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserContentDescriptorPreferences {
        static instance: UserContentDescriptorPreferences = UserContentDescriptorPreferences {
            content_descriptors_to_exclude: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for UserContentDescriptorPreferences {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserContentDescriptorPreferences").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserContentDescriptorPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for UserContentDescriptorPreferences {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UserContentDescriptorPreferences`
pub mod user_content_descriptor_preferences {
    // @@protoc_insertion_point(message:UserContentDescriptorPreferences.ContentDescriptor)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ContentDescriptor {
        // message fields
        // @@protoc_insertion_point(field:UserContentDescriptorPreferences.ContentDescriptor.content_descriptorid)
        pub content_descriptorid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:UserContentDescriptorPreferences.ContentDescriptor.timestamp_added)
        pub timestamp_added: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:UserContentDescriptorPreferences.ContentDescriptor.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContentDescriptor {
        fn default() -> &'a ContentDescriptor {
            <ContentDescriptor as crate::Message>::default_instance()
        }
    }

    impl ContentDescriptor {
        pub fn new() -> ContentDescriptor {
            ::std::default::Default::default()
        }

        // optional uint32 content_descriptorid = 1;

        pub fn content_descriptorid(&self) -> u32 {
            self.content_descriptorid.unwrap_or(0)
        }

        pub fn clear_content_descriptorid(&mut self) {
            self.content_descriptorid = ::std::option::Option::None;
        }

        pub fn has_content_descriptorid(&self) -> bool {
            self.content_descriptorid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_content_descriptorid(&mut self, v: u32) {
            self.content_descriptorid = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp_added = 2;

        pub fn timestamp_added(&self) -> u32 {
            self.timestamp_added.unwrap_or(0)
        }

        pub fn clear_timestamp_added(&mut self) {
            self.timestamp_added = ::std::option::Option::None;
        }

        pub fn has_timestamp_added(&self) -> bool {
            self.timestamp_added.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_added(&mut self, v: u32) {
            self.timestamp_added = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "content_descriptorid",
                |m: &ContentDescriptor| { &m.content_descriptorid },
                |m: &mut ContentDescriptor| { &mut m.content_descriptorid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp_added",
                |m: &ContentDescriptor| { &m.timestamp_added },
                |m: &mut ContentDescriptor| { &mut m.timestamp_added },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ContentDescriptor>(
                "UserContentDescriptorPreferences.ContentDescriptor",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ContentDescriptor {
        const NAME: &'static str = "ContentDescriptor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.content_descriptorid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp_added = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.content_descriptorid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp_added {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.content_descriptorid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp_added {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContentDescriptor {
            ContentDescriptor::new()
        }

        fn clear(&mut self) {
            self.content_descriptorid = ::std::option::Option::None;
            self.timestamp_added = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContentDescriptor {
            static instance: ContentDescriptor = ContentDescriptor {
                content_descriptorid: ::std::option::Option::None,
                timestamp_added: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ContentDescriptor {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UserContentDescriptorPreferences.ContentDescriptor").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ContentDescriptor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ContentDescriptor {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBanContentCheckResult)
pub enum EBanContentCheckResult {
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_NotScanned)
    k_EBanContentCheckResult_NotScanned = 0,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Reset)
    k_EBanContentCheckResult_Reset = 1,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_NeedsChecking)
    k_EBanContentCheckResult_NeedsChecking = 2,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_VeryUnlikely)
    k_EBanContentCheckResult_VeryUnlikely = 5,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Unlikely)
    k_EBanContentCheckResult_Unlikely = 30,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Possible)
    k_EBanContentCheckResult_Possible = 50,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Likely)
    k_EBanContentCheckResult_Likely = 75,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_VeryLikely)
    k_EBanContentCheckResult_VeryLikely = 100,
}

impl crate::Enum for EBanContentCheckResult {
    const NAME: &'static str = "EBanContentCheckResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBanContentCheckResult> {
        match value {
            0 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            1 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Reset),
            2 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking),
            5 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Unlikely),
            50 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Possible),
            75 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Likely),
            100 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBanContentCheckResult> {
        match str {
            "k_EBanContentCheckResult_NotScanned" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            "k_EBanContentCheckResult_Reset" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Reset),
            "k_EBanContentCheckResult_NeedsChecking" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking),
            "k_EBanContentCheckResult_VeryUnlikely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely),
            "k_EBanContentCheckResult_Unlikely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Unlikely),
            "k_EBanContentCheckResult_Possible" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Possible),
            "k_EBanContentCheckResult_Likely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Likely),
            "k_EBanContentCheckResult_VeryLikely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBanContentCheckResult] = &[
        EBanContentCheckResult::k_EBanContentCheckResult_NotScanned,
        EBanContentCheckResult::k_EBanContentCheckResult_Reset,
        EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking,
        EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely,
        EBanContentCheckResult::k_EBanContentCheckResult_Unlikely,
        EBanContentCheckResult::k_EBanContentCheckResult_Possible,
        EBanContentCheckResult::k_EBanContentCheckResult_Likely,
        EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely,
    ];
}

impl crate::EnumFull for EBanContentCheckResult {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBanContentCheckResult").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EBanContentCheckResult::k_EBanContentCheckResult_NotScanned => 0,
            EBanContentCheckResult::k_EBanContentCheckResult_Reset => 1,
            EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking => 2,
            EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely => 3,
            EBanContentCheckResult::k_EBanContentCheckResult_Unlikely => 4,
            EBanContentCheckResult::k_EBanContentCheckResult_Possible => 5,
            EBanContentCheckResult::k_EBanContentCheckResult_Likely => 6,
            EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBanContentCheckResult {
    fn default() -> Self {
        EBanContentCheckResult::k_EBanContentCheckResult_NotScanned
    }
}

impl EBanContentCheckResult {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EBanContentCheckResult>("EBanContentCheckResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProtoClanEventType)
pub enum EProtoClanEventType {
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanOtherEvent)
    k_EClanOtherEvent = 1,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameEvent)
    k_EClanGameEvent = 2,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanPartyEvent)
    k_EClanPartyEvent = 3,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMeetingEvent)
    k_EClanMeetingEvent = 4,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSpecialCauseEvent)
    k_EClanSpecialCauseEvent = 5,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMusicAndArtsEvent)
    k_EClanMusicAndArtsEvent = 6,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSportsEvent)
    k_EClanSportsEvent = 7,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanTripEvent)
    k_EClanTripEvent = 8,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanChatEvent)
    k_EClanChatEvent = 9,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameReleaseEvent)
    k_EClanGameReleaseEvent = 10,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanBroadcastEvent)
    k_EClanBroadcastEvent = 11,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSmallUpdateEvent)
    k_EClanSmallUpdateEvent = 12,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanPreAnnounceMajorUpdateEvent)
    k_EClanPreAnnounceMajorUpdateEvent = 13,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMajorUpdateEvent)
    k_EClanMajorUpdateEvent = 14,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanDLCReleaseEvent)
    k_EClanDLCReleaseEvent = 15,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFutureReleaseEvent)
    k_EClanFutureReleaseEvent = 16,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanESportTournamentStreamEvent)
    k_EClanESportTournamentStreamEvent = 17,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanDevStreamEvent)
    k_EClanDevStreamEvent = 18,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFamousStreamEvent)
    k_EClanFamousStreamEvent = 19,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameSalesEvent)
    k_EClanGameSalesEvent = 20,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameItemSalesEvent)
    k_EClanGameItemSalesEvent = 21,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameBonusXPEvent)
    k_EClanInGameBonusXPEvent = 22,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameLootEvent)
    k_EClanInGameLootEvent = 23,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGamePerksEvent)
    k_EClanInGamePerksEvent = 24,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameChallengeEvent)
    k_EClanInGameChallengeEvent = 25,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameContestEvent)
    k_EClanInGameContestEvent = 26,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanIRLEvent)
    k_EClanIRLEvent = 27,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanNewsEvent)
    k_EClanNewsEvent = 28,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanBetaReleaseEvent)
    k_EClanBetaReleaseEvent = 29,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameContentReleaseEvent)
    k_EClanInGameContentReleaseEvent = 30,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFreeTrial)
    k_EClanFreeTrial = 31,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSeasonRelease)
    k_EClanSeasonRelease = 32,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSeasonUpdate)
    k_EClanSeasonUpdate = 33,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanCrosspostEvent)
    k_EClanCrosspostEvent = 34,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameEventGeneral)
    k_EClanInGameEventGeneral = 35,
}

impl crate::Enum for EProtoClanEventType {
    const NAME: &'static str = "EProtoClanEventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProtoClanEventType> {
        match value {
            1 => ::std::option::Option::Some(EProtoClanEventType::k_EClanOtherEvent),
            2 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameEvent),
            3 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPartyEvent),
            4 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMeetingEvent),
            5 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSpecialCauseEvent),
            6 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMusicAndArtsEvent),
            7 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSportsEvent),
            8 => ::std::option::Option::Some(EProtoClanEventType::k_EClanTripEvent),
            9 => ::std::option::Option::Some(EProtoClanEventType::k_EClanChatEvent),
            10 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameReleaseEvent),
            11 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBroadcastEvent),
            12 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSmallUpdateEvent),
            13 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent),
            14 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMajorUpdateEvent),
            15 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDLCReleaseEvent),
            16 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFutureReleaseEvent),
            17 => ::std::option::Option::Some(EProtoClanEventType::k_EClanESportTournamentStreamEvent),
            18 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDevStreamEvent),
            19 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFamousStreamEvent),
            20 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameSalesEvent),
            21 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameItemSalesEvent),
            22 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameBonusXPEvent),
            23 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameLootEvent),
            24 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGamePerksEvent),
            25 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameChallengeEvent),
            26 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContestEvent),
            27 => ::std::option::Option::Some(EProtoClanEventType::k_EClanIRLEvent),
            28 => ::std::option::Option::Some(EProtoClanEventType::k_EClanNewsEvent),
            29 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBetaReleaseEvent),
            30 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContentReleaseEvent),
            31 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFreeTrial),
            32 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonRelease),
            33 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonUpdate),
            34 => ::std::option::Option::Some(EProtoClanEventType::k_EClanCrosspostEvent),
            35 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameEventGeneral),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProtoClanEventType> {
        match str {
            "k_EClanOtherEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanOtherEvent),
            "k_EClanGameEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameEvent),
            "k_EClanPartyEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanPartyEvent),
            "k_EClanMeetingEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanMeetingEvent),
            "k_EClanSpecialCauseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSpecialCauseEvent),
            "k_EClanMusicAndArtsEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanMusicAndArtsEvent),
            "k_EClanSportsEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSportsEvent),
            "k_EClanTripEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanTripEvent),
            "k_EClanChatEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanChatEvent),
            "k_EClanGameReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameReleaseEvent),
            "k_EClanBroadcastEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanBroadcastEvent),
            "k_EClanSmallUpdateEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSmallUpdateEvent),
            "k_EClanPreAnnounceMajorUpdateEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent),
            "k_EClanMajorUpdateEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanMajorUpdateEvent),
            "k_EClanDLCReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanDLCReleaseEvent),
            "k_EClanFutureReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanFutureReleaseEvent),
            "k_EClanESportTournamentStreamEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanESportTournamentStreamEvent),
            "k_EClanDevStreamEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanDevStreamEvent),
            "k_EClanFamousStreamEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanFamousStreamEvent),
            "k_EClanGameSalesEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameSalesEvent),
            "k_EClanGameItemSalesEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameItemSalesEvent),
            "k_EClanInGameBonusXPEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameBonusXPEvent),
            "k_EClanInGameLootEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameLootEvent),
            "k_EClanInGamePerksEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGamePerksEvent),
            "k_EClanInGameChallengeEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameChallengeEvent),
            "k_EClanInGameContestEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContestEvent),
            "k_EClanIRLEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanIRLEvent),
            "k_EClanNewsEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanNewsEvent),
            "k_EClanBetaReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanBetaReleaseEvent),
            "k_EClanInGameContentReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContentReleaseEvent),
            "k_EClanFreeTrial" => ::std::option::Option::Some(EProtoClanEventType::k_EClanFreeTrial),
            "k_EClanSeasonRelease" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonRelease),
            "k_EClanSeasonUpdate" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonUpdate),
            "k_EClanCrosspostEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanCrosspostEvent),
            "k_EClanInGameEventGeneral" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameEventGeneral),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProtoClanEventType] = &[
        EProtoClanEventType::k_EClanOtherEvent,
        EProtoClanEventType::k_EClanGameEvent,
        EProtoClanEventType::k_EClanPartyEvent,
        EProtoClanEventType::k_EClanMeetingEvent,
        EProtoClanEventType::k_EClanSpecialCauseEvent,
        EProtoClanEventType::k_EClanMusicAndArtsEvent,
        EProtoClanEventType::k_EClanSportsEvent,
        EProtoClanEventType::k_EClanTripEvent,
        EProtoClanEventType::k_EClanChatEvent,
        EProtoClanEventType::k_EClanGameReleaseEvent,
        EProtoClanEventType::k_EClanBroadcastEvent,
        EProtoClanEventType::k_EClanSmallUpdateEvent,
        EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent,
        EProtoClanEventType::k_EClanMajorUpdateEvent,
        EProtoClanEventType::k_EClanDLCReleaseEvent,
        EProtoClanEventType::k_EClanFutureReleaseEvent,
        EProtoClanEventType::k_EClanESportTournamentStreamEvent,
        EProtoClanEventType::k_EClanDevStreamEvent,
        EProtoClanEventType::k_EClanFamousStreamEvent,
        EProtoClanEventType::k_EClanGameSalesEvent,
        EProtoClanEventType::k_EClanGameItemSalesEvent,
        EProtoClanEventType::k_EClanInGameBonusXPEvent,
        EProtoClanEventType::k_EClanInGameLootEvent,
        EProtoClanEventType::k_EClanInGamePerksEvent,
        EProtoClanEventType::k_EClanInGameChallengeEvent,
        EProtoClanEventType::k_EClanInGameContestEvent,
        EProtoClanEventType::k_EClanIRLEvent,
        EProtoClanEventType::k_EClanNewsEvent,
        EProtoClanEventType::k_EClanBetaReleaseEvent,
        EProtoClanEventType::k_EClanInGameContentReleaseEvent,
        EProtoClanEventType::k_EClanFreeTrial,
        EProtoClanEventType::k_EClanSeasonRelease,
        EProtoClanEventType::k_EClanSeasonUpdate,
        EProtoClanEventType::k_EClanCrosspostEvent,
        EProtoClanEventType::k_EClanInGameEventGeneral,
    ];
}

impl crate::EnumFull for EProtoClanEventType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProtoClanEventType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EProtoClanEventType::k_EClanOtherEvent => 0,
            EProtoClanEventType::k_EClanGameEvent => 1,
            EProtoClanEventType::k_EClanPartyEvent => 2,
            EProtoClanEventType::k_EClanMeetingEvent => 3,
            EProtoClanEventType::k_EClanSpecialCauseEvent => 4,
            EProtoClanEventType::k_EClanMusicAndArtsEvent => 5,
            EProtoClanEventType::k_EClanSportsEvent => 6,
            EProtoClanEventType::k_EClanTripEvent => 7,
            EProtoClanEventType::k_EClanChatEvent => 8,
            EProtoClanEventType::k_EClanGameReleaseEvent => 9,
            EProtoClanEventType::k_EClanBroadcastEvent => 10,
            EProtoClanEventType::k_EClanSmallUpdateEvent => 11,
            EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent => 12,
            EProtoClanEventType::k_EClanMajorUpdateEvent => 13,
            EProtoClanEventType::k_EClanDLCReleaseEvent => 14,
            EProtoClanEventType::k_EClanFutureReleaseEvent => 15,
            EProtoClanEventType::k_EClanESportTournamentStreamEvent => 16,
            EProtoClanEventType::k_EClanDevStreamEvent => 17,
            EProtoClanEventType::k_EClanFamousStreamEvent => 18,
            EProtoClanEventType::k_EClanGameSalesEvent => 19,
            EProtoClanEventType::k_EClanGameItemSalesEvent => 20,
            EProtoClanEventType::k_EClanInGameBonusXPEvent => 21,
            EProtoClanEventType::k_EClanInGameLootEvent => 22,
            EProtoClanEventType::k_EClanInGamePerksEvent => 23,
            EProtoClanEventType::k_EClanInGameChallengeEvent => 24,
            EProtoClanEventType::k_EClanInGameContestEvent => 25,
            EProtoClanEventType::k_EClanIRLEvent => 26,
            EProtoClanEventType::k_EClanNewsEvent => 27,
            EProtoClanEventType::k_EClanBetaReleaseEvent => 28,
            EProtoClanEventType::k_EClanInGameContentReleaseEvent => 29,
            EProtoClanEventType::k_EClanFreeTrial => 30,
            EProtoClanEventType::k_EClanSeasonRelease => 31,
            EProtoClanEventType::k_EClanSeasonUpdate => 32,
            EProtoClanEventType::k_EClanCrosspostEvent => 33,
            EProtoClanEventType::k_EClanInGameEventGeneral => 34,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EProtoClanEventType {
    fn default() -> Self {
        EProtoClanEventType::k_EClanOtherEvent
    }
}

impl EProtoClanEventType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EProtoClanEventType>("EProtoClanEventType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PartnerEventNotificationType)
pub enum PartnerEventNotificationType {
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventStart)
    k_EEventStart = 0,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventBroadcastStart)
    k_EEventBroadcastStart = 1,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventMatchStart)
    k_EEventMatchStart = 2,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventPartnerMaxType)
    k_EEventPartnerMaxType = 3,
}

impl crate::Enum for PartnerEventNotificationType {
    const NAME: &'static str = "PartnerEventNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerEventNotificationType> {
        match value {
            0 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventStart),
            1 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventBroadcastStart),
            2 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventMatchStart),
            3 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventPartnerMaxType),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PartnerEventNotificationType> {
        match str {
            "k_EEventStart" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventStart),
            "k_EEventBroadcastStart" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventBroadcastStart),
            "k_EEventMatchStart" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventMatchStart),
            "k_EEventPartnerMaxType" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventPartnerMaxType),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PartnerEventNotificationType] = &[
        PartnerEventNotificationType::k_EEventStart,
        PartnerEventNotificationType::k_EEventBroadcastStart,
        PartnerEventNotificationType::k_EEventMatchStart,
        PartnerEventNotificationType::k_EEventPartnerMaxType,
    ];
}

impl crate::EnumFull for PartnerEventNotificationType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PartnerEventNotificationType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PartnerEventNotificationType {
    fn default() -> Self {
        PartnerEventNotificationType::k_EEventStart
    }
}

impl PartnerEventNotificationType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<PartnerEventNotificationType>("PartnerEventNotificationType")
    }
}

/// Extension fields
pub mod exts {

    pub const msgpool_soft_limit: crate::ext::ExtFieldOptional<crate::descriptor::MessageOptions, i32> = crate::ext::ExtFieldOptional::new(50000, crate::descriptor::field_descriptor_proto::Type::TYPE_INT32);

    pub const msgpool_hard_limit: crate::ext::ExtFieldOptional<crate::descriptor::MessageOptions, i32> = crate::ext::ExtFieldOptional::new(50001, crate::descriptor::field_descriptor_proto::Type::TYPE_INT32);

    pub const force_php_generation: crate::ext::ExtFieldOptional<crate::descriptor::FileOptions, bool> = crate::ext::ExtFieldOptional::new(50000, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const php_output_always_number: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(50020, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const allow_field_named_steam_id: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(50024, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18steammessages_base.proto\x1a\x20google/protobuf/descriptor.proto\"\
    9\n\rCMsgIPAddress\x12\x10\n\x02v4\x18\x01\x20\x01(\x07H\0R\x02v4\x12\
    \x10\n\x02v6\x18\x02\x20\x01(\x0cH\0R\x02v6B\x04\n\x02ip\"m\n\x13CMsgIPA\
    ddressBucket\x12>\n\x13original_ip_address\x18\x01\x20\x01(\x0b2\x0e.CMs\
    gIPAddressR\x11originalIpAddress\x12\x16\n\x06bucket\x18\x02\x20\x01(\
    \x06R\x06bucket\"l\n\x1bCMsgGCRoutingProtoBufHeader\x12$\n\x0edst_gcid_q\
    ueue\x18\x01\x20\x01(\x04R\x0cdstGcidQueue\x12'\n\x10dst_gc_dir_index\
    \x18\x02\x20\x01(\rR\rdstGcDirIndex\"\xf4\x0b\n\x12CMsgProtoBufHeader\
    \x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12)\n\x10client_\
    sessionid\x18\x02\x20\x01(\x05R\x0fclientSessionid\x12#\n\rrouting_appid\
    \x18\x03\x20\x01(\rR\x0croutingAppid\x127\n\x0cjobid_source\x18\n\x20\
    \x01(\x06:\x1418446744073709551615R\x0bjobidSource\x127\n\x0cjobid_targe\
    t\x18\x0b\x20\x01(\x06:\x1418446744073709551615R\x0bjobidTarget\x12&\n\
    \x0ftarget_job_name\x18\x0c\x20\x01(\tR\rtargetJobName\x12\x17\n\x07seq_\
    num\x18\x18\x20\x01(\x05R\x06seqNum\x12\x1b\n\x07eresult\x18\r\x20\x01(\
    \x05:\x012R\x07eresult\x12#\n\rerror_message\x18\x0e\x20\x01(\tR\x0cerro\
    rMessage\x12,\n\x12auth_account_flags\x18\x10\x20\x01(\rR\x10authAccount\
    Flags\x12!\n\x0ctoken_source\x18\x16\x20\x01(\rR\x0btokenSource\x12.\n\
    \x13admin_spoofing_user\x18\x17\x20\x01(\x08R\x11adminSpoofingUser\x12*\
    \n\x0ftransport_error\x18\x11\x20\x01(\x05:\x011R\x0etransportError\x122\
    \n\tmessageid\x18\x12\x20\x01(\x04:\x1418446744073709551615R\tmessageid\
    \x12,\n\x12publisher_group_id\x18\x13\x20\x01(\rR\x10publisherGroupId\
    \x12\x14\n\x05sysid\x18\x14\x20\x01(\rR\x05sysid\x12\x1b\n\ttrace_tag\
    \x18\x15\x20\x01(\x04R\x08traceTag\x12\"\n\rwebapi_key_id\x18\x19\x20\
    \x01(\rR\x0bwebapiKeyId\x125\n\x17is_from_external_source\x18\x1a\x20\
    \x01(\x08R\x14isFromExternalSource\x12(\n\x10forward_to_sysid\x18\x1b\
    \x20\x03(\rR\x0eforwardToSysid\x12\x19\n\x08cm_sysid\x18\x1c\x20\x01(\rR\
    \x07cmSysid\x12&\n\rlauncher_type\x18\x1f\x20\x01(\r:\x010R\x0clauncherT\
    ype\x12\x17\n\x05realm\x18\x20\x20\x01(\r:\x010R\x05realm\x12!\n\ntimeou\
    t_ms\x18!\x20\x01(\x05:\x02-1R\ttimeoutMs\x12!\n\x0cdebug_source\x18\"\
    \x20\x01(\tR\x0bdebugSource\x129\n\x19debug_source_string_index\x18#\x20\
    \x01(\rR\x16debugSourceStringIndex\x12\x19\n\x08token_id\x18$\x20\x01(\
    \x04R\x07tokenId\x12;\n\nrouting_gc\x18%\x20\x01(\x0b2\x1c.CMsgGCRouting\
    ProtoBufHeaderR\troutingGc\x12u\n\x13session_disposition\x18&\x20\x01(\
    \x0e2'.CMsgProtoBufHeader.ESessionDisposition:\x1bk_ESessionDispositionN\
    ormalR\x12sessionDisposition\x12\x19\n\x08wg_token\x18'\x20\x01(\tR\x07w\
    gToken\x12$\n\x0ewebui_auth_key\x18(\x20\x01(\tR\x0cwebuiAuthKey\x12:\n\
    \x19exclude_client_sessionids\x18)\x20\x03(\x05R\x17excludeClientSession\
    ids\x12\x10\n\x02ip\x18\x0f\x20\x01(\rH\0R\x02ip\x12\x15\n\x05ip_v6\x18\
    \x1d\x20\x01(\x0cH\0R\x04ipV6\"[\n\x13ESessionDisposition\x12\x1f\n\x1bk\
    _ESessionDispositionNormal\x10\0\x12#\n\x1fk_ESessionDispositionDisconne\
    ct\x10\x01B\t\n\x07ip_addr\"S\n\tCMsgMulti\x12#\n\rsize_unzipped\x18\x01\
    \x20\x01(\rR\x0csizeUnzipped\x12!\n\x0cmessage_body\x18\x02\x20\x01(\x0c\
    R\x0bmessageBody\"8\n\x13CMsgProtobufWrapped\x12!\n\x0cmessage_body\x18\
    \x01\x20\x01(\x0cR\x0bmessageBody\"\x96\x02\n\x0eCMsgAuthTicket\x12\x16\
    \n\x06estate\x18\x01\x20\x01(\rR\x06estate\x12\x1b\n\x07eresult\x18\x02\
    \x20\x01(\r:\x012R\x07eresult\x12\x18\n\x07steamid\x18\x03\x20\x01(\x06R\
    \x07steamid\x12\x16\n\x06gameid\x18\x04\x20\x01(\x06R\x06gameid\x12\x20\
    \n\x0ch_steam_pipe\x18\x05\x20\x01(\rR\nhSteamPipe\x12\x1d\n\nticket_crc\
    \x18\x06\x20\x01(\rR\tticketCrc\x12\x16\n\x06ticket\x18\x07\x20\x01(\x0c\
    R\x06ticket\x12#\n\rserver_secret\x18\x08\x20\x01(\x0cR\x0cserverSecret\
    \x12\x1f\n\x0bticket_type\x18\t\x20\x01(\rR\nticketType\"\xb7\x04\n\x14C\
    CDDBAppDetailCommon\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04icon\x18\x03\x20\
    \x01(\tR\x04icon\x12\x12\n\x04tool\x18\x06\x20\x01(\x08R\x04tool\x12\x12\
    \n\x04demo\x18\x07\x20\x01(\x08R\x04demo\x12\x14\n\x05media\x18\x08\x20\
    \x01(\x08R\x05media\x126\n\x17community_visible_stats\x18\t\x20\x01(\x08\
    R\x15communityVisibleStats\x12#\n\rfriendly_name\x18\n\x20\x01(\tR\x0cfr\
    iendlyName\x12\x20\n\x0bpropagation\x18\x0b\x20\x01(\tR\x0bpropagation\
    \x12*\n\x11has_adult_content\x18\x0c\x20\x01(\x08R\x0fhasAdultContent\
    \x128\n\x19is_visible_in_steam_china\x18\r\x20\x01(\x08R\x15isVisibleInS\
    teamChina\x12\x19\n\x08app_type\x18\x0e\x20\x01(\rR\x07appType\x121\n\
    \x15has_adult_content_sex\x18\x0f\x20\x01(\x08R\x12hasAdultContentSex\
    \x12;\n\x1ahas_adult_content_violence\x18\x10\x20\x01(\x08R\x17hasAdultC\
    ontentViolence\x123\n\x15content_descriptorids\x18\x11\x20\x03(\rR\x14co\
    ntentDescriptorids\"\xbb\x05\n\rCMsgAppRights\x12\x1b\n\tedit_info\x18\
    \x01\x20\x01(\x08R\x08editInfo\x12\x18\n\x07publish\x18\x02\x20\x01(\x08\
    R\x07publish\x12&\n\x0fview_error_data\x18\x03\x20\x01(\x08R\rviewErrorD\
    ata\x12\x1a\n\x08download\x18\x04\x20\x01(\x08R\x08download\x12#\n\ruplo\
    ad_cdkeys\x18\x05\x20\x01(\x08R\x0cuploadCdkeys\x12'\n\x0fgenerate_cdkey\
    s\x18\x06\x20\x01(\x08R\x0egenerateCdkeys\x12'\n\x0fview_financials\x18\
    \x07\x20\x01(\x08R\x0eviewFinancials\x12\x1d\n\nmanage_ceg\x18\x08\x20\
    \x01(\x08R\tmanageCeg\x12%\n\x0emanage_signing\x18\t\x20\x01(\x08R\rmana\
    geSigning\x12#\n\rmanage_cdkeys\x18\n\x20\x01(\x08R\x0cmanageCdkeys\x12%\
    \n\x0eedit_marketing\x18\x0b\x20\x01(\x08R\reditMarketing\x12'\n\x0fecon\
    omy_support\x18\x0c\x20\x01(\x08R\x0eeconomySupport\x12<\n\x1aeconomy_su\
    pport_supervisor\x18\r\x20\x01(\x08R\x18economySupportSupervisor\x12%\n\
    \x0emanage_pricing\x18\x0e\x20\x01(\x08R\rmanagePricing\x12%\n\x0ebroadc\
    ast_live\x18\x0f\x20\x01(\x08R\rbroadcastLive\x124\n\x16view_marketing_t\
    raffic\x18\x10\x20\x01(\x08R\x14viewMarketingTraffic\x12;\n\x1aedit_stor\
    e_display_content\x18\x11\x20\x01(\x08R\x17editStoreDisplayContent\"\xcd\
    \x04\n\x13CCuratorPreferences\x12/\n\x13supported_languages\x18\x01\x20\
    \x01(\rR\x12supportedLanguages\x12)\n\x10platform_windows\x18\x02\x20\
    \x01(\x08R\x0fplatformWindows\x12!\n\x0cplatform_mac\x18\x03\x20\x01(\
    \x08R\x0bplatformMac\x12%\n\x0eplatform_linux\x18\x04\x20\x01(\x08R\rpla\
    tformLinux\x12\x1d\n\nvr_content\x18\x05\x20\x01(\x08R\tvrContent\x124\n\
    \x16adult_content_violence\x18\x06\x20\x01(\x08R\x14adultContentViolence\
    \x12*\n\x11adult_content_sex\x18\x07\x20\x01(\x08R\x0fadultContentSex\
    \x12+\n\x11timestamp_updated\x18\x08\x20\x01(\rR\x10timestampUpdated\x12\
    %\n\x0etagids_curated\x18\t\x20\x03(\rR\rtagidsCurated\x12'\n\x0ftagids_\
    filtered\x18\n\x20\x03(\rR\x0etagidsFiltered\x12#\n\rwebsite_title\x18\
    \x0b\x20\x01(\tR\x0cwebsiteTitle\x12\x1f\n\x0bwebsite_url\x18\x0c\x20\
    \x01(\tR\nwebsiteUrl\x12%\n\x0ediscussion_url\x18\r\x20\x01(\tR\rdiscuss\
    ionUrl\x12%\n\x0eshow_broadcast\x18\x0e\x20\x01(\x08R\rshowBroadcast\"[\
    \n\x12CLocalizationToken\x12\x1a\n\x08language\x18\x01\x20\x01(\rR\x08la\
    nguage\x12)\n\x10localized_string\x18\x02\x20\x01(\tR\x0flocalizedString\
    \"\xe6\x02\n\x17CClanEventUserNewsTuple\x12\x16\n\x06clanid\x18\x01\x20\
    \x01(\rR\x06clanid\x12\x1b\n\tevent_gid\x18\x02\x20\x01(\x06R\x08eventGi\
    d\x12)\n\x10announcement_gid\x18\x03\x20\x01(\x06R\x0fannouncementGid\
    \x12\x1f\n\x0brtime_start\x18\x04\x20\x01(\rR\nrtimeStart\x12\x1b\n\trti\
    me_end\x18\x05\x20\x01(\rR\x08rtimeEnd\x12%\n\x0epriority_score\x18\x06\
    \x20\x01(\rR\rpriorityScore\x12\x12\n\x04type\x18\x07\x20\x01(\rR\x04typ\
    e\x12(\n\x10clamp_range_slot\x18\x08\x20\x01(\rR\x0eclampRangeSlot\x12\
    \x14\n\x05appid\x18\t\x20\x01(\rR\x05appid\x122\n\x15rtime32_last_modifi\
    ed\x18\n\x20\x01(\rR\x13rtime32LastModified\"\xac\x01\n\x16CClanMatchEve\
    ntByRange\x12!\n\x0crtime_before\x18\x01\x20\x01(\rR\x0brtimeBefore\x12\
    \x1f\n\x0brtime_after\x18\x02\x20\x01(\rR\nrtimeAfter\x12\x1c\n\tqualifi\
    ed\x18\x03\x20\x01(\rR\tqualified\x120\n\x06events\x18\x04\x20\x03(\x0b2\
    \x18.CClanEventUserNewsTupleR\x06events\"\xca\x04\n\x1fCCommunity_ClanAn\
    nouncementInfo\x12\x10\n\x03gid\x18\x01\x20\x01(\x04R\x03gid\x12\x16\n\
    \x06clanid\x18\x02\x20\x01(\x04R\x06clanid\x12\x1a\n\x08posterid\x18\x03\
    \x20\x01(\x04R\x08posterid\x12\x1a\n\x08headline\x18\x04\x20\x01(\tR\x08\
    headline\x12\x1a\n\x08posttime\x18\x05\x20\x01(\rR\x08posttime\x12\x1e\n\
    \nupdatetime\x18\x06\x20\x01(\rR\nupdatetime\x12\x12\n\x04body\x18\x07\
    \x20\x01(\tR\x04body\x12\"\n\x0ccommentcount\x18\x08\x20\x01(\x05R\x0cco\
    mmentcount\x12\x12\n\x04tags\x18\t\x20\x03(\tR\x04tags\x12\x1a\n\x08lang\
    uage\x18\n\x20\x01(\x05R\x08language\x12\x16\n\x06hidden\x18\x0b\x20\x01\
    (\x08R\x06hidden\x12$\n\x0eforum_topic_id\x18\x0c\x20\x01(\x06R\x0cforum\
    TopicId\x12\x1b\n\tevent_gid\x18\r\x20\x01(\x06R\x08eventGid\x12\x20\n\
    \x0bvoteupcount\x18\x0e\x20\x01(\x05R\x0bvoteupcount\x12$\n\rvotedowncou\
    nt\x18\x0f\x20\x01(\x05R\rvotedowncount\x12f\n\x10ban_check_result\x18\
    \x10\x20\x01(\x0e2\x17.EBanContentCheckResult:#k_EBanContentCheckResult_\
    NotScannedR\x0ebanCheckResult\x12\x16\n\x06banned\x18\x11\x20\x01(\x08R\
    \x06banned\"\xde\t\n\x0eCClanEventData\x12\x10\n\x03gid\x18\x01\x20\x01(\
    \x06R\x03gid\x12!\n\x0cclan_steamid\x18\x02\x20\x01(\x06R\x0bclanSteamid\
    \x12\x1d\n\nevent_name\x18\x03\x20\x01(\tR\teventName\x12F\n\nevent_type\
    \x18\x04\x20\x01(\x0e2\x14.EProtoClanEventType:\x11k_EClanOtherEventR\te\
    ventType\x12\x14\n\x05appid\x18\x05\x20\x01(\rR\x05appid\x12%\n\x0eserve\
    r_address\x18\x06\x20\x01(\tR\rserverAddress\x12'\n\x0fserver_password\
    \x18\x07\x20\x01(\tR\x0eserverPassword\x12,\n\x12rtime32_start_time\x18\
    \x08\x20\x01(\rR\x10rtime32StartTime\x12(\n\x10rtime32_end_time\x18\t\
    \x20\x01(\rR\x0ertime32EndTime\x12#\n\rcomment_count\x18\n\x20\x01(\x05R\
    \x0ccommentCount\x12'\n\x0fcreator_steamid\x18\x0b\x20\x01(\x06R\x0ecrea\
    torSteamid\x12.\n\x13last_update_steamid\x18\x0c\x20\x01(\x06R\x11lastUp\
    dateSteamid\x12\x1f\n\x0bevent_notes\x18\r\x20\x01(\tR\neventNotes\x12\
    \x1a\n\x08jsondata\x18\x0e\x20\x01(\tR\x08jsondata\x12M\n\x11announcemen\
    t_body\x18\x0f\x20\x01(\x0b2\x20.CCommunity_ClanAnnouncementInfoR\x10ann\
    ouncementBody\x12\x1c\n\tpublished\x18\x10\x20\x01(\x08R\tpublished\x12\
    \x16\n\x06hidden\x18\x11\x20\x01(\x08R\x06hidden\x128\n\x18rtime32_visib\
    ility_start\x18\x12\x20\x01(\rR\x16rtime32VisibilityStart\x124\n\x16rtim\
    e32_visibility_end\x18\x13\x20\x01(\rR\x14rtime32VisibilityEnd\x123\n\
    \x15broadcaster_accountid\x18\x14\x20\x01(\rR\x14broadcasterAccountid\
    \x12%\n\x0efollower_count\x18\x15\x20\x01(\rR\rfollowerCount\x12!\n\x0ci\
    gnore_count\x18\x16\x20\x01(\rR\x0bignoreCount\x12$\n\x0eforum_topic_id\
    \x18\x17\x20\x01(\x06R\x0cforumTopicId\x122\n\x15rtime32_last_modified\
    \x18\x18\x20\x01(\rR\x13rtime32LastModified\x12\"\n\rnews_post_gid\x18\
    \x19\x20\x01(\x06R\x0bnewsPostGid\x12,\n\x12rtime_mod_reviewed\x18\x1a\
    \x20\x01(\rR\x10rtimeModReviewed\x12,\n\x12featured_app_tagid\x18\x1b\
    \x20\x01(\rR\x10featuredAppTagid\x12+\n\x11referenced_appids\x18\x1c\x20\
    \x03(\rR\x10referencedAppids\x12\x19\n\x08build_id\x18\x1d\x20\x01(\rR\
    \x07buildId\x12!\n\x0cbuild_branch\x18\x1e\x20\x01(\tR\x0bbuildBranch\"\
    \xa7\x02\n\x10CBilling_Address\x12\x1d\n\nfirst_name\x18\x01\x20\x01(\tR\
    \tfirstName\x12\x1b\n\tlast_name\x18\x02\x20\x01(\tR\x08lastName\x12\x1a\
    \n\x08address1\x18\x03\x20\x01(\tR\x08address1\x12\x1a\n\x08address2\x18\
    \x04\x20\x01(\tR\x08address2\x12\x12\n\x04city\x18\x05\x20\x01(\tR\x04ci\
    ty\x12\x19\n\x08us_state\x18\x06\x20\x01(\tR\x07usState\x12!\n\x0ccountr\
    y_code\x18\x07\x20\x01(\tR\x0bcountryCode\x12\x1a\n\x08postcode\x18\x08\
    \x20\x01(\tR\x08postcode\x12\x1b\n\tzip_plus4\x18\t\x20\x01(\x05R\x08zip\
    Plus4\x12\x14\n\x05phone\x18\n\x20\x01(\tR\x05phone\"\xc2\x03\n\x19CPack\
    ageReservationStatus\x12\x1c\n\tpackageid\x18\x01\x20\x01(\rR\tpackageid\
    \x12+\n\x11reservation_state\x18\x02\x20\x01(\x05R\x10reservationState\
    \x12%\n\x0equeue_position\x18\x03\x20\x01(\x05R\rqueuePosition\x12(\n\
    \x10total_queue_size\x18\x04\x20\x01(\x05R\x0etotalQueueSize\x128\n\x18r\
    eservation_country_code\x18\x05\x20\x01(\tR\x16reservationCountryCode\
    \x12\x18\n\x07expired\x18\x06\x20\x01(\x08R\x07expired\x12!\n\x0ctime_ex\
    pires\x18\x07\x20\x01(\rR\x0btimeExpires\x12#\n\rtime_reserved\x18\x08\
    \x20\x01(\rR\x0ctimeReserved\x12@\n\x1crtime_estimated_notification\x18\
    \t\x20\x01(\rR\x1artimeEstimatedNotification\x12+\n\x11notificaton_token\
    \x18\n\x20\x01(\tR\x10notificatonToken\"<\n\x10CMsgKeyValuePair\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value\":\n\x0fCMsgKeyValueSet\x12'\n\x05pairs\x18\x01\x20\
    \x03(\x0b2\x11.CMsgKeyValuePairR\x05pairs\"\x8d\x02\n\x20UserContentDesc\
    riptorPreferences\x12x\n\x1econtent_descriptors_to_exclude\x18\x01\x20\
    \x03(\x0b23.UserContentDescriptorPreferences.ContentDescriptorR\x1bconte\
    ntDescriptorsToExclude\x1ao\n\x11ContentDescriptor\x121\n\x14content_des\
    criptorid\x18\x01\x20\x01(\rR\x13contentDescriptorid\x12'\n\x0ftimestamp\
    _added\x18\x02\x20\x01(\rR\x0etimestampAdded*\xd8\x02\n\x16EBanContentCh\
    eckResult\x12'\n#k_EBanContentCheckResult_NotScanned\x10\0\x12\"\n\x1ek_\
    EBanContentCheckResult_Reset\x10\x01\x12*\n&k_EBanContentCheckResult_Nee\
    dsChecking\x10\x02\x12)\n%k_EBanContentCheckResult_VeryUnlikely\x10\x05\
    \x12%\n!k_EBanContentCheckResult_Unlikely\x10\x1e\x12%\n!k_EBanContentCh\
    eckResult_Possible\x102\x12#\n\x1fk_EBanContentCheckResult_Likely\x10K\
    \x12'\n#k_EBanContentCheckResult_VeryLikely\x10d*\xeb\x07\n\x13EProtoCla\
    nEventType\x12\x15\n\x11k_EClanOtherEvent\x10\x01\x12\x14\n\x10k_EClanGa\
    meEvent\x10\x02\x12\x15\n\x11k_EClanPartyEvent\x10\x03\x12\x17\n\x13k_EC\
    lanMeetingEvent\x10\x04\x12\x1c\n\x18k_EClanSpecialCauseEvent\x10\x05\
    \x12\x1c\n\x18k_EClanMusicAndArtsEvent\x10\x06\x12\x16\n\x12k_EClanSport\
    sEvent\x10\x07\x12\x14\n\x10k_EClanTripEvent\x10\x08\x12\x14\n\x10k_ECla\
    nChatEvent\x10\t\x12\x1b\n\x17k_EClanGameReleaseEvent\x10\n\x12\x19\n\
    \x15k_EClanBroadcastEvent\x10\x0b\x12\x1b\n\x17k_EClanSmallUpdateEvent\
    \x10\x0c\x12&\n\"k_EClanPreAnnounceMajorUpdateEvent\x10\r\x12\x1b\n\x17k\
    _EClanMajorUpdateEvent\x10\x0e\x12\x1a\n\x16k_EClanDLCReleaseEvent\x10\
    \x0f\x12\x1d\n\x19k_EClanFutureReleaseEvent\x10\x10\x12&\n\"k_EClanESpor\
    tTournamentStreamEvent\x10\x11\x12\x19\n\x15k_EClanDevStreamEvent\x10\
    \x12\x12\x1c\n\x18k_EClanFamousStreamEvent\x10\x13\x12\x19\n\x15k_EClanG\
    ameSalesEvent\x10\x14\x12\x1d\n\x19k_EClanGameItemSalesEvent\x10\x15\x12\
    \x1d\n\x19k_EClanInGameBonusXPEvent\x10\x16\x12\x1a\n\x16k_EClanInGameLo\
    otEvent\x10\x17\x12\x1b\n\x17k_EClanInGamePerksEvent\x10\x18\x12\x1f\n\
    \x1bk_EClanInGameChallengeEvent\x10\x19\x12\x1d\n\x19k_EClanInGameContes\
    tEvent\x10\x1a\x12\x13\n\x0fk_EClanIRLEvent\x10\x1b\x12\x14\n\x10k_EClan\
    NewsEvent\x10\x1c\x12\x1b\n\x17k_EClanBetaReleaseEvent\x10\x1d\x12$\n\
    \x20k_EClanInGameContentReleaseEvent\x10\x1e\x12\x14\n\x10k_EClanFreeTri\
    al\x10\x1f\x12\x18\n\x14k_EClanSeasonRelease\x10\x20\x12\x17\n\x13k_ECla\
    nSeasonUpdate\x10!\x12\x19\n\x15k_EClanCrosspostEvent\x10\"\x12\x1d\n\
    \x19k_EClanInGameEventGeneral\x10#*\x81\x01\n\x1cPartnerEventNotificatio\
    nType\x12\x11\n\rk_EEventStart\x10\0\x12\x1a\n\x16k_EEventBroadcastStart\
    \x10\x01\x12\x16\n\x12k_EEventMatchStart\x10\x02\x12\x1a\n\x16k_EEventPa\
    rtnerMaxType\x10\x03:S\n\x12msgpool_soft_limit\x18\xd0\x86\x03\x20\x01(\
    \x05\x12\x1f.google.protobuf.MessageOptions:\x0232R\x10msgpoolSoftLimit:\
    T\n\x12msgpool_hard_limit\x18\xd1\x86\x03\x20\x01(\x05\x12\x1f.google.pr\
    otobuf.MessageOptions:\x03384R\x10msgpoolHardLimit:W\n\x14force_php_gene\
    ration\x18\xd0\x86\x03\x20\x01(\x08\x12\x1c.google.protobuf.FileOptions:\
    \x05falseR\x12forcePhpGeneration:_\n\x18php_output_always_number\x18\xe4\
    \x86\x03\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x05falseR\
    \x15phpOutputAlwaysNumber:b\n\x1aallow_field_named_steam_id\x18\xe8\x86\
    \x03\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x05falseR\x16all\
    owFieldNamedSteamIdB\tH\x01\x80\x01\x01\x80\xb5\x18\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(crate::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(CMsgIPAddress::generated_message_descriptor_data());
            messages.push(CMsgIPAddressBucket::generated_message_descriptor_data());
            messages.push(CMsgGCRoutingProtoBufHeader::generated_message_descriptor_data());
            messages.push(CMsgProtoBufHeader::generated_message_descriptor_data());
            messages.push(CMsgMulti::generated_message_descriptor_data());
            messages.push(CMsgProtobufWrapped::generated_message_descriptor_data());
            messages.push(CMsgAuthTicket::generated_message_descriptor_data());
            messages.push(CCDDBAppDetailCommon::generated_message_descriptor_data());
            messages.push(CMsgAppRights::generated_message_descriptor_data());
            messages.push(CCuratorPreferences::generated_message_descriptor_data());
            messages.push(CLocalizationToken::generated_message_descriptor_data());
            messages.push(CClanEventUserNewsTuple::generated_message_descriptor_data());
            messages.push(CClanMatchEventByRange::generated_message_descriptor_data());
            messages.push(CCommunity_ClanAnnouncementInfo::generated_message_descriptor_data());
            messages.push(CClanEventData::generated_message_descriptor_data());
            messages.push(CBilling_Address::generated_message_descriptor_data());
            messages.push(CPackageReservationStatus::generated_message_descriptor_data());
            messages.push(CMsgKeyValuePair::generated_message_descriptor_data());
            messages.push(CMsgKeyValueSet::generated_message_descriptor_data());
            messages.push(UserContentDescriptorPreferences::generated_message_descriptor_data());
            messages.push(user_content_descriptor_preferences::ContentDescriptor::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(EBanContentCheckResult::generated_enum_descriptor_data());
            enums.push(EProtoClanEventType::generated_enum_descriptor_data());
            enums.push(PartnerEventNotificationType::generated_enum_descriptor_data());
            enums.push(cmsg_proto_buf_header::ESessionDisposition::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
