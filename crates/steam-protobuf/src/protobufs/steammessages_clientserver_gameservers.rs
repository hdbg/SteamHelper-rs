// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]


#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_gameservers.proto`

// @@protoc_insertion_point(message:CMsgGSServerType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSServerType {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSServerType.app_id_served)
    pub app_id_served: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.deprecated_game_ip_address)
    pub deprecated_game_ip_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_dir)
    pub game_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_version)
    pub game_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_query_port)
    pub game_query_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_port_local)
    pub game_port_local: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.sdr_logon)
    pub sdr_logon: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgGSServerType.fake_ip)
    pub fake_ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSServerType.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSServerType {
    fn default() -> &'a CMsgGSServerType {
        <CMsgGSServerType as crate::Message>::default_instance()
    }
}

impl CMsgGSServerType {
    pub fn new() -> CMsgGSServerType {
        ::std::default::Default::default()
    }

    // optional uint32 app_id_served = 1;

    pub fn app_id_served(&self) -> u32 {
        self.app_id_served.unwrap_or(0)
    }

    pub fn clear_app_id_served(&mut self) {
        self.app_id_served = ::std::option::Option::None;
    }

    pub fn has_app_id_served(&self) -> bool {
        self.app_id_served.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id_served(&mut self, v: u32) {
        self.app_id_served = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_ip_address = 3;

    pub fn deprecated_game_ip_address(&self) -> u32 {
        self.deprecated_game_ip_address.unwrap_or(0)
    }

    pub fn clear_deprecated_game_ip_address(&mut self) {
        self.deprecated_game_ip_address = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_ip_address(&self) -> bool {
        self.deprecated_game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
        self.deprecated_game_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 5;

    pub fn game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir = ::std::option::Option::None;
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_version = 6;

    pub fn game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_version(&mut self) {
        self.game_version = ::std::option::Option::None;
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_query_port = 7;

    pub fn game_query_port(&self) -> u32 {
        self.game_query_port.unwrap_or(0)
    }

    pub fn clear_game_query_port(&mut self) {
        self.game_query_port = ::std::option::Option::None;
    }

    pub fn has_game_query_port(&self) -> bool {
        self.game_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_query_port(&mut self, v: u32) {
        self.game_query_port = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port_local = 10;

    pub fn game_port_local(&self) -> u32 {
        self.game_port_local.unwrap_or(0)
    }

    pub fn clear_game_port_local(&mut self) {
        self.game_port_local = ::std::option::Option::None;
    }

    pub fn has_game_port_local(&self) -> bool {
        self.game_port_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port_local(&mut self, v: u32) {
        self.game_port_local = ::std::option::Option::Some(v);
    }

    // optional bytes sdr_logon = 8;

    pub fn sdr_logon(&self) -> &[u8] {
        match self.sdr_logon.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sdr_logon(&mut self) {
        self.sdr_logon = ::std::option::Option::None;
    }

    pub fn has_sdr_logon(&self) -> bool {
        self.sdr_logon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_logon(&mut self, v: ::bytes::Bytes) {
        self.sdr_logon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr_logon(&mut self) -> &mut ::bytes::Bytes {
        if self.sdr_logon.is_none() {
            self.sdr_logon = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sdr_logon.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr_logon(&mut self) -> ::bytes::Bytes {
        self.sdr_logon.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed32 fake_ip = 9;

    pub fn fake_ip(&self) -> u32 {
        self.fake_ip.unwrap_or(0)
    }

    pub fn clear_fake_ip(&mut self) {
        self.fake_ip = ::std::option::Option::None;
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: u32) {
        self.fake_ip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id_served",
            |m: &CMsgGSServerType| { &m.app_id_served },
            |m: &mut CMsgGSServerType| { &mut m.app_id_served },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgGSServerType| { &m.flags },
            |m: &mut CMsgGSServerType| { &mut m.flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_game_ip_address",
            |m: &CMsgGSServerType| { &m.deprecated_game_ip_address },
            |m: &mut CMsgGSServerType| { &mut m.deprecated_game_ip_address },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port",
            |m: &CMsgGSServerType| { &m.game_port },
            |m: &mut CMsgGSServerType| { &mut m.game_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_dir",
            |m: &CMsgGSServerType| { &m.game_dir },
            |m: &mut CMsgGSServerType| { &mut m.game_dir },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_version",
            |m: &CMsgGSServerType| { &m.game_version },
            |m: &mut CMsgGSServerType| { &mut m.game_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_query_port",
            |m: &CMsgGSServerType| { &m.game_query_port },
            |m: &mut CMsgGSServerType| { &mut m.game_query_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port_local",
            |m: &CMsgGSServerType| { &m.game_port_local },
            |m: &mut CMsgGSServerType| { &mut m.game_port_local },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdr_logon",
            |m: &CMsgGSServerType| { &m.sdr_logon },
            |m: &mut CMsgGSServerType| { &mut m.sdr_logon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fake_ip",
            |m: &CMsgGSServerType| { &m.fake_ip },
            |m: &mut CMsgGSServerType| { &mut m.fake_ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSServerType>(
            "CMsgGSServerType",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSServerType {
    const NAME: &'static str = "CMsgGSServerType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id_served = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.game_dir = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.game_version = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.game_query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.game_port_local = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.sdr_logon = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                77 => {
                    self.fake_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id_served {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.flags {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deprecated_game_ip_address {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_version.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_query_port {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.game_port_local {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.sdr_logon.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.fake_ip {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id_served {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deprecated_game_ip_address {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_version.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_query_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.game_port_local {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.sdr_logon.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.fake_ip {
            os.write_fixed32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSServerType {
        CMsgGSServerType::new()
    }

    fn clear(&mut self) {
        self.app_id_served = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.deprecated_game_ip_address = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.game_dir = ::std::option::Option::None;
        self.game_version = ::std::option::Option::None;
        self.game_query_port = ::std::option::Option::None;
        self.game_port_local = ::std::option::Option::None;
        self.sdr_logon = ::std::option::Option::None;
        self.fake_ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSServerType {
        static instance: CMsgGSServerType = CMsgGSServerType {
            app_id_served: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            deprecated_game_ip_address: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            game_dir: ::std::option::Option::None,
            game_version: ::std::option::Option::None,
            game_query_port: ::std::option::Option::None,
            game_port_local: ::std::option::Option::None,
            sdr_logon: ::std::option::Option::None,
            fake_ip: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSServerType {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSServerType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSServerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSServerType {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSStatusReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSStatusReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSStatusReply.is_secure)
    pub is_secure: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSStatusReply.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSStatusReply {
    fn default() -> &'a CMsgGSStatusReply {
        <CMsgGSStatusReply as crate::Message>::default_instance()
    }
}

impl CMsgGSStatusReply {
    pub fn new() -> CMsgGSStatusReply {
        ::std::default::Default::default()
    }

    // optional bool is_secure = 1;

    pub fn is_secure(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }

    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_secure",
            |m: &CMsgGSStatusReply| { &m.is_secure },
            |m: &mut CMsgGSStatusReply| { &mut m.is_secure },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSStatusReply>(
            "CMsgGSStatusReply",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSStatusReply {
    const NAME: &'static str = "CMsgGSStatusReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_secure {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.is_secure {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSStatusReply {
        CMsgGSStatusReply::new()
    }

    fn clear(&mut self) {
        self.is_secure = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSStatusReply {
        static instance: CMsgGSStatusReply = CMsgGSStatusReply {
            is_secure: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSStatusReply {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSStatusReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSStatusReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSStatusReply {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSPlayerList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSPlayerList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSPlayerList.players)
    pub players: ::std::vec::Vec<cmsg_gsplayer_list::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSPlayerList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSPlayerList {
    fn default() -> &'a CMsgGSPlayerList {
        <CMsgGSPlayerList as crate::Message>::default_instance()
    }
}

impl CMsgGSPlayerList {
    pub fn new() -> CMsgGSPlayerList {
        ::std::default::Default::default()
    }

    // repeated .CMsgGSPlayerList.Player players = 1;

    pub fn players(&self) -> &[cmsg_gsplayer_list::Player] {
        &self.players
    }

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::std::vec::Vec<cmsg_gsplayer_list::Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::std::vec::Vec<cmsg_gsplayer_list::Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::std::vec::Vec<cmsg_gsplayer_list::Player> {
        ::std::mem::replace(&mut self.players, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgGSPlayerList| { &m.players },
            |m: &mut CMsgGSPlayerList| { &mut m.players },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSPlayerList>(
            "CMsgGSPlayerList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSPlayerList {
    const NAME: &'static str = "CMsgGSPlayerList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.players {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSPlayerList {
        CMsgGSPlayerList::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSPlayerList {
        static instance: CMsgGSPlayerList = CMsgGSPlayerList {
            players: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSPlayerList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSPlayerList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSPlayerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSPlayerList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGSPlayerList`
pub mod cmsg_gsplayer_list {
    // @@protoc_insertion_point(message:CMsgGSPlayerList.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.deprecated_public_ip)
        pub deprecated_public_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.token)
        pub token: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.public_ip)
        pub public_ip: crate::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGSPlayerList.Player.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as crate::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_public_ip = 2;

        pub fn deprecated_public_ip(&self) -> u32 {
            self.deprecated_public_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_public_ip(&mut self) {
            self.deprecated_public_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_public_ip(&self) -> bool {
            self.deprecated_public_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_public_ip(&mut self, v: u32) {
            self.deprecated_public_ip = ::std::option::Option::Some(v);
        }

        // optional bytes token = 3;

        pub fn token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::bytes::Bytes) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::bytes::Bytes {
            self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional .CMsgIPAddress public_ip = 4;

        pub fn public_ip(&self) -> &super::super::steammessages_base::CMsgIPAddress {
            self.public_ip.as_ref().unwrap_or_else(|| <super::super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
        }

        pub fn clear_public_ip(&mut self) {
            self.public_ip.clear();
        }

        pub fn has_public_ip(&self) -> bool {
            self.public_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_public_ip(&mut self, v: super::super::steammessages_base::CMsgIPAddress) {
            self.public_ip = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_public_ip(&mut self) -> &mut super::super::steammessages_base::CMsgIPAddress {
            self.public_ip.mut_or_insert_default()
        }

        // Take field
        pub fn take_public_ip(&mut self) -> super::super::steammessages_base::CMsgIPAddress {
            self.public_ip.take().unwrap_or_else(|| super::super::steammessages_base::CMsgIPAddress::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "deprecated_public_ip",
                |m: &Player| { &m.deprecated_public_ip },
                |m: &mut Player| { &mut m.deprecated_public_ip },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "token",
                |m: &Player| { &m.token },
                |m: &mut Player| { &mut m.token },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_base::CMsgIPAddress>(
                "public_ip",
                |m: &Player| { &m.public_ip },
                |m: &mut Player| { &mut m.public_ip },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgGSPlayerList.Player",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    34 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += crate::rt::uint64_size(1, v);
            }
            if let Some(v) = self.deprecated_public_ip {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.token.as_ref() {
                my_size += crate::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.public_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.deprecated_public_ip {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.public_ip.as_ref() {
                crate::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.deprecated_public_ip = ::std::option::Option::None;
            self.token = ::std::option::Option::None;
            self.public_ip.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                deprecated_public_ip: ::std::option::Option::None,
                token: ::std::option::Option::None,
                public_ip: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Player {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGSPlayerList.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Player {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGSUserPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSUserPlaying {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.public_ip)
    pub public_ip: crate::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSUserPlaying.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSUserPlaying {
    fn default() -> &'a CMsgGSUserPlaying {
        <CMsgGSUserPlaying as crate::Message>::default_instance()
    }
}

impl CMsgGSUserPlaying {
    pub fn new() -> CMsgGSUserPlaying {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 2;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes token = 3;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional .CMsgIPAddress public_ip = 4;

    pub fn public_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.public_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
    }

    pub fn clear_public_ip(&mut self) {
        self.public_ip.clear();
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.public_ip = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        self.public_ip.mut_or_insert_default()
    }

    // Take field
    pub fn take_public_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.public_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSUserPlaying| { &m.steam_id },
            |m: &mut CMsgGSUserPlaying| { &mut m.steam_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_public_ip",
            |m: &CMsgGSUserPlaying| { &m.deprecated_public_ip },
            |m: &mut CMsgGSUserPlaying| { &mut m.deprecated_public_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgGSUserPlaying| { &m.token },
            |m: &mut CMsgGSUserPlaying| { &mut m.token },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "public_ip",
            |m: &CMsgGSUserPlaying| { &m.public_ip },
            |m: &mut CMsgGSUserPlaying| { &mut m.public_ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSUserPlaying>(
            "CMsgGSUserPlaying",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSUserPlaying {
    const NAME: &'static str = "CMsgGSUserPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSUserPlaying {
        CMsgGSUserPlaying::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSUserPlaying {
        static instance: CMsgGSUserPlaying = CMsgGSUserPlaying {
            steam_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            token: ::std::option::Option::None,
            public_ip: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSUserPlaying {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSUserPlaying").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSUserPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSUserPlaying {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSDisconnectNotice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSDisconnectNotice {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSDisconnectNotice.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSDisconnectNotice.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSDisconnectNotice {
    fn default() -> &'a CMsgGSDisconnectNotice {
        <CMsgGSDisconnectNotice as crate::Message>::default_instance()
    }
}

impl CMsgGSDisconnectNotice {
    pub fn new() -> CMsgGSDisconnectNotice {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSDisconnectNotice| { &m.steam_id },
            |m: &mut CMsgGSDisconnectNotice| { &mut m.steam_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSDisconnectNotice>(
            "CMsgGSDisconnectNotice",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSDisconnectNotice {
    const NAME: &'static str = "CMsgGSDisconnectNotice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSDisconnectNotice {
        CMsgGSDisconnectNotice::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSDisconnectNotice {
        static instance: CMsgGSDisconnectNotice = CMsgGSDisconnectNotice {
            steam_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSDisconnectNotice {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSDisconnectNotice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSDisconnectNotice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSDisconnectNotice {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameServerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerData.revision)
    pub revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.query_port)
    pub query_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.spectator_port)
    pub spectator_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.server_name)
    pub server_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_description)
    pub game_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.spectator_server_name)
    pub spectator_server_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.fake_ip)
    pub fake_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.sdr_ping_location)
    pub sdr_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.gamedir)
    pub gamedir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.region)
    pub region: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.players)
    pub players: ::std::vec::Vec<cmsg_game_server_data::Player>,
    // @@protoc_insertion_point(field:CMsgGameServerData.max_players)
    pub max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.bot_count)
    pub bot_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.password)
    pub password: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.secure)
    pub secure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.dedicated)
    pub dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_data)
    pub game_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_type)
    pub game_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.map)
    pub map: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerData {
    fn default() -> &'a CMsgGameServerData {
        <CMsgGameServerData as crate::Message>::default_instance()
    }
}

impl CMsgGameServerData {
    pub fn new() -> CMsgGameServerData {
        ::std::default::Default::default()
    }

    // optional uint32 revision = 24;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional uint32 query_port = 3;

    pub fn query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }

    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional uint32 spectator_port = 5;

    pub fn spectator_port(&self) -> u32 {
        self.spectator_port.unwrap_or(0)
    }

    pub fn clear_spectator_port(&mut self) {
        self.spectator_port = ::std::option::Option::None;
    }

    pub fn has_spectator_port(&self) -> bool {
        self.spectator_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_port(&mut self, v: u32) {
        self.spectator_port = ::std::option::Option::Some(v);
    }

    // optional string server_name = 22;

    pub fn server_name(&self) -> &str {
        match self.server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_name(&mut self) {
        self.server_name = ::std::option::Option::None;
    }

    pub fn has_server_name(&self) -> bool {
        self.server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_name(&mut self, v: ::std::string::String) {
        self.server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_name(&mut self) -> &mut ::std::string::String {
        if self.server_name.is_none() {
            self.server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_name(&mut self) -> ::std::string::String {
        self.server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_description = 29;

    pub fn game_description(&self) -> &str {
        match self.game_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_description(&mut self) {
        self.game_description = ::std::option::Option::None;
    }

    pub fn has_game_description(&self) -> bool {
        self.game_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_description(&mut self, v: ::std::string::String) {
        self.game_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_description(&mut self) -> &mut ::std::string::String {
        if self.game_description.is_none() {
            self.game_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_description(&mut self) -> ::std::string::String {
        self.game_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string spectator_server_name = 27;

    pub fn spectator_server_name(&self) -> &str {
        match self.spectator_server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_spectator_server_name(&mut self) {
        self.spectator_server_name = ::std::option::Option::None;
    }

    pub fn has_spectator_server_name(&self) -> bool {
        self.spectator_server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_server_name(&mut self, v: ::std::string::String) {
        self.spectator_server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spectator_server_name(&mut self) -> &mut ::std::string::String {
        if self.spectator_server_name.is_none() {
            self.spectator_server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.spectator_server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_spectator_server_name(&mut self) -> ::std::string::String {
        self.spectator_server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 fake_ip = 28;

    pub fn fake_ip(&self) -> u32 {
        self.fake_ip.unwrap_or(0)
    }

    pub fn clear_fake_ip(&mut self) {
        self.fake_ip = ::std::option::Option::None;
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: u32) {
        self.fake_ip = ::std::option::Option::Some(v);
    }

    // optional string sdr_ping_location = 30;

    pub fn sdr_ping_location(&self) -> &str {
        match self.sdr_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdr_ping_location(&mut self) {
        self.sdr_ping_location = ::std::option::Option::None;
    }

    pub fn has_sdr_ping_location(&self) -> bool {
        self.sdr_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_ping_location(&mut self, v: ::std::string::String) {
        self.sdr_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr_ping_location(&mut self) -> &mut ::std::string::String {
        if self.sdr_ping_location.is_none() {
            self.sdr_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdr_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr_ping_location(&mut self) -> ::std::string::String {
        self.sdr_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 6;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string gamedir = 7;

    pub fn gamedir(&self) -> &str {
        match self.gamedir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamedir(&mut self) {
        self.gamedir = ::std::option::Option::None;
    }

    pub fn has_gamedir(&self) -> bool {
        self.gamedir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamedir(&mut self, v: ::std::string::String) {
        self.gamedir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamedir(&mut self) -> &mut ::std::string::String {
        if self.gamedir.is_none() {
            self.gamedir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gamedir.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamedir(&mut self) -> ::std::string::String {
        self.gamedir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 8;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product = 9;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string region = 10;

    pub fn region(&self) -> &str {
        match self.region.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        if self.region.is_none() {
            self.region = ::std::option::Option::Some(::std::string::String::new());
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        self.region.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgGameServerData.Player players = 11;

    pub fn players(&self) -> &[cmsg_game_server_data::Player] {
        &self.players
    }

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::std::vec::Vec<cmsg_game_server_data::Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::std::vec::Vec<cmsg_game_server_data::Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::std::vec::Vec<cmsg_game_server_data::Player> {
        ::std::mem::replace(&mut self.players, ::std::vec::Vec::new())
    }

    // optional uint32 max_players = 12;

    pub fn max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }

    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_count = 13;

    pub fn bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }

    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional bool password = 14;

    pub fn password(&self) -> bool {
        self.password.unwrap_or(false)
    }

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: bool) {
        self.password = ::std::option::Option::Some(v);
    }

    // optional bool secure = 15;

    pub fn secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }

    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool dedicated = 16;

    pub fn dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }

    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional string os = 17;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_data = 18;

    pub fn game_data(&self) -> &str {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::string::String) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::string::String {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::string::String {
        self.game_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_type = 20;

    pub fn game_type(&self) -> &str {
        match self.game_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: ::std::string::String) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_type(&mut self) -> &mut ::std::string::String {
        if self.game_type.is_none() {
            self.game_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_type(&mut self) -> ::std::string::String {
        self.game_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map = 21;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CMsgGameServerData| { &m.revision },
            |m: &mut CMsgGameServerData| { &mut m.revision },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "query_port",
            |m: &CMsgGameServerData| { &m.query_port },
            |m: &mut CMsgGameServerData| { &mut m.query_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port",
            |m: &CMsgGameServerData| { &m.game_port },
            |m: &mut CMsgGameServerData| { &mut m.game_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectator_port",
            |m: &CMsgGameServerData| { &m.spectator_port },
            |m: &mut CMsgGameServerData| { &mut m.spectator_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_name",
            |m: &CMsgGameServerData| { &m.server_name },
            |m: &mut CMsgGameServerData| { &mut m.server_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_description",
            |m: &CMsgGameServerData| { &m.game_description },
            |m: &mut CMsgGameServerData| { &mut m.game_description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectator_server_name",
            |m: &CMsgGameServerData| { &m.spectator_server_name },
            |m: &mut CMsgGameServerData| { &mut m.spectator_server_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fake_ip",
            |m: &CMsgGameServerData| { &m.fake_ip },
            |m: &mut CMsgGameServerData| { &mut m.fake_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdr_ping_location",
            |m: &CMsgGameServerData| { &m.sdr_ping_location },
            |m: &mut CMsgGameServerData| { &mut m.sdr_ping_location },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgGameServerData| { &m.app_id },
            |m: &mut CMsgGameServerData| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamedir",
            |m: &CMsgGameServerData| { &m.gamedir },
            |m: &mut CMsgGameServerData| { &mut m.gamedir },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGameServerData| { &m.version },
            |m: &mut CMsgGameServerData| { &mut m.version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &CMsgGameServerData| { &m.product },
            |m: &mut CMsgGameServerData| { &mut m.product },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "region",
            |m: &CMsgGameServerData| { &m.region },
            |m: &mut CMsgGameServerData| { &mut m.region },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgGameServerData| { &m.players },
            |m: &mut CMsgGameServerData| { &mut m.players },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_players",
            |m: &CMsgGameServerData| { &m.max_players },
            |m: &mut CMsgGameServerData| { &mut m.max_players },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_count",
            |m: &CMsgGameServerData| { &m.bot_count },
            |m: &mut CMsgGameServerData| { &mut m.bot_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "password",
            |m: &CMsgGameServerData| { &m.password },
            |m: &mut CMsgGameServerData| { &mut m.password },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "secure",
            |m: &CMsgGameServerData| { &m.secure },
            |m: &mut CMsgGameServerData| { &mut m.secure },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dedicated",
            |m: &CMsgGameServerData| { &m.dedicated },
            |m: &mut CMsgGameServerData| { &mut m.dedicated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &CMsgGameServerData| { &m.os },
            |m: &mut CMsgGameServerData| { &mut m.os },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data",
            |m: &CMsgGameServerData| { &m.game_data },
            |m: &mut CMsgGameServerData| { &mut m.game_data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGameServerData| { &m.game_type },
            |m: &mut CMsgGameServerData| { &mut m.game_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGameServerData| { &m.map },
            |m: &mut CMsgGameServerData| { &mut m.map },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerData>(
            "CMsgGameServerData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGameServerData {
    const NAME: &'static str = "CMsgGameServerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                192 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.spectator_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    self.server_name = ::std::option::Option::Some(is.read_string()?);
                },
                234 => {
                    self.game_description = ::std::option::Option::Some(is.read_string()?);
                },
                218 => {
                    self.spectator_server_name = ::std::option::Option::Some(is.read_string()?);
                },
                229 => {
                    self.fake_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                242 => {
                    self.sdr_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.gamedir = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.region = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.players.push(is.read_message()?);
                },
                96 => {
                    self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.bot_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.password = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.secure = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.game_data = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.game_type = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision {
            my_size += crate::rt::uint32_size(24, v);
        }
        if let Some(v) = self.query_port {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.spectator_port {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.server_name.as_ref() {
            my_size += crate::rt::string_size(22, &v);
        }
        if let Some(v) = self.game_description.as_ref() {
            my_size += crate::rt::string_size(29, &v);
        }
        if let Some(v) = self.spectator_server_name.as_ref() {
            my_size += crate::rt::string_size(27, &v);
        }
        if let Some(v) = self.fake_ip {
            my_size += 2 + 4;
        }
        if let Some(v) = self.sdr_ping_location.as_ref() {
            my_size += crate::rt::string_size(30, &v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.gamedir.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.product.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        if let Some(v) = self.region.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_players {
            my_size += crate::rt::uint32_size(12, v);
        }
        if let Some(v) = self.bot_count {
            my_size += crate::rt::uint32_size(13, v);
        }
        if let Some(v) = self.password {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dedicated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.os.as_ref() {
            my_size += crate::rt::string_size(17, &v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += crate::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_type.as_ref() {
            my_size += crate::rt::string_size(20, &v);
        }
        if let Some(v) = self.map.as_ref() {
            my_size += crate::rt::string_size(21, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.revision {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spectator_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.server_name.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.game_description.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.spectator_server_name.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.fake_ip {
            os.write_fixed32(28, v)?;
        }
        if let Some(v) = self.sdr_ping_location.as_ref() {
            os.write_string(30, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.gamedir.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.product.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.region.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.players {
            crate::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.max_players {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.password {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.dedicated {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.game_type.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerData {
        CMsgGameServerData::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.query_port = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.spectator_port = ::std::option::Option::None;
        self.server_name = ::std::option::Option::None;
        self.game_description = ::std::option::Option::None;
        self.spectator_server_name = ::std::option::Option::None;
        self.fake_ip = ::std::option::Option::None;
        self.sdr_ping_location = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.gamedir = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.product = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.players.clear();
        self.max_players = ::std::option::Option::None;
        self.bot_count = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.dedicated = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerData {
        static instance: CMsgGameServerData = CMsgGameServerData {
            revision: ::std::option::Option::None,
            query_port: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            spectator_port: ::std::option::Option::None,
            server_name: ::std::option::Option::None,
            game_description: ::std::option::Option::None,
            spectator_server_name: ::std::option::Option::None,
            fake_ip: ::std::option::Option::None,
            sdr_ping_location: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            gamedir: ::std::option::Option::None,
            version: ::std::option::Option::None,
            product: ::std::option::Option::None,
            region: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            max_players: ::std::option::Option::None,
            bot_count: ::std::option::Option::None,
            password: ::std::option::Option::None,
            secure: ::std::option::Option::None,
            dedicated: ::std::option::Option::None,
            os: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            map: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGameServerData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGameServerData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameServerData`
pub mod cmsg_game_server_data {
    // @@protoc_insertion_point(message:CMsgGameServerData.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameServerData.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameServerData.Player.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as crate::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgGameServerData.Player",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Player {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameServerData.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Player {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGameServerRemove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerRemove {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerRemove.legacy_steam_id_gs)
    pub legacy_steam_id_gs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerRemove.legacy_query_port)
    pub legacy_query_port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerRemove.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerRemove {
    fn default() -> &'a CMsgGameServerRemove {
        <CMsgGameServerRemove as crate::Message>::default_instance()
    }
}

impl CMsgGameServerRemove {
    pub fn new() -> CMsgGameServerRemove {
        ::std::default::Default::default()
    }

    // optional fixed64 legacy_steam_id_gs = 1;

    pub fn legacy_steam_id_gs(&self) -> u64 {
        self.legacy_steam_id_gs.unwrap_or(0)
    }

    pub fn clear_legacy_steam_id_gs(&mut self) {
        self.legacy_steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_legacy_steam_id_gs(&self) -> bool {
        self.legacy_steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_steam_id_gs(&mut self, v: u64) {
        self.legacy_steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_query_port = 3;

    pub fn legacy_query_port(&self) -> u32 {
        self.legacy_query_port.unwrap_or(0)
    }

    pub fn clear_legacy_query_port(&mut self) {
        self.legacy_query_port = ::std::option::Option::None;
    }

    pub fn has_legacy_query_port(&self) -> bool {
        self.legacy_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_query_port(&mut self, v: u32) {
        self.legacy_query_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_steam_id_gs",
            |m: &CMsgGameServerRemove| { &m.legacy_steam_id_gs },
            |m: &mut CMsgGameServerRemove| { &mut m.legacy_steam_id_gs },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_query_port",
            |m: &CMsgGameServerRemove| { &m.legacy_query_port },
            |m: &mut CMsgGameServerRemove| { &mut m.legacy_query_port },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerRemove>(
            "CMsgGameServerRemove",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGameServerRemove {
    const NAME: &'static str = "CMsgGameServerRemove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.legacy_steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.legacy_query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_steam_id_gs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_query_port {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.legacy_steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.legacy_query_port {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerRemove {
        CMsgGameServerRemove::new()
    }

    fn clear(&mut self) {
        self.legacy_steam_id_gs = ::std::option::Option::None;
        self.legacy_query_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerRemove {
        static instance: CMsgGameServerRemove = CMsgGameServerRemove {
            legacy_steam_id_gs: ::std::option::Option::None,
            legacy_query_port: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGameServerRemove {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerRemove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGameServerRemove {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGMSServerQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGMSServerQuery {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.geo_location_ip)
    pub geo_location_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.region_code)
    pub region_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.filter_text)
    pub filter_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.max_servers)
    pub max_servers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGMSServerQuery.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGMSServerQuery {
    fn default() -> &'a CMsgClientGMSServerQuery {
        <CMsgClientGMSServerQuery as crate::Message>::default_instance()
    }
}

impl CMsgClientGMSServerQuery {
    pub fn new() -> CMsgClientGMSServerQuery {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 geo_location_ip = 2;

    pub fn geo_location_ip(&self) -> u32 {
        self.geo_location_ip.unwrap_or(0)
    }

    pub fn clear_geo_location_ip(&mut self) {
        self.geo_location_ip = ::std::option::Option::None;
    }

    pub fn has_geo_location_ip(&self) -> bool {
        self.geo_location_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_location_ip(&mut self, v: u32) {
        self.geo_location_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 region_code = 3;

    pub fn region_code(&self) -> u32 {
        self.region_code.unwrap_or(0)
    }

    pub fn clear_region_code(&mut self) {
        self.region_code = ::std::option::Option::None;
    }

    pub fn has_region_code(&self) -> bool {
        self.region_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_code(&mut self, v: u32) {
        self.region_code = ::std::option::Option::Some(v);
    }

    // optional string filter_text = 4;

    pub fn filter_text(&self) -> &str {
        match self.filter_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filter_text(&mut self) {
        self.filter_text = ::std::option::Option::None;
    }

    pub fn has_filter_text(&self) -> bool {
        self.filter_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_text(&mut self, v: ::std::string::String) {
        self.filter_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_text(&mut self) -> &mut ::std::string::String {
        if self.filter_text.is_none() {
            self.filter_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filter_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_text(&mut self) -> ::std::string::String {
        self.filter_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_servers = 5;

    pub fn max_servers(&self) -> u32 {
        self.max_servers.unwrap_or(0)
    }

    pub fn clear_max_servers(&mut self) {
        self.max_servers = ::std::option::Option::None;
    }

    pub fn has_max_servers(&self) -> bool {
        self.max_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_servers(&mut self, v: u32) {
        self.max_servers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGMSServerQuery| { &m.app_id },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "geo_location_ip",
            |m: &CMsgClientGMSServerQuery| { &m.geo_location_ip },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.geo_location_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_code",
            |m: &CMsgClientGMSServerQuery| { &m.region_code },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.region_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "filter_text",
            |m: &CMsgClientGMSServerQuery| { &m.filter_text },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.filter_text },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_servers",
            |m: &CMsgClientGMSServerQuery| { &m.max_servers },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.max_servers },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGMSServerQuery>(
            "CMsgClientGMSServerQuery",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGMSServerQuery {
    const NAME: &'static str = "CMsgClientGMSServerQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.geo_location_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.region_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.filter_text = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.max_servers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.geo_location_ip {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.region_code {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filter_text.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.max_servers {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.geo_location_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.region_code {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_text.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.max_servers {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGMSServerQuery {
        CMsgClientGMSServerQuery::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.geo_location_ip = ::std::option::Option::None;
        self.region_code = ::std::option::Option::None;
        self.filter_text = ::std::option::Option::None;
        self.max_servers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGMSServerQuery {
        static instance: CMsgClientGMSServerQuery = CMsgClientGMSServerQuery {
            app_id: ::std::option::Option::None,
            geo_location_ip: ::std::option::Option::None,
            region_code: ::std::option::Option::None,
            filter_text: ::std::option::Option::None,
            max_servers: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGMSServerQuery {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGMSServerQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGMSServerQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGMSServerQuery {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGMSClientServerQueryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGMSClientServerQueryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.servers)
    pub servers: ::std::vec::Vec<cmsg_gmsclient_server_query_response::Server>,
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.default_server_data)
    pub default_server_data: crate::MessageField<cmsg_gmsclient_server_query_response::Server>,
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.server_strings)
    pub server_strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGMSClientServerQueryResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGMSClientServerQueryResponse {
    fn default() -> &'a CMsgGMSClientServerQueryResponse {
        <CMsgGMSClientServerQueryResponse as crate::Message>::default_instance()
    }
}

impl CMsgGMSClientServerQueryResponse {
    pub fn new() -> CMsgGMSClientServerQueryResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgGMSClientServerQueryResponse.Server servers = 1;

    pub fn servers(&self) -> &[cmsg_gmsclient_server_query_response::Server] {
        &self.servers
    }

    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::std::vec::Vec<cmsg_gmsclient_server_query_response::Server>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::std::vec::Vec<cmsg_gmsclient_server_query_response::Server> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::std::vec::Vec<cmsg_gmsclient_server_query_response::Server> {
        ::std::mem::replace(&mut self.servers, ::std::vec::Vec::new())
    }

    // optional string error = 2;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgGMSClientServerQueryResponse.Server default_server_data = 3;

    pub fn default_server_data(&self) -> &cmsg_gmsclient_server_query_response::Server {
        self.default_server_data.as_ref().unwrap_or_else(|| <cmsg_gmsclient_server_query_response::Server as crate::Message>::default_instance())
    }

    pub fn clear_default_server_data(&mut self) {
        self.default_server_data.clear();
    }

    pub fn has_default_server_data(&self) -> bool {
        self.default_server_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_server_data(&mut self, v: cmsg_gmsclient_server_query_response::Server) {
        self.default_server_data = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_server_data(&mut self) -> &mut cmsg_gmsclient_server_query_response::Server {
        self.default_server_data.mut_or_insert_default()
    }

    // Take field
    pub fn take_default_server_data(&mut self) -> cmsg_gmsclient_server_query_response::Server {
        self.default_server_data.take().unwrap_or_else(|| cmsg_gmsclient_server_query_response::Server::new())
    }

    // repeated string server_strings = 4;

    pub fn server_strings(&self) -> &[::std::string::String] {
        &self.server_strings
    }

    pub fn clear_server_strings(&mut self) {
        self.server_strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_strings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.server_strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_strings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.server_strings
    }

    // Take field
    pub fn take_server_strings(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.server_strings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "servers",
            |m: &CMsgGMSClientServerQueryResponse| { &m.servers },
            |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.servers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &CMsgGMSClientServerQueryResponse| { &m.error },
            |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.error },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cmsg_gmsclient_server_query_response::Server>(
            "default_server_data",
            |m: &CMsgGMSClientServerQueryResponse| { &m.default_server_data },
            |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.default_server_data },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "server_strings",
            |m: &CMsgGMSClientServerQueryResponse| { &m.server_strings },
            |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.server_strings },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGMSClientServerQueryResponse>(
            "CMsgGMSClientServerQueryResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGMSClientServerQueryResponse {
    const NAME: &'static str = "CMsgGMSClientServerQueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_message()?);
                },
                18 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.default_server_data)?;
                },
                34 => {
                    self.server_strings.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_server_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.server_strings {
            my_size += crate::rt::string_size(4, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.servers {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_server_data.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.server_strings {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGMSClientServerQueryResponse {
        CMsgGMSClientServerQueryResponse::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.error = ::std::option::Option::None;
        self.default_server_data.clear();
        self.server_strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGMSClientServerQueryResponse {
        static instance: CMsgGMSClientServerQueryResponse = CMsgGMSClientServerQueryResponse {
            servers: ::std::vec::Vec::new(),
            error: ::std::option::Option::None,
            default_server_data: crate::MessageField::none(),
            server_strings: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGMSClientServerQueryResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGMSClientServerQueryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGMSClientServerQueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGMSClientServerQueryResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGMSClientServerQueryResponse`
pub mod cmsg_gmsclient_server_query_response {
    // @@protoc_insertion_point(message:CMsgGMSClientServerQueryResponse.Server)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Server {
        // message fields
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.deprecated_server_ip)
        pub deprecated_server_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.query_port)
        pub query_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.auth_players)
        pub auth_players: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.server_ip)
        pub server_ip: crate::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.revision)
        pub revision: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.players)
        pub players: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.game_port)
        pub game_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.sdr_popid)
        pub sdr_popid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.sdr_ping_location)
        pub sdr_ping_location: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.max_players)
        pub max_players: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.bots)
        pub bots: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.spectator_port)
        pub spectator_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gamedir_str)
        pub gamedir_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gamedir_strindex)
        pub gamedir_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.map_str)
        pub map_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.map_strindex)
        pub map_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.name_str)
        pub name_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.name_strindex)
        pub name_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.game_description_str)
        pub game_description_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.game_description_strindex)
        pub game_description_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.version_str)
        pub version_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.version_strindex)
        pub version_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gametype_str)
        pub gametype_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gametype_strindex)
        pub gametype_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.spectator_name_str)
        pub spectator_name_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.spectator_name_strindex)
        pub spectator_name_strindex: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGMSClientServerQueryResponse.Server.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server {
        fn default() -> &'a Server {
            <Server as crate::Message>::default_instance()
        }
    }

    impl Server {
        pub fn new() -> Server {
            ::std::default::Default::default()
        }

        // optional uint32 deprecated_server_ip = 1;

        pub fn deprecated_server_ip(&self) -> u32 {
            self.deprecated_server_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_server_ip(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_server_ip(&self) -> bool {
            self.deprecated_server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_server_ip(&mut self, v: u32) {
            self.deprecated_server_ip = ::std::option::Option::Some(v);
        }

        // optional uint32 query_port = 2;

        pub fn query_port(&self) -> u32 {
            self.query_port.unwrap_or(0)
        }

        pub fn clear_query_port(&mut self) {
            self.query_port = ::std::option::Option::None;
        }

        pub fn has_query_port(&self) -> bool {
            self.query_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_port(&mut self, v: u32) {
            self.query_port = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_players = 3;

        pub fn auth_players(&self) -> u32 {
            self.auth_players.unwrap_or(0)
        }

        pub fn clear_auth_players(&mut self) {
            self.auth_players = ::std::option::Option::None;
        }

        pub fn has_auth_players(&self) -> bool {
            self.auth_players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_players(&mut self, v: u32) {
            self.auth_players = ::std::option::Option::Some(v);
        }

        // optional .CMsgIPAddress server_ip = 4;

        pub fn server_ip(&self) -> &super::super::steammessages_base::CMsgIPAddress {
            self.server_ip.as_ref().unwrap_or_else(|| <super::super::steammessages_base::CMsgIPAddress as crate::Message>::default_instance())
        }

        pub fn clear_server_ip(&mut self) {
            self.server_ip.clear();
        }

        pub fn has_server_ip(&self) -> bool {
            self.server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_ip(&mut self, v: super::super::steammessages_base::CMsgIPAddress) {
            self.server_ip = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_server_ip(&mut self) -> &mut super::super::steammessages_base::CMsgIPAddress {
            self.server_ip.mut_or_insert_default()
        }

        // Take field
        pub fn take_server_ip(&mut self) -> super::super::steammessages_base::CMsgIPAddress {
            self.server_ip.take().unwrap_or_else(|| super::super::steammessages_base::CMsgIPAddress::new())
        }

        // optional fixed64 steam_id = 6;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 revision = 7;

        pub fn revision(&self) -> u32 {
            self.revision.unwrap_or(0)
        }

        pub fn clear_revision(&mut self) {
            self.revision = ::std::option::Option::None;
        }

        pub fn has_revision(&self) -> bool {
            self.revision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revision(&mut self, v: u32) {
            self.revision = ::std::option::Option::Some(v);
        }

        // optional uint32 players = 8;

        pub fn players(&self) -> u32 {
            self.players.unwrap_or(0)
        }

        pub fn clear_players(&mut self) {
            self.players = ::std::option::Option::None;
        }

        pub fn has_players(&self) -> bool {
            self.players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_players(&mut self, v: u32) {
            self.players = ::std::option::Option::Some(v);
        }

        // optional uint32 game_port = 9;

        pub fn game_port(&self) -> u32 {
            self.game_port.unwrap_or(0)
        }

        pub fn clear_game_port(&mut self) {
            self.game_port = ::std::option::Option::None;
        }

        pub fn has_game_port(&self) -> bool {
            self.game_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_port(&mut self, v: u32) {
            self.game_port = ::std::option::Option::Some(v);
        }

        // optional fixed32 sdr_popid = 10;

        pub fn sdr_popid(&self) -> u32 {
            self.sdr_popid.unwrap_or(0)
        }

        pub fn clear_sdr_popid(&mut self) {
            self.sdr_popid = ::std::option::Option::None;
        }

        pub fn has_sdr_popid(&self) -> bool {
            self.sdr_popid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sdr_popid(&mut self, v: u32) {
            self.sdr_popid = ::std::option::Option::Some(v);
        }

        // optional string sdr_ping_location = 32;

        pub fn sdr_ping_location(&self) -> &str {
            match self.sdr_ping_location.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_sdr_ping_location(&mut self) {
            self.sdr_ping_location = ::std::option::Option::None;
        }

        pub fn has_sdr_ping_location(&self) -> bool {
            self.sdr_ping_location.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sdr_ping_location(&mut self, v: ::std::string::String) {
            self.sdr_ping_location = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sdr_ping_location(&mut self) -> &mut ::std::string::String {
            if self.sdr_ping_location.is_none() {
                self.sdr_ping_location = ::std::option::Option::Some(::std::string::String::new());
            }
            self.sdr_ping_location.as_mut().unwrap()
        }

        // Take field
        pub fn take_sdr_ping_location(&mut self) -> ::std::string::String {
            self.sdr_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 flags = 11;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 12;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 max_players = 13;

        pub fn max_players(&self) -> u32 {
            self.max_players.unwrap_or(0)
        }

        pub fn clear_max_players(&mut self) {
            self.max_players = ::std::option::Option::None;
        }

        pub fn has_max_players(&self) -> bool {
            self.max_players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_players(&mut self, v: u32) {
            self.max_players = ::std::option::Option::Some(v);
        }

        // optional uint32 bots = 14;

        pub fn bots(&self) -> u32 {
            self.bots.unwrap_or(0)
        }

        pub fn clear_bots(&mut self) {
            self.bots = ::std::option::Option::None;
        }

        pub fn has_bots(&self) -> bool {
            self.bots.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bots(&mut self, v: u32) {
            self.bots = ::std::option::Option::Some(v);
        }

        // optional uint32 spectator_port = 15;

        pub fn spectator_port(&self) -> u32 {
            self.spectator_port.unwrap_or(0)
        }

        pub fn clear_spectator_port(&mut self) {
            self.spectator_port = ::std::option::Option::None;
        }

        pub fn has_spectator_port(&self) -> bool {
            self.spectator_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectator_port(&mut self, v: u32) {
            self.spectator_port = ::std::option::Option::Some(v);
        }

        // optional string gamedir_str = 16;

        pub fn gamedir_str(&self) -> &str {
            match self.gamedir_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_gamedir_str(&mut self) {
            self.gamedir_str = ::std::option::Option::None;
        }

        pub fn has_gamedir_str(&self) -> bool {
            self.gamedir_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gamedir_str(&mut self, v: ::std::string::String) {
            self.gamedir_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_gamedir_str(&mut self) -> &mut ::std::string::String {
            if self.gamedir_str.is_none() {
                self.gamedir_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.gamedir_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_gamedir_str(&mut self) -> ::std::string::String {
            self.gamedir_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 gamedir_strindex = 17;

        pub fn gamedir_strindex(&self) -> u32 {
            self.gamedir_strindex.unwrap_or(0)
        }

        pub fn clear_gamedir_strindex(&mut self) {
            self.gamedir_strindex = ::std::option::Option::None;
        }

        pub fn has_gamedir_strindex(&self) -> bool {
            self.gamedir_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gamedir_strindex(&mut self, v: u32) {
            self.gamedir_strindex = ::std::option::Option::Some(v);
        }

        // optional string map_str = 18;

        pub fn map_str(&self) -> &str {
            match self.map_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_map_str(&mut self) {
            self.map_str = ::std::option::Option::None;
        }

        pub fn has_map_str(&self) -> bool {
            self.map_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_str(&mut self, v: ::std::string::String) {
            self.map_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_map_str(&mut self) -> &mut ::std::string::String {
            if self.map_str.is_none() {
                self.map_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.map_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_map_str(&mut self) -> ::std::string::String {
            self.map_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 map_strindex = 19;

        pub fn map_strindex(&self) -> u32 {
            self.map_strindex.unwrap_or(0)
        }

        pub fn clear_map_strindex(&mut self) {
            self.map_strindex = ::std::option::Option::None;
        }

        pub fn has_map_strindex(&self) -> bool {
            self.map_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_strindex(&mut self, v: u32) {
            self.map_strindex = ::std::option::Option::Some(v);
        }

        // optional string name_str = 20;

        pub fn name_str(&self) -> &str {
            match self.name_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_str(&mut self) {
            self.name_str = ::std::option::Option::None;
        }

        pub fn has_name_str(&self) -> bool {
            self.name_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_str(&mut self, v: ::std::string::String) {
            self.name_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_str(&mut self) -> &mut ::std::string::String {
            if self.name_str.is_none() {
                self.name_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_str(&mut self) -> ::std::string::String {
            self.name_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 name_strindex = 21;

        pub fn name_strindex(&self) -> u32 {
            self.name_strindex.unwrap_or(0)
        }

        pub fn clear_name_strindex(&mut self) {
            self.name_strindex = ::std::option::Option::None;
        }

        pub fn has_name_strindex(&self) -> bool {
            self.name_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_strindex(&mut self, v: u32) {
            self.name_strindex = ::std::option::Option::Some(v);
        }

        // optional string game_description_str = 22;

        pub fn game_description_str(&self) -> &str {
            match self.game_description_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_description_str(&mut self) {
            self.game_description_str = ::std::option::Option::None;
        }

        pub fn has_game_description_str(&self) -> bool {
            self.game_description_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_description_str(&mut self, v: ::std::string::String) {
            self.game_description_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_description_str(&mut self) -> &mut ::std::string::String {
            if self.game_description_str.is_none() {
                self.game_description_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_description_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_description_str(&mut self) -> ::std::string::String {
            self.game_description_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 game_description_strindex = 23;

        pub fn game_description_strindex(&self) -> u32 {
            self.game_description_strindex.unwrap_or(0)
        }

        pub fn clear_game_description_strindex(&mut self) {
            self.game_description_strindex = ::std::option::Option::None;
        }

        pub fn has_game_description_strindex(&self) -> bool {
            self.game_description_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_description_strindex(&mut self, v: u32) {
            self.game_description_strindex = ::std::option::Option::Some(v);
        }

        // optional string version_str = 24;

        pub fn version_str(&self) -> &str {
            match self.version_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_version_str(&mut self) {
            self.version_str = ::std::option::Option::None;
        }

        pub fn has_version_str(&self) -> bool {
            self.version_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_str(&mut self, v: ::std::string::String) {
            self.version_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_version_str(&mut self) -> &mut ::std::string::String {
            if self.version_str.is_none() {
                self.version_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.version_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_version_str(&mut self) -> ::std::string::String {
            self.version_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 version_strindex = 25;

        pub fn version_strindex(&self) -> u32 {
            self.version_strindex.unwrap_or(0)
        }

        pub fn clear_version_strindex(&mut self) {
            self.version_strindex = ::std::option::Option::None;
        }

        pub fn has_version_strindex(&self) -> bool {
            self.version_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_strindex(&mut self, v: u32) {
            self.version_strindex = ::std::option::Option::Some(v);
        }

        // optional string gametype_str = 26;

        pub fn gametype_str(&self) -> &str {
            match self.gametype_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_gametype_str(&mut self) {
            self.gametype_str = ::std::option::Option::None;
        }

        pub fn has_gametype_str(&self) -> bool {
            self.gametype_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gametype_str(&mut self, v: ::std::string::String) {
            self.gametype_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_gametype_str(&mut self) -> &mut ::std::string::String {
            if self.gametype_str.is_none() {
                self.gametype_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.gametype_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_gametype_str(&mut self) -> ::std::string::String {
            self.gametype_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 gametype_strindex = 27;

        pub fn gametype_strindex(&self) -> u32 {
            self.gametype_strindex.unwrap_or(0)
        }

        pub fn clear_gametype_strindex(&mut self) {
            self.gametype_strindex = ::std::option::Option::None;
        }

        pub fn has_gametype_strindex(&self) -> bool {
            self.gametype_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gametype_strindex(&mut self, v: u32) {
            self.gametype_strindex = ::std::option::Option::Some(v);
        }

        // optional string spectator_name_str = 30;

        pub fn spectator_name_str(&self) -> &str {
            match self.spectator_name_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_spectator_name_str(&mut self) {
            self.spectator_name_str = ::std::option::Option::None;
        }

        pub fn has_spectator_name_str(&self) -> bool {
            self.spectator_name_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectator_name_str(&mut self, v: ::std::string::String) {
            self.spectator_name_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_spectator_name_str(&mut self) -> &mut ::std::string::String {
            if self.spectator_name_str.is_none() {
                self.spectator_name_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.spectator_name_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_spectator_name_str(&mut self) -> ::std::string::String {
            self.spectator_name_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 spectator_name_strindex = 31;

        pub fn spectator_name_strindex(&self) -> u32 {
            self.spectator_name_strindex.unwrap_or(0)
        }

        pub fn clear_spectator_name_strindex(&mut self) {
            self.spectator_name_strindex = ::std::option::Option::None;
        }

        pub fn has_spectator_name_strindex(&self) -> bool {
            self.spectator_name_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectator_name_strindex(&mut self, v: u32) {
            self.spectator_name_strindex = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(29);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "deprecated_server_ip",
                |m: &Server| { &m.deprecated_server_ip },
                |m: &mut Server| { &mut m.deprecated_server_ip },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "query_port",
                |m: &Server| { &m.query_port },
                |m: &mut Server| { &mut m.query_port },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "auth_players",
                |m: &Server| { &m.auth_players },
                |m: &mut Server| { &mut m.auth_players },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_base::CMsgIPAddress>(
                "server_ip",
                |m: &Server| { &m.server_ip },
                |m: &mut Server| { &mut m.server_ip },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Server| { &m.steam_id },
                |m: &mut Server| { &mut m.steam_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "revision",
                |m: &Server| { &m.revision },
                |m: &mut Server| { &mut m.revision },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "players",
                |m: &Server| { &m.players },
                |m: &mut Server| { &mut m.players },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_port",
                |m: &Server| { &m.game_port },
                |m: &mut Server| { &mut m.game_port },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sdr_popid",
                |m: &Server| { &m.sdr_popid },
                |m: &mut Server| { &mut m.sdr_popid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sdr_ping_location",
                |m: &Server| { &m.sdr_ping_location },
                |m: &mut Server| { &mut m.sdr_ping_location },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Server| { &m.flags },
                |m: &mut Server| { &mut m.flags },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &Server| { &m.app_id },
                |m: &mut Server| { &mut m.app_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_players",
                |m: &Server| { &m.max_players },
                |m: &mut Server| { &mut m.max_players },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bots",
                |m: &Server| { &m.bots },
                |m: &mut Server| { &mut m.bots },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "spectator_port",
                |m: &Server| { &m.spectator_port },
                |m: &mut Server| { &mut m.spectator_port },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "gamedir_str",
                |m: &Server| { &m.gamedir_str },
                |m: &mut Server| { &mut m.gamedir_str },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "gamedir_strindex",
                |m: &Server| { &m.gamedir_strindex },
                |m: &mut Server| { &mut m.gamedir_strindex },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "map_str",
                |m: &Server| { &m.map_str },
                |m: &mut Server| { &mut m.map_str },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "map_strindex",
                |m: &Server| { &m.map_strindex },
                |m: &mut Server| { &mut m.map_strindex },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_str",
                |m: &Server| { &m.name_str },
                |m: &mut Server| { &mut m.name_str },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_strindex",
                |m: &Server| { &m.name_strindex },
                |m: &mut Server| { &mut m.name_strindex },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_description_str",
                |m: &Server| { &m.game_description_str },
                |m: &mut Server| { &mut m.game_description_str },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_description_strindex",
                |m: &Server| { &m.game_description_strindex },
                |m: &mut Server| { &mut m.game_description_strindex },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "version_str",
                |m: &Server| { &m.version_str },
                |m: &mut Server| { &mut m.version_str },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "version_strindex",
                |m: &Server| { &m.version_strindex },
                |m: &mut Server| { &mut m.version_strindex },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "gametype_str",
                |m: &Server| { &m.gametype_str },
                |m: &mut Server| { &mut m.gametype_str },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "gametype_strindex",
                |m: &Server| { &m.gametype_strindex },
                |m: &mut Server| { &mut m.gametype_strindex },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "spectator_name_str",
                |m: &Server| { &m.spectator_name_str },
                |m: &mut Server| { &mut m.spectator_name_str },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "spectator_name_strindex",
                |m: &Server| { &m.spectator_name_strindex },
                |m: &mut Server| { &mut m.spectator_name_strindex },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Server>(
                "CMsgGMSClientServerQueryResponse.Server",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Server {
        const NAME: &'static str = "Server";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.deprecated_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.auth_players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.server_ip)?;
                    },
                    49 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    56 => {
                        self.revision = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    85 => {
                        self.sdr_popid = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    258 => {
                        self.sdr_ping_location = ::std::option::Option::Some(is.read_string()?);
                    },
                    88 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.bots = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.spectator_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    130 => {
                        self.gamedir_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    136 => {
                        self.gamedir_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    146 => {
                        self.map_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    152 => {
                        self.map_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    162 => {
                        self.name_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    168 => {
                        self.name_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    178 => {
                        self.game_description_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    184 => {
                        self.game_description_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    194 => {
                        self.version_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    200 => {
                        self.version_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    210 => {
                        self.gametype_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    216 => {
                        self.gametype_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    242 => {
                        self.spectator_name_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    248 => {
                        self.spectator_name_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.deprecated_server_ip {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.query_port {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.auth_players {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.server_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.revision {
                my_size += crate::rt::uint32_size(7, v);
            }
            if let Some(v) = self.players {
                my_size += crate::rt::uint32_size(8, v);
            }
            if let Some(v) = self.game_port {
                my_size += crate::rt::uint32_size(9, v);
            }
            if let Some(v) = self.sdr_popid {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sdr_ping_location.as_ref() {
                my_size += crate::rt::string_size(32, &v);
            }
            if let Some(v) = self.flags {
                my_size += crate::rt::uint32_size(11, v);
            }
            if let Some(v) = self.app_id {
                my_size += crate::rt::uint32_size(12, v);
            }
            if let Some(v) = self.max_players {
                my_size += crate::rt::uint32_size(13, v);
            }
            if let Some(v) = self.bots {
                my_size += crate::rt::uint32_size(14, v);
            }
            if let Some(v) = self.spectator_port {
                my_size += crate::rt::uint32_size(15, v);
            }
            if let Some(v) = self.gamedir_str.as_ref() {
                my_size += crate::rt::string_size(16, &v);
            }
            if let Some(v) = self.gamedir_strindex {
                my_size += crate::rt::uint32_size(17, v);
            }
            if let Some(v) = self.map_str.as_ref() {
                my_size += crate::rt::string_size(18, &v);
            }
            if let Some(v) = self.map_strindex {
                my_size += crate::rt::uint32_size(19, v);
            }
            if let Some(v) = self.name_str.as_ref() {
                my_size += crate::rt::string_size(20, &v);
            }
            if let Some(v) = self.name_strindex {
                my_size += crate::rt::uint32_size(21, v);
            }
            if let Some(v) = self.game_description_str.as_ref() {
                my_size += crate::rt::string_size(22, &v);
            }
            if let Some(v) = self.game_description_strindex {
                my_size += crate::rt::uint32_size(23, v);
            }
            if let Some(v) = self.version_str.as_ref() {
                my_size += crate::rt::string_size(24, &v);
            }
            if let Some(v) = self.version_strindex {
                my_size += crate::rt::uint32_size(25, v);
            }
            if let Some(v) = self.gametype_str.as_ref() {
                my_size += crate::rt::string_size(26, &v);
            }
            if let Some(v) = self.gametype_strindex {
                my_size += crate::rt::uint32_size(27, v);
            }
            if let Some(v) = self.spectator_name_str.as_ref() {
                my_size += crate::rt::string_size(30, &v);
            }
            if let Some(v) = self.spectator_name_strindex {
                my_size += crate::rt::uint32_size(31, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.deprecated_server_ip {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.query_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.auth_players {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.server_ip.as_ref() {
                crate::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.steam_id {
                os.write_fixed64(6, v)?;
            }
            if let Some(v) = self.revision {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.players {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.game_port {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.sdr_popid {
                os.write_fixed32(10, v)?;
            }
            if let Some(v) = self.sdr_ping_location.as_ref() {
                os.write_string(32, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.max_players {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.bots {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.spectator_port {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.gamedir_str.as_ref() {
                os.write_string(16, v)?;
            }
            if let Some(v) = self.gamedir_strindex {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.map_str.as_ref() {
                os.write_string(18, v)?;
            }
            if let Some(v) = self.map_strindex {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.name_str.as_ref() {
                os.write_string(20, v)?;
            }
            if let Some(v) = self.name_strindex {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.game_description_str.as_ref() {
                os.write_string(22, v)?;
            }
            if let Some(v) = self.game_description_strindex {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.version_str.as_ref() {
                os.write_string(24, v)?;
            }
            if let Some(v) = self.version_strindex {
                os.write_uint32(25, v)?;
            }
            if let Some(v) = self.gametype_str.as_ref() {
                os.write_string(26, v)?;
            }
            if let Some(v) = self.gametype_strindex {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.spectator_name_str.as_ref() {
                os.write_string(30, v)?;
            }
            if let Some(v) = self.spectator_name_strindex {
                os.write_uint32(31, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server {
            Server::new()
        }

        fn clear(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
            self.query_port = ::std::option::Option::None;
            self.auth_players = ::std::option::Option::None;
            self.server_ip.clear();
            self.steam_id = ::std::option::Option::None;
            self.revision = ::std::option::Option::None;
            self.players = ::std::option::Option::None;
            self.game_port = ::std::option::Option::None;
            self.sdr_popid = ::std::option::Option::None;
            self.sdr_ping_location = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.max_players = ::std::option::Option::None;
            self.bots = ::std::option::Option::None;
            self.spectator_port = ::std::option::Option::None;
            self.gamedir_str = ::std::option::Option::None;
            self.gamedir_strindex = ::std::option::Option::None;
            self.map_str = ::std::option::Option::None;
            self.map_strindex = ::std::option::Option::None;
            self.name_str = ::std::option::Option::None;
            self.name_strindex = ::std::option::Option::None;
            self.game_description_str = ::std::option::Option::None;
            self.game_description_strindex = ::std::option::Option::None;
            self.version_str = ::std::option::Option::None;
            self.version_strindex = ::std::option::Option::None;
            self.gametype_str = ::std::option::Option::None;
            self.gametype_strindex = ::std::option::Option::None;
            self.spectator_name_str = ::std::option::Option::None;
            self.spectator_name_strindex = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server {
            static instance: Server = Server {
                deprecated_server_ip: ::std::option::Option::None,
                query_port: ::std::option::Option::None,
                auth_players: ::std::option::Option::None,
                server_ip: crate::MessageField::none(),
                steam_id: ::std::option::Option::None,
                revision: ::std::option::Option::None,
                players: ::std::option::Option::None,
                game_port: ::std::option::Option::None,
                sdr_popid: ::std::option::Option::None,
                sdr_ping_location: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                max_players: ::std::option::Option::None,
                bots: ::std::option::Option::None,
                spectator_port: ::std::option::Option::None,
                gamedir_str: ::std::option::Option::None,
                gamedir_strindex: ::std::option::Option::None,
                map_str: ::std::option::Option::None,
                map_strindex: ::std::option::Option::None,
                name_str: ::std::option::Option::None,
                name_strindex: ::std::option::Option::None,
                game_description_str: ::std::option::Option::None,
                game_description_strindex: ::std::option::Option::None,
                version_str: ::std::option::Option::None,
                version_strindex: ::std::option::Option::None,
                gametype_str: ::std::option::Option::None,
                gametype_strindex: ::std::option::Option::None,
                spectator_name_str: ::std::option::Option::None,
                spectator_name_strindex: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Server {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGMSClientServerQueryResponse.Server").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Server {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Server {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGMSClientServerQueryResponse.EFlags)
    pub enum EFlags {
        // @@protoc_insertion_point(enum_value:CMsgGMSClientServerQueryResponse.EFlags.k_EFlag_HasPassword)
        k_EFlag_HasPassword = 1,
        // @@protoc_insertion_point(enum_value:CMsgGMSClientServerQueryResponse.EFlags.k_EFlag_Secure)
        k_EFlag_Secure = 2,
    }

    impl crate::Enum for EFlags {
        const NAME: &'static str = "EFlags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EFlags> {
            match value {
                1 => ::std::option::Option::Some(EFlags::k_EFlag_HasPassword),
                2 => ::std::option::Option::Some(EFlags::k_EFlag_Secure),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EFlags> {
            match str {
                "k_EFlag_HasPassword" => ::std::option::Option::Some(EFlags::k_EFlag_HasPassword),
                "k_EFlag_Secure" => ::std::option::Option::Some(EFlags::k_EFlag_Secure),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EFlags] = &[
            EFlags::k_EFlag_HasPassword,
            EFlags::k_EFlag_Secure,
        ];
    }

    impl crate::EnumFull for EFlags {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGMSClientServerQueryResponse.EFlags").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = match self {
                EFlags::k_EFlag_HasPassword => 0,
                EFlags::k_EFlag_Secure => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EFlags {
        fn default() -> Self {
            EFlags::k_EFlag_HasPassword
        }
    }

    impl EFlags {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<EFlags>("CMsgGMSClientServerQueryResponse.EFlags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameServerOutOfDate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerOutOfDate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.steam_id_gs)
    pub steam_id_gs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.reject)
    pub reject: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerOutOfDate.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerOutOfDate {
    fn default() -> &'a CMsgGameServerOutOfDate {
        <CMsgGameServerOutOfDate as crate::Message>::default_instance()
    }
}

impl CMsgGameServerOutOfDate {
    pub fn new() -> CMsgGameServerOutOfDate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_gs = 1;

    pub fn steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }

    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional bool reject = 2;

    pub fn reject(&self) -> bool {
        self.reject.unwrap_or(false)
    }

    pub fn clear_reject(&mut self) {
        self.reject = ::std::option::Option::None;
    }

    pub fn has_reject(&self) -> bool {
        self.reject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reject(&mut self, v: bool) {
        self.reject = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_gs",
            |m: &CMsgGameServerOutOfDate| { &m.steam_id_gs },
            |m: &mut CMsgGameServerOutOfDate| { &mut m.steam_id_gs },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reject",
            |m: &CMsgGameServerOutOfDate| { &m.reject },
            |m: &mut CMsgGameServerOutOfDate| { &mut m.reject },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgGameServerOutOfDate| { &m.message },
            |m: &mut CMsgGameServerOutOfDate| { &mut m.message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerOutOfDate>(
            "CMsgGameServerOutOfDate",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGameServerOutOfDate {
    const NAME: &'static str = "CMsgGameServerOutOfDate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.reject = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reject {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.reject {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerOutOfDate {
        CMsgGameServerOutOfDate::new()
    }

    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.reject = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerOutOfDate {
        static instance: CMsgGameServerOutOfDate = CMsgGameServerOutOfDate {
            steam_id_gs: ::std::option::Option::None,
            reject: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGameServerOutOfDate {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerOutOfDate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerOutOfDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGameServerOutOfDate {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSAssociateWithClan)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSAssociateWithClan {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClan.steam_id_clan)
    pub steam_id_clan: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSAssociateWithClan.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClan {
    fn default() -> &'a CMsgGSAssociateWithClan {
        <CMsgGSAssociateWithClan as crate::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClan {
    pub fn new() -> CMsgGSAssociateWithClan {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_clan",
            |m: &CMsgGSAssociateWithClan| { &m.steam_id_clan },
            |m: &mut CMsgGSAssociateWithClan| { &mut m.steam_id_clan },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSAssociateWithClan>(
            "CMsgGSAssociateWithClan",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSAssociateWithClan {
    const NAME: &'static str = "CMsgGSAssociateWithClan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSAssociateWithClan {
        CMsgGSAssociateWithClan::new()
    }

    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClan {
        static instance: CMsgGSAssociateWithClan = CMsgGSAssociateWithClan {
            steam_id_clan: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSAssociateWithClan {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSAssociateWithClan").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSAssociateWithClan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSAssociateWithClan {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSAssociateWithClanResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSAssociateWithClanResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClanResponse.steam_id_clan)
    pub steam_id_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClanResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSAssociateWithClanResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClanResponse {
    fn default() -> &'a CMsgGSAssociateWithClanResponse {
        <CMsgGSAssociateWithClanResponse as crate::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClanResponse {
    pub fn new() -> CMsgGSAssociateWithClanResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_clan",
            |m: &CMsgGSAssociateWithClanResponse| { &m.steam_id_clan },
            |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.steam_id_clan },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgGSAssociateWithClanResponse| { &m.eresult },
            |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSAssociateWithClanResponse>(
            "CMsgGSAssociateWithClanResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSAssociateWithClanResponse {
    const NAME: &'static str = "CMsgGSAssociateWithClanResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSAssociateWithClanResponse {
        CMsgGSAssociateWithClanResponse::new()
    }

    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClanResponse {
        static instance: CMsgGSAssociateWithClanResponse = CMsgGSAssociateWithClanResponse {
            steam_id_clan: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSAssociateWithClanResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSAssociateWithClanResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSAssociateWithClanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSAssociateWithClanResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSComputeNewPlayerCompatibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSComputeNewPlayerCompatibility {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibility.steam_id_candidate)
    pub steam_id_candidate: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSComputeNewPlayerCompatibility.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibility {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibility {
        <CMsgGSComputeNewPlayerCompatibility as crate::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibility {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibility {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_candidate",
            |m: &CMsgGSComputeNewPlayerCompatibility| { &m.steam_id_candidate },
            |m: &mut CMsgGSComputeNewPlayerCompatibility| { &mut m.steam_id_candidate },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSComputeNewPlayerCompatibility>(
            "CMsgGSComputeNewPlayerCompatibility",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSComputeNewPlayerCompatibility {
    const NAME: &'static str = "CMsgGSComputeNewPlayerCompatibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibility {
        CMsgGSComputeNewPlayerCompatibility::new()
    }

    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibility {
        static instance: CMsgGSComputeNewPlayerCompatibility = CMsgGSComputeNewPlayerCompatibility {
            steam_id_candidate: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSComputeNewPlayerCompatibility {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSComputeNewPlayerCompatibility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSComputeNewPlayerCompatibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibility {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSComputeNewPlayerCompatibilityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSComputeNewPlayerCompatibilityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.steam_id_candidate)
    pub steam_id_candidate: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.is_clan_member)
    pub is_clan_member: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_dont_like_you)
    pub ct_dont_like_you: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_you_dont_like)
    pub ct_you_dont_like: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_clanmembers_dont_like_you)
    pub ct_clanmembers_dont_like_you: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSComputeNewPlayerCompatibilityResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibilityResponse {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibilityResponse {
        <CMsgGSComputeNewPlayerCompatibilityResponse as crate::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibilityResponse {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_clan_member = 3;

    pub fn is_clan_member(&self) -> bool {
        self.is_clan_member.unwrap_or(false)
    }

    pub fn clear_is_clan_member(&mut self) {
        self.is_clan_member = ::std::option::Option::None;
    }

    pub fn has_is_clan_member(&self) -> bool {
        self.is_clan_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_clan_member(&mut self, v: bool) {
        self.is_clan_member = ::std::option::Option::Some(v);
    }

    // optional int32 ct_dont_like_you = 4;

    pub fn ct_dont_like_you(&self) -> i32 {
        self.ct_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_dont_like_you(&mut self) {
        self.ct_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_dont_like_you(&self) -> bool {
        self.ct_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_dont_like_you(&mut self, v: i32) {
        self.ct_dont_like_you = ::std::option::Option::Some(v);
    }

    // optional int32 ct_you_dont_like = 5;

    pub fn ct_you_dont_like(&self) -> i32 {
        self.ct_you_dont_like.unwrap_or(0)
    }

    pub fn clear_ct_you_dont_like(&mut self) {
        self.ct_you_dont_like = ::std::option::Option::None;
    }

    pub fn has_ct_you_dont_like(&self) -> bool {
        self.ct_you_dont_like.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_you_dont_like(&mut self, v: i32) {
        self.ct_you_dont_like = ::std::option::Option::Some(v);
    }

    // optional int32 ct_clanmembers_dont_like_you = 6;

    pub fn ct_clanmembers_dont_like_you(&self) -> i32 {
        self.ct_clanmembers_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_clanmembers_dont_like_you(&mut self) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_clanmembers_dont_like_you(&self) -> bool {
        self.ct_clanmembers_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_clanmembers_dont_like_you(&mut self, v: i32) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_candidate",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.steam_id_candidate },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.steam_id_candidate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.eresult },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_clan_member",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.is_clan_member },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.is_clan_member },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_dont_like_you",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_dont_like_you },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_dont_like_you },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_you_dont_like",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_you_dont_like },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_you_dont_like },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_clanmembers_dont_like_you",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_clanmembers_dont_like_you },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_clanmembers_dont_like_you },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSComputeNewPlayerCompatibilityResponse>(
            "CMsgGSComputeNewPlayerCompatibilityResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGSComputeNewPlayerCompatibilityResponse {
    const NAME: &'static str = "CMsgGSComputeNewPlayerCompatibilityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_clan_member = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ct_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.ct_you_dont_like = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_clan_member {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ct_dont_like_you {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.ct_you_dont_like {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            my_size += crate::rt::int32_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_clan_member {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ct_dont_like_you {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ct_you_dont_like {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        CMsgGSComputeNewPlayerCompatibilityResponse::new()
    }

    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.is_clan_member = ::std::option::Option::None;
        self.ct_dont_like_you = ::std::option::Option::None;
        self.ct_you_dont_like = ::std::option::Option::None;
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibilityResponse {
        static instance: CMsgGSComputeNewPlayerCompatibilityResponse = CMsgGSComputeNewPlayerCompatibilityResponse {
            steam_id_candidate: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            is_clan_member: ::std::option::Option::None,
            ct_dont_like_you: ::std::option::Option::None,
            ct_you_dont_like: ::std::option::Option::None,
            ct_clanmembers_dont_like_you: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSComputeNewPlayerCompatibilityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibilityResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,steammessages_clientserver_gameservers.proto\x1a\x18steammessages_bas\
    e.proto\"\xea\x02\n\x10CMsgGSServerType\x12\"\n\rapp_id_served\x18\x01\
    \x20\x01(\rR\x0bappIdServed\x12\x14\n\x05flags\x18\x02\x20\x01(\rR\x05fl\
    ags\x12;\n\x1adeprecated_game_ip_address\x18\x03\x20\x01(\rR\x17deprecat\
    edGameIpAddress\x12\x1b\n\tgame_port\x18\x04\x20\x01(\rR\x08gamePort\x12\
    \x19\n\x08game_dir\x18\x05\x20\x01(\tR\x07gameDir\x12!\n\x0cgame_version\
    \x18\x06\x20\x01(\tR\x0bgameVersion\x12&\n\x0fgame_query_port\x18\x07\
    \x20\x01(\rR\rgameQueryPort\x12&\n\x0fgame_port_local\x18\n\x20\x01(\rR\
    \rgamePortLocal\x12\x1b\n\tsdr_logon\x18\x08\x20\x01(\x0cR\x08sdrLogon\
    \x12\x17\n\x07fake_ip\x18\t\x20\x01(\x07R\x06fakeIp\"0\n\x11CMsgGSStatus\
    Reply\x12\x1b\n\tis_secure\x18\x01\x20\x01(\x08R\x08isSecure\"\xe1\x01\n\
    \x10CMsgGSPlayerList\x122\n\x07players\x18\x01\x20\x03(\x0b2\x18.CMsgGSP\
    layerList.PlayerR\x07players\x1a\x98\x01\n\x06Player\x12\x19\n\x08steam_\
    id\x18\x01\x20\x01(\x04R\x07steamId\x120\n\x14deprecated_public_ip\x18\
    \x02\x20\x01(\rR\x12deprecatedPublicIp\x12\x14\n\x05token\x18\x03\x20\
    \x01(\x0cR\x05token\x12+\n\tpublic_ip\x18\x04\x20\x01(\x0b2\x0e.CMsgIPAd\
    dressR\x08publicIp\"\xa3\x01\n\x11CMsgGSUserPlaying\x12\x19\n\x08steam_i\
    d\x18\x01\x20\x01(\x06R\x07steamId\x120\n\x14deprecated_public_ip\x18\
    \x02\x20\x01(\rR\x12deprecatedPublicIp\x12\x14\n\x05token\x18\x03\x20\
    \x01(\x0cR\x05token\x12+\n\tpublic_ip\x18\x04\x20\x01(\x0b2\x0e.CMsgIPAd\
    dressR\x08publicIp\"3\n\x16CMsgGSDisconnectNotice\x12\x19\n\x08steam_id\
    \x18\x01\x20\x01(\x06R\x07steamId\"\x9c\x06\n\x12CMsgGameServerData\x12\
    \x1a\n\x08revision\x18\x18\x20\x01(\rR\x08revision\x12\x1d\n\nquery_port\
    \x18\x03\x20\x01(\rR\tqueryPort\x12\x1b\n\tgame_port\x18\x04\x20\x01(\rR\
    \x08gamePort\x12%\n\x0espectator_port\x18\x05\x20\x01(\rR\rspectatorPort\
    \x12\x1f\n\x0bserver_name\x18\x16\x20\x01(\tR\nserverName\x12)\n\x10game\
    _description\x18\x1d\x20\x01(\tR\x0fgameDescription\x122\n\x15spectator_\
    server_name\x18\x1b\x20\x01(\tR\x13spectatorServerName\x12\x17\n\x07fake\
    _ip\x18\x1c\x20\x01(\x07R\x06fakeIp\x12*\n\x11sdr_ping_location\x18\x1e\
    \x20\x01(\tR\x0fsdrPingLocation\x12\x15\n\x06app_id\x18\x06\x20\x01(\rR\
    \x05appId\x12\x18\n\x07gamedir\x18\x07\x20\x01(\tR\x07gamedir\x12\x18\n\
    \x07version\x18\x08\x20\x01(\tR\x07version\x12\x18\n\x07product\x18\t\
    \x20\x01(\tR\x07product\x12\x16\n\x06region\x18\n\x20\x01(\tR\x06region\
    \x124\n\x07players\x18\x0b\x20\x03(\x0b2\x1a.CMsgGameServerData.PlayerR\
    \x07players\x12\x1f\n\x0bmax_players\x18\x0c\x20\x01(\rR\nmaxPlayers\x12\
    \x1b\n\tbot_count\x18\r\x20\x01(\rR\x08botCount\x12\x1a\n\x08password\
    \x18\x0e\x20\x01(\x08R\x08password\x12\x16\n\x06secure\x18\x0f\x20\x01(\
    \x08R\x06secure\x12\x1c\n\tdedicated\x18\x10\x20\x01(\x08R\tdedicated\
    \x12\x0e\n\x02os\x18\x11\x20\x01(\tR\x02os\x12\x1b\n\tgame_data\x18\x12\
    \x20\x01(\tR\x08gameData\x12\x1b\n\tgame_type\x18\x14\x20\x01(\tR\x08gam\
    eType\x12\x10\n\x03map\x18\x15\x20\x01(\tR\x03map\x1a#\n\x06Player\x12\
    \x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"o\n\x14CMsgGameServ\
    erRemove\x12+\n\x12legacy_steam_id_gs\x18\x01\x20\x01(\x06R\x0flegacySte\
    amIdGs\x12*\n\x11legacy_query_port\x18\x03\x20\x01(\rR\x0flegacyQueryPor\
    t\"\xbc\x01\n\x18CMsgClientGMSServerQuery\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12&\n\x0fgeo_location_ip\x18\x02\x20\x01(\rR\rgeo\
    LocationIp\x12\x1f\n\x0bregion_code\x18\x03\x20\x01(\rR\nregionCode\x12\
    \x1f\n\x0bfilter_text\x18\x04\x20\x01(\tR\nfilterText\x12\x1f\n\x0bmax_s\
    ervers\x18\x05\x20\x01(\rR\nmaxServers\"\xd8\n\n\x20CMsgGMSClientServerQ\
    ueryResponse\x12B\n\x07servers\x18\x01\x20\x03(\x0b2(.CMsgGMSClientServe\
    rQueryResponse.ServerR\x07servers\x12\x14\n\x05error\x18\x02\x20\x01(\tR\
    \x05error\x12X\n\x13default_server_data\x18\x03\x20\x01(\x0b2(.CMsgGMSCl\
    ientServerQueryResponse.ServerR\x11defaultServerData\x12%\n\x0eserver_st\
    rings\x18\x04\x20\x03(\tR\rserverStrings\x1a\xa1\x08\n\x06Server\x120\n\
    \x14deprecated_server_ip\x18\x01\x20\x01(\rR\x12deprecatedServerIp\x12\
    \x1d\n\nquery_port\x18\x02\x20\x01(\rR\tqueryPort\x12!\n\x0cauth_players\
    \x18\x03\x20\x01(\rR\x0bauthPlayers\x12+\n\tserver_ip\x18\x04\x20\x01(\
    \x0b2\x0e.CMsgIPAddressR\x08serverIp\x12\x19\n\x08steam_id\x18\x06\x20\
    \x01(\x06R\x07steamId\x12\x1a\n\x08revision\x18\x07\x20\x01(\rR\x08revis\
    ion\x12\x18\n\x07players\x18\x08\x20\x01(\rR\x07players\x12\x1b\n\tgame_\
    port\x18\t\x20\x01(\rR\x08gamePort\x12\x1b\n\tsdr_popid\x18\n\x20\x01(\
    \x07R\x08sdrPopid\x12*\n\x11sdr_ping_location\x18\x20\x20\x01(\tR\x0fsdr\
    PingLocation\x12\x14\n\x05flags\x18\x0b\x20\x01(\rR\x05flags\x12\x15\n\
    \x06app_id\x18\x0c\x20\x01(\rR\x05appId\x12\x1f\n\x0bmax_players\x18\r\
    \x20\x01(\rR\nmaxPlayers\x12\x12\n\x04bots\x18\x0e\x20\x01(\rR\x04bots\
    \x12%\n\x0espectator_port\x18\x0f\x20\x01(\rR\rspectatorPort\x12\x1f\n\
    \x0bgamedir_str\x18\x10\x20\x01(\tR\ngamedirStr\x12)\n\x10gamedir_strind\
    ex\x18\x11\x20\x01(\rR\x0fgamedirStrindex\x12\x17\n\x07map_str\x18\x12\
    \x20\x01(\tR\x06mapStr\x12!\n\x0cmap_strindex\x18\x13\x20\x01(\rR\x0bmap\
    Strindex\x12\x19\n\x08name_str\x18\x14\x20\x01(\tR\x07nameStr\x12#\n\rna\
    me_strindex\x18\x15\x20\x01(\rR\x0cnameStrindex\x120\n\x14game_descripti\
    on_str\x18\x16\x20\x01(\tR\x12gameDescriptionStr\x12:\n\x19game_descript\
    ion_strindex\x18\x17\x20\x01(\rR\x17gameDescriptionStrindex\x12\x1f\n\
    \x0bversion_str\x18\x18\x20\x01(\tR\nversionStr\x12)\n\x10version_strind\
    ex\x18\x19\x20\x01(\rR\x0fversionStrindex\x12!\n\x0cgametype_str\x18\x1a\
    \x20\x01(\tR\x0bgametypeStr\x12+\n\x11gametype_strindex\x18\x1b\x20\x01(\
    \rR\x10gametypeStrindex\x12,\n\x12spectator_name_str\x18\x1e\x20\x01(\tR\
    \x10spectatorNameStr\x126\n\x17spectator_name_strindex\x18\x1f\x20\x01(\
    \rR\x15spectatorNameStrindex\"5\n\x06EFlags\x12\x17\n\x13k_EFlag_HasPass\
    word\x10\x01\x12\x12\n\x0ek_EFlag_Secure\x10\x02\"k\n\x17CMsgGameServerO\
    utOfDate\x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\x01(\x06R\tsteamIdGs\x12\
    \x16\n\x06reject\x18\x02\x20\x01(\x08R\x06reject\x12\x18\n\x07message\
    \x18\x03\x20\x01(\tR\x07message\"=\n\x17CMsgGSAssociateWithClan\x12\"\n\
    \rsteam_id_clan\x18\x01\x20\x01(\x06R\x0bsteamIdClan\"b\n\x1fCMsgGSAssoc\
    iateWithClanResponse\x12\"\n\rsteam_id_clan\x18\x01\x20\x01(\x06R\x0bste\
    amIdClan\x12\x1b\n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07eresult\"S\n#\
    CMsgGSComputeNewPlayerCompatibility\x12,\n\x12steam_id_candidate\x18\x01\
    \x20\x01(\x06R\x10steamIdCandidate\"\xb0\x02\n+CMsgGSComputeNewPlayerCom\
    patibilityResponse\x12,\n\x12steam_id_candidate\x18\x01\x20\x01(\x06R\
    \x10steamIdCandidate\x12\x1b\n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07e\
    result\x12$\n\x0eis_clan_member\x18\x03\x20\x01(\x08R\x0cisClanMember\
    \x12'\n\x10ct_dont_like_you\x18\x04\x20\x01(\x05R\rctDontLikeYou\x12'\n\
    \x10ct_you_dont_like\x18\x05\x20\x01(\x05R\rctYouDontLike\x12>\n\x1cct_c\
    lanmembers_dont_like_you\x18\x06\x20\x01(\x05R\x18ctClanmembersDontLikeY\
    ouB\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(CMsgGSServerType::generated_message_descriptor_data());
            messages.push(CMsgGSStatusReply::generated_message_descriptor_data());
            messages.push(CMsgGSPlayerList::generated_message_descriptor_data());
            messages.push(CMsgGSUserPlaying::generated_message_descriptor_data());
            messages.push(CMsgGSDisconnectNotice::generated_message_descriptor_data());
            messages.push(CMsgGameServerData::generated_message_descriptor_data());
            messages.push(CMsgGameServerRemove::generated_message_descriptor_data());
            messages.push(CMsgClientGMSServerQuery::generated_message_descriptor_data());
            messages.push(CMsgGMSClientServerQueryResponse::generated_message_descriptor_data());
            messages.push(CMsgGameServerOutOfDate::generated_message_descriptor_data());
            messages.push(CMsgGSAssociateWithClan::generated_message_descriptor_data());
            messages.push(CMsgGSAssociateWithClanResponse::generated_message_descriptor_data());
            messages.push(CMsgGSComputeNewPlayerCompatibility::generated_message_descriptor_data());
            messages.push(CMsgGSComputeNewPlayerCompatibilityResponse::generated_message_descriptor_data());
            messages.push(cmsg_gsplayer_list::Player::generated_message_descriptor_data());
            messages.push(cmsg_game_server_data::Player::generated_message_descriptor_data());
            messages.push(cmsg_gmsclient_server_query_response::Server::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(cmsg_gmsclient_server_query_response::EFlags::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
