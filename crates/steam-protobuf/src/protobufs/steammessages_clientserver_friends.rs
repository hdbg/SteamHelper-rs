// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_friends.proto`

// @@protoc_insertion_point(message:CMsgClientFriendMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.chat_entry_type)
    pub chat_entry_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.message)
    pub message: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.rtime32_server_timestamp)
    pub rtime32_server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.echo_to_sender)
    pub echo_to_sender: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsg {
    fn default() -> &'a CMsgClientFriendMsg {
        <CMsgClientFriendMsg as crate::Message>::default_instance()
    }
}

impl CMsgClientFriendMsg {
    pub fn new() -> CMsgClientFriendMsg {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;

    pub fn chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bytes message = 3;

    pub fn message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::bytes::Bytes) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::bytes::Bytes {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::bytes::Bytes {
        self.message.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed32 rtime32_server_timestamp = 4;

    pub fn rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool echo_to_sender = 5;

    pub fn echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }

    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientFriendMsg| { &m.steamid },
            |m: &mut CMsgClientFriendMsg| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_entry_type",
            |m: &CMsgClientFriendMsg| { &m.chat_entry_type },
            |m: &mut CMsgClientFriendMsg| { &mut m.chat_entry_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgClientFriendMsg| { &m.message },
            |m: &mut CMsgClientFriendMsg| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_server_timestamp",
            |m: &CMsgClientFriendMsg| { &m.rtime32_server_timestamp },
            |m: &mut CMsgClientFriendMsg| { &mut m.rtime32_server_timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "echo_to_sender",
            |m: &CMsgClientFriendMsg| { &m.echo_to_sender },
            |m: &mut CMsgClientFriendMsg| { &mut m.echo_to_sender },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendMsg>(
            "CMsgClientFriendMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFriendMsg {
    const NAME: &'static str = "CMsgClientFriendMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_entry_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                37 => {
                    self.rtime32_server_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.echo_to_sender = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendMsg {
        CMsgClientFriendMsg::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendMsg {
        static instance: CMsgClientFriendMsg = CMsgClientFriendMsg {
            steamid: ::std::option::Option::None,
            chat_entry_type: ::std::option::Option::None,
            message: ::std::option::Option::None,
            rtime32_server_timestamp: ::std::option::Option::None,
            echo_to_sender: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFriendMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFriendMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFriendMsgIncoming)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendMsgIncoming {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.steamid_from)
    pub steamid_from: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.chat_entry_type)
    pub chat_entry_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.from_limited_account)
    pub from_limited_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.message)
    pub message: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.rtime32_server_timestamp)
    pub rtime32_server_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendMsgIncoming.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsgIncoming {
    fn default() -> &'a CMsgClientFriendMsgIncoming {
        <CMsgClientFriendMsgIncoming as crate::Message>::default_instance()
    }
}

impl CMsgClientFriendMsgIncoming {
    pub fn new() -> CMsgClientFriendMsgIncoming {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_from = 1;

    pub fn steamid_from(&self) -> u64 {
        self.steamid_from.unwrap_or(0)
    }

    pub fn clear_steamid_from(&mut self) {
        self.steamid_from = ::std::option::Option::None;
    }

    pub fn has_steamid_from(&self) -> bool {
        self.steamid_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_from(&mut self, v: u64) {
        self.steamid_from = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;

    pub fn chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bool from_limited_account = 3;

    pub fn from_limited_account(&self) -> bool {
        self.from_limited_account.unwrap_or(false)
    }

    pub fn clear_from_limited_account(&mut self) {
        self.from_limited_account = ::std::option::Option::None;
    }

    pub fn has_from_limited_account(&self) -> bool {
        self.from_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_limited_account(&mut self, v: bool) {
        self.from_limited_account = ::std::option::Option::Some(v);
    }

    // optional bytes message = 4;

    pub fn message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::bytes::Bytes) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::bytes::Bytes {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::bytes::Bytes {
        self.message.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed32 rtime32_server_timestamp = 5;

    pub fn rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_from",
            |m: &CMsgClientFriendMsgIncoming| { &m.steamid_from },
            |m: &mut CMsgClientFriendMsgIncoming| { &mut m.steamid_from },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_entry_type",
            |m: &CMsgClientFriendMsgIncoming| { &m.chat_entry_type },
            |m: &mut CMsgClientFriendMsgIncoming| { &mut m.chat_entry_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_limited_account",
            |m: &CMsgClientFriendMsgIncoming| { &m.from_limited_account },
            |m: &mut CMsgClientFriendMsgIncoming| { &mut m.from_limited_account },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgClientFriendMsgIncoming| { &m.message },
            |m: &mut CMsgClientFriendMsgIncoming| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_server_timestamp",
            |m: &CMsgClientFriendMsgIncoming| { &m.rtime32_server_timestamp },
            |m: &mut CMsgClientFriendMsgIncoming| { &mut m.rtime32_server_timestamp },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendMsgIncoming>(
            "CMsgClientFriendMsgIncoming",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFriendMsgIncoming {
    const NAME: &'static str = "CMsgClientFriendMsgIncoming";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_from = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_entry_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_limited_account = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                45 => {
                    self.rtime32_server_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_from {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_limited_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_from {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_limited_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendMsgIncoming {
        CMsgClientFriendMsgIncoming::new()
    }

    fn clear(&mut self) {
        self.steamid_from = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.from_limited_account = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendMsgIncoming {
        static instance: CMsgClientFriendMsgIncoming = CMsgClientFriendMsgIncoming {
            steamid_from: ::std::option::Option::None,
            chat_entry_type: ::std::option::Option::None,
            from_limited_account: ::std::option::Option::None,
            message: ::std::option::Option::None,
            rtime32_server_timestamp: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFriendMsgIncoming {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendMsgIncoming").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendMsgIncoming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFriendMsgIncoming {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAddFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriend.steamid_to_add)
    pub steamid_to_add: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientAddFriend.accountname_or_email_to_add)
    pub accountname_or_email_to_add: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriend.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriend {
    fn default() -> &'a CMsgClientAddFriend {
        <CMsgClientAddFriend as crate::Message>::default_instance()
    }
}

impl CMsgClientAddFriend {
    pub fn new() -> CMsgClientAddFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_to_add = 1;

    pub fn steamid_to_add(&self) -> u64 {
        self.steamid_to_add.unwrap_or(0)
    }

    pub fn clear_steamid_to_add(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
    }

    pub fn has_steamid_to_add(&self) -> bool {
        self.steamid_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_add(&mut self, v: u64) {
        self.steamid_to_add = ::std::option::Option::Some(v);
    }

    // optional string accountname_or_email_to_add = 2;

    pub fn accountname_or_email_to_add(&self) -> &str {
        match self.accountname_or_email_to_add.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accountname_or_email_to_add(&mut self) {
        self.accountname_or_email_to_add = ::std::option::Option::None;
    }

    pub fn has_accountname_or_email_to_add(&self) -> bool {
        self.accountname_or_email_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountname_or_email_to_add(&mut self, v: ::std::string::String) {
        self.accountname_or_email_to_add = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountname_or_email_to_add(&mut self) -> &mut ::std::string::String {
        if self.accountname_or_email_to_add.is_none() {
            self.accountname_or_email_to_add = ::std::option::Option::Some(::std::string::String::new());
        }
        self.accountname_or_email_to_add.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountname_or_email_to_add(&mut self) -> ::std::string::String {
        self.accountname_or_email_to_add.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_to_add",
            |m: &CMsgClientAddFriend| { &m.steamid_to_add },
            |m: &mut CMsgClientAddFriend| { &mut m.steamid_to_add },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountname_or_email_to_add",
            |m: &CMsgClientAddFriend| { &m.accountname_or_email_to_add },
            |m: &mut CMsgClientAddFriend| { &mut m.accountname_or_email_to_add },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAddFriend>(
            "CMsgClientAddFriend",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAddFriend {
    const NAME: &'static str = "CMsgClientAddFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_to_add = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.accountname_or_email_to_add = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_to_add {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accountname_or_email_to_add.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_to_add {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.accountname_or_email_to_add.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriend {
        CMsgClientAddFriend::new()
    }

    fn clear(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
        self.accountname_or_email_to_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriend {
        static instance: CMsgClientAddFriend = CMsgClientAddFriend {
            steamid_to_add: ::std::option::Option::None,
            accountname_or_email_to_add: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAddFriend {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAddFriend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAddFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAddFriend {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAddFriendResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriendResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriendResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAddFriendResponse.steam_id_added)
    pub steam_id_added: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientAddFriendResponse.persona_name_added)
    pub persona_name_added: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriendResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendResponse {
    fn default() -> &'a CMsgClientAddFriendResponse {
        <CMsgClientAddFriendResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientAddFriendResponse {
    pub fn new() -> CMsgClientAddFriendResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_added = 2;

    pub fn steam_id_added(&self) -> u64 {
        self.steam_id_added.unwrap_or(0)
    }

    pub fn clear_steam_id_added(&mut self) {
        self.steam_id_added = ::std::option::Option::None;
    }

    pub fn has_steam_id_added(&self) -> bool {
        self.steam_id_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_added(&mut self, v: u64) {
        self.steam_id_added = ::std::option::Option::Some(v);
    }

    // optional string persona_name_added = 3;

    pub fn persona_name_added(&self) -> &str {
        match self.persona_name_added.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name_added(&mut self) {
        self.persona_name_added = ::std::option::Option::None;
    }

    pub fn has_persona_name_added(&self) -> bool {
        self.persona_name_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_added(&mut self, v: ::std::string::String) {
        self.persona_name_added = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_added(&mut self) -> &mut ::std::string::String {
        if self.persona_name_added.is_none() {
            self.persona_name_added = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name_added.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_added(&mut self) -> ::std::string::String {
        self.persona_name_added.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAddFriendResponse| { &m.eresult },
            |m: &mut CMsgClientAddFriendResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_added",
            |m: &CMsgClientAddFriendResponse| { &m.steam_id_added },
            |m: &mut CMsgClientAddFriendResponse| { &mut m.steam_id_added },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name_added",
            |m: &CMsgClientAddFriendResponse| { &m.persona_name_added },
            |m: &mut CMsgClientAddFriendResponse| { &mut m.persona_name_added },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAddFriendResponse>(
            "CMsgClientAddFriendResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAddFriendResponse {
    const NAME: &'static str = "CMsgClientAddFriendResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steam_id_added = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.persona_name_added = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.steam_id_added {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name_added.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steam_id_added {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.persona_name_added.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriendResponse {
        CMsgClientAddFriendResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steam_id_added = ::std::option::Option::None;
        self.persona_name_added = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriendResponse {
        static instance: CMsgClientAddFriendResponse = CMsgClientAddFriendResponse {
            eresult: ::std::option::Option::None,
            steam_id_added: ::std::option::Option::None,
            persona_name_added: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAddFriendResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAddFriendResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAddFriendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAddFriendResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRemoveFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRemoveFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRemoveFriend.friendid)
    pub friendid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRemoveFriend.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriend {
    fn default() -> &'a CMsgClientRemoveFriend {
        <CMsgClientRemoveFriend as crate::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriend {
    pub fn new() -> CMsgClientRemoveFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;

    pub fn friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "friendid",
            |m: &CMsgClientRemoveFriend| { &m.friendid },
            |m: &mut CMsgClientRemoveFriend| { &mut m.friendid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRemoveFriend>(
            "CMsgClientRemoveFriend",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRemoveFriend {
    const NAME: &'static str = "CMsgClientRemoveFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRemoveFriend {
        CMsgClientRemoveFriend::new()
    }

    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRemoveFriend {
        static instance: CMsgClientRemoveFriend = CMsgClientRemoveFriend {
            friendid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRemoveFriend {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRemoveFriend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRemoveFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRemoveFriend {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientHideFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientHideFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientHideFriend.friendid)
    pub friendid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientHideFriend.hide)
    pub hide: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientHideFriend.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHideFriend {
    fn default() -> &'a CMsgClientHideFriend {
        <CMsgClientHideFriend as crate::Message>::default_instance()
    }
}

impl CMsgClientHideFriend {
    pub fn new() -> CMsgClientHideFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;

    pub fn friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    // optional bool hide = 2;

    pub fn hide(&self) -> bool {
        self.hide.unwrap_or(false)
    }

    pub fn clear_hide(&mut self) {
        self.hide = ::std::option::Option::None;
    }

    pub fn has_hide(&self) -> bool {
        self.hide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide(&mut self, v: bool) {
        self.hide = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "friendid",
            |m: &CMsgClientHideFriend| { &m.friendid },
            |m: &mut CMsgClientHideFriend| { &mut m.friendid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hide",
            |m: &CMsgClientHideFriend| { &m.hide },
            |m: &mut CMsgClientHideFriend| { &mut m.hide },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientHideFriend>(
            "CMsgClientHideFriend",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientHideFriend {
    const NAME: &'static str = "CMsgClientHideFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.hide = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.hide {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hide {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHideFriend {
        CMsgClientHideFriend::new()
    }

    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.hide = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHideFriend {
        static instance: CMsgClientHideFriend = CMsgClientHideFriend {
            friendid: ::std::option::Option::None,
            hide: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientHideFriend {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientHideFriend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientHideFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientHideFriend {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFriendsList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendsList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendsList.bincremental)
    pub bincremental: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.friends)
    pub friends: ::std::vec::Vec<cmsg_client_friends_list::Friend>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.max_friend_count)
    pub max_friend_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.active_friend_count)
    pub active_friend_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.friends_limit_hit)
    pub friends_limit_hit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendsList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsList {
    fn default() -> &'a CMsgClientFriendsList {
        <CMsgClientFriendsList as crate::Message>::default_instance()
    }
}

impl CMsgClientFriendsList {
    pub fn new() -> CMsgClientFriendsList {
        ::std::default::Default::default()
    }

    // optional bool bincremental = 1;

    pub fn bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientFriendsList.Friend friends = 2;

    pub fn friends(&self) -> &[cmsg_client_friends_list::Friend] {
        &self.friends
    }

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::std::vec::Vec<cmsg_client_friends_list::Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::std::vec::Vec<cmsg_client_friends_list::Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::std::vec::Vec<cmsg_client_friends_list::Friend> {
        ::std::mem::replace(&mut self.friends, ::std::vec::Vec::new())
    }

    // optional uint32 max_friend_count = 3;

    pub fn max_friend_count(&self) -> u32 {
        self.max_friend_count.unwrap_or(0)
    }

    pub fn clear_max_friend_count(&mut self) {
        self.max_friend_count = ::std::option::Option::None;
    }

    pub fn has_max_friend_count(&self) -> bool {
        self.max_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_friend_count(&mut self, v: u32) {
        self.max_friend_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_friend_count = 4;

    pub fn active_friend_count(&self) -> u32 {
        self.active_friend_count.unwrap_or(0)
    }

    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }

    // optional bool friends_limit_hit = 5;

    pub fn friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.unwrap_or(false)
    }

    pub fn clear_friends_limit_hit(&mut self) {
        self.friends_limit_hit = ::std::option::Option::None;
    }

    pub fn has_friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_limit_hit(&mut self, v: bool) {
        self.friends_limit_hit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bincremental",
            |m: &CMsgClientFriendsList| { &m.bincremental },
            |m: &mut CMsgClientFriendsList| { &mut m.bincremental },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends",
            |m: &CMsgClientFriendsList| { &m.friends },
            |m: &mut CMsgClientFriendsList| { &mut m.friends },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_friend_count",
            |m: &CMsgClientFriendsList| { &m.max_friend_count },
            |m: &mut CMsgClientFriendsList| { &mut m.max_friend_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_friend_count",
            |m: &CMsgClientFriendsList| { &m.active_friend_count },
            |m: &mut CMsgClientFriendsList| { &mut m.active_friend_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "friends_limit_hit",
            |m: &CMsgClientFriendsList| { &m.friends_limit_hit },
            |m: &mut CMsgClientFriendsList| { &mut m.friends_limit_hit },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendsList>(
            "CMsgClientFriendsList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFriendsList {
    const NAME: &'static str = "CMsgClientFriendsList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bincremental = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.friends.push(is.read_message()?);
                },
                24 => {
                    self.max_friend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.active_friend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.friends_limit_hit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bincremental {
            my_size += 1 + 1;
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_friend_count {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.active_friend_count {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.friends_limit_hit {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.bincremental {
            os.write_bool(1, v)?;
        }
        for v in &self.friends {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.max_friend_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_friend_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.friends_limit_hit {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendsList {
        CMsgClientFriendsList::new()
    }

    fn clear(&mut self) {
        self.bincremental = ::std::option::Option::None;
        self.friends.clear();
        self.max_friend_count = ::std::option::Option::None;
        self.active_friend_count = ::std::option::Option::None;
        self.friends_limit_hit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendsList {
        static instance: CMsgClientFriendsList = CMsgClientFriendsList {
            bincremental: ::std::option::Option::None,
            friends: ::std::vec::Vec::new(),
            max_friend_count: ::std::option::Option::None,
            active_friend_count: ::std::option::Option::None,
            friends_limit_hit: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFriendsList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendsList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFriendsList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientFriendsList`
pub mod cmsg_client_friends_list {
    // @@protoc_insertion_point(message:CMsgClientFriendsList.Friend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Friend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFriendsList.Friend.ulfriendid)
        pub ulfriendid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientFriendsList.Friend.efriendrelationship)
        pub efriendrelationship: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFriendsList.Friend.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as crate::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional fixed64 ulfriendid = 1;

        pub fn ulfriendid(&self) -> u64 {
            self.ulfriendid.unwrap_or(0)
        }

        pub fn clear_ulfriendid(&mut self) {
            self.ulfriendid = ::std::option::Option::None;
        }

        pub fn has_ulfriendid(&self) -> bool {
            self.ulfriendid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ulfriendid(&mut self, v: u64) {
            self.ulfriendid = ::std::option::Option::Some(v);
        }

        // optional uint32 efriendrelationship = 2;

        pub fn efriendrelationship(&self) -> u32 {
            self.efriendrelationship.unwrap_or(0)
        }

        pub fn clear_efriendrelationship(&mut self) {
            self.efriendrelationship = ::std::option::Option::None;
        }

        pub fn has_efriendrelationship(&self) -> bool {
            self.efriendrelationship.is_some()
        }

        // Param is passed by value, moved
        pub fn set_efriendrelationship(&mut self, v: u32) {
            self.efriendrelationship = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ulfriendid",
                |m: &Friend| { &m.ulfriendid },
                |m: &mut Friend| { &mut m.ulfriendid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "efriendrelationship",
                |m: &Friend| { &m.efriendrelationship },
                |m: &mut Friend| { &mut m.efriendrelationship },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Friend>(
                "CMsgClientFriendsList.Friend",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Friend {
        const NAME: &'static str = "Friend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.ulfriendid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.efriendrelationship = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ulfriendid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.efriendrelationship {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.ulfriendid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.efriendrelationship {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn clear(&mut self) {
            self.ulfriendid = ::std::option::Option::None;
            self.efriendrelationship = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Friend {
            static instance: Friend = Friend {
                ulfriendid: ::std::option::Option::None,
                efriendrelationship: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Friend {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientFriendsList.Friend").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Friend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Friend {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendsGroupsList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendsGroupsList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.bremoval)
    pub bremoval: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.bincremental)
    pub bincremental: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.friendGroups)
    pub friendGroups: ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroup>,
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.memberships)
    pub memberships: ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroupsMembership>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendsGroupsList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsGroupsList {
    fn default() -> &'a CMsgClientFriendsGroupsList {
        <CMsgClientFriendsGroupsList as crate::Message>::default_instance()
    }
}

impl CMsgClientFriendsGroupsList {
    pub fn new() -> CMsgClientFriendsGroupsList {
        ::std::default::Default::default()
    }

    // optional bool bremoval = 1;

    pub fn bremoval(&self) -> bool {
        self.bremoval.unwrap_or(false)
    }

    pub fn clear_bremoval(&mut self) {
        self.bremoval = ::std::option::Option::None;
    }

    pub fn has_bremoval(&self) -> bool {
        self.bremoval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bremoval(&mut self, v: bool) {
        self.bremoval = ::std::option::Option::Some(v);
    }

    // optional bool bincremental = 2;

    pub fn bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientFriendsGroupsList.FriendGroup friendGroups = 3;

    pub fn friendGroups(&self) -> &[cmsg_client_friends_groups_list::FriendGroup] {
        &self.friendGroups
    }

    pub fn clear_friendGroups(&mut self) {
        self.friendGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_friendGroups(&mut self, v: ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroup>) {
        self.friendGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friendGroups(&mut self) -> &mut ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroup> {
        &mut self.friendGroups
    }

    // Take field
    pub fn take_friendGroups(&mut self) -> ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroup> {
        ::std::mem::replace(&mut self.friendGroups, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientFriendsGroupsList.FriendGroupsMembership memberships = 4;

    pub fn memberships(&self) -> &[cmsg_client_friends_groups_list::FriendGroupsMembership] {
        &self.memberships
    }

    pub fn clear_memberships(&mut self) {
        self.memberships.clear();
    }

    // Param is passed by value, moved
    pub fn set_memberships(&mut self, v: ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroupsMembership>) {
        self.memberships = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memberships(&mut self) -> &mut ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroupsMembership> {
        &mut self.memberships
    }

    // Take field
    pub fn take_memberships(&mut self) -> ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroupsMembership> {
        ::std::mem::replace(&mut self.memberships, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bremoval",
            |m: &CMsgClientFriendsGroupsList| { &m.bremoval },
            |m: &mut CMsgClientFriendsGroupsList| { &mut m.bremoval },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bincremental",
            |m: &CMsgClientFriendsGroupsList| { &m.bincremental },
            |m: &mut CMsgClientFriendsGroupsList| { &mut m.bincremental },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friendGroups",
            |m: &CMsgClientFriendsGroupsList| { &m.friendGroups },
            |m: &mut CMsgClientFriendsGroupsList| { &mut m.friendGroups },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memberships",
            |m: &CMsgClientFriendsGroupsList| { &m.memberships },
            |m: &mut CMsgClientFriendsGroupsList| { &mut m.memberships },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendsGroupsList>(
            "CMsgClientFriendsGroupsList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFriendsGroupsList {
    const NAME: &'static str = "CMsgClientFriendsGroupsList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bremoval = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bincremental = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.friendGroups.push(is.read_message()?);
                },
                34 => {
                    self.memberships.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bremoval {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bincremental {
            my_size += 1 + 1;
        }
        for value in &self.friendGroups {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.memberships {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.bremoval {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bincremental {
            os.write_bool(2, v)?;
        }
        for v in &self.friendGroups {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.memberships {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendsGroupsList {
        CMsgClientFriendsGroupsList::new()
    }

    fn clear(&mut self) {
        self.bremoval = ::std::option::Option::None;
        self.bincremental = ::std::option::Option::None;
        self.friendGroups.clear();
        self.memberships.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendsGroupsList {
        static instance: CMsgClientFriendsGroupsList = CMsgClientFriendsGroupsList {
            bremoval: ::std::option::Option::None,
            bincremental: ::std::option::Option::None,
            friendGroups: ::std::vec::Vec::new(),
            memberships: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFriendsGroupsList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendsGroupsList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendsGroupsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFriendsGroupsList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientFriendsGroupsList`
pub mod cmsg_client_friends_groups_list {
    // @@protoc_insertion_point(message:CMsgClientFriendsGroupsList.FriendGroup)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendGroup {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroup.nGroupID)
        pub nGroupID: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroup.strGroupName)
        pub strGroupName: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFriendsGroupsList.FriendGroup.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendGroup {
        fn default() -> &'a FriendGroup {
            <FriendGroup as crate::Message>::default_instance()
        }
    }

    impl FriendGroup {
        pub fn new() -> FriendGroup {
            ::std::default::Default::default()
        }

        // optional int32 nGroupID = 1;

        pub fn nGroupID(&self) -> i32 {
            self.nGroupID.unwrap_or(0)
        }

        pub fn clear_nGroupID(&mut self) {
            self.nGroupID = ::std::option::Option::None;
        }

        pub fn has_nGroupID(&self) -> bool {
            self.nGroupID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nGroupID(&mut self, v: i32) {
            self.nGroupID = ::std::option::Option::Some(v);
        }

        // optional string strGroupName = 2;

        pub fn strGroupName(&self) -> &str {
            match self.strGroupName.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_strGroupName(&mut self) {
            self.strGroupName = ::std::option::Option::None;
        }

        pub fn has_strGroupName(&self) -> bool {
            self.strGroupName.is_some()
        }

        // Param is passed by value, moved
        pub fn set_strGroupName(&mut self, v: ::std::string::String) {
            self.strGroupName = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_strGroupName(&mut self) -> &mut ::std::string::String {
            if self.strGroupName.is_none() {
                self.strGroupName = ::std::option::Option::Some(::std::string::String::new());
            }
            self.strGroupName.as_mut().unwrap()
        }

        // Take field
        pub fn take_strGroupName(&mut self) -> ::std::string::String {
            self.strGroupName.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "nGroupID",
                |m: &FriendGroup| { &m.nGroupID },
                |m: &mut FriendGroup| { &mut m.nGroupID },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "strGroupName",
                |m: &FriendGroup| { &m.strGroupName },
                |m: &mut FriendGroup| { &mut m.strGroupName },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<FriendGroup>(
                "CMsgClientFriendsGroupsList.FriendGroup",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for FriendGroup {
        const NAME: &'static str = "FriendGroup";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.nGroupID = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.strGroupName = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.nGroupID {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.strGroupName.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.nGroupID {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.strGroupName.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendGroup {
            FriendGroup::new()
        }

        fn clear(&mut self) {
            self.nGroupID = ::std::option::Option::None;
            self.strGroupName = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendGroup {
            static instance: FriendGroup = FriendGroup {
                nGroupID: ::std::option::Option::None,
                strGroupName: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for FriendGroup {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientFriendsGroupsList.FriendGroup").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FriendGroup {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for FriendGroup {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientFriendsGroupsList.FriendGroupsMembership)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendGroupsMembership {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroupsMembership.ulSteamID)
        pub ulSteamID: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroupsMembership.nGroupID)
        pub nGroupID: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFriendsGroupsList.FriendGroupsMembership.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendGroupsMembership {
        fn default() -> &'a FriendGroupsMembership {
            <FriendGroupsMembership as crate::Message>::default_instance()
        }
    }

    impl FriendGroupsMembership {
        pub fn new() -> FriendGroupsMembership {
            ::std::default::Default::default()
        }

        // optional fixed64 ulSteamID = 1;

        pub fn ulSteamID(&self) -> u64 {
            self.ulSteamID.unwrap_or(0)
        }

        pub fn clear_ulSteamID(&mut self) {
            self.ulSteamID = ::std::option::Option::None;
        }

        pub fn has_ulSteamID(&self) -> bool {
            self.ulSteamID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ulSteamID(&mut self, v: u64) {
            self.ulSteamID = ::std::option::Option::Some(v);
        }

        // optional int32 nGroupID = 2;

        pub fn nGroupID(&self) -> i32 {
            self.nGroupID.unwrap_or(0)
        }

        pub fn clear_nGroupID(&mut self) {
            self.nGroupID = ::std::option::Option::None;
        }

        pub fn has_nGroupID(&self) -> bool {
            self.nGroupID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nGroupID(&mut self, v: i32) {
            self.nGroupID = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ulSteamID",
                |m: &FriendGroupsMembership| { &m.ulSteamID },
                |m: &mut FriendGroupsMembership| { &mut m.ulSteamID },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "nGroupID",
                |m: &FriendGroupsMembership| { &m.nGroupID },
                |m: &mut FriendGroupsMembership| { &mut m.nGroupID },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<FriendGroupsMembership>(
                "CMsgClientFriendsGroupsList.FriendGroupsMembership",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for FriendGroupsMembership {
        const NAME: &'static str = "FriendGroupsMembership";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.ulSteamID = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.nGroupID = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ulSteamID {
                my_size += 1 + 8;
            }
            if let Some(v) = self.nGroupID {
                my_size += crate::rt::int32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.ulSteamID {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.nGroupID {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendGroupsMembership {
            FriendGroupsMembership::new()
        }

        fn clear(&mut self) {
            self.ulSteamID = ::std::option::Option::None;
            self.nGroupID = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendGroupsMembership {
            static instance: FriendGroupsMembership = FriendGroupsMembership {
                ulSteamID: ::std::option::Option::None,
                nGroupID: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for FriendGroupsMembership {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientFriendsGroupsList.FriendGroupsMembership").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FriendGroupsMembership {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for FriendGroupsMembership {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientPlayerNicknameList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPlayerNicknameList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.removal)
    pub removal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.incremental)
    pub incremental: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.nicknames)
    pub nicknames: ::std::vec::Vec<cmsg_client_player_nickname_list::PlayerNickname>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPlayerNicknameList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayerNicknameList {
    fn default() -> &'a CMsgClientPlayerNicknameList {
        <CMsgClientPlayerNicknameList as crate::Message>::default_instance()
    }
}

impl CMsgClientPlayerNicknameList {
    pub fn new() -> CMsgClientPlayerNicknameList {
        ::std::default::Default::default()
    }

    // optional bool removal = 1;

    pub fn removal(&self) -> bool {
        self.removal.unwrap_or(false)
    }

    pub fn clear_removal(&mut self) {
        self.removal = ::std::option::Option::None;
    }

    pub fn has_removal(&self) -> bool {
        self.removal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removal(&mut self, v: bool) {
        self.removal = ::std::option::Option::Some(v);
    }

    // optional bool incremental = 2;

    pub fn incremental(&self) -> bool {
        self.incremental.unwrap_or(false)
    }

    pub fn clear_incremental(&mut self) {
        self.incremental = ::std::option::Option::None;
    }

    pub fn has_incremental(&self) -> bool {
        self.incremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incremental(&mut self, v: bool) {
        self.incremental = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientPlayerNicknameList.PlayerNickname nicknames = 3;

    pub fn nicknames(&self) -> &[cmsg_client_player_nickname_list::PlayerNickname] {
        &self.nicknames
    }

    pub fn clear_nicknames(&mut self) {
        self.nicknames.clear();
    }

    // Param is passed by value, moved
    pub fn set_nicknames(&mut self, v: ::std::vec::Vec<cmsg_client_player_nickname_list::PlayerNickname>) {
        self.nicknames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nicknames(&mut self) -> &mut ::std::vec::Vec<cmsg_client_player_nickname_list::PlayerNickname> {
        &mut self.nicknames
    }

    // Take field
    pub fn take_nicknames(&mut self) -> ::std::vec::Vec<cmsg_client_player_nickname_list::PlayerNickname> {
        ::std::mem::replace(&mut self.nicknames, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "removal",
            |m: &CMsgClientPlayerNicknameList| { &m.removal },
            |m: &mut CMsgClientPlayerNicknameList| { &mut m.removal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "incremental",
            |m: &CMsgClientPlayerNicknameList| { &m.incremental },
            |m: &mut CMsgClientPlayerNicknameList| { &mut m.incremental },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nicknames",
            |m: &CMsgClientPlayerNicknameList| { &m.nicknames },
            |m: &mut CMsgClientPlayerNicknameList| { &mut m.nicknames },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPlayerNicknameList>(
            "CMsgClientPlayerNicknameList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientPlayerNicknameList {
    const NAME: &'static str = "CMsgClientPlayerNicknameList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.removal = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.incremental = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.nicknames.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.removal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.incremental {
            my_size += 1 + 1;
        }
        for value in &self.nicknames {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.removal {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.incremental {
            os.write_bool(2, v)?;
        }
        for v in &self.nicknames {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPlayerNicknameList {
        CMsgClientPlayerNicknameList::new()
    }

    fn clear(&mut self) {
        self.removal = ::std::option::Option::None;
        self.incremental = ::std::option::Option::None;
        self.nicknames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPlayerNicknameList {
        static instance: CMsgClientPlayerNicknameList = CMsgClientPlayerNicknameList {
            removal: ::std::option::Option::None,
            incremental: ::std::option::Option::None,
            nicknames: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientPlayerNicknameList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPlayerNicknameList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPlayerNicknameList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientPlayerNicknameList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientPlayerNicknameList`
pub mod cmsg_client_player_nickname_list {
    // @@protoc_insertion_point(message:CMsgClientPlayerNicknameList.PlayerNickname)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerNickname {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.PlayerNickname.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.PlayerNickname.nickname)
        pub nickname: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPlayerNicknameList.PlayerNickname.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerNickname {
        fn default() -> &'a PlayerNickname {
            <PlayerNickname as crate::Message>::default_instance()
        }
    }

    impl PlayerNickname {
        pub fn new() -> PlayerNickname {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string nickname = 3;

        pub fn nickname(&self) -> &str {
            match self.nickname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_nickname(&mut self) {
            self.nickname = ::std::option::Option::None;
        }

        pub fn has_nickname(&self) -> bool {
            self.nickname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nickname(&mut self, v: ::std::string::String) {
            self.nickname = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
            if self.nickname.is_none() {
                self.nickname = ::std::option::Option::Some(::std::string::String::new());
            }
            self.nickname.as_mut().unwrap()
        }

        // Take field
        pub fn take_nickname(&mut self) -> ::std::string::String {
            self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &PlayerNickname| { &m.steamid },
                |m: &mut PlayerNickname| { &mut m.steamid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "nickname",
                |m: &PlayerNickname| { &m.nickname },
                |m: &mut PlayerNickname| { &mut m.nickname },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PlayerNickname>(
                "CMsgClientPlayerNicknameList.PlayerNickname",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PlayerNickname {
        const NAME: &'static str = "PlayerNickname";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    26 => {
                        self.nickname = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.nickname.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.nickname.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerNickname {
            PlayerNickname::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.nickname = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerNickname {
            static instance: PlayerNickname = PlayerNickname {
                steamid: ::std::option::Option::None,
                nickname: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PlayerNickname {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPlayerNicknameList.PlayerNickname").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerNickname {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PlayerNickname {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientSetPlayerNickname)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetPlayerNickname {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetPlayerNickname.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientSetPlayerNickname.nickname)
    pub nickname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetPlayerNickname.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNickname {
    fn default() -> &'a CMsgClientSetPlayerNickname {
        <CMsgClientSetPlayerNickname as crate::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNickname {
    pub fn new() -> CMsgClientSetPlayerNickname {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;

    pub fn nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nickname(&mut self) {
        self.nickname = ::std::option::Option::None;
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientSetPlayerNickname| { &m.steamid },
            |m: &mut CMsgClientSetPlayerNickname| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nickname",
            |m: &CMsgClientSetPlayerNickname| { &m.nickname },
            |m: &mut CMsgClientSetPlayerNickname| { &mut m.nickname },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSetPlayerNickname>(
            "CMsgClientSetPlayerNickname",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSetPlayerNickname {
    const NAME: &'static str = "CMsgClientSetPlayerNickname";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.nickname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetPlayerNickname {
        CMsgClientSetPlayerNickname::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.nickname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNickname {
        static instance: CMsgClientSetPlayerNickname = CMsgClientSetPlayerNickname {
            steamid: ::std::option::Option::None,
            nickname: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSetPlayerNickname {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSetPlayerNickname").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSetPlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSetPlayerNickname {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSetPlayerNicknameResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetPlayerNicknameResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetPlayerNicknameResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetPlayerNicknameResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNicknameResponse {
    fn default() -> &'a CMsgClientSetPlayerNicknameResponse {
        <CMsgClientSetPlayerNicknameResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNicknameResponse {
    pub fn new() -> CMsgClientSetPlayerNicknameResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientSetPlayerNicknameResponse| { &m.eresult },
            |m: &mut CMsgClientSetPlayerNicknameResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSetPlayerNicknameResponse>(
            "CMsgClientSetPlayerNicknameResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientSetPlayerNicknameResponse {
    const NAME: &'static str = "CMsgClientSetPlayerNicknameResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetPlayerNicknameResponse {
        CMsgClientSetPlayerNicknameResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNicknameResponse {
        static instance: CMsgClientSetPlayerNicknameResponse = CMsgClientSetPlayerNicknameResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientSetPlayerNicknameResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSetPlayerNicknameResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSetPlayerNicknameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientSetPlayerNicknameResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestFriendData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFriendData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFriendData.persona_state_requested)
    pub persona_state_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFriendData.friends)
    pub friends: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFriendData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFriendData {
    fn default() -> &'a CMsgClientRequestFriendData {
        <CMsgClientRequestFriendData as crate::Message>::default_instance()
    }
}

impl CMsgClientRequestFriendData {
    pub fn new() -> CMsgClientRequestFriendData {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state_requested = 1;

    pub fn persona_state_requested(&self) -> u32 {
        self.persona_state_requested.unwrap_or(0)
    }

    pub fn clear_persona_state_requested(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
    }

    pub fn has_persona_state_requested(&self) -> bool {
        self.persona_state_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_requested(&mut self, v: u32) {
        self.persona_state_requested = ::std::option::Option::Some(v);
    }

    // repeated fixed64 friends = 2;

    pub fn friends(&self) -> &[u64] {
        &self.friends
    }

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::std::vec::Vec<u64>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.friends, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_state_requested",
            |m: &CMsgClientRequestFriendData| { &m.persona_state_requested },
            |m: &mut CMsgClientRequestFriendData| { &mut m.persona_state_requested },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends",
            |m: &CMsgClientRequestFriendData| { &m.friends },
            |m: &mut CMsgClientRequestFriendData| { &mut m.friends },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestFriendData>(
            "CMsgClientRequestFriendData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRequestFriendData {
    const NAME: &'static str = "CMsgClientRequestFriendData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.persona_state_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.friends)?;
                },
                17 => {
                    self.friends.push(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state_requested {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += 9 * self.friends.len() as u64;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.persona_state_requested {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFriendData {
        CMsgClientRequestFriendData::new()
    }

    fn clear(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFriendData {
        static instance: CMsgClientRequestFriendData = CMsgClientRequestFriendData {
            persona_state_requested: ::std::option::Option::None,
            friends: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRequestFriendData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestFriendData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRequestFriendData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientChangeStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChangeStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.persona_state)
    pub persona_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.is_auto_generated_name)
    pub is_auto_generated_name: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.high_priority)
    pub high_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.persona_set_by_user)
    pub persona_set_by_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.persona_state_flags)
    pub persona_state_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.need_persona_response)
    pub need_persona_response: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.is_client_idle)
    pub is_client_idle: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChangeStatus.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChangeStatus {
    fn default() -> &'a CMsgClientChangeStatus {
        <CMsgClientChangeStatus as crate::Message>::default_instance()
    }
}

impl CMsgClientChangeStatus {
    pub fn new() -> CMsgClientChangeStatus {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state = 1;

    pub fn persona_state(&self) -> u32 {
        self.persona_state.unwrap_or(0)
    }

    pub fn clear_persona_state(&mut self) {
        self.persona_state = ::std::option::Option::None;
    }

    pub fn has_persona_state(&self) -> bool {
        self.persona_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state(&mut self, v: u32) {
        self.persona_state = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_auto_generated_name = 3;

    pub fn is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.unwrap_or(false)
    }

    pub fn clear_is_auto_generated_name(&mut self) {
        self.is_auto_generated_name = ::std::option::Option::None;
    }

    pub fn has_is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_auto_generated_name(&mut self, v: bool) {
        self.is_auto_generated_name = ::std::option::Option::Some(v);
    }

    // optional bool high_priority = 4;

    pub fn high_priority(&self) -> bool {
        self.high_priority.unwrap_or(false)
    }

    pub fn clear_high_priority(&mut self) {
        self.high_priority = ::std::option::Option::None;
    }

    pub fn has_high_priority(&self) -> bool {
        self.high_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority(&mut self, v: bool) {
        self.high_priority = ::std::option::Option::Some(v);
    }

    // optional bool persona_set_by_user = 5;

    pub fn persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.unwrap_or(false)
    }

    pub fn clear_persona_set_by_user(&mut self) {
        self.persona_set_by_user = ::std::option::Option::None;
    }

    pub fn has_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_set_by_user(&mut self, v: bool) {
        self.persona_set_by_user = ::std::option::Option::Some(v);
    }

    // optional uint32 persona_state_flags = 6;

    pub fn persona_state_flags(&self) -> u32 {
        self.persona_state_flags.unwrap_or(0u32)
    }

    pub fn clear_persona_state_flags(&mut self) {
        self.persona_state_flags = ::std::option::Option::None;
    }

    pub fn has_persona_state_flags(&self) -> bool {
        self.persona_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_flags(&mut self, v: u32) {
        self.persona_state_flags = ::std::option::Option::Some(v);
    }

    // optional bool need_persona_response = 7;

    pub fn need_persona_response(&self) -> bool {
        self.need_persona_response.unwrap_or(false)
    }

    pub fn clear_need_persona_response(&mut self) {
        self.need_persona_response = ::std::option::Option::None;
    }

    pub fn has_need_persona_response(&self) -> bool {
        self.need_persona_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_persona_response(&mut self, v: bool) {
        self.need_persona_response = ::std::option::Option::Some(v);
    }

    // optional bool is_client_idle = 8;

    pub fn is_client_idle(&self) -> bool {
        self.is_client_idle.unwrap_or(false)
    }

    pub fn clear_is_client_idle(&mut self) {
        self.is_client_idle = ::std::option::Option::None;
    }

    pub fn has_is_client_idle(&self) -> bool {
        self.is_client_idle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_client_idle(&mut self, v: bool) {
        self.is_client_idle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_state",
            |m: &CMsgClientChangeStatus| { &m.persona_state },
            |m: &mut CMsgClientChangeStatus| { &mut m.persona_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_name",
            |m: &CMsgClientChangeStatus| { &m.player_name },
            |m: &mut CMsgClientChangeStatus| { &mut m.player_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_auto_generated_name",
            |m: &CMsgClientChangeStatus| { &m.is_auto_generated_name },
            |m: &mut CMsgClientChangeStatus| { &mut m.is_auto_generated_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_priority",
            |m: &CMsgClientChangeStatus| { &m.high_priority },
            |m: &mut CMsgClientChangeStatus| { &mut m.high_priority },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_set_by_user",
            |m: &CMsgClientChangeStatus| { &m.persona_set_by_user },
            |m: &mut CMsgClientChangeStatus| { &mut m.persona_set_by_user },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_state_flags",
            |m: &CMsgClientChangeStatus| { &m.persona_state_flags },
            |m: &mut CMsgClientChangeStatus| { &mut m.persona_state_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "need_persona_response",
            |m: &CMsgClientChangeStatus| { &m.need_persona_response },
            |m: &mut CMsgClientChangeStatus| { &mut m.need_persona_response },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_client_idle",
            |m: &CMsgClientChangeStatus| { &m.is_client_idle },
            |m: &mut CMsgClientChangeStatus| { &mut m.is_client_idle },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChangeStatus>(
            "CMsgClientChangeStatus",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientChangeStatus {
    const NAME: &'static str = "CMsgClientChangeStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.persona_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.is_auto_generated_name = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.high_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.persona_set_by_user = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.persona_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.need_persona_response = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.is_client_idle = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_auto_generated_name {
            my_size += 1 + 1;
        }
        if let Some(v) = self.high_priority {
            my_size += 1 + 1;
        }
        if let Some(v) = self.persona_set_by_user {
            my_size += 1 + 1;
        }
        if let Some(v) = self.persona_state_flags {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.need_persona_response {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_client_idle {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.persona_state {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_auto_generated_name {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.high_priority {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.persona_set_by_user {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.persona_state_flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.need_persona_response {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_client_idle {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChangeStatus {
        CMsgClientChangeStatus::new()
    }

    fn clear(&mut self) {
        self.persona_state = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.is_auto_generated_name = ::std::option::Option::None;
        self.high_priority = ::std::option::Option::None;
        self.persona_set_by_user = ::std::option::Option::None;
        self.persona_state_flags = ::std::option::Option::None;
        self.need_persona_response = ::std::option::Option::None;
        self.is_client_idle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChangeStatus {
        static instance: CMsgClientChangeStatus = CMsgClientChangeStatus {
            persona_state: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            is_auto_generated_name: ::std::option::Option::None,
            high_priority: ::std::option::Option::None,
            persona_set_by_user: ::std::option::Option::None,
            persona_state_flags: ::std::option::Option::None,
            need_persona_response: ::std::option::Option::None,
            is_client_idle: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientChangeStatus {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChangeStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChangeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientChangeStatus {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPersonaChangeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPersonaChangeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPersonaChangeResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPersonaChangeResponse.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPersonaChangeResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPersonaChangeResponse {
    fn default() -> &'a CMsgPersonaChangeResponse {
        <CMsgPersonaChangeResponse as crate::Message>::default_instance()
    }
}

impl CMsgPersonaChangeResponse {
    pub fn new() -> CMsgPersonaChangeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgPersonaChangeResponse| { &m.result },
            |m: &mut CMsgPersonaChangeResponse| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_name",
            |m: &CMsgPersonaChangeResponse| { &m.player_name },
            |m: &mut CMsgPersonaChangeResponse| { &mut m.player_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPersonaChangeResponse>(
            "CMsgPersonaChangeResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgPersonaChangeResponse {
    const NAME: &'static str = "CMsgPersonaChangeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPersonaChangeResponse {
        CMsgPersonaChangeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPersonaChangeResponse {
        static instance: CMsgPersonaChangeResponse = CMsgPersonaChangeResponse {
            result: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgPersonaChangeResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPersonaChangeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPersonaChangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgPersonaChangeResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPersonaState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPersonaState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPersonaState.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPersonaState.friends)
    pub friends: ::std::vec::Vec<cmsg_client_persona_state::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPersonaState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPersonaState {
    fn default() -> &'a CMsgClientPersonaState {
        <CMsgClientPersonaState as crate::Message>::default_instance()
    }
}

impl CMsgClientPersonaState {
    pub fn new() -> CMsgClientPersonaState {
        ::std::default::Default::default()
    }

    // optional uint32 status_flags = 1;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientPersonaState.Friend friends = 2;

    pub fn friends(&self) -> &[cmsg_client_persona_state::Friend] {
        &self.friends
    }

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::std::vec::Vec<cmsg_client_persona_state::Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::std::vec::Vec<cmsg_client_persona_state::Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::std::vec::Vec<cmsg_client_persona_state::Friend> {
        ::std::mem::replace(&mut self.friends, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_flags",
            |m: &CMsgClientPersonaState| { &m.status_flags },
            |m: &mut CMsgClientPersonaState| { &mut m.status_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends",
            |m: &CMsgClientPersonaState| { &m.friends },
            |m: &mut CMsgClientPersonaState| { &mut m.friends },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPersonaState>(
            "CMsgClientPersonaState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientPersonaState {
    const NAME: &'static str = "CMsgClientPersonaState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.friends.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status_flags {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.status_flags {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPersonaState {
        CMsgClientPersonaState::new()
    }

    fn clear(&mut self) {
        self.status_flags = ::std::option::Option::None;
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPersonaState {
        static instance: CMsgClientPersonaState = CMsgClientPersonaState {
            status_flags: ::std::option::Option::None,
            friends: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientPersonaState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPersonaState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPersonaState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientPersonaState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientPersonaState`
pub mod cmsg_client_persona_state {
    // @@protoc_insertion_point(message:CMsgClientPersonaState.Friend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Friend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.friendid)
        pub friendid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.persona_state)
        pub persona_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_played_app_id)
        pub game_played_app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_server_ip)
        pub game_server_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_server_port)
        pub game_server_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.persona_state_flags)
        pub persona_state_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.online_session_instances)
        pub online_session_instances: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.persona_set_by_user)
        pub persona_set_by_user: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.query_port)
        pub query_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.steamid_source)
        pub steamid_source: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.avatar_hash)
        pub avatar_hash: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.last_logoff)
        pub last_logoff: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.last_logon)
        pub last_logon: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.last_seen_online)
        pub last_seen_online: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.clan_rank)
        pub clan_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_name)
        pub game_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.gameid)
        pub gameid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_data_blob)
        pub game_data_blob: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.clan_data)
        pub clan_data: crate::MessageField<friend::ClanData>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.clan_tag)
        pub clan_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.rich_presence)
        pub rich_presence: ::std::vec::Vec<friend::KV>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.broadcast_id)
        pub broadcast_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_lobby_id)
        pub game_lobby_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_accountid)
        pub watching_broadcast_accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_appid)
        pub watching_broadcast_appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_viewers)
        pub watching_broadcast_viewers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_title)
        pub watching_broadcast_title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.is_community_banned)
        pub is_community_banned: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.player_name_pending_review)
        pub player_name_pending_review: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.avatar_pending_review)
        pub avatar_pending_review: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPersonaState.Friend.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as crate::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional fixed64 friendid = 1;

        pub fn friendid(&self) -> u64 {
            self.friendid.unwrap_or(0)
        }

        pub fn clear_friendid(&mut self) {
            self.friendid = ::std::option::Option::None;
        }

        pub fn has_friendid(&self) -> bool {
            self.friendid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friendid(&mut self, v: u64) {
            self.friendid = ::std::option::Option::Some(v);
        }

        // optional uint32 persona_state = 2;

        pub fn persona_state(&self) -> u32 {
            self.persona_state.unwrap_or(0)
        }

        pub fn clear_persona_state(&mut self) {
            self.persona_state = ::std::option::Option::None;
        }

        pub fn has_persona_state(&self) -> bool {
            self.persona_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_state(&mut self, v: u32) {
            self.persona_state = ::std::option::Option::Some(v);
        }

        // optional uint32 game_played_app_id = 3;

        pub fn game_played_app_id(&self) -> u32 {
            self.game_played_app_id.unwrap_or(0)
        }

        pub fn clear_game_played_app_id(&mut self) {
            self.game_played_app_id = ::std::option::Option::None;
        }

        pub fn has_game_played_app_id(&self) -> bool {
            self.game_played_app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_played_app_id(&mut self, v: u32) {
            self.game_played_app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_server_ip = 4;

        pub fn game_server_ip(&self) -> u32 {
            self.game_server_ip.unwrap_or(0)
        }

        pub fn clear_game_server_ip(&mut self) {
            self.game_server_ip = ::std::option::Option::None;
        }

        pub fn has_game_server_ip(&self) -> bool {
            self.game_server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_ip(&mut self, v: u32) {
            self.game_server_ip = ::std::option::Option::Some(v);
        }

        // optional uint32 game_server_port = 5;

        pub fn game_server_port(&self) -> u32 {
            self.game_server_port.unwrap_or(0)
        }

        pub fn clear_game_server_port(&mut self) {
            self.game_server_port = ::std::option::Option::None;
        }

        pub fn has_game_server_port(&self) -> bool {
            self.game_server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_port(&mut self, v: u32) {
            self.game_server_port = ::std::option::Option::Some(v);
        }

        // optional uint32 persona_state_flags = 6;

        pub fn persona_state_flags(&self) -> u32 {
            self.persona_state_flags.unwrap_or(0)
        }

        pub fn clear_persona_state_flags(&mut self) {
            self.persona_state_flags = ::std::option::Option::None;
        }

        pub fn has_persona_state_flags(&self) -> bool {
            self.persona_state_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_state_flags(&mut self, v: u32) {
            self.persona_state_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 online_session_instances = 7;

        pub fn online_session_instances(&self) -> u32 {
            self.online_session_instances.unwrap_or(0)
        }

        pub fn clear_online_session_instances(&mut self) {
            self.online_session_instances = ::std::option::Option::None;
        }

        pub fn has_online_session_instances(&self) -> bool {
            self.online_session_instances.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online_session_instances(&mut self, v: u32) {
            self.online_session_instances = ::std::option::Option::Some(v);
        }

        // optional bool persona_set_by_user = 10;

        pub fn persona_set_by_user(&self) -> bool {
            self.persona_set_by_user.unwrap_or(false)
        }

        pub fn clear_persona_set_by_user(&mut self) {
            self.persona_set_by_user = ::std::option::Option::None;
        }

        pub fn has_persona_set_by_user(&self) -> bool {
            self.persona_set_by_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_set_by_user(&mut self, v: bool) {
            self.persona_set_by_user = ::std::option::Option::Some(v);
        }

        // optional string player_name = 15;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 query_port = 20;

        pub fn query_port(&self) -> u32 {
            self.query_port.unwrap_or(0)
        }

        pub fn clear_query_port(&mut self) {
            self.query_port = ::std::option::Option::None;
        }

        pub fn has_query_port(&self) -> bool {
            self.query_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_port(&mut self, v: u32) {
            self.query_port = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid_source = 25;

        pub fn steamid_source(&self) -> u64 {
            self.steamid_source.unwrap_or(0)
        }

        pub fn clear_steamid_source(&mut self) {
            self.steamid_source = ::std::option::Option::None;
        }

        pub fn has_steamid_source(&self) -> bool {
            self.steamid_source.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_source(&mut self, v: u64) {
            self.steamid_source = ::std::option::Option::Some(v);
        }

        // optional bytes avatar_hash = 31;

        pub fn avatar_hash(&self) -> &[u8] {
            match self.avatar_hash.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_avatar_hash(&mut self) {
            self.avatar_hash = ::std::option::Option::None;
        }

        pub fn has_avatar_hash(&self) -> bool {
            self.avatar_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_hash(&mut self, v: ::bytes::Bytes) {
            self.avatar_hash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_avatar_hash(&mut self) -> &mut ::bytes::Bytes {
            if self.avatar_hash.is_none() {
                self.avatar_hash = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.avatar_hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_avatar_hash(&mut self) -> ::bytes::Bytes {
            self.avatar_hash.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional uint32 last_logoff = 45;

        pub fn last_logoff(&self) -> u32 {
            self.last_logoff.unwrap_or(0)
        }

        pub fn clear_last_logoff(&mut self) {
            self.last_logoff = ::std::option::Option::None;
        }

        pub fn has_last_logoff(&self) -> bool {
            self.last_logoff.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_logoff(&mut self, v: u32) {
            self.last_logoff = ::std::option::Option::Some(v);
        }

        // optional uint32 last_logon = 46;

        pub fn last_logon(&self) -> u32 {
            self.last_logon.unwrap_or(0)
        }

        pub fn clear_last_logon(&mut self) {
            self.last_logon = ::std::option::Option::None;
        }

        pub fn has_last_logon(&self) -> bool {
            self.last_logon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_logon(&mut self, v: u32) {
            self.last_logon = ::std::option::Option::Some(v);
        }

        // optional uint32 last_seen_online = 47;

        pub fn last_seen_online(&self) -> u32 {
            self.last_seen_online.unwrap_or(0)
        }

        pub fn clear_last_seen_online(&mut self) {
            self.last_seen_online = ::std::option::Option::None;
        }

        pub fn has_last_seen_online(&self) -> bool {
            self.last_seen_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_seen_online(&mut self, v: u32) {
            self.last_seen_online = ::std::option::Option::Some(v);
        }

        // optional uint32 clan_rank = 50;

        pub fn clan_rank(&self) -> u32 {
            self.clan_rank.unwrap_or(0)
        }

        pub fn clear_clan_rank(&mut self) {
            self.clan_rank = ::std::option::Option::None;
        }

        pub fn has_clan_rank(&self) -> bool {
            self.clan_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_rank(&mut self, v: u32) {
            self.clan_rank = ::std::option::Option::Some(v);
        }

        // optional string game_name = 55;

        pub fn game_name(&self) -> &str {
            match self.game_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_name(&mut self) {
            self.game_name = ::std::option::Option::None;
        }

        pub fn has_game_name(&self) -> bool {
            self.game_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_name(&mut self, v: ::std::string::String) {
            self.game_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
            if self.game_name.is_none() {
                self.game_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_name(&mut self) -> ::std::string::String {
            self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 gameid = 56;

        pub fn gameid(&self) -> u64 {
            self.gameid.unwrap_or(0)
        }

        pub fn clear_gameid(&mut self) {
            self.gameid = ::std::option::Option::None;
        }

        pub fn has_gameid(&self) -> bool {
            self.gameid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameid(&mut self, v: u64) {
            self.gameid = ::std::option::Option::Some(v);
        }

        // optional bytes game_data_blob = 60;

        pub fn game_data_blob(&self) -> &[u8] {
            match self.game_data_blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_game_data_blob(&mut self) {
            self.game_data_blob = ::std::option::Option::None;
        }

        pub fn has_game_data_blob(&self) -> bool {
            self.game_data_blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_data_blob(&mut self, v: ::bytes::Bytes) {
            self.game_data_blob = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_data_blob(&mut self) -> &mut ::bytes::Bytes {
            if self.game_data_blob.is_none() {
                self.game_data_blob = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.game_data_blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_data_blob(&mut self) -> ::bytes::Bytes {
            self.game_data_blob.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional .CMsgClientPersonaState.Friend.ClanData clan_data = 64;

        pub fn clan_data(&self) -> &friend::ClanData {
            self.clan_data.as_ref().unwrap_or_else(|| <friend::ClanData as crate::Message>::default_instance())
        }

        pub fn clear_clan_data(&mut self) {
            self.clan_data.clear();
        }

        pub fn has_clan_data(&self) -> bool {
            self.clan_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_data(&mut self, v: friend::ClanData) {
            self.clan_data = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_data(&mut self) -> &mut friend::ClanData {
            self.clan_data.mut_or_insert_default()
        }

        // Take field
        pub fn take_clan_data(&mut self) -> friend::ClanData {
            self.clan_data.take().unwrap_or_else(|| friend::ClanData::new())
        }

        // optional string clan_tag = 65;

        pub fn clan_tag(&self) -> &str {
            match self.clan_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_tag(&mut self) {
            self.clan_tag = ::std::option::Option::None;
        }

        pub fn has_clan_tag(&self) -> bool {
            self.clan_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_tag(&mut self, v: ::std::string::String) {
            self.clan_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_tag(&mut self) -> &mut ::std::string::String {
            if self.clan_tag.is_none() {
                self.clan_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.clan_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_tag(&mut self) -> ::std::string::String {
            self.clan_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // repeated .CMsgClientPersonaState.Friend.KV rich_presence = 71;

        pub fn rich_presence(&self) -> &[friend::KV] {
            &self.rich_presence
        }

        pub fn clear_rich_presence(&mut self) {
            self.rich_presence.clear();
        }

        // Param is passed by value, moved
        pub fn set_rich_presence(&mut self, v: ::std::vec::Vec<friend::KV>) {
            self.rich_presence = v;
        }

        // Mutable pointer to the field.
        pub fn mut_rich_presence(&mut self) -> &mut ::std::vec::Vec<friend::KV> {
            &mut self.rich_presence
        }

        // Take field
        pub fn take_rich_presence(&mut self) -> ::std::vec::Vec<friend::KV> {
            ::std::mem::replace(&mut self.rich_presence, ::std::vec::Vec::new())
        }

        // optional fixed64 broadcast_id = 72;

        pub fn broadcast_id(&self) -> u64 {
            self.broadcast_id.unwrap_or(0)
        }

        pub fn clear_broadcast_id(&mut self) {
            self.broadcast_id = ::std::option::Option::None;
        }

        pub fn has_broadcast_id(&self) -> bool {
            self.broadcast_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_broadcast_id(&mut self, v: u64) {
            self.broadcast_id = ::std::option::Option::Some(v);
        }

        // optional fixed64 game_lobby_id = 73;

        pub fn game_lobby_id(&self) -> u64 {
            self.game_lobby_id.unwrap_or(0)
        }

        pub fn clear_game_lobby_id(&mut self) {
            self.game_lobby_id = ::std::option::Option::None;
        }

        pub fn has_game_lobby_id(&self) -> bool {
            self.game_lobby_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_lobby_id(&mut self, v: u64) {
            self.game_lobby_id = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_accountid = 74;

        pub fn watching_broadcast_accountid(&self) -> u32 {
            self.watching_broadcast_accountid.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_accountid(&mut self) {
            self.watching_broadcast_accountid = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_accountid(&self) -> bool {
            self.watching_broadcast_accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
            self.watching_broadcast_accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_appid = 75;

        pub fn watching_broadcast_appid(&self) -> u32 {
            self.watching_broadcast_appid.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_appid(&mut self) {
            self.watching_broadcast_appid = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_appid(&self) -> bool {
            self.watching_broadcast_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_appid(&mut self, v: u32) {
            self.watching_broadcast_appid = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_viewers = 76;

        pub fn watching_broadcast_viewers(&self) -> u32 {
            self.watching_broadcast_viewers.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_viewers(&mut self) {
            self.watching_broadcast_viewers = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_viewers(&self) -> bool {
            self.watching_broadcast_viewers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_viewers(&mut self, v: u32) {
            self.watching_broadcast_viewers = ::std::option::Option::Some(v);
        }

        // optional string watching_broadcast_title = 77;

        pub fn watching_broadcast_title(&self) -> &str {
            match self.watching_broadcast_title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_watching_broadcast_title(&mut self) {
            self.watching_broadcast_title = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_title(&self) -> bool {
            self.watching_broadcast_title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_title(&mut self, v: ::std::string::String) {
            self.watching_broadcast_title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_watching_broadcast_title(&mut self) -> &mut ::std::string::String {
            if self.watching_broadcast_title.is_none() {
                self.watching_broadcast_title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.watching_broadcast_title.as_mut().unwrap()
        }

        // Take field
        pub fn take_watching_broadcast_title(&mut self) -> ::std::string::String {
            self.watching_broadcast_title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_community_banned = 78;

        pub fn is_community_banned(&self) -> bool {
            self.is_community_banned.unwrap_or(false)
        }

        pub fn clear_is_community_banned(&mut self) {
            self.is_community_banned = ::std::option::Option::None;
        }

        pub fn has_is_community_banned(&self) -> bool {
            self.is_community_banned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_community_banned(&mut self, v: bool) {
            self.is_community_banned = ::std::option::Option::Some(v);
        }

        // optional bool player_name_pending_review = 79;

        pub fn player_name_pending_review(&self) -> bool {
            self.player_name_pending_review.unwrap_or(false)
        }

        pub fn clear_player_name_pending_review(&mut self) {
            self.player_name_pending_review = ::std::option::Option::None;
        }

        pub fn has_player_name_pending_review(&self) -> bool {
            self.player_name_pending_review.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name_pending_review(&mut self, v: bool) {
            self.player_name_pending_review = ::std::option::Option::Some(v);
        }

        // optional bool avatar_pending_review = 80;

        pub fn avatar_pending_review(&self) -> bool {
            self.avatar_pending_review.unwrap_or(false)
        }

        pub fn clear_avatar_pending_review(&mut self) {
            self.avatar_pending_review = ::std::option::Option::None;
        }

        pub fn has_avatar_pending_review(&self) -> bool {
            self.avatar_pending_review.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_pending_review(&mut self, v: bool) {
            self.avatar_pending_review = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(31);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friendid",
                |m: &Friend| { &m.friendid },
                |m: &mut Friend| { &mut m.friendid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona_state",
                |m: &Friend| { &m.persona_state },
                |m: &mut Friend| { &mut m.persona_state },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_played_app_id",
                |m: &Friend| { &m.game_played_app_id },
                |m: &mut Friend| { &mut m.game_played_app_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_server_ip",
                |m: &Friend| { &m.game_server_ip },
                |m: &mut Friend| { &mut m.game_server_ip },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_server_port",
                |m: &Friend| { &m.game_server_port },
                |m: &mut Friend| { &mut m.game_server_port },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona_state_flags",
                |m: &Friend| { &m.persona_state_flags },
                |m: &mut Friend| { &mut m.persona_state_flags },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "online_session_instances",
                |m: &Friend| { &m.online_session_instances },
                |m: &mut Friend| { &mut m.online_session_instances },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona_set_by_user",
                |m: &Friend| { &m.persona_set_by_user },
                |m: &mut Friend| { &mut m.persona_set_by_user },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name",
                |m: &Friend| { &m.player_name },
                |m: &mut Friend| { &mut m.player_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "query_port",
                |m: &Friend| { &m.query_port },
                |m: &mut Friend| { &mut m.query_port },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid_source",
                |m: &Friend| { &m.steamid_source },
                |m: &mut Friend| { &mut m.steamid_source },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "avatar_hash",
                |m: &Friend| { &m.avatar_hash },
                |m: &mut Friend| { &mut m.avatar_hash },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_logoff",
                |m: &Friend| { &m.last_logoff },
                |m: &mut Friend| { &mut m.last_logoff },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_logon",
                |m: &Friend| { &m.last_logon },
                |m: &mut Friend| { &mut m.last_logon },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_seen_online",
                |m: &Friend| { &m.last_seen_online },
                |m: &mut Friend| { &mut m.last_seen_online },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "clan_rank",
                |m: &Friend| { &m.clan_rank },
                |m: &mut Friend| { &mut m.clan_rank },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_name",
                |m: &Friend| { &m.game_name },
                |m: &mut Friend| { &mut m.game_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "gameid",
                |m: &Friend| { &m.gameid },
                |m: &mut Friend| { &mut m.gameid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_data_blob",
                |m: &Friend| { &m.game_data_blob },
                |m: &mut Friend| { &mut m.game_data_blob },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, friend::ClanData>(
                "clan_data",
                |m: &Friend| { &m.clan_data },
                |m: &mut Friend| { &mut m.clan_data },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "clan_tag",
                |m: &Friend| { &m.clan_tag },
                |m: &mut Friend| { &mut m.clan_tag },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "rich_presence",
                |m: &Friend| { &m.rich_presence },
                |m: &mut Friend| { &mut m.rich_presence },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "broadcast_id",
                |m: &Friend| { &m.broadcast_id },
                |m: &mut Friend| { &mut m.broadcast_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_lobby_id",
                |m: &Friend| { &m.game_lobby_id },
                |m: &mut Friend| { &mut m.game_lobby_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "watching_broadcast_accountid",
                |m: &Friend| { &m.watching_broadcast_accountid },
                |m: &mut Friend| { &mut m.watching_broadcast_accountid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "watching_broadcast_appid",
                |m: &Friend| { &m.watching_broadcast_appid },
                |m: &mut Friend| { &mut m.watching_broadcast_appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "watching_broadcast_viewers",
                |m: &Friend| { &m.watching_broadcast_viewers },
                |m: &mut Friend| { &mut m.watching_broadcast_viewers },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "watching_broadcast_title",
                |m: &Friend| { &m.watching_broadcast_title },
                |m: &mut Friend| { &mut m.watching_broadcast_title },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_community_banned",
                |m: &Friend| { &m.is_community_banned },
                |m: &mut Friend| { &mut m.is_community_banned },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name_pending_review",
                |m: &Friend| { &m.player_name_pending_review },
                |m: &mut Friend| { &mut m.player_name_pending_review },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "avatar_pending_review",
                |m: &Friend| { &m.avatar_pending_review },
                |m: &mut Friend| { &mut m.avatar_pending_review },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Friend>(
                "CMsgClientPersonaState.Friend",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Friend {
        const NAME: &'static str = "Friend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.persona_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.game_played_app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.persona_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.online_session_instances = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.persona_set_by_user = ::std::option::Option::Some(is.read_bool()?);
                    },
                    122 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    160 => {
                        self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    201 => {
                        self.steamid_source = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    250 => {
                        self.avatar_hash = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    360 => {
                        self.last_logoff = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    368 => {
                        self.last_logon = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    376 => {
                        self.last_seen_online = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    400 => {
                        self.clan_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    442 => {
                        self.game_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    449 => {
                        self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    482 => {
                        self.game_data_blob = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    514 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.clan_data)?;
                    },
                    522 => {
                        self.clan_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    570 => {
                        self.rich_presence.push(is.read_message()?);
                    },
                    577 => {
                        self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    585 => {
                        self.game_lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    592 => {
                        self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    600 => {
                        self.watching_broadcast_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    608 => {
                        self.watching_broadcast_viewers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    618 => {
                        self.watching_broadcast_title = ::std::option::Option::Some(is.read_string()?);
                    },
                    624 => {
                        self.is_community_banned = ::std::option::Option::Some(is.read_bool()?);
                    },
                    632 => {
                        self.player_name_pending_review = ::std::option::Option::Some(is.read_bool()?);
                    },
                    640 => {
                        self.avatar_pending_review = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friendid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_state {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.game_played_app_id {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_server_ip {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.game_server_port {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.persona_state_flags {
                my_size += crate::rt::uint32_size(6, v);
            }
            if let Some(v) = self.online_session_instances {
                my_size += crate::rt::uint32_size(7, v);
            }
            if let Some(v) = self.persona_set_by_user {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += crate::rt::string_size(15, &v);
            }
            if let Some(v) = self.query_port {
                my_size += crate::rt::uint32_size(20, v);
            }
            if let Some(v) = self.steamid_source {
                my_size += 2 + 8;
            }
            if let Some(v) = self.avatar_hash.as_ref() {
                my_size += crate::rt::bytes_size(31, &v);
            }
            if let Some(v) = self.last_logoff {
                my_size += crate::rt::uint32_size(45, v);
            }
            if let Some(v) = self.last_logon {
                my_size += crate::rt::uint32_size(46, v);
            }
            if let Some(v) = self.last_seen_online {
                my_size += crate::rt::uint32_size(47, v);
            }
            if let Some(v) = self.clan_rank {
                my_size += crate::rt::uint32_size(50, v);
            }
            if let Some(v) = self.game_name.as_ref() {
                my_size += crate::rt::string_size(55, &v);
            }
            if let Some(v) = self.gameid {
                my_size += 2 + 8;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                my_size += crate::rt::bytes_size(60, &v);
            }
            if let Some(v) = self.clan_data.as_ref() {
                let len = v.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.clan_tag.as_ref() {
                my_size += crate::rt::string_size(65, &v);
            }
            for value in &self.rich_presence {
                let len = value.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.broadcast_id {
                my_size += 2 + 8;
            }
            if let Some(v) = self.game_lobby_id {
                my_size += 2 + 8;
            }
            if let Some(v) = self.watching_broadcast_accountid {
                my_size += crate::rt::uint32_size(74, v);
            }
            if let Some(v) = self.watching_broadcast_appid {
                my_size += crate::rt::uint32_size(75, v);
            }
            if let Some(v) = self.watching_broadcast_viewers {
                my_size += crate::rt::uint32_size(76, v);
            }
            if let Some(v) = self.watching_broadcast_title.as_ref() {
                my_size += crate::rt::string_size(77, &v);
            }
            if let Some(v) = self.is_community_banned {
                my_size += 2 + 1;
            }
            if let Some(v) = self.player_name_pending_review {
                my_size += 2 + 1;
            }
            if let Some(v) = self.avatar_pending_review {
                my_size += 2 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.friendid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_state {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.game_played_app_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_server_ip {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.game_server_port {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.persona_state_flags {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.online_session_instances {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.persona_set_by_user {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(15, v)?;
            }
            if let Some(v) = self.query_port {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.steamid_source {
                os.write_fixed64(25, v)?;
            }
            if let Some(v) = self.avatar_hash.as_ref() {
                os.write_bytes(31, v)?;
            }
            if let Some(v) = self.last_logoff {
                os.write_uint32(45, v)?;
            }
            if let Some(v) = self.last_logon {
                os.write_uint32(46, v)?;
            }
            if let Some(v) = self.last_seen_online {
                os.write_uint32(47, v)?;
            }
            if let Some(v) = self.clan_rank {
                os.write_uint32(50, v)?;
            }
            if let Some(v) = self.game_name.as_ref() {
                os.write_string(55, v)?;
            }
            if let Some(v) = self.gameid {
                os.write_fixed64(56, v)?;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                os.write_bytes(60, v)?;
            }
            if let Some(v) = self.clan_data.as_ref() {
                crate::rt::write_message_field_with_cached_size(64, v, os)?;
            }
            if let Some(v) = self.clan_tag.as_ref() {
                os.write_string(65, v)?;
            }
            for v in &self.rich_presence {
                crate::rt::write_message_field_with_cached_size(71, v, os)?;
            };
            if let Some(v) = self.broadcast_id {
                os.write_fixed64(72, v)?;
            }
            if let Some(v) = self.game_lobby_id {
                os.write_fixed64(73, v)?;
            }
            if let Some(v) = self.watching_broadcast_accountid {
                os.write_uint32(74, v)?;
            }
            if let Some(v) = self.watching_broadcast_appid {
                os.write_uint32(75, v)?;
            }
            if let Some(v) = self.watching_broadcast_viewers {
                os.write_uint32(76, v)?;
            }
            if let Some(v) = self.watching_broadcast_title.as_ref() {
                os.write_string(77, v)?;
            }
            if let Some(v) = self.is_community_banned {
                os.write_bool(78, v)?;
            }
            if let Some(v) = self.player_name_pending_review {
                os.write_bool(79, v)?;
            }
            if let Some(v) = self.avatar_pending_review {
                os.write_bool(80, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn clear(&mut self) {
            self.friendid = ::std::option::Option::None;
            self.persona_state = ::std::option::Option::None;
            self.game_played_app_id = ::std::option::Option::None;
            self.game_server_ip = ::std::option::Option::None;
            self.game_server_port = ::std::option::Option::None;
            self.persona_state_flags = ::std::option::Option::None;
            self.online_session_instances = ::std::option::Option::None;
            self.persona_set_by_user = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.query_port = ::std::option::Option::None;
            self.steamid_source = ::std::option::Option::None;
            self.avatar_hash = ::std::option::Option::None;
            self.last_logoff = ::std::option::Option::None;
            self.last_logon = ::std::option::Option::None;
            self.last_seen_online = ::std::option::Option::None;
            self.clan_rank = ::std::option::Option::None;
            self.game_name = ::std::option::Option::None;
            self.gameid = ::std::option::Option::None;
            self.game_data_blob = ::std::option::Option::None;
            self.clan_data.clear();
            self.clan_tag = ::std::option::Option::None;
            self.rich_presence.clear();
            self.broadcast_id = ::std::option::Option::None;
            self.game_lobby_id = ::std::option::Option::None;
            self.watching_broadcast_accountid = ::std::option::Option::None;
            self.watching_broadcast_appid = ::std::option::Option::None;
            self.watching_broadcast_viewers = ::std::option::Option::None;
            self.watching_broadcast_title = ::std::option::Option::None;
            self.is_community_banned = ::std::option::Option::None;
            self.player_name_pending_review = ::std::option::Option::None;
            self.avatar_pending_review = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Friend {
            static instance: Friend = Friend {
                friendid: ::std::option::Option::None,
                persona_state: ::std::option::Option::None,
                game_played_app_id: ::std::option::Option::None,
                game_server_ip: ::std::option::Option::None,
                game_server_port: ::std::option::Option::None,
                persona_state_flags: ::std::option::Option::None,
                online_session_instances: ::std::option::Option::None,
                persona_set_by_user: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                query_port: ::std::option::Option::None,
                steamid_source: ::std::option::Option::None,
                avatar_hash: ::std::option::Option::None,
                last_logoff: ::std::option::Option::None,
                last_logon: ::std::option::Option::None,
                last_seen_online: ::std::option::Option::None,
                clan_rank: ::std::option::Option::None,
                game_name: ::std::option::Option::None,
                gameid: ::std::option::Option::None,
                game_data_blob: ::std::option::Option::None,
                clan_data: crate::MessageField::none(),
                clan_tag: ::std::option::Option::None,
                rich_presence: ::std::vec::Vec::new(),
                broadcast_id: ::std::option::Option::None,
                game_lobby_id: ::std::option::Option::None,
                watching_broadcast_accountid: ::std::option::Option::None,
                watching_broadcast_appid: ::std::option::Option::None,
                watching_broadcast_viewers: ::std::option::Option::None,
                watching_broadcast_title: ::std::option::Option::None,
                is_community_banned: ::std::option::Option::None,
                player_name_pending_review: ::std::option::Option::None,
                avatar_pending_review: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Friend {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPersonaState.Friend").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Friend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Friend {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Friend`
    pub mod friend {
        // @@protoc_insertion_point(message:CMsgClientPersonaState.Friend.ClanData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ClanData {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.ClanData.ogg_app_id)
            pub ogg_app_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.ClanData.chat_group_id)
            pub chat_group_id: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientPersonaState.Friend.ClanData.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ClanData {
            fn default() -> &'a ClanData {
                <ClanData as crate::Message>::default_instance()
            }
        }

        impl ClanData {
            pub fn new() -> ClanData {
                ::std::default::Default::default()
            }

            // optional uint32 ogg_app_id = 1;

            pub fn ogg_app_id(&self) -> u32 {
                self.ogg_app_id.unwrap_or(0)
            }

            pub fn clear_ogg_app_id(&mut self) {
                self.ogg_app_id = ::std::option::Option::None;
            }

            pub fn has_ogg_app_id(&self) -> bool {
                self.ogg_app_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ogg_app_id(&mut self, v: u32) {
                self.ogg_app_id = ::std::option::Option::Some(v);
            }

            // optional uint64 chat_group_id = 2;

            pub fn chat_group_id(&self) -> u64 {
                self.chat_group_id.unwrap_or(0)
            }

            pub fn clear_chat_group_id(&mut self) {
                self.chat_group_id = ::std::option::Option::None;
            }

            pub fn has_chat_group_id(&self) -> bool {
                self.chat_group_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_chat_group_id(&mut self, v: u64) {
                self.chat_group_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ogg_app_id",
                    |m: &ClanData| { &m.ogg_app_id },
                    |m: &mut ClanData| { &mut m.ogg_app_id },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "chat_group_id",
                    |m: &ClanData| { &m.chat_group_id },
                    |m: &mut ClanData| { &mut m.chat_group_id },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<ClanData>(
                    "CMsgClientPersonaState.Friend.ClanData",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for ClanData {
            const NAME: &'static str = "ClanData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.ogg_app_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.ogg_app_id {
                    my_size += crate::rt::uint32_size(1, v);
                }
                if let Some(v) = self.chat_group_id {
                    my_size += crate::rt::uint64_size(2, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.ogg_app_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.chat_group_id {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ClanData {
                ClanData::new()
            }

            fn clear(&mut self) {
                self.ogg_app_id = ::std::option::Option::None;
                self.chat_group_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ClanData {
                static instance: ClanData = ClanData {
                    ogg_app_id: ::std::option::Option::None,
                    chat_group_id: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for ClanData {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientPersonaState.Friend.ClanData").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ClanData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for ClanData {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CMsgClientPersonaState.Friend.KV)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct KV {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.KV.key)
            pub key: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.KV.value)
            pub value: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientPersonaState.Friend.KV.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a KV {
            fn default() -> &'a KV {
                <KV as crate::Message>::default_instance()
            }
        }

        impl KV {
            pub fn new() -> KV {
                ::std::default::Default::default()
            }

            // optional string key = 1;

            pub fn key(&self) -> &str {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::string::String) {
                self.key = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::string::String {
                if self.key.is_none() {
                    self.key = ::std::option::Option::Some(::std::string::String::new());
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::string::String {
                self.key.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string value = 2;

            pub fn value(&self) -> &str {
                match self.value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: ::std::string::String) {
                self.value = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_value(&mut self) -> &mut ::std::string::String {
                if self.value.is_none() {
                    self.value = ::std::option::Option::Some(::std::string::String::new());
                }
                self.value.as_mut().unwrap()
            }

            // Take field
            pub fn take_value(&mut self) -> ::std::string::String {
                self.value.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &KV| { &m.key },
                    |m: &mut KV| { &mut m.key },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value",
                    |m: &KV| { &m.value },
                    |m: &mut KV| { &mut m.value },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<KV>(
                    "CMsgClientPersonaState.Friend.KV",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for KV {
            const NAME: &'static str = "KV";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.key = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.value = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.key.as_ref() {
                    my_size += crate::rt::string_size(1, &v);
                }
                if let Some(v) = self.value.as_ref() {
                    my_size += crate::rt::string_size(2, &v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.key.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> KV {
                KV::new()
            }

            fn clear(&mut self) {
                self.key = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static KV {
                static instance: KV = KV {
                    key: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for KV {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientPersonaState.Friend.KV").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for KV {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for KV {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendProfileInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendProfileInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfo.steamid_friend)
    pub steamid_friend: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendProfileInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfo {
    fn default() -> &'a CMsgClientFriendProfileInfo {
        <CMsgClientFriendProfileInfo as crate::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfo {
    pub fn new() -> CMsgClientFriendProfileInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_friend = 1;

    pub fn steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_friend",
            |m: &CMsgClientFriendProfileInfo| { &m.steamid_friend },
            |m: &mut CMsgClientFriendProfileInfo| { &mut m.steamid_friend },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendProfileInfo>(
            "CMsgClientFriendProfileInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFriendProfileInfo {
    const NAME: &'static str = "CMsgClientFriendProfileInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_friend = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_friend {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendProfileInfo {
        CMsgClientFriendProfileInfo::new()
    }

    fn clear(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfo {
        static instance: CMsgClientFriendProfileInfo = CMsgClientFriendProfileInfo {
            steamid_friend: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFriendProfileInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendProfileInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendProfileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFriendProfileInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFriendProfileInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendProfileInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.steamid_friend)
    pub steamid_friend: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.time_created)
    pub time_created: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.real_name)
    pub real_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.city_name)
    pub city_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.state_name)
    pub state_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.country_name)
    pub country_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.summary)
    pub summary: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendProfileInfoResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfoResponse {
    fn default() -> &'a CMsgClientFriendProfileInfoResponse {
        <CMsgClientFriendProfileInfoResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfoResponse {
    pub fn new() -> CMsgClientFriendProfileInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_friend = 2;

    pub fn steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    // optional uint32 time_created = 3;

    pub fn time_created(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }

    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    // optional string real_name = 4;

    pub fn real_name(&self) -> &str {
        match self.real_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_real_name(&mut self) {
        self.real_name = ::std::option::Option::None;
    }

    pub fn has_real_name(&self) -> bool {
        self.real_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_name(&mut self, v: ::std::string::String) {
        self.real_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_name(&mut self) -> &mut ::std::string::String {
        if self.real_name.is_none() {
            self.real_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.real_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_name(&mut self) -> ::std::string::String {
        self.real_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city_name = 5;

    pub fn city_name(&self) -> &str {
        match self.city_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_city_name(&mut self) {
        self.city_name = ::std::option::Option::None;
    }

    pub fn has_city_name(&self) -> bool {
        self.city_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city_name(&mut self, v: ::std::string::String) {
        self.city_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city_name(&mut self) -> &mut ::std::string::String {
        if self.city_name.is_none() {
            self.city_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.city_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_city_name(&mut self) -> ::std::string::String {
        self.city_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string state_name = 6;

    pub fn state_name(&self) -> &str {
        match self.state_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_state_name(&mut self) {
        self.state_name = ::std::option::Option::None;
    }

    pub fn has_state_name(&self) -> bool {
        self.state_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_name(&mut self, v: ::std::string::String) {
        self.state_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_name(&mut self) -> &mut ::std::string::String {
        if self.state_name.is_none() {
            self.state_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.state_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_name(&mut self) -> ::std::string::String {
        self.state_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_name = 7;

    pub fn country_name(&self) -> &str {
        match self.country_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_name(&mut self) {
        self.country_name = ::std::option::Option::None;
    }

    pub fn has_country_name(&self) -> bool {
        self.country_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_name(&mut self, v: ::std::string::String) {
        self.country_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_name(&mut self) -> &mut ::std::string::String {
        if self.country_name.is_none() {
            self.country_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_name(&mut self) -> ::std::string::String {
        self.country_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 8;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 9;

    pub fn summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_summary(&mut self) {
        self.summary = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary = ::std::option::Option::Some(::std::string::String::new());
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.eresult },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_friend",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.steamid_friend },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.steamid_friend },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_created",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.time_created },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.time_created },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_name",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.real_name },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.real_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "city_name",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.city_name },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.city_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_name",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.state_name },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.state_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_name",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.country_name },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.country_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "headline",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.headline },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.headline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "summary",
            |m: &CMsgClientFriendProfileInfoResponse| { &m.summary },
            |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.summary },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendProfileInfoResponse>(
            "CMsgClientFriendProfileInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientFriendProfileInfoResponse {
    const NAME: &'static str = "CMsgClientFriendProfileInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid_friend = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.time_created = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.real_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.city_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.state_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.country_name = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.summary = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid_friend {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_created {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.real_name.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.city_name.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.state_name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.country_name.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.summary.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_created {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.real_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.city_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.state_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.country_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendProfileInfoResponse {
        CMsgClientFriendProfileInfoResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_friend = ::std::option::Option::None;
        self.time_created = ::std::option::Option::None;
        self.real_name = ::std::option::Option::None;
        self.city_name = ::std::option::Option::None;
        self.state_name = ::std::option::Option::None;
        self.country_name = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.summary = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfoResponse {
        static instance: CMsgClientFriendProfileInfoResponse = CMsgClientFriendProfileInfoResponse {
            eresult: ::std::option::Option::None,
            steamid_friend: ::std::option::Option::None,
            time_created: ::std::option::Option::None,
            real_name: ::std::option::Option::None,
            city_name: ::std::option::Option::None,
            state_name: ::std::option::Option::None,
            country_name: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            summary: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientFriendProfileInfoResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendProfileInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendProfileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientFriendProfileInfoResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCreateFriendsGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCreateFriendsGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroup.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroup.groupname)
    pub groupname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroup.steamid_friends)
    pub steamid_friends: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCreateFriendsGroup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroup {
    fn default() -> &'a CMsgClientCreateFriendsGroup {
        <CMsgClientCreateFriendsGroup as crate::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroup {
    pub fn new() -> CMsgClientCreateFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;

    pub fn groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupname(&mut self) {
        self.groupname = ::std::option::Option::None;
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed64 steamid_friends = 3;

    pub fn steamid_friends(&self) -> &[u64] {
        &self.steamid_friends
    }

    pub fn clear_steamid_friends(&mut self) {
        self.steamid_friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_friends(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_friends(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_friends
    }

    // Take field
    pub fn take_steamid_friends(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_friends, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientCreateFriendsGroup| { &m.steamid },
            |m: &mut CMsgClientCreateFriendsGroup| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupname",
            |m: &CMsgClientCreateFriendsGroup| { &m.groupname },
            |m: &mut CMsgClientCreateFriendsGroup| { &mut m.groupname },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_friends",
            |m: &CMsgClientCreateFriendsGroup| { &m.steamid_friends },
            |m: &mut CMsgClientCreateFriendsGroup| { &mut m.steamid_friends },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCreateFriendsGroup>(
            "CMsgClientCreateFriendsGroup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCreateFriendsGroup {
    const NAME: &'static str = "CMsgClientCreateFriendsGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.groupname = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_friends)?;
                },
                25 => {
                    self.steamid_friends.push(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.groupname.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends.len() as u64;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.groupname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.steamid_friends {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCreateFriendsGroup {
        CMsgClientCreateFriendsGroup::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupname = ::std::option::Option::None;
        self.steamid_friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroup {
        static instance: CMsgClientCreateFriendsGroup = CMsgClientCreateFriendsGroup {
            steamid: ::std::option::Option::None,
            groupname: ::std::option::Option::None,
            steamid_friends: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCreateFriendsGroup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCreateFriendsGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCreateFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCreateFriendsGroup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCreateFriendsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCreateFriendsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroupResponse.groupid)
    pub groupid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCreateFriendsGroupResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroupResponse {
    fn default() -> &'a CMsgClientCreateFriendsGroupResponse {
        <CMsgClientCreateFriendsGroupResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroupResponse {
    pub fn new() -> CMsgClientCreateFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientCreateFriendsGroupResponse| { &m.eresult },
            |m: &mut CMsgClientCreateFriendsGroupResponse| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupid",
            |m: &CMsgClientCreateFriendsGroupResponse| { &m.groupid },
            |m: &mut CMsgClientCreateFriendsGroupResponse| { &mut m.groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCreateFriendsGroupResponse>(
            "CMsgClientCreateFriendsGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientCreateFriendsGroupResponse {
    const NAME: &'static str = "CMsgClientCreateFriendsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.groupid {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCreateFriendsGroupResponse {
        CMsgClientCreateFriendsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroupResponse {
        static instance: CMsgClientCreateFriendsGroupResponse = CMsgClientCreateFriendsGroupResponse {
            eresult: ::std::option::Option::None,
            groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientCreateFriendsGroupResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCreateFriendsGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCreateFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientCreateFriendsGroupResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDeleteFriendsGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeleteFriendsGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeleteFriendsGroup.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientDeleteFriendsGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeleteFriendsGroup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroup {
    fn default() -> &'a CMsgClientDeleteFriendsGroup {
        <CMsgClientDeleteFriendsGroup as crate::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroup {
    pub fn new() -> CMsgClientDeleteFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientDeleteFriendsGroup| { &m.steamid },
            |m: &mut CMsgClientDeleteFriendsGroup| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupid",
            |m: &CMsgClientDeleteFriendsGroup| { &m.groupid },
            |m: &mut CMsgClientDeleteFriendsGroup| { &mut m.groupid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeleteFriendsGroup>(
            "CMsgClientDeleteFriendsGroup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDeleteFriendsGroup {
    const NAME: &'static str = "CMsgClientDeleteFriendsGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.groupid {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeleteFriendsGroup {
        CMsgClientDeleteFriendsGroup::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroup {
        static instance: CMsgClientDeleteFriendsGroup = CMsgClientDeleteFriendsGroup {
            steamid: ::std::option::Option::None,
            groupid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDeleteFriendsGroup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeleteFriendsGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeleteFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDeleteFriendsGroup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDeleteFriendsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeleteFriendsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeleteFriendsGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeleteFriendsGroupResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroupResponse {
    fn default() -> &'a CMsgClientDeleteFriendsGroupResponse {
        <CMsgClientDeleteFriendsGroupResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroupResponse {
    pub fn new() -> CMsgClientDeleteFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientDeleteFriendsGroupResponse| { &m.eresult },
            |m: &mut CMsgClientDeleteFriendsGroupResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeleteFriendsGroupResponse>(
            "CMsgClientDeleteFriendsGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientDeleteFriendsGroupResponse {
    const NAME: &'static str = "CMsgClientDeleteFriendsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeleteFriendsGroupResponse {
        CMsgClientDeleteFriendsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroupResponse {
        static instance: CMsgClientDeleteFriendsGroupResponse = CMsgClientDeleteFriendsGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientDeleteFriendsGroupResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeleteFriendsGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeleteFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientDeleteFriendsGroupResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientManageFriendsGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientManageFriendsGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.groupname)
    pub groupname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.steamid_friends_added)
    pub steamid_friends_added: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.steamid_friends_removed)
    pub steamid_friends_removed: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientManageFriendsGroup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroup {
    fn default() -> &'a CMsgClientManageFriendsGroup {
        <CMsgClientManageFriendsGroup as crate::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroup {
    pub fn new() -> CMsgClientManageFriendsGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;

    pub fn groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupname(&mut self) {
        self.groupname = ::std::option::Option::None;
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed64 steamid_friends_added = 3;

    pub fn steamid_friends_added(&self) -> &[u64] {
        &self.steamid_friends_added
    }

    pub fn clear_steamid_friends_added(&mut self) {
        self.steamid_friends_added.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_friends_added(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_friends_added = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_friends_added(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_friends_added
    }

    // Take field
    pub fn take_steamid_friends_added(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_friends_added, ::std::vec::Vec::new())
    }

    // repeated fixed64 steamid_friends_removed = 4;

    pub fn steamid_friends_removed(&self) -> &[u64] {
        &self.steamid_friends_removed
    }

    pub fn clear_steamid_friends_removed(&mut self) {
        self.steamid_friends_removed.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_friends_removed(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_friends_removed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_friends_removed(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_friends_removed
    }

    // Take field
    pub fn take_steamid_friends_removed(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_friends_removed, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupid",
            |m: &CMsgClientManageFriendsGroup| { &m.groupid },
            |m: &mut CMsgClientManageFriendsGroup| { &mut m.groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupname",
            |m: &CMsgClientManageFriendsGroup| { &m.groupname },
            |m: &mut CMsgClientManageFriendsGroup| { &mut m.groupname },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_friends_added",
            |m: &CMsgClientManageFriendsGroup| { &m.steamid_friends_added },
            |m: &mut CMsgClientManageFriendsGroup| { &mut m.steamid_friends_added },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_friends_removed",
            |m: &CMsgClientManageFriendsGroup| { &m.steamid_friends_removed },
            |m: &mut CMsgClientManageFriendsGroup| { &mut m.steamid_friends_removed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientManageFriendsGroup>(
            "CMsgClientManageFriendsGroup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientManageFriendsGroup {
    const NAME: &'static str = "CMsgClientManageFriendsGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.groupname = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_friends_added)?;
                },
                25 => {
                    self.steamid_friends_added.push(is.read_fixed64()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_friends_removed)?;
                },
                33 => {
                    self.steamid_friends_removed.push(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.groupname.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends_added.len() as u64;
        my_size += 9 * self.steamid_friends_removed.len() as u64;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.groupname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.steamid_friends_added {
            os.write_fixed64(3, *v)?;
        };
        for v in &self.steamid_friends_removed {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientManageFriendsGroup {
        CMsgClientManageFriendsGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.groupname = ::std::option::Option::None;
        self.steamid_friends_added.clear();
        self.steamid_friends_removed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroup {
        static instance: CMsgClientManageFriendsGroup = CMsgClientManageFriendsGroup {
            groupid: ::std::option::Option::None,
            groupname: ::std::option::Option::None,
            steamid_friends_added: ::std::vec::Vec::new(),
            steamid_friends_removed: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientManageFriendsGroup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientManageFriendsGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientManageFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientManageFriendsGroup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientManageFriendsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientManageFriendsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientManageFriendsGroupResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroupResponse {
    fn default() -> &'a CMsgClientManageFriendsGroupResponse {
        <CMsgClientManageFriendsGroupResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroupResponse {
    pub fn new() -> CMsgClientManageFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientManageFriendsGroupResponse| { &m.eresult },
            |m: &mut CMsgClientManageFriendsGroupResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientManageFriendsGroupResponse>(
            "CMsgClientManageFriendsGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientManageFriendsGroupResponse {
    const NAME: &'static str = "CMsgClientManageFriendsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientManageFriendsGroupResponse {
        CMsgClientManageFriendsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroupResponse {
        static instance: CMsgClientManageFriendsGroupResponse = CMsgClientManageFriendsGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientManageFriendsGroupResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientManageFriendsGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientManageFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientManageFriendsGroupResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAddFriendToGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriendToGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriendToGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAddFriendToGroup.steamiduser)
    pub steamiduser: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriendToGroup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroup {
    fn default() -> &'a CMsgClientAddFriendToGroup {
        <CMsgClientAddFriendToGroup as crate::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroup {
    pub fn new() -> CMsgClientAddFriendToGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;

    pub fn steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }

    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupid",
            |m: &CMsgClientAddFriendToGroup| { &m.groupid },
            |m: &mut CMsgClientAddFriendToGroup| { &mut m.groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamiduser",
            |m: &CMsgClientAddFriendToGroup| { &m.steamiduser },
            |m: &mut CMsgClientAddFriendToGroup| { &mut m.steamiduser },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAddFriendToGroup>(
            "CMsgClientAddFriendToGroup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAddFriendToGroup {
    const NAME: &'static str = "CMsgClientAddFriendToGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamiduser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamiduser {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriendToGroup {
        CMsgClientAddFriendToGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroup {
        static instance: CMsgClientAddFriendToGroup = CMsgClientAddFriendToGroup {
            groupid: ::std::option::Option::None,
            steamiduser: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAddFriendToGroup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAddFriendToGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAddFriendToGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAddFriendToGroup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAddFriendToGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriendToGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriendToGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriendToGroupResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroupResponse {
    fn default() -> &'a CMsgClientAddFriendToGroupResponse {
        <CMsgClientAddFriendToGroupResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroupResponse {
    pub fn new() -> CMsgClientAddFriendToGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAddFriendToGroupResponse| { &m.eresult },
            |m: &mut CMsgClientAddFriendToGroupResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAddFriendToGroupResponse>(
            "CMsgClientAddFriendToGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientAddFriendToGroupResponse {
    const NAME: &'static str = "CMsgClientAddFriendToGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriendToGroupResponse {
        CMsgClientAddFriendToGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroupResponse {
        static instance: CMsgClientAddFriendToGroupResponse = CMsgClientAddFriendToGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientAddFriendToGroupResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAddFriendToGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAddFriendToGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientAddFriendToGroupResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRemoveFriendFromGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRemoveFriendFromGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRemoveFriendFromGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRemoveFriendFromGroup.steamiduser)
    pub steamiduser: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRemoveFriendFromGroup.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroup {
    fn default() -> &'a CMsgClientRemoveFriendFromGroup {
        <CMsgClientRemoveFriendFromGroup as crate::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroup {
    pub fn new() -> CMsgClientRemoveFriendFromGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;

    pub fn steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }

    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupid",
            |m: &CMsgClientRemoveFriendFromGroup| { &m.groupid },
            |m: &mut CMsgClientRemoveFriendFromGroup| { &mut m.groupid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamiduser",
            |m: &CMsgClientRemoveFriendFromGroup| { &m.steamiduser },
            |m: &mut CMsgClientRemoveFriendFromGroup| { &mut m.steamiduser },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRemoveFriendFromGroup>(
            "CMsgClientRemoveFriendFromGroup",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRemoveFriendFromGroup {
    const NAME: &'static str = "CMsgClientRemoveFriendFromGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamiduser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamiduser {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRemoveFriendFromGroup {
        CMsgClientRemoveFriendFromGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroup {
        static instance: CMsgClientRemoveFriendFromGroup = CMsgClientRemoveFriendFromGroup {
            groupid: ::std::option::Option::None,
            steamiduser: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRemoveFriendFromGroup {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRemoveFriendFromGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRemoveFriendFromGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRemoveFriendFromGroup {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRemoveFriendFromGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRemoveFriendFromGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRemoveFriendFromGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRemoveFriendFromGroupResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroupResponse {
    fn default() -> &'a CMsgClientRemoveFriendFromGroupResponse {
        <CMsgClientRemoveFriendFromGroupResponse as crate::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroupResponse {
    pub fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRemoveFriendFromGroupResponse| { &m.eresult },
            |m: &mut CMsgClientRemoveFriendFromGroupResponse| { &mut m.eresult },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRemoveFriendFromGroupResponse>(
            "CMsgClientRemoveFriendFromGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientRemoveFriendFromGroupResponse {
    const NAME: &'static str = "CMsgClientRemoveFriendFromGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        CMsgClientRemoveFriendFromGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroupResponse {
        static instance: CMsgClientRemoveFriendFromGroupResponse = CMsgClientRemoveFriendFromGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientRemoveFriendFromGroupResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRemoveFriendFromGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRemoveFriendFromGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientRemoveFriendFromGroupResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetEmoticonList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetEmoticonList {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetEmoticonList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetEmoticonList {
    fn default() -> &'a CMsgClientGetEmoticonList {
        <CMsgClientGetEmoticonList as crate::Message>::default_instance()
    }
}

impl CMsgClientGetEmoticonList {
    pub fn new() -> CMsgClientGetEmoticonList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetEmoticonList>(
            "CMsgClientGetEmoticonList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientGetEmoticonList {
    const NAME: &'static str = "CMsgClientGetEmoticonList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetEmoticonList {
        CMsgClientGetEmoticonList::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetEmoticonList {
        static instance: CMsgClientGetEmoticonList = CMsgClientGetEmoticonList {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientGetEmoticonList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetEmoticonList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetEmoticonList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientGetEmoticonList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientEmoticonList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEmoticonList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEmoticonList.emoticons)
    pub emoticons: ::std::vec::Vec<cmsg_client_emoticon_list::Emoticon>,
    // @@protoc_insertion_point(field:CMsgClientEmoticonList.stickers)
    pub stickers: ::std::vec::Vec<cmsg_client_emoticon_list::Sticker>,
    // @@protoc_insertion_point(field:CMsgClientEmoticonList.effects)
    pub effects: ::std::vec::Vec<cmsg_client_emoticon_list::Effect>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmoticonList {
    fn default() -> &'a CMsgClientEmoticonList {
        <CMsgClientEmoticonList as crate::Message>::default_instance()
    }
}

impl CMsgClientEmoticonList {
    pub fn new() -> CMsgClientEmoticonList {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientEmoticonList.Emoticon emoticons = 1;

    pub fn emoticons(&self) -> &[cmsg_client_emoticon_list::Emoticon] {
        &self.emoticons
    }

    pub fn clear_emoticons(&mut self) {
        self.emoticons.clear();
    }

    // Param is passed by value, moved
    pub fn set_emoticons(&mut self, v: ::std::vec::Vec<cmsg_client_emoticon_list::Emoticon>) {
        self.emoticons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_emoticons(&mut self) -> &mut ::std::vec::Vec<cmsg_client_emoticon_list::Emoticon> {
        &mut self.emoticons
    }

    // Take field
    pub fn take_emoticons(&mut self) -> ::std::vec::Vec<cmsg_client_emoticon_list::Emoticon> {
        ::std::mem::replace(&mut self.emoticons, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientEmoticonList.Sticker stickers = 2;

    pub fn stickers(&self) -> &[cmsg_client_emoticon_list::Sticker] {
        &self.stickers
    }

    pub fn clear_stickers(&mut self) {
        self.stickers.clear();
    }

    // Param is passed by value, moved
    pub fn set_stickers(&mut self, v: ::std::vec::Vec<cmsg_client_emoticon_list::Sticker>) {
        self.stickers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stickers(&mut self) -> &mut ::std::vec::Vec<cmsg_client_emoticon_list::Sticker> {
        &mut self.stickers
    }

    // Take field
    pub fn take_stickers(&mut self) -> ::std::vec::Vec<cmsg_client_emoticon_list::Sticker> {
        ::std::mem::replace(&mut self.stickers, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientEmoticonList.Effect effects = 3;

    pub fn effects(&self) -> &[cmsg_client_emoticon_list::Effect] {
        &self.effects
    }

    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ::std::vec::Vec<cmsg_client_emoticon_list::Effect>) {
        self.effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ::std::vec::Vec<cmsg_client_emoticon_list::Effect> {
        &mut self.effects
    }

    // Take field
    pub fn take_effects(&mut self) -> ::std::vec::Vec<cmsg_client_emoticon_list::Effect> {
        ::std::mem::replace(&mut self.effects, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "emoticons",
            |m: &CMsgClientEmoticonList| { &m.emoticons },
            |m: &mut CMsgClientEmoticonList| { &mut m.emoticons },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stickers",
            |m: &CMsgClientEmoticonList| { &m.stickers },
            |m: &mut CMsgClientEmoticonList| { &mut m.stickers },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effects",
            |m: &CMsgClientEmoticonList| { &m.effects },
            |m: &mut CMsgClientEmoticonList| { &mut m.effects },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientEmoticonList>(
            "CMsgClientEmoticonList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientEmoticonList {
    const NAME: &'static str = "CMsgClientEmoticonList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.emoticons.push(is.read_message()?);
                },
                18 => {
                    self.stickers.push(is.read_message()?);
                },
                26 => {
                    self.effects.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.emoticons {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.emoticons {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.stickers {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.effects {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEmoticonList {
        CMsgClientEmoticonList::new()
    }

    fn clear(&mut self) {
        self.emoticons.clear();
        self.stickers.clear();
        self.effects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEmoticonList {
        static instance: CMsgClientEmoticonList = CMsgClientEmoticonList {
            emoticons: ::std::vec::Vec::new(),
            stickers: ::std::vec::Vec::new(),
            effects: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientEmoticonList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientEmoticonList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientEmoticonList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientEmoticonList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientEmoticonList`
pub mod cmsg_client_emoticon_list {
    // @@protoc_insertion_point(message:CMsgClientEmoticonList.Emoticon)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Emoticon {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.count)
        pub count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.time_last_used)
        pub time_last_used: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.use_count)
        pub use_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.time_received)
        pub time_received: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.appid)
        pub appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.Emoticon.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Emoticon {
        fn default() -> &'a Emoticon {
            <Emoticon as crate::Message>::default_instance()
        }
    }

    impl Emoticon {
        pub fn new() -> Emoticon {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_used = 3;

        pub fn time_last_used(&self) -> u32 {
            self.time_last_used.unwrap_or(0)
        }

        pub fn clear_time_last_used(&mut self) {
            self.time_last_used = ::std::option::Option::None;
        }

        pub fn has_time_last_used(&self) -> bool {
            self.time_last_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_used(&mut self, v: u32) {
            self.time_last_used = ::std::option::Option::Some(v);
        }

        // optional uint32 use_count = 4;

        pub fn use_count(&self) -> u32 {
            self.use_count.unwrap_or(0)
        }

        pub fn clear_use_count(&mut self) {
            self.use_count = ::std::option::Option::None;
        }

        pub fn has_use_count(&self) -> bool {
            self.use_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_count(&mut self, v: u32) {
            self.use_count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 5;

        pub fn time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 6;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Emoticon| { &m.name },
                |m: &mut Emoticon| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &Emoticon| { &m.count },
                |m: &mut Emoticon| { &mut m.count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_last_used",
                |m: &Emoticon| { &m.time_last_used },
                |m: &mut Emoticon| { &mut m.time_last_used },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "use_count",
                |m: &Emoticon| { &m.use_count },
                |m: &mut Emoticon| { &mut m.use_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_received",
                |m: &Emoticon| { &m.time_received },
                |m: &mut Emoticon| { &mut m.time_received },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &Emoticon| { &m.appid },
                |m: &mut Emoticon| { &mut m.appid },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Emoticon>(
                "CMsgClientEmoticonList.Emoticon",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Emoticon {
        const NAME: &'static str = "Emoticon";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.time_last_used = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.use_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.time_last_used {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.use_count {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.time_received {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(6, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_last_used {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.use_count {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Emoticon {
            Emoticon::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.time_last_used = ::std::option::Option::None;
            self.use_count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Emoticon {
            static instance: Emoticon = Emoticon {
                name: ::std::option::Option::None,
                count: ::std::option::Option::None,
                time_last_used: ::std::option::Option::None,
                use_count: ::std::option::Option::None,
                time_received: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Emoticon {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientEmoticonList.Emoticon").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Emoticon {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Emoticon {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientEmoticonList.Sticker)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sticker {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.count)
        pub count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.time_received)
        pub time_received: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.time_last_used)
        pub time_last_used: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.use_count)
        pub use_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.Sticker.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sticker {
        fn default() -> &'a Sticker {
            <Sticker as crate::Message>::default_instance()
        }
    }

    impl Sticker {
        pub fn new() -> Sticker {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 3;

        pub fn time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 4;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_used = 5;

        pub fn time_last_used(&self) -> u32 {
            self.time_last_used.unwrap_or(0)
        }

        pub fn clear_time_last_used(&mut self) {
            self.time_last_used = ::std::option::Option::None;
        }

        pub fn has_time_last_used(&self) -> bool {
            self.time_last_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_used(&mut self, v: u32) {
            self.time_last_used = ::std::option::Option::Some(v);
        }

        // optional uint32 use_count = 6;

        pub fn use_count(&self) -> u32 {
            self.use_count.unwrap_or(0)
        }

        pub fn clear_use_count(&mut self) {
            self.use_count = ::std::option::Option::None;
        }

        pub fn has_use_count(&self) -> bool {
            self.use_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_count(&mut self, v: u32) {
            self.use_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Sticker| { &m.name },
                |m: &mut Sticker| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &Sticker| { &m.count },
                |m: &mut Sticker| { &mut m.count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_received",
                |m: &Sticker| { &m.time_received },
                |m: &mut Sticker| { &mut m.time_received },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &Sticker| { &m.appid },
                |m: &mut Sticker| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_last_used",
                |m: &Sticker| { &m.time_last_used },
                |m: &mut Sticker| { &mut m.time_last_used },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "use_count",
                |m: &Sticker| { &m.use_count },
                |m: &mut Sticker| { &mut m.use_count },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Sticker>(
                "CMsgClientEmoticonList.Sticker",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Sticker {
        const NAME: &'static str = "Sticker";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.time_last_used = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.use_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.time_received {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.time_last_used {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.use_count {
                my_size += crate::rt::uint32_size(6, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_last_used {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.use_count {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sticker {
            Sticker::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.time_last_used = ::std::option::Option::None;
            self.use_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sticker {
            static instance: Sticker = Sticker {
                name: ::std::option::Option::None,
                count: ::std::option::Option::None,
                time_received: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                time_last_used: ::std::option::Option::None,
                use_count: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Sticker {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientEmoticonList.Sticker").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sticker {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Sticker {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientEmoticonList.Effect)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Effect {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.count)
        pub count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.time_received)
        pub time_received: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.infinite_use)
        pub infinite_use: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.appid)
        pub appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.Effect.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Effect {
        fn default() -> &'a Effect {
            <Effect as crate::Message>::default_instance()
        }
    }

    impl Effect {
        pub fn new() -> Effect {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 3;

        pub fn time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }

        // optional bool infinite_use = 4;

        pub fn infinite_use(&self) -> bool {
            self.infinite_use.unwrap_or(false)
        }

        pub fn clear_infinite_use(&mut self) {
            self.infinite_use = ::std::option::Option::None;
        }

        pub fn has_infinite_use(&self) -> bool {
            self.infinite_use.is_some()
        }

        // Param is passed by value, moved
        pub fn set_infinite_use(&mut self, v: bool) {
            self.infinite_use = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 5;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Effect| { &m.name },
                |m: &mut Effect| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &Effect| { &m.count },
                |m: &mut Effect| { &mut m.count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_received",
                |m: &Effect| { &m.time_received },
                |m: &mut Effect| { &mut m.time_received },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "infinite_use",
                |m: &Effect| { &m.infinite_use },
                |m: &mut Effect| { &mut m.infinite_use },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &Effect| { &m.appid },
                |m: &mut Effect| { &mut m.appid },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Effect>(
                "CMsgClientEmoticonList.Effect",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Effect {
        const NAME: &'static str = "Effect";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.infinite_use = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.time_received {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.infinite_use {
                my_size += 1 + 1;
            }
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(5, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.infinite_use {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Effect {
            Effect::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.infinite_use = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Effect {
            static instance: Effect = Effect {
                name: ::std::option::Option::None,
                count: ::std::option::Option::None,
                time_received: ::std::option::Option::None,
                infinite_use: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Effect {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientEmoticonList.Effect").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Effect {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Effect {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(steammessages_clientserver_friends.proto\x1a\x18steammessages_base.pr\
    oto\"\xd1\x01\n\x13CMsgClientFriendMsg\x12\x18\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamid\x12&\n\x0fchat_entry_type\x18\x02\x20\x01(\x05R\rc\
    hatEntryType\x12\x18\n\x07message\x18\x03\x20\x01(\x0cR\x07message\x128\
    \n\x18rtime32_server_timestamp\x18\x04\x20\x01(\x07R\x16rtime32ServerTim\
    estamp\x12$\n\x0eecho_to_sender\x18\x05\x20\x01(\x08R\x0cechoToSender\"\
    \xee\x01\n\x1bCMsgClientFriendMsgIncoming\x12!\n\x0csteamid_from\x18\x01\
    \x20\x01(\x06R\x0bsteamidFrom\x12&\n\x0fchat_entry_type\x18\x02\x20\x01(\
    \x05R\rchatEntryType\x120\n\x14from_limited_account\x18\x03\x20\x01(\x08\
    R\x12fromLimitedAccount\x12\x18\n\x07message\x18\x04\x20\x01(\x0cR\x07me\
    ssage\x128\n\x18rtime32_server_timestamp\x18\x05\x20\x01(\x07R\x16rtime3\
    2ServerTimestamp\"y\n\x13CMsgClientAddFriend\x12$\n\x0esteamid_to_add\
    \x18\x01\x20\x01(\x06R\x0csteamidToAdd\x12<\n\x1baccountname_or_email_to\
    _add\x18\x02\x20\x01(\tR\x17accountnameOrEmailToAdd\"\x8e\x01\n\x1bCMsgC\
    lientAddFriendResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12$\n\x0esteam_id_added\x18\x02\x20\x01(\x06R\x0csteamIdAdd\
    ed\x12,\n\x12persona_name_added\x18\x03\x20\x01(\tR\x10personaNameAdded\
    \"4\n\x16CMsgClientRemoveFriend\x12\x1a\n\x08friendid\x18\x01\x20\x01(\
    \x06R\x08friendid\"F\n\x14CMsgClientHideFriend\x12\x1a\n\x08friendid\x18\
    \x01\x20\x01(\x06R\x08friendid\x12\x12\n\x04hide\x18\x02\x20\x01(\x08R\
    \x04hide\"\xd6\x02\n\x15CMsgClientFriendsList\x12\"\n\x0cbincremental\
    \x18\x01\x20\x01(\x08R\x0cbincremental\x127\n\x07friends\x18\x02\x20\x03\
    (\x0b2\x1d.CMsgClientFriendsList.FriendR\x07friends\x12(\n\x10max_friend\
    _count\x18\x03\x20\x01(\rR\x0emaxFriendCount\x12.\n\x13active_friend_cou\
    nt\x18\x04\x20\x01(\rR\x11activeFriendCount\x12*\n\x11friends_limit_hit\
    \x18\x05\x20\x01(\x08R\x0ffriendsLimitHit\x1aZ\n\x06Friend\x12\x1e\n\nul\
    friendid\x18\x01\x20\x01(\x06R\nulfriendid\x120\n\x13efriendrelationship\
    \x18\x02\x20\x01(\rR\x13efriendrelationship\"\xa5\x03\n\x1bCMsgClientFri\
    endsGroupsList\x12\x1a\n\x08bremoval\x18\x01\x20\x01(\x08R\x08bremoval\
    \x12\"\n\x0cbincremental\x18\x02\x20\x01(\x08R\x0cbincremental\x12L\n\
    \x0cfriendGroups\x18\x03\x20\x03(\x0b2(.CMsgClientFriendsGroupsList.Frie\
    ndGroupR\x0cfriendGroups\x12U\n\x0bmemberships\x18\x04\x20\x03(\x0b23.CM\
    sgClientFriendsGroupsList.FriendGroupsMembershipR\x0bmemberships\x1aM\n\
    \x0bFriendGroup\x12\x1a\n\x08nGroupID\x18\x01\x20\x01(\x05R\x08nGroupID\
    \x12\"\n\x0cstrGroupName\x18\x02\x20\x01(\tR\x0cstrGroupName\x1aR\n\x16F\
    riendGroupsMembership\x12\x1c\n\tulSteamID\x18\x01\x20\x01(\x06R\tulStea\
    mID\x12\x1a\n\x08nGroupID\x18\x02\x20\x01(\x05R\x08nGroupID\"\xee\x01\n\
    \x1cCMsgClientPlayerNicknameList\x12\x18\n\x07removal\x18\x01\x20\x01(\
    \x08R\x07removal\x12\x20\n\x0bincremental\x18\x02\x20\x01(\x08R\x0bincre\
    mental\x12J\n\tnicknames\x18\x03\x20\x03(\x0b2,.CMsgClientPlayerNickname\
    List.PlayerNicknameR\tnicknames\x1aF\n\x0ePlayerNickname\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1a\n\x08nickname\x18\x03\x20\
    \x01(\tR\x08nickname\"S\n\x1bCMsgClientSetPlayerNickname\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1a\n\x08nickname\x18\x02\x20\
    \x01(\tR\x08nickname\"?\n#CMsgClientSetPlayerNicknameResponse\x12\x18\n\
    \x07eresult\x18\x01\x20\x01(\rR\x07eresult\"o\n\x1bCMsgClientRequestFrie\
    ndData\x126\n\x17persona_state_requested\x18\x01\x20\x01(\rR\x15personaS\
    tateRequested\x12\x18\n\x07friends\x18\x02\x20\x03(\x06R\x07friends\"\
    \xf4\x02\n\x16CMsgClientChangeStatus\x12#\n\rpersona_state\x18\x01\x20\
    \x01(\rR\x0cpersonaState\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\np\
    layerName\x123\n\x16is_auto_generated_name\x18\x03\x20\x01(\x08R\x13isAu\
    toGeneratedName\x12#\n\rhigh_priority\x18\x04\x20\x01(\x08R\x0chighPrior\
    ity\x12-\n\x13persona_set_by_user\x18\x05\x20\x01(\x08R\x10personaSetByU\
    ser\x121\n\x13persona_state_flags\x18\x06\x20\x01(\r:\x010R\x11personaSt\
    ateFlags\x122\n\x15need_persona_response\x18\x07\x20\x01(\x08R\x13needPe\
    rsonaResponse\x12$\n\x0eis_client_idle\x18\x08\x20\x01(\x08R\x0cisClient\
    Idle\"T\n\x19CMsgPersonaChangeResponse\x12\x16\n\x06result\x18\x01\x20\
    \x01(\rR\x06result\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\nplayerN\
    ame\"\xc2\x0c\n\x16CMsgClientPersonaState\x12!\n\x0cstatus_flags\x18\x01\
    \x20\x01(\rR\x0bstatusFlags\x128\n\x07friends\x18\x02\x20\x03(\x0b2\x1e.\
    CMsgClientPersonaState.FriendR\x07friends\x1a\xca\x0b\n\x06Friend\x12\
    \x1a\n\x08friendid\x18\x01\x20\x01(\x06R\x08friendid\x12#\n\rpersona_sta\
    te\x18\x02\x20\x01(\rR\x0cpersonaState\x12+\n\x12game_played_app_id\x18\
    \x03\x20\x01(\rR\x0fgamePlayedAppId\x12$\n\x0egame_server_ip\x18\x04\x20\
    \x01(\rR\x0cgameServerIp\x12(\n\x10game_server_port\x18\x05\x20\x01(\rR\
    \x0egameServerPort\x12.\n\x13persona_state_flags\x18\x06\x20\x01(\rR\x11\
    personaStateFlags\x128\n\x18online_session_instances\x18\x07\x20\x01(\rR\
    \x16onlineSessionInstances\x12-\n\x13persona_set_by_user\x18\n\x20\x01(\
    \x08R\x10personaSetByUser\x12\x1f\n\x0bplayer_name\x18\x0f\x20\x01(\tR\n\
    playerName\x12\x1d\n\nquery_port\x18\x14\x20\x01(\rR\tqueryPort\x12%\n\
    \x0esteamid_source\x18\x19\x20\x01(\x06R\rsteamidSource\x12\x1f\n\x0bava\
    tar_hash\x18\x1f\x20\x01(\x0cR\navatarHash\x12\x1f\n\x0blast_logoff\x18-\
    \x20\x01(\rR\nlastLogoff\x12\x1d\n\nlast_logon\x18.\x20\x01(\rR\tlastLog\
    on\x12(\n\x10last_seen_online\x18/\x20\x01(\rR\x0elastSeenOnline\x12\x1b\
    \n\tclan_rank\x182\x20\x01(\rR\x08clanRank\x12\x1b\n\tgame_name\x187\x20\
    \x01(\tR\x08gameName\x12\x16\n\x06gameid\x188\x20\x01(\x06R\x06gameid\
    \x12$\n\x0egame_data_blob\x18<\x20\x01(\x0cR\x0cgameDataBlob\x12D\n\tcla\
    n_data\x18@\x20\x01(\x0b2'.CMsgClientPersonaState.Friend.ClanDataR\x08cl\
    anData\x12\x19\n\x08clan_tag\x18A\x20\x01(\tR\x07clanTag\x12F\n\rrich_pr\
    esence\x18G\x20\x03(\x0b2!.CMsgClientPersonaState.Friend.KVR\x0crichPres\
    ence\x12!\n\x0cbroadcast_id\x18H\x20\x01(\x06R\x0bbroadcastId\x12\"\n\rg\
    ame_lobby_id\x18I\x20\x01(\x06R\x0bgameLobbyId\x12@\n\x1cwatching_broadc\
    ast_accountid\x18J\x20\x01(\rR\x1awatchingBroadcastAccountid\x128\n\x18w\
    atching_broadcast_appid\x18K\x20\x01(\rR\x16watchingBroadcastAppid\x12<\
    \n\x1awatching_broadcast_viewers\x18L\x20\x01(\rR\x18watchingBroadcastVi\
    ewers\x128\n\x18watching_broadcast_title\x18M\x20\x01(\tR\x16watchingBro\
    adcastTitle\x12.\n\x13is_community_banned\x18N\x20\x01(\x08R\x11isCommun\
    ityBanned\x12;\n\x1aplayer_name_pending_review\x18O\x20\x01(\x08R\x17pla\
    yerNamePendingReview\x122\n\x15avatar_pending_review\x18P\x20\x01(\x08R\
    \x13avatarPendingReview\x1aL\n\x08ClanData\x12\x1c\n\nogg_app_id\x18\x01\
    \x20\x01(\rR\x08oggAppId\x12\"\n\rchat_group_id\x18\x02\x20\x01(\x04R\
    \x0bchatGroupId\x1a,\n\x02KV\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"D\n\x1bCMsgClientFrien\
    dProfileInfo\x12%\n\x0esteamid_friend\x18\x01\x20\x01(\x06R\rsteamidFrie\
    nd\"\xbe\x02\n#CMsgClientFriendProfileInfoResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12%\n\x0esteamid_friend\x18\x02\
    \x20\x01(\x06R\rsteamidFriend\x12!\n\x0ctime_created\x18\x03\x20\x01(\rR\
    \x0btimeCreated\x12\x1b\n\treal_name\x18\x04\x20\x01(\tR\x08realName\x12\
    \x1b\n\tcity_name\x18\x05\x20\x01(\tR\x08cityName\x12\x1d\n\nstate_name\
    \x18\x06\x20\x01(\tR\tstateName\x12!\n\x0ccountry_name\x18\x07\x20\x01(\
    \tR\x0bcountryName\x12\x1a\n\x08headline\x18\x08\x20\x01(\tR\x08headline\
    \x12\x18\n\x07summary\x18\t\x20\x01(\tR\x07summary\"\x7f\n\x1cCMsgClient\
    CreateFriendsGroup\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\
    \x12\x1c\n\tgroupname\x18\x02\x20\x01(\tR\tgroupname\x12'\n\x0fsteamid_f\
    riends\x18\x03\x20\x03(\x06R\x0esteamidFriends\"Z\n$CMsgClientCreateFrie\
    ndsGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\x12\
    \x18\n\x07groupid\x18\x02\x20\x01(\x05R\x07groupid\"R\n\x1cCMsgClientDel\
    eteFriendsGroup\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\
    \x12\x18\n\x07groupid\x18\x02\x20\x01(\x05R\x07groupid\"@\n$CMsgClientDe\
    leteFriendsGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07ere\
    sult\"\xc2\x01\n\x1cCMsgClientManageFriendsGroup\x12\x18\n\x07groupid\
    \x18\x01\x20\x01(\x05R\x07groupid\x12\x1c\n\tgroupname\x18\x02\x20\x01(\
    \tR\tgroupname\x122\n\x15steamid_friends_added\x18\x03\x20\x03(\x06R\x13\
    steamidFriendsAdded\x126\n\x17steamid_friends_removed\x18\x04\x20\x03(\
    \x06R\x15steamidFriendsRemoved\"@\n$CMsgClientManageFriendsGroupResponse\
    \x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\"X\n\x1aCMsgClientA\
    ddFriendToGroup\x12\x18\n\x07groupid\x18\x01\x20\x01(\x05R\x07groupid\
    \x12\x20\n\x0bsteamiduser\x18\x02\x20\x01(\x06R\x0bsteamiduser\">\n\"CMs\
    gClientAddFriendToGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\
    \x07eresult\"]\n\x1fCMsgClientRemoveFriendFromGroup\x12\x18\n\x07groupid\
    \x18\x01\x20\x01(\x05R\x07groupid\x12\x20\n\x0bsteamiduser\x18\x02\x20\
    \x01(\x06R\x0bsteamiduser\"C\n'CMsgClientRemoveFriendFromGroupResponse\
    \x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\"\x1b\n\x19CMsgClie\
    ntGetEmoticonList\"\xcb\x05\n\x16CMsgClientEmoticonList\x12>\n\temoticon\
    s\x18\x01\x20\x03(\x0b2\x20.CMsgClientEmoticonList.EmoticonR\temoticons\
    \x12;\n\x08stickers\x18\x02\x20\x03(\x0b2\x1f.CMsgClientEmoticonList.Sti\
    ckerR\x08stickers\x128\n\x07effects\x18\x03\x20\x03(\x0b2\x1e.CMsgClient\
    EmoticonList.EffectR\x07effects\x1a\xb2\x01\n\x08Emoticon\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\
    \x05count\x12$\n\x0etime_last_used\x18\x03\x20\x01(\rR\x0ctimeLastUsed\
    \x12\x1b\n\tuse_count\x18\x04\x20\x01(\rR\x08useCount\x12#\n\rtime_recei\
    ved\x18\x05\x20\x01(\rR\x0ctimeReceived\x12\x14\n\x05appid\x18\x06\x20\
    \x01(\rR\x05appid\x1a\xb1\x01\n\x07Sticker\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12#\
    \n\rtime_received\x18\x03\x20\x01(\rR\x0ctimeReceived\x12\x14\n\x05appid\
    \x18\x04\x20\x01(\rR\x05appid\x12$\n\x0etime_last_used\x18\x05\x20\x01(\
    \rR\x0ctimeLastUsed\x12\x1b\n\tuse_count\x18\x06\x20\x01(\rR\x08useCount\
    \x1a\x90\x01\n\x06Effect\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12#\n\rtime_received\
    \x18\x03\x20\x01(\rR\x0ctimeReceived\x12!\n\x0cinfinite_use\x18\x04\x20\
    \x01(\x08R\x0binfiniteUse\x12\x14\n\x05appid\x18\x05\x20\x01(\rR\x05appi\
    dB\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(39);
            messages.push(CMsgClientFriendMsg::generated_message_descriptor_data());
            messages.push(CMsgClientFriendMsgIncoming::generated_message_descriptor_data());
            messages.push(CMsgClientAddFriend::generated_message_descriptor_data());
            messages.push(CMsgClientAddFriendResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRemoveFriend::generated_message_descriptor_data());
            messages.push(CMsgClientHideFriend::generated_message_descriptor_data());
            messages.push(CMsgClientFriendsList::generated_message_descriptor_data());
            messages.push(CMsgClientFriendsGroupsList::generated_message_descriptor_data());
            messages.push(CMsgClientPlayerNicknameList::generated_message_descriptor_data());
            messages.push(CMsgClientSetPlayerNickname::generated_message_descriptor_data());
            messages.push(CMsgClientSetPlayerNicknameResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRequestFriendData::generated_message_descriptor_data());
            messages.push(CMsgClientChangeStatus::generated_message_descriptor_data());
            messages.push(CMsgPersonaChangeResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPersonaState::generated_message_descriptor_data());
            messages.push(CMsgClientFriendProfileInfo::generated_message_descriptor_data());
            messages.push(CMsgClientFriendProfileInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientCreateFriendsGroup::generated_message_descriptor_data());
            messages.push(CMsgClientCreateFriendsGroupResponse::generated_message_descriptor_data());
            messages.push(CMsgClientDeleteFriendsGroup::generated_message_descriptor_data());
            messages.push(CMsgClientDeleteFriendsGroupResponse::generated_message_descriptor_data());
            messages.push(CMsgClientManageFriendsGroup::generated_message_descriptor_data());
            messages.push(CMsgClientManageFriendsGroupResponse::generated_message_descriptor_data());
            messages.push(CMsgClientAddFriendToGroup::generated_message_descriptor_data());
            messages.push(CMsgClientAddFriendToGroupResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRemoveFriendFromGroup::generated_message_descriptor_data());
            messages.push(CMsgClientRemoveFriendFromGroupResponse::generated_message_descriptor_data());
            messages.push(CMsgClientGetEmoticonList::generated_message_descriptor_data());
            messages.push(CMsgClientEmoticonList::generated_message_descriptor_data());
            messages.push(cmsg_client_friends_list::Friend::generated_message_descriptor_data());
            messages.push(cmsg_client_friends_groups_list::FriendGroup::generated_message_descriptor_data());
            messages.push(cmsg_client_friends_groups_list::FriendGroupsMembership::generated_message_descriptor_data());
            messages.push(cmsg_client_player_nickname_list::PlayerNickname::generated_message_descriptor_data());
            messages.push(cmsg_client_persona_state::Friend::generated_message_descriptor_data());
            messages.push(cmsg_client_persona_state::friend::ClanData::generated_message_descriptor_data());
            messages.push(cmsg_client_persona_state::friend::KV::generated_message_descriptor_data());
            messages.push(cmsg_client_emoticon_list::Emoticon::generated_message_descriptor_data());
            messages.push(cmsg_client_emoticon_list::Sticker::generated_message_descriptor_data());
            messages.push(cmsg_client_emoticon_list::Effect::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
