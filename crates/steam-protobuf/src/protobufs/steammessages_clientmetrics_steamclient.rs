// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientmetrics.steamclient.proto`

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceCreation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceCreation {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceCreation.raw_version)
    pub raw_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceCreation.requested_interface_type)
    pub requested_interface_type: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceCreation.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceCreation {
    fn default() -> &'a CClientMetrics_AppInterfaceCreation {
        <CClientMetrics_AppInterfaceCreation as crate::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceCreation {
    pub fn new() -> CClientMetrics_AppInterfaceCreation {
        ::std::default::Default::default()
    }

    // optional string raw_version = 1;

    pub fn raw_version(&self) -> &str {
        match self.raw_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_raw_version(&mut self) {
        self.raw_version = ::std::option::Option::None;
    }

    pub fn has_raw_version(&self) -> bool {
        self.raw_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_version(&mut self, v: ::std::string::String) {
        self.raw_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_version(&mut self) -> &mut ::std::string::String {
        if self.raw_version.is_none() {
            self.raw_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.raw_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_version(&mut self) -> ::std::string::String {
        self.raw_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requested_interface_type = 2;

    pub fn requested_interface_type(&self) -> &str {
        match self.requested_interface_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requested_interface_type(&mut self) {
        self.requested_interface_type = ::std::option::Option::None;
    }

    pub fn has_requested_interface_type(&self) -> bool {
        self.requested_interface_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_interface_type(&mut self, v: ::std::string::String) {
        self.requested_interface_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requested_interface_type(&mut self) -> &mut ::std::string::String {
        if self.requested_interface_type.is_none() {
            self.requested_interface_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.requested_interface_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_requested_interface_type(&mut self) -> ::std::string::String {
        self.requested_interface_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_version",
            |m: &CClientMetrics_AppInterfaceCreation| { &m.raw_version },
            |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.raw_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requested_interface_type",
            |m: &CClientMetrics_AppInterfaceCreation| { &m.requested_interface_type },
            |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.requested_interface_type },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_AppInterfaceCreation>(
            "CClientMetrics_AppInterfaceCreation",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_AppInterfaceCreation {
    const NAME: &'static str = "CClientMetrics_AppInterfaceCreation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.raw_version = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.requested_interface_type = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_version.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.raw_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceCreation {
        CClientMetrics_AppInterfaceCreation::new()
    }

    fn clear(&mut self) {
        self.raw_version = ::std::option::Option::None;
        self.requested_interface_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceCreation {
        static instance: CClientMetrics_AppInterfaceCreation = CClientMetrics_AppInterfaceCreation {
            raw_version: ::std::option::Option::None,
            requested_interface_type: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_AppInterfaceCreation {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_AppInterfaceCreation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_AppInterfaceCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_AppInterfaceCreation {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceMethodCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceMethodCounts {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.interface_name)
    pub interface_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.call_count)
    pub call_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceMethodCounts.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceMethodCounts {
    fn default() -> &'a CClientMetrics_AppInterfaceMethodCounts {
        <CClientMetrics_AppInterfaceMethodCounts as crate::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceMethodCounts {
    pub fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        ::std::default::Default::default()
    }

    // optional string interface_name = 1;

    pub fn interface_name(&self) -> &str {
        match self.interface_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interface_name(&mut self) {
        self.interface_name = ::std::option::Option::None;
    }

    pub fn has_interface_name(&self) -> bool {
        self.interface_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_name(&mut self, v: ::std::string::String) {
        self.interface_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_name(&mut self) -> &mut ::std::string::String {
        if self.interface_name.is_none() {
            self.interface_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.interface_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface_name(&mut self) -> ::std::string::String {
        self.interface_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string method_name = 2;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 call_count = 3;

    pub fn call_count(&self) -> u32 {
        self.call_count.unwrap_or(0)
    }

    pub fn clear_call_count(&mut self) {
        self.call_count = ::std::option::Option::None;
    }

    pub fn has_call_count(&self) -> bool {
        self.call_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_count(&mut self, v: u32) {
        self.call_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "interface_name",
            |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.interface_name },
            |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.interface_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_name",
            |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.method_name },
            |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.method_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "call_count",
            |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.call_count },
            |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.call_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_AppInterfaceMethodCounts>(
            "CClientMetrics_AppInterfaceMethodCounts",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_AppInterfaceMethodCounts {
    const NAME: &'static str = "CClientMetrics_AppInterfaceMethodCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.interface_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.call_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.interface_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.method_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.call_count {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.interface_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.call_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        CClientMetrics_AppInterfaceMethodCounts::new()
    }

    fn clear(&mut self) {
        self.interface_name = ::std::option::Option::None;
        self.method_name = ::std::option::Option::None;
        self.call_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceMethodCounts {
        static instance: CClientMetrics_AppInterfaceMethodCounts = CClientMetrics_AppInterfaceMethodCounts {
            interface_name: ::std::option::Option::None,
            method_name: ::std::option::Option::None,
            call_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_AppInterfaceMethodCounts {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_AppInterfaceMethodCounts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_AppInterfaceMethodCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_AppInterfaceMethodCounts {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.interfaces_created)
    pub interfaces_created: ::std::vec::Vec<CClientMetrics_AppInterfaceCreation>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.methods_called)
    pub methods_called: ::std::vec::Vec<CClientMetrics_AppInterfaceMethodCounts>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.session_length_seconds)
    pub session_length_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceStats_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceStats_Notification {
    fn default() -> &'a CClientMetrics_AppInterfaceStats_Notification {
        <CClientMetrics_AppInterfaceStats_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceStats_Notification {
    pub fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_AppInterfaceCreation interfaces_created = 2;

    pub fn interfaces_created(&self) -> &[CClientMetrics_AppInterfaceCreation] {
        &self.interfaces_created
    }

    pub fn clear_interfaces_created(&mut self) {
        self.interfaces_created.clear();
    }

    // Param is passed by value, moved
    pub fn set_interfaces_created(&mut self, v: ::std::vec::Vec<CClientMetrics_AppInterfaceCreation>) {
        self.interfaces_created = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interfaces_created(&mut self) -> &mut ::std::vec::Vec<CClientMetrics_AppInterfaceCreation> {
        &mut self.interfaces_created
    }

    // Take field
    pub fn take_interfaces_created(&mut self) -> ::std::vec::Vec<CClientMetrics_AppInterfaceCreation> {
        ::std::mem::replace(&mut self.interfaces_created, ::std::vec::Vec::new())
    }

    // repeated .CClientMetrics_AppInterfaceMethodCounts methods_called = 3;

    pub fn methods_called(&self) -> &[CClientMetrics_AppInterfaceMethodCounts] {
        &self.methods_called
    }

    pub fn clear_methods_called(&mut self) {
        self.methods_called.clear();
    }

    // Param is passed by value, moved
    pub fn set_methods_called(&mut self, v: ::std::vec::Vec<CClientMetrics_AppInterfaceMethodCounts>) {
        self.methods_called = v;
    }

    // Mutable pointer to the field.
    pub fn mut_methods_called(&mut self) -> &mut ::std::vec::Vec<CClientMetrics_AppInterfaceMethodCounts> {
        &mut self.methods_called
    }

    // Take field
    pub fn take_methods_called(&mut self) -> ::std::vec::Vec<CClientMetrics_AppInterfaceMethodCounts> {
        ::std::mem::replace(&mut self.methods_called, ::std::vec::Vec::new())
    }

    // optional uint32 session_length_seconds = 4;

    pub fn session_length_seconds(&self) -> u32 {
        self.session_length_seconds.unwrap_or(0)
    }

    pub fn clear_session_length_seconds(&mut self) {
        self.session_length_seconds = ::std::option::Option::None;
    }

    pub fn has_session_length_seconds(&self) -> bool {
        self.session_length_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_seconds(&mut self, v: u32) {
        self.session_length_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.game_id },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.game_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interfaces_created",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.interfaces_created },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.interfaces_created },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "methods_called",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.methods_called },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.methods_called },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_length_seconds",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.session_length_seconds },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.session_length_seconds },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_AppInterfaceStats_Notification>(
            "CClientMetrics_AppInterfaceStats_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_AppInterfaceStats_Notification {
    const NAME: &'static str = "CClientMetrics_AppInterfaceStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.interfaces_created.push(is.read_message()?);
                },
                26 => {
                    self.methods_called.push(is.read_message()?);
                },
                32 => {
                    self.session_length_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        for value in &self.interfaces_created {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.methods_called {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.session_length_seconds {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.interfaces_created {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.methods_called {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.session_length_seconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        CClientMetrics_AppInterfaceStats_Notification::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.interfaces_created.clear();
        self.methods_called.clear();
        self.session_length_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceStats_Notification {
        static instance: CClientMetrics_AppInterfaceStats_Notification = CClientMetrics_AppInterfaceStats_Notification {
            game_id: ::std::option::Option::None,
            interfaces_created: ::std::vec::Vec::new(),
            methods_called: ::std::vec::Vec::new(),
            session_length_seconds: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_AppInterfaceStats_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_AppInterfaceStats_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_AppInterfaceStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_AppInterfaceStats_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_IPv6Connectivity_Result)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_IPv6Connectivity_Result {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Result.protocol_tested)
    pub protocol_tested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Result.connectivity_state)
    pub connectivity_state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_IPv6Connectivity_Result.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Result {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Result {
        <CClientMetrics_IPv6Connectivity_Result as crate::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Result {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Result {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_tested = 1;

    pub fn protocol_tested(&self) -> u32 {
        self.protocol_tested.unwrap_or(0)
    }

    pub fn clear_protocol_tested(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
    }

    pub fn has_protocol_tested(&self) -> bool {
        self.protocol_tested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_tested(&mut self, v: u32) {
        self.protocol_tested = ::std::option::Option::Some(v);
    }

    // optional uint32 connectivity_state = 2;

    pub fn connectivity_state(&self) -> u32 {
        self.connectivity_state.unwrap_or(0)
    }

    pub fn clear_connectivity_state(&mut self) {
        self.connectivity_state = ::std::option::Option::None;
    }

    pub fn has_connectivity_state(&self) -> bool {
        self.connectivity_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectivity_state(&mut self, v: u32) {
        self.connectivity_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_tested",
            |m: &CClientMetrics_IPv6Connectivity_Result| { &m.protocol_tested },
            |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.protocol_tested },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectivity_state",
            |m: &CClientMetrics_IPv6Connectivity_Result| { &m.connectivity_state },
            |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.connectivity_state },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_IPv6Connectivity_Result>(
            "CClientMetrics_IPv6Connectivity_Result",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_IPv6Connectivity_Result {
    const NAME: &'static str = "CClientMetrics_IPv6Connectivity_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_tested = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.connectivity_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_tested {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.connectivity_state {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.protocol_tested {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connectivity_state {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Result {
        CClientMetrics_IPv6Connectivity_Result::new()
    }

    fn clear(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
        self.connectivity_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Result {
        static instance: CClientMetrics_IPv6Connectivity_Result = CClientMetrics_IPv6Connectivity_Result {
            protocol_tested: ::std::option::Option::None,
            connectivity_state: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_IPv6Connectivity_Result {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_IPv6Connectivity_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_IPv6Connectivity_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Result {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_IPv6Connectivity_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_IPv6Connectivity_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.results)
    pub results: ::std::vec::Vec<CClientMetrics_IPv6Connectivity_Result>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.private_ip_is_rfc6598)
    pub private_ip_is_rfc6598: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_IPv6Connectivity_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Notification {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Notification {
        <CClientMetrics_IPv6Connectivity_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Notification {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_IPv6Connectivity_Result results = 2;

    pub fn results(&self) -> &[CClientMetrics_IPv6Connectivity_Result] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<CClientMetrics_IPv6Connectivity_Result>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<CClientMetrics_IPv6Connectivity_Result> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<CClientMetrics_IPv6Connectivity_Result> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    // optional bool private_ip_is_rfc6598 = 3;

    pub fn private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.unwrap_or(false)
    }

    pub fn clear_private_ip_is_rfc6598(&mut self) {
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
    }

    pub fn has_private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_ip_is_rfc6598(&mut self, v: bool) {
        self.private_ip_is_rfc6598 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.cell_id },
            |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.cell_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.results },
            |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.results },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "private_ip_is_rfc6598",
            |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.private_ip_is_rfc6598 },
            |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.private_ip_is_rfc6598 },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_IPv6Connectivity_Notification>(
            "CClientMetrics_IPv6Connectivity_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_IPv6Connectivity_Notification {
    const NAME: &'static str = "CClientMetrics_IPv6Connectivity_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                24 => {
                    self.private_ip_is_rfc6598 = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        CClientMetrics_IPv6Connectivity_Notification::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.results.clear();
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Notification {
        static instance: CClientMetrics_IPv6Connectivity_Notification = CClientMetrics_IPv6Connectivity_Notification {
            cell_id: ::std::option::Option::None,
            results: ::std::vec::Vec::new(),
            private_ip_is_rfc6598: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_IPv6Connectivity_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_IPv6Connectivity_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_IPv6Connectivity_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_SteamPipeWorkStats_Operation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_SteamPipeWorkStats_Operation {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<ESteamPipeOperationType>>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.num_ops)
    pub num_ops: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.num_bytes)
    pub num_bytes: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.busy_time_ms)
    pub busy_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.idle_time_ms)
    pub idle_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.sum_run_time_ms)
    pub sum_run_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.sum_wait_time_ms)
    pub sum_wait_time_ms: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_SteamPipeWorkStats_Operation.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Operation {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Operation {
        <CClientMetrics_SteamPipeWorkStats_Operation as crate::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Operation {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        ::std::default::Default::default()
    }

    // optional .ESteamPipeOperationType type = 1;

    pub fn type_(&self) -> ESteamPipeOperationType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            None => ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESteamPipeOperationType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 num_ops = 2;

    pub fn num_ops(&self) -> u32 {
        self.num_ops.unwrap_or(0)
    }

    pub fn clear_num_ops(&mut self) {
        self.num_ops = ::std::option::Option::None;
    }

    pub fn has_num_ops(&self) -> bool {
        self.num_ops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_ops(&mut self, v: u32) {
        self.num_ops = ::std::option::Option::Some(v);
    }

    // optional uint64 num_bytes = 3;

    pub fn num_bytes(&self) -> u64 {
        self.num_bytes.unwrap_or(0)
    }

    pub fn clear_num_bytes(&mut self) {
        self.num_bytes = ::std::option::Option::None;
    }

    pub fn has_num_bytes(&self) -> bool {
        self.num_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bytes(&mut self, v: u64) {
        self.num_bytes = ::std::option::Option::Some(v);
    }

    // optional uint64 busy_time_ms = 4;

    pub fn busy_time_ms(&self) -> u64 {
        self.busy_time_ms.unwrap_or(0)
    }

    pub fn clear_busy_time_ms(&mut self) {
        self.busy_time_ms = ::std::option::Option::None;
    }

    pub fn has_busy_time_ms(&self) -> bool {
        self.busy_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_busy_time_ms(&mut self, v: u64) {
        self.busy_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 idle_time_ms = 5;

    pub fn idle_time_ms(&self) -> u64 {
        self.idle_time_ms.unwrap_or(0)
    }

    pub fn clear_idle_time_ms(&mut self) {
        self.idle_time_ms = ::std::option::Option::None;
    }

    pub fn has_idle_time_ms(&self) -> bool {
        self.idle_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_time_ms(&mut self, v: u64) {
        self.idle_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_run_time_ms = 6;

    pub fn sum_run_time_ms(&self) -> u64 {
        self.sum_run_time_ms.unwrap_or(0)
    }

    pub fn clear_sum_run_time_ms(&mut self) {
        self.sum_run_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_run_time_ms(&self) -> bool {
        self.sum_run_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_run_time_ms(&mut self, v: u64) {
        self.sum_run_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_wait_time_ms = 7;

    pub fn sum_wait_time_ms(&self) -> u64 {
        self.sum_wait_time_ms.unwrap_or(0)
    }

    pub fn clear_sum_wait_time_ms(&mut self) {
        self.sum_wait_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_wait_time_ms(&self) -> bool {
        self.sum_wait_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_wait_time_ms(&mut self, v: u64) {
        self.sum_wait_time_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.type_ },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_ops",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.num_ops },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.num_ops },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_bytes",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.num_bytes },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.num_bytes },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "busy_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.busy_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.busy_time_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.idle_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.idle_time_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum_run_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.sum_run_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.sum_run_time_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum_wait_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.sum_wait_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.sum_wait_time_ms },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_SteamPipeWorkStats_Operation>(
            "CClientMetrics_SteamPipeWorkStats_Operation",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_SteamPipeWorkStats_Operation {
    const NAME: &'static str = "CClientMetrics_SteamPipeWorkStats_Operation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.num_ops = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_bytes = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.busy_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.idle_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.sum_run_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.sum_wait_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.num_ops {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_bytes {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.busy_time_ms {
            my_size += crate::rt::uint64_size(4, v);
        }
        if let Some(v) = self.idle_time_ms {
            my_size += crate::rt::uint64_size(5, v);
        }
        if let Some(v) = self.sum_run_time_ms {
            my_size += crate::rt::uint64_size(6, v);
        }
        if let Some(v) = self.sum_wait_time_ms {
            my_size += crate::rt::uint64_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.num_ops {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_bytes {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.busy_time_ms {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.idle_time_ms {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.sum_run_time_ms {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.sum_wait_time_ms {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        CClientMetrics_SteamPipeWorkStats_Operation::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.num_ops = ::std::option::Option::None;
        self.num_bytes = ::std::option::Option::None;
        self.busy_time_ms = ::std::option::Option::None;
        self.idle_time_ms = ::std::option::Option::None;
        self.sum_run_time_ms = ::std::option::Option::None;
        self.sum_wait_time_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Operation {
        static instance: CClientMetrics_SteamPipeWorkStats_Operation = CClientMetrics_SteamPipeWorkStats_Operation {
            type_: ::std::option::Option::None,
            num_ops: ::std::option::Option::None,
            num_bytes: ::std::option::Option::None,
            busy_time_ms: ::std::option::Option::None,
            idle_time_ms: ::std::option::Option::None,
            sum_run_time_ms: ::std::option::Option::None,
            sum_wait_time_ms: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_SteamPipeWorkStats_Operation {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_SteamPipeWorkStats_Operation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_SteamPipeWorkStats_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_SteamPipeWorkStats_Operation {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_SteamPipeWorkStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_SteamPipeWorkStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.depotid)
    pub depotid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.work_type)
    pub work_type: ::std::option::Option<crate::EnumOrUnknown<ESteamPipeWorkType>>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.operations)
    pub operations: ::std::vec::Vec<CClientMetrics_SteamPipeWorkStats_Operation>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.hardware_type)
    pub hardware_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_SteamPipeWorkStats_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Notification {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Notification {
        <CClientMetrics_SteamPipeWorkStats_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Notification {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 depotid = 2;

    pub fn depotid(&self) -> u32 {
        self.depotid.unwrap_or(0)
    }

    pub fn clear_depotid(&mut self) {
        self.depotid = ::std::option::Option::None;
    }

    pub fn has_depotid(&self) -> bool {
        self.depotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depotid(&mut self, v: u32) {
        self.depotid = ::std::option::Option::Some(v);
    }

    // optional .ESteamPipeWorkType work_type = 3;

    pub fn work_type(&self) -> ESteamPipeWorkType {
        match self.work_type {
            Some(e) => e.enum_value_or(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            None => ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid,
        }
    }

    pub fn clear_work_type(&mut self) {
        self.work_type = ::std::option::Option::None;
    }

    pub fn has_work_type(&self) -> bool {
        self.work_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_work_type(&mut self, v: ESteamPipeWorkType) {
        self.work_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // repeated .CClientMetrics_SteamPipeWorkStats_Operation operations = 4;

    pub fn operations(&self) -> &[CClientMetrics_SteamPipeWorkStats_Operation] {
        &self.operations
    }

    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::std::vec::Vec<CClientMetrics_SteamPipeWorkStats_Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::std::vec::Vec<CClientMetrics_SteamPipeWorkStats_Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::std::vec::Vec<CClientMetrics_SteamPipeWorkStats_Operation> {
        ::std::mem::replace(&mut self.operations, ::std::vec::Vec::new())
    }

    // optional uint32 hardware_type = 5;

    pub fn hardware_type(&self) -> u32 {
        self.hardware_type.unwrap_or(0)
    }

    pub fn clear_hardware_type(&mut self) {
        self.hardware_type = ::std::option::Option::None;
    }

    pub fn has_hardware_type(&self) -> bool {
        self.hardware_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hardware_type(&mut self, v: u32) {
        self.hardware_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.appid },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "depotid",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.depotid },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.depotid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "work_type",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.work_type },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.work_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operations",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.operations },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.operations },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hardware_type",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.hardware_type },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.hardware_type },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_SteamPipeWorkStats_Notification>(
            "CClientMetrics_SteamPipeWorkStats_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_SteamPipeWorkStats_Notification {
    const NAME: &'static str = "CClientMetrics_SteamPipeWorkStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.depotid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.work_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.operations.push(is.read_message()?);
                },
                40 => {
                    self.hardware_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.depotid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.work_type {
            my_size += crate::rt::int32_size(3, v.value());
        }
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hardware_type {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.depotid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.work_type {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        for v in &self.operations {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.hardware_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        CClientMetrics_SteamPipeWorkStats_Notification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.depotid = ::std::option::Option::None;
        self.work_type = ::std::option::Option::None;
        self.operations.clear();
        self.hardware_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Notification {
        static instance: CClientMetrics_SteamPipeWorkStats_Notification = CClientMetrics_SteamPipeWorkStats_Notification {
            appid: ::std::option::Option::None,
            depotid: ::std::option::Option::None,
            work_type: ::std::option::Option::None,
            operations: ::std::vec::Vec::new(),
            hardware_type: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_SteamPipeWorkStats_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_SteamPipeWorkStats_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_SteamPipeWorkStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_SteamPipeWorkStats_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ReportReactUsage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.routes)
    pub routes: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::RouteData>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.components)
    pub components: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ComponentData>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.actions)
    pub actions: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ActionData>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportReactUsage_Notification {
    fn default() -> &'a CClientMetrics_ReportReactUsage_Notification {
        <CClientMetrics_ReportReactUsage_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_ReportReactUsage_Notification {
    pub fn new() -> CClientMetrics_ReportReactUsage_Notification {
        ::std::default::Default::default()
    }

    // optional string product = 1;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CClientMetrics_ReportReactUsage_Notification.RouteData routes = 3;

    pub fn routes(&self) -> &[cclient_metrics_report_react_usage_notification::RouteData] {
        &self.routes
    }

    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::RouteData>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<cclient_metrics_report_react_usage_notification::RouteData> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<cclient_metrics_report_react_usage_notification::RouteData> {
        ::std::mem::replace(&mut self.routes, ::std::vec::Vec::new())
    }

    // repeated .CClientMetrics_ReportReactUsage_Notification.ComponentData components = 4;

    pub fn components(&self) -> &[cclient_metrics_report_react_usage_notification::ComponentData] {
        &self.components
    }

    pub fn clear_components(&mut self) {
        self.components.clear();
    }

    // Param is passed by value, moved
    pub fn set_components(&mut self, v: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ComponentData>) {
        self.components = v;
    }

    // Mutable pointer to the field.
    pub fn mut_components(&mut self) -> &mut ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ComponentData> {
        &mut self.components
    }

    // Take field
    pub fn take_components(&mut self) -> ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ComponentData> {
        ::std::mem::replace(&mut self.components, ::std::vec::Vec::new())
    }

    // repeated .CClientMetrics_ReportReactUsage_Notification.ActionData actions = 5;

    pub fn actions(&self) -> &[cclient_metrics_report_react_usage_notification::ActionData] {
        &self.actions
    }

    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ActionData>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ActionData> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ActionData> {
        ::std::mem::replace(&mut self.actions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &CClientMetrics_ReportReactUsage_Notification| { &m.product },
            |m: &mut CClientMetrics_ReportReactUsage_Notification| { &mut m.product },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CClientMetrics_ReportReactUsage_Notification| { &m.version },
            |m: &mut CClientMetrics_ReportReactUsage_Notification| { &mut m.version },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "routes",
            |m: &CClientMetrics_ReportReactUsage_Notification| { &m.routes },
            |m: &mut CClientMetrics_ReportReactUsage_Notification| { &mut m.routes },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "components",
            |m: &CClientMetrics_ReportReactUsage_Notification| { &m.components },
            |m: &mut CClientMetrics_ReportReactUsage_Notification| { &mut m.components },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &CClientMetrics_ReportReactUsage_Notification| { &m.actions },
            |m: &mut CClientMetrics_ReportReactUsage_Notification| { &mut m.actions },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ReportReactUsage_Notification>(
            "CClientMetrics_ReportReactUsage_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_ReportReactUsage_Notification {
    const NAME: &'static str = "CClientMetrics_ReportReactUsage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.routes.push(is.read_message()?);
                },
                34 => {
                    self.components.push(is.read_message()?);
                },
                42 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.components {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.product.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.routes {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.components {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.actions {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ReportReactUsage_Notification {
        CClientMetrics_ReportReactUsage_Notification::new()
    }

    fn clear(&mut self) {
        self.product = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.routes.clear();
        self.components.clear();
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ReportReactUsage_Notification {
        static instance: CClientMetrics_ReportReactUsage_Notification = CClientMetrics_ReportReactUsage_Notification {
            product: ::std::option::Option::None,
            version: ::std::option::Option::None,
            routes: ::std::vec::Vec::new(),
            components: ::std::vec::Vec::new(),
            actions: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_ReportReactUsage_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ReportReactUsage_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ReportReactUsage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_ReportReactUsage_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CClientMetrics_ReportReactUsage_Notification`
pub mod cclient_metrics_report_react_usage_notification {
    // @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification.RouteData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RouteData {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.RouteData.route)
        pub route: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.RouteData.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.RouteData.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RouteData {
        fn default() -> &'a RouteData {
            <RouteData as crate::Message>::default_instance()
        }
    }

    impl RouteData {
        pub fn new() -> RouteData {
            ::std::default::Default::default()
        }

        // optional string route = 1;

        pub fn route(&self) -> &str {
            match self.route.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_route(&mut self) {
            self.route = ::std::option::Option::None;
        }

        pub fn has_route(&self) -> bool {
            self.route.is_some()
        }

        // Param is passed by value, moved
        pub fn set_route(&mut self, v: ::std::string::String) {
            self.route = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_route(&mut self) -> &mut ::std::string::String {
            if self.route.is_none() {
                self.route = ::std::option::Option::Some(::std::string::String::new());
            }
            self.route.as_mut().unwrap()
        }

        // Take field
        pub fn take_route(&mut self) -> ::std::string::String {
            self.route.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "route",
                |m: &RouteData| { &m.route },
                |m: &mut RouteData| { &mut m.route },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &RouteData| { &m.count },
                |m: &mut RouteData| { &mut m.count },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<RouteData>(
                "CClientMetrics_ReportReactUsage_Notification.RouteData",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for RouteData {
        const NAME: &'static str = "RouteData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.route = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.route.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.route.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RouteData {
            RouteData::new()
        }

        fn clear(&mut self) {
            self.route = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RouteData {
            static instance: RouteData = RouteData {
                route: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for RouteData {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CClientMetrics_ReportReactUsage_Notification.RouteData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RouteData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for RouteData {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification.ComponentData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ComponentData {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ComponentData.component)
        pub component: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ComponentData.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.ComponentData.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ComponentData {
        fn default() -> &'a ComponentData {
            <ComponentData as crate::Message>::default_instance()
        }
    }

    impl ComponentData {
        pub fn new() -> ComponentData {
            ::std::default::Default::default()
        }

        // optional string component = 1;

        pub fn component(&self) -> &str {
            match self.component.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_component(&mut self) {
            self.component = ::std::option::Option::None;
        }

        pub fn has_component(&self) -> bool {
            self.component.is_some()
        }

        // Param is passed by value, moved
        pub fn set_component(&mut self, v: ::std::string::String) {
            self.component = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_component(&mut self) -> &mut ::std::string::String {
            if self.component.is_none() {
                self.component = ::std::option::Option::Some(::std::string::String::new());
            }
            self.component.as_mut().unwrap()
        }

        // Take field
        pub fn take_component(&mut self) -> ::std::string::String {
            self.component.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "component",
                |m: &ComponentData| { &m.component },
                |m: &mut ComponentData| { &mut m.component },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &ComponentData| { &m.count },
                |m: &mut ComponentData| { &mut m.count },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ComponentData>(
                "CClientMetrics_ReportReactUsage_Notification.ComponentData",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ComponentData {
        const NAME: &'static str = "ComponentData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.component = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.component.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.component.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ComponentData {
            ComponentData::new()
        }

        fn clear(&mut self) {
            self.component = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ComponentData {
            static instance: ComponentData = ComponentData {
                component: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ComponentData {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CClientMetrics_ReportReactUsage_Notification.ComponentData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ComponentData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ComponentData {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification.ActionData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ActionData {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ActionData.action)
        pub action: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ActionData.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.ActionData.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ActionData {
        fn default() -> &'a ActionData {
            <ActionData as crate::Message>::default_instance()
        }
    }

    impl ActionData {
        pub fn new() -> ActionData {
            ::std::default::Default::default()
        }

        // optional string action = 1;

        pub fn action(&self) -> &str {
            match self.action.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_action(&mut self) {
            self.action = ::std::option::Option::None;
        }

        pub fn has_action(&self) -> bool {
            self.action.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action(&mut self, v: ::std::string::String) {
            self.action = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_action(&mut self) -> &mut ::std::string::String {
            if self.action.is_none() {
                self.action = ::std::option::Option::Some(::std::string::String::new());
            }
            self.action.as_mut().unwrap()
        }

        // Take field
        pub fn take_action(&mut self) -> ::std::string::String {
            self.action.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "action",
                |m: &ActionData| { &m.action },
                |m: &mut ActionData| { &mut m.action },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &ActionData| { &m.count },
                |m: &mut ActionData| { &mut m.count },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ActionData>(
                "CClientMetrics_ReportReactUsage_Notification.ActionData",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ActionData {
        const NAME: &'static str = "ActionData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.action = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.action.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.action.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ActionData {
            ActionData::new()
        }

        fn clear(&mut self) {
            self.action = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ActionData {
            static instance: ActionData = ActionData {
                action: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ActionData {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CClientMetrics_ReportReactUsage_Notification.ActionData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ActionData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ActionData {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ReportClientError_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ReportClientError_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.errors)
    pub errors: ::std::vec::Vec<cclient_metrics_report_client_error_notification::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientError_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportClientError_Notification {
    fn default() -> &'a CClientMetrics_ReportClientError_Notification {
        <CClientMetrics_ReportClientError_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_ReportClientError_Notification {
    pub fn new() -> CClientMetrics_ReportClientError_Notification {
        ::std::default::Default::default()
    }

    // optional string product = 1;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CClientMetrics_ReportClientError_Notification.Error errors = 3;

    pub fn errors(&self) -> &[cclient_metrics_report_client_error_notification::Error] {
        &self.errors
    }

    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::std::vec::Vec<cclient_metrics_report_client_error_notification::Error>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::std::vec::Vec<cclient_metrics_report_client_error_notification::Error> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::std::vec::Vec<cclient_metrics_report_client_error_notification::Error> {
        ::std::mem::replace(&mut self.errors, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &CClientMetrics_ReportClientError_Notification| { &m.product },
            |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.product },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CClientMetrics_ReportClientError_Notification| { &m.version },
            |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.version },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "errors",
            |m: &CClientMetrics_ReportClientError_Notification| { &m.errors },
            |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.errors },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ReportClientError_Notification>(
            "CClientMetrics_ReportClientError_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_ReportClientError_Notification {
    const NAME: &'static str = "CClientMetrics_ReportClientError_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.errors.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.product.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.errors {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ReportClientError_Notification {
        CClientMetrics_ReportClientError_Notification::new()
    }

    fn clear(&mut self) {
        self.product = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.errors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ReportClientError_Notification {
        static instance: CClientMetrics_ReportClientError_Notification = CClientMetrics_ReportClientError_Notification {
            product: ::std::option::Option::None,
            version: ::std::option::Option::None,
            errors: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_ReportClientError_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ReportClientError_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ReportClientError_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_ReportClientError_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CClientMetrics_ReportClientError_Notification`
pub mod cclient_metrics_report_client_error_notification {
    // @@protoc_insertion_point(message:CClientMetrics_ReportClientError_Notification.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.identifier)
        pub identifier: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientError_Notification.Error.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as crate::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }

        // optional string identifier = 1;

        pub fn identifier(&self) -> &str {
            match self.identifier.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_identifier(&mut self) {
            self.identifier = ::std::option::Option::None;
        }

        pub fn has_identifier(&self) -> bool {
            self.identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_identifier(&mut self, v: ::std::string::String) {
            self.identifier = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
            if self.identifier.is_none() {
                self.identifier = ::std::option::Option::Some(::std::string::String::new());
            }
            self.identifier.as_mut().unwrap()
        }

        // Take field
        pub fn take_identifier(&mut self) -> ::std::string::String {
            self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string message = 2;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 3;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "identifier",
                |m: &Error| { &m.identifier },
                |m: &mut Error| { &mut m.identifier },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &Error| { &m.message },
                |m: &mut Error| { &mut m.message },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &Error| { &m.count },
                |m: &mut Error| { &mut m.count },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Error>(
                "CClientMetrics_ReportClientError_Notification.Error",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.identifier = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.identifier.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.count {
                my_size += crate::rt::uint32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.identifier.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.identifier = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                identifier: ::std::option::Option::None,
                message: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Error {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CClientMetrics_ReportClientError_Notification.Error").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Error {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ClientBootstrap_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ClientBootstrap_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ClientBootstrap_Notification.summary)
    pub summary: crate::MessageField<super::clientmetrics::CClientMetrics_ClientBootstrap_Summary>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ClientBootstrap_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ClientBootstrap_Notification {
    fn default() -> &'a CClientMetrics_ClientBootstrap_Notification {
        <CClientMetrics_ClientBootstrap_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_ClientBootstrap_Notification {
    pub fn new() -> CClientMetrics_ClientBootstrap_Notification {
        ::std::default::Default::default()
    }

    // optional .CClientMetrics_ClientBootstrap_Summary summary = 1;

    pub fn summary(&self) -> &super::clientmetrics::CClientMetrics_ClientBootstrap_Summary {
        self.summary.as_ref().unwrap_or_else(|| <super::clientmetrics::CClientMetrics_ClientBootstrap_Summary as crate::Message>::default_instance())
    }

    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: super::clientmetrics::CClientMetrics_ClientBootstrap_Summary) {
        self.summary = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut super::clientmetrics::CClientMetrics_ClientBootstrap_Summary {
        self.summary.mut_or_insert_default()
    }

    // Take field
    pub fn take_summary(&mut self) -> super::clientmetrics::CClientMetrics_ClientBootstrap_Summary {
        self.summary.take().unwrap_or_else(|| super::clientmetrics::CClientMetrics_ClientBootstrap_Summary::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::clientmetrics::CClientMetrics_ClientBootstrap_Summary>(
            "summary",
            |m: &CClientMetrics_ClientBootstrap_Notification| { &m.summary },
            |m: &mut CClientMetrics_ClientBootstrap_Notification| { &mut m.summary },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ClientBootstrap_Notification>(
            "CClientMetrics_ClientBootstrap_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_ClientBootstrap_Notification {
    const NAME: &'static str = "CClientMetrics_ClientBootstrap_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.summary.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ClientBootstrap_Notification {
        CClientMetrics_ClientBootstrap_Notification::new()
    }

    fn clear(&mut self) {
        self.summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ClientBootstrap_Notification {
        static instance: CClientMetrics_ClientBootstrap_Notification = CClientMetrics_ClientBootstrap_Notification {
            summary: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_ClientBootstrap_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ClientBootstrap_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ClientBootstrap_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_ClientBootstrap_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_DownloadRates_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_DownloadRates_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.stats)
    pub stats: ::std::vec::Vec<cclient_metrics_download_rates_notification::StatsInfo>,
    // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.throttling_kbps)
    pub throttling_kbps: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_DownloadRates_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_DownloadRates_Notification {
    fn default() -> &'a CClientMetrics_DownloadRates_Notification {
        <CClientMetrics_DownloadRates_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_DownloadRates_Notification {
    pub fn new() -> CClientMetrics_DownloadRates_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_DownloadRates_Notification.StatsInfo stats = 2;

    pub fn stats(&self) -> &[cclient_metrics_download_rates_notification::StatsInfo] {
        &self.stats
    }

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::vec::Vec<cclient_metrics_download_rates_notification::StatsInfo>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::vec::Vec<cclient_metrics_download_rates_notification::StatsInfo> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::vec::Vec<cclient_metrics_download_rates_notification::StatsInfo> {
        ::std::mem::replace(&mut self.stats, ::std::vec::Vec::new())
    }

    // optional uint32 throttling_kbps = 3;

    pub fn throttling_kbps(&self) -> u32 {
        self.throttling_kbps.unwrap_or(0)
    }

    pub fn clear_throttling_kbps(&mut self) {
        self.throttling_kbps = ::std::option::Option::None;
    }

    pub fn has_throttling_kbps(&self) -> bool {
        self.throttling_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_kbps(&mut self, v: u32) {
        self.throttling_kbps = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CClientMetrics_DownloadRates_Notification| { &m.cell_id },
            |m: &mut CClientMetrics_DownloadRates_Notification| { &mut m.cell_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CClientMetrics_DownloadRates_Notification| { &m.stats },
            |m: &mut CClientMetrics_DownloadRates_Notification| { &mut m.stats },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "throttling_kbps",
            |m: &CClientMetrics_DownloadRates_Notification| { &m.throttling_kbps },
            |m: &mut CClientMetrics_DownloadRates_Notification| { &mut m.throttling_kbps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_DownloadRates_Notification>(
            "CClientMetrics_DownloadRates_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_DownloadRates_Notification {
    const NAME: &'static str = "CClientMetrics_DownloadRates_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                24 => {
                    self.throttling_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.throttling_kbps {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.throttling_kbps {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_DownloadRates_Notification {
        CClientMetrics_DownloadRates_Notification::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.stats.clear();
        self.throttling_kbps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_DownloadRates_Notification {
        static instance: CClientMetrics_DownloadRates_Notification = CClientMetrics_DownloadRates_Notification {
            cell_id: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            throttling_kbps: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_DownloadRates_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_DownloadRates_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_DownloadRates_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_DownloadRates_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CClientMetrics_DownloadRates_Notification`
pub mod cclient_metrics_download_rates_notification {
    // @@protoc_insertion_point(message:CClientMetrics_DownloadRates_Notification.StatsInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatsInfo {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.source_type)
        pub source_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.source_id)
        pub source_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.bytes)
        pub bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.host_name)
        pub host_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.microseconds)
        pub microseconds: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.used_ipv6)
        pub used_ipv6: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.proxied)
        pub proxied: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.used_http2)
        pub used_http2: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.cache_hits)
        pub cache_hits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.cache_misses)
        pub cache_misses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.hit_bytes)
        pub hit_bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.miss_bytes)
        pub miss_bytes: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_DownloadRates_Notification.StatsInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsInfo {
        fn default() -> &'a StatsInfo {
            <StatsInfo as crate::Message>::default_instance()
        }
    }

    impl StatsInfo {
        pub fn new() -> StatsInfo {
            ::std::default::Default::default()
        }

        // optional uint32 source_type = 1;

        pub fn source_type(&self) -> u32 {
            self.source_type.unwrap_or(0)
        }

        pub fn clear_source_type(&mut self) {
            self.source_type = ::std::option::Option::None;
        }

        pub fn has_source_type(&self) -> bool {
            self.source_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_type(&mut self, v: u32) {
            self.source_type = ::std::option::Option::Some(v);
        }

        // optional uint32 source_id = 2;

        pub fn source_id(&self) -> u32 {
            self.source_id.unwrap_or(0)
        }

        pub fn clear_source_id(&mut self) {
            self.source_id = ::std::option::Option::None;
        }

        pub fn has_source_id(&self) -> bool {
            self.source_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_id(&mut self, v: u32) {
            self.source_id = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes = 3;

        pub fn bytes(&self) -> u64 {
            self.bytes.unwrap_or(0)
        }

        pub fn clear_bytes(&mut self) {
            self.bytes = ::std::option::Option::None;
        }

        pub fn has_bytes(&self) -> bool {
            self.bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes(&mut self, v: u64) {
            self.bytes = ::std::option::Option::Some(v);
        }

        // optional string host_name = 4;

        pub fn host_name(&self) -> &str {
            match self.host_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_host_name(&mut self) {
            self.host_name = ::std::option::Option::None;
        }

        pub fn has_host_name(&self) -> bool {
            self.host_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_host_name(&mut self, v: ::std::string::String) {
            self.host_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
            if self.host_name.is_none() {
                self.host_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.host_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_host_name(&mut self) -> ::std::string::String {
            self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 microseconds = 5;

        pub fn microseconds(&self) -> u64 {
            self.microseconds.unwrap_or(0)
        }

        pub fn clear_microseconds(&mut self) {
            self.microseconds = ::std::option::Option::None;
        }

        pub fn has_microseconds(&self) -> bool {
            self.microseconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_microseconds(&mut self, v: u64) {
            self.microseconds = ::std::option::Option::Some(v);
        }

        // optional bool used_ipv6 = 6;

        pub fn used_ipv6(&self) -> bool {
            self.used_ipv6.unwrap_or(false)
        }

        pub fn clear_used_ipv6(&mut self) {
            self.used_ipv6 = ::std::option::Option::None;
        }

        pub fn has_used_ipv6(&self) -> bool {
            self.used_ipv6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_ipv6(&mut self, v: bool) {
            self.used_ipv6 = ::std::option::Option::Some(v);
        }

        // optional bool proxied = 7;

        pub fn proxied(&self) -> bool {
            self.proxied.unwrap_or(false)
        }

        pub fn clear_proxied(&mut self) {
            self.proxied = ::std::option::Option::None;
        }

        pub fn has_proxied(&self) -> bool {
            self.proxied.is_some()
        }

        // Param is passed by value, moved
        pub fn set_proxied(&mut self, v: bool) {
            self.proxied = ::std::option::Option::Some(v);
        }

        // optional bool used_http2 = 8;

        pub fn used_http2(&self) -> bool {
            self.used_http2.unwrap_or(false)
        }

        pub fn clear_used_http2(&mut self) {
            self.used_http2 = ::std::option::Option::None;
        }

        pub fn has_used_http2(&self) -> bool {
            self.used_http2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_http2(&mut self, v: bool) {
            self.used_http2 = ::std::option::Option::Some(v);
        }

        // optional uint32 cache_hits = 9;

        pub fn cache_hits(&self) -> u32 {
            self.cache_hits.unwrap_or(0)
        }

        pub fn clear_cache_hits(&mut self) {
            self.cache_hits = ::std::option::Option::None;
        }

        pub fn has_cache_hits(&self) -> bool {
            self.cache_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cache_hits(&mut self, v: u32) {
            self.cache_hits = ::std::option::Option::Some(v);
        }

        // optional uint32 cache_misses = 10;

        pub fn cache_misses(&self) -> u32 {
            self.cache_misses.unwrap_or(0)
        }

        pub fn clear_cache_misses(&mut self) {
            self.cache_misses = ::std::option::Option::None;
        }

        pub fn has_cache_misses(&self) -> bool {
            self.cache_misses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cache_misses(&mut self, v: u32) {
            self.cache_misses = ::std::option::Option::Some(v);
        }

        // optional uint64 hit_bytes = 11;

        pub fn hit_bytes(&self) -> u64 {
            self.hit_bytes.unwrap_or(0)
        }

        pub fn clear_hit_bytes(&mut self) {
            self.hit_bytes = ::std::option::Option::None;
        }

        pub fn has_hit_bytes(&self) -> bool {
            self.hit_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hit_bytes(&mut self, v: u64) {
            self.hit_bytes = ::std::option::Option::Some(v);
        }

        // optional uint64 miss_bytes = 12;

        pub fn miss_bytes(&self) -> u64 {
            self.miss_bytes.unwrap_or(0)
        }

        pub fn clear_miss_bytes(&mut self) {
            self.miss_bytes = ::std::option::Option::None;
        }

        pub fn has_miss_bytes(&self) -> bool {
            self.miss_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_miss_bytes(&mut self, v: u64) {
            self.miss_bytes = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_type",
                |m: &StatsInfo| { &m.source_type },
                |m: &mut StatsInfo| { &mut m.source_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_id",
                |m: &StatsInfo| { &m.source_id },
                |m: &mut StatsInfo| { &mut m.source_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes",
                |m: &StatsInfo| { &m.bytes },
                |m: &mut StatsInfo| { &mut m.bytes },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "host_name",
                |m: &StatsInfo| { &m.host_name },
                |m: &mut StatsInfo| { &mut m.host_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "microseconds",
                |m: &StatsInfo| { &m.microseconds },
                |m: &mut StatsInfo| { &mut m.microseconds },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "used_ipv6",
                |m: &StatsInfo| { &m.used_ipv6 },
                |m: &mut StatsInfo| { &mut m.used_ipv6 },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "proxied",
                |m: &StatsInfo| { &m.proxied },
                |m: &mut StatsInfo| { &mut m.proxied },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "used_http2",
                |m: &StatsInfo| { &m.used_http2 },
                |m: &mut StatsInfo| { &mut m.used_http2 },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "cache_hits",
                |m: &StatsInfo| { &m.cache_hits },
                |m: &mut StatsInfo| { &mut m.cache_hits },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "cache_misses",
                |m: &StatsInfo| { &m.cache_misses },
                |m: &mut StatsInfo| { &mut m.cache_misses },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "hit_bytes",
                |m: &StatsInfo| { &m.hit_bytes },
                |m: &mut StatsInfo| { &mut m.hit_bytes },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "miss_bytes",
                |m: &StatsInfo| { &m.miss_bytes },
                |m: &mut StatsInfo| { &mut m.miss_bytes },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<StatsInfo>(
                "CClientMetrics_DownloadRates_Notification.StatsInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for StatsInfo {
        const NAME: &'static str = "StatsInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.source_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.host_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.microseconds = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.used_ipv6 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.proxied = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.used_http2 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.cache_hits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.cache_misses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.hit_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    96 => {
                        self.miss_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_type {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.source_id {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.bytes {
                my_size += crate::rt::uint64_size(3, v);
            }
            if let Some(v) = self.host_name.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.microseconds {
                my_size += crate::rt::uint64_size(5, v);
            }
            if let Some(v) = self.used_ipv6 {
                my_size += 1 + 1;
            }
            if let Some(v) = self.proxied {
                my_size += 1 + 1;
            }
            if let Some(v) = self.used_http2 {
                my_size += 1 + 1;
            }
            if let Some(v) = self.cache_hits {
                my_size += crate::rt::uint32_size(9, v);
            }
            if let Some(v) = self.cache_misses {
                my_size += crate::rt::uint32_size(10, v);
            }
            if let Some(v) = self.hit_bytes {
                my_size += crate::rt::uint64_size(11, v);
            }
            if let Some(v) = self.miss_bytes {
                my_size += crate::rt::uint64_size(12, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.source_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.source_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.bytes {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.host_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.microseconds {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.used_ipv6 {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.proxied {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.used_http2 {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.cache_hits {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.cache_misses {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.hit_bytes {
                os.write_uint64(11, v)?;
            }
            if let Some(v) = self.miss_bytes {
                os.write_uint64(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsInfo {
            StatsInfo::new()
        }

        fn clear(&mut self) {
            self.source_type = ::std::option::Option::None;
            self.source_id = ::std::option::Option::None;
            self.bytes = ::std::option::Option::None;
            self.host_name = ::std::option::Option::None;
            self.microseconds = ::std::option::Option::None;
            self.used_ipv6 = ::std::option::Option::None;
            self.proxied = ::std::option::Option::None;
            self.used_http2 = ::std::option::Option::None;
            self.cache_hits = ::std::option::Option::None;
            self.cache_misses = ::std::option::Option::None;
            self.hit_bytes = ::std::option::Option::None;
            self.miss_bytes = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsInfo {
            static instance: StatsInfo = StatsInfo {
                source_type: ::std::option::Option::None,
                source_id: ::std::option::Option::None,
                bytes: ::std::option::Option::None,
                host_name: ::std::option::Option::None,
                microseconds: ::std::option::Option::None,
                used_ipv6: ::std::option::Option::None,
                proxied: ::std::option::Option::None,
                used_http2: ::std::option::Option::None,
                cache_hits: ::std::option::Option::None,
                cache_misses: ::std::option::Option::None,
                hit_bytes: ::std::option::Option::None,
                miss_bytes: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for StatsInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CClientMetrics_DownloadRates_Notification.StatsInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatsInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for StatsInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ContentValidation_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ContentValidation_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.validation_result)
    pub validation_result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.staged_files)
    pub staged_files: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.user_initiated)
    pub user_initiated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.early_out)
    pub early_out: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.chunks_scanned)
    pub chunks_scanned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.chunks_corrupt)
    pub chunks_corrupt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.bytes_scanned)
    pub bytes_scanned: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.chunk_bytes_corrupt)
    pub chunk_bytes_corrupt: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.total_file_size_corrupt)
    pub total_file_size_corrupt: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ContentValidation_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ContentValidation_Notification {
    fn default() -> &'a CClientMetrics_ContentValidation_Notification {
        <CClientMetrics_ContentValidation_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_ContentValidation_Notification {
    pub fn new() -> CClientMetrics_ContentValidation_Notification {
        ::std::default::Default::default()
    }

    // optional int32 validation_result = 1;

    pub fn validation_result(&self) -> i32 {
        self.validation_result.unwrap_or(0)
    }

    pub fn clear_validation_result(&mut self) {
        self.validation_result = ::std::option::Option::None;
    }

    pub fn has_validation_result(&self) -> bool {
        self.validation_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validation_result(&mut self, v: i32) {
        self.validation_result = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bool staged_files = 3;

    pub fn staged_files(&self) -> bool {
        self.staged_files.unwrap_or(false)
    }

    pub fn clear_staged_files(&mut self) {
        self.staged_files = ::std::option::Option::None;
    }

    pub fn has_staged_files(&self) -> bool {
        self.staged_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staged_files(&mut self, v: bool) {
        self.staged_files = ::std::option::Option::Some(v);
    }

    // optional bool user_initiated = 4;

    pub fn user_initiated(&self) -> bool {
        self.user_initiated.unwrap_or(false)
    }

    pub fn clear_user_initiated(&mut self) {
        self.user_initiated = ::std::option::Option::None;
    }

    pub fn has_user_initiated(&self) -> bool {
        self.user_initiated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_initiated(&mut self, v: bool) {
        self.user_initiated = ::std::option::Option::Some(v);
    }

    // optional bool early_out = 5;

    pub fn early_out(&self) -> bool {
        self.early_out.unwrap_or(false)
    }

    pub fn clear_early_out(&mut self) {
        self.early_out = ::std::option::Option::None;
    }

    pub fn has_early_out(&self) -> bool {
        self.early_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_early_out(&mut self, v: bool) {
        self.early_out = ::std::option::Option::Some(v);
    }

    // optional uint32 chunks_scanned = 6;

    pub fn chunks_scanned(&self) -> u32 {
        self.chunks_scanned.unwrap_or(0)
    }

    pub fn clear_chunks_scanned(&mut self) {
        self.chunks_scanned = ::std::option::Option::None;
    }

    pub fn has_chunks_scanned(&self) -> bool {
        self.chunks_scanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunks_scanned(&mut self, v: u32) {
        self.chunks_scanned = ::std::option::Option::Some(v);
    }

    // optional uint32 chunks_corrupt = 7;

    pub fn chunks_corrupt(&self) -> u32 {
        self.chunks_corrupt.unwrap_or(0)
    }

    pub fn clear_chunks_corrupt(&mut self) {
        self.chunks_corrupt = ::std::option::Option::None;
    }

    pub fn has_chunks_corrupt(&self) -> bool {
        self.chunks_corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunks_corrupt(&mut self, v: u32) {
        self.chunks_corrupt = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_scanned = 8;

    pub fn bytes_scanned(&self) -> u64 {
        self.bytes_scanned.unwrap_or(0)
    }

    pub fn clear_bytes_scanned(&mut self) {
        self.bytes_scanned = ::std::option::Option::None;
    }

    pub fn has_bytes_scanned(&self) -> bool {
        self.bytes_scanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_scanned(&mut self, v: u64) {
        self.bytes_scanned = ::std::option::Option::Some(v);
    }

    // optional uint64 chunk_bytes_corrupt = 9;

    pub fn chunk_bytes_corrupt(&self) -> u64 {
        self.chunk_bytes_corrupt.unwrap_or(0)
    }

    pub fn clear_chunk_bytes_corrupt(&mut self) {
        self.chunk_bytes_corrupt = ::std::option::Option::None;
    }

    pub fn has_chunk_bytes_corrupt(&self) -> bool {
        self.chunk_bytes_corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunk_bytes_corrupt(&mut self, v: u64) {
        self.chunk_bytes_corrupt = ::std::option::Option::Some(v);
    }

    // optional uint64 total_file_size_corrupt = 10;

    pub fn total_file_size_corrupt(&self) -> u64 {
        self.total_file_size_corrupt.unwrap_or(0)
    }

    pub fn clear_total_file_size_corrupt(&mut self) {
        self.total_file_size_corrupt = ::std::option::Option::None;
    }

    pub fn has_total_file_size_corrupt(&self) -> bool {
        self.total_file_size_corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_file_size_corrupt(&mut self, v: u64) {
        self.total_file_size_corrupt = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "validation_result",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.validation_result },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.validation_result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.app_id },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "staged_files",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.staged_files },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.staged_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_initiated",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.user_initiated },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.user_initiated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "early_out",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.early_out },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.early_out },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunks_scanned",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.chunks_scanned },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.chunks_scanned },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunks_corrupt",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.chunks_corrupt },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.chunks_corrupt },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_scanned",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.bytes_scanned },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.bytes_scanned },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunk_bytes_corrupt",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.chunk_bytes_corrupt },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.chunk_bytes_corrupt },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_file_size_corrupt",
            |m: &CClientMetrics_ContentValidation_Notification| { &m.total_file_size_corrupt },
            |m: &mut CClientMetrics_ContentValidation_Notification| { &mut m.total_file_size_corrupt },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ContentValidation_Notification>(
            "CClientMetrics_ContentValidation_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_ContentValidation_Notification {
    const NAME: &'static str = "CClientMetrics_ContentValidation_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.validation_result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.staged_files = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.user_initiated = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.early_out = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.chunks_scanned = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.chunks_corrupt = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.bytes_scanned = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.chunk_bytes_corrupt = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.total_file_size_corrupt = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.validation_result {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.staged_files {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_initiated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.early_out {
            my_size += 1 + 1;
        }
        if let Some(v) = self.chunks_scanned {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.chunks_corrupt {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bytes_scanned {
            my_size += crate::rt::uint64_size(8, v);
        }
        if let Some(v) = self.chunk_bytes_corrupt {
            my_size += crate::rt::uint64_size(9, v);
        }
        if let Some(v) = self.total_file_size_corrupt {
            my_size += crate::rt::uint64_size(10, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.validation_result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.staged_files {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.user_initiated {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.early_out {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.chunks_scanned {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.chunks_corrupt {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_scanned {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.chunk_bytes_corrupt {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.total_file_size_corrupt {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ContentValidation_Notification {
        CClientMetrics_ContentValidation_Notification::new()
    }

    fn clear(&mut self) {
        self.validation_result = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.staged_files = ::std::option::Option::None;
        self.user_initiated = ::std::option::Option::None;
        self.early_out = ::std::option::Option::None;
        self.chunks_scanned = ::std::option::Option::None;
        self.chunks_corrupt = ::std::option::Option::None;
        self.bytes_scanned = ::std::option::Option::None;
        self.chunk_bytes_corrupt = ::std::option::Option::None;
        self.total_file_size_corrupt = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ContentValidation_Notification {
        static instance: CClientMetrics_ContentValidation_Notification = CClientMetrics_ContentValidation_Notification {
            validation_result: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            staged_files: ::std::option::Option::None,
            user_initiated: ::std::option::Option::None,
            early_out: ::std::option::Option::None,
            chunks_scanned: ::std::option::Option::None,
            chunks_corrupt: ::std::option::Option::None,
            bytes_scanned: ::std::option::Option::None,
            chunk_bytes_corrupt: ::std::option::Option::None,
            total_file_size_corrupt: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_ContentValidation_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ContentValidation_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ContentValidation_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_ContentValidation_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_CloudAppSyncStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_CloudAppSyncStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.platform_type)
    pub platform_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.preload)
    pub preload: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.blocking_app_launch)
    pub blocking_app_launch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_uploaded)
    pub files_uploaded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_downloaded)
    pub files_downloaded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_deleted)
    pub files_deleted: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.bytes_uploaded)
    pub bytes_uploaded: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.bytes_downloaded)
    pub bytes_downloaded: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_total)
    pub microsec_total: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_init_caches)
    pub microsec_init_caches: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_validate_state)
    pub microsec_validate_state: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_ac_launch)
    pub microsec_ac_launch: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_ac_prep_user_files)
    pub microsec_ac_prep_user_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_ac_exit)
    pub microsec_ac_exit: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_build_sync_list)
    pub microsec_build_sync_list: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_delete_files)
    pub microsec_delete_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_download_files)
    pub microsec_download_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_upload_files)
    pub microsec_upload_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.hardware_type)
    pub hardware_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_managed)
    pub files_managed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_CloudAppSyncStats_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_CloudAppSyncStats_Notification {
    fn default() -> &'a CClientMetrics_CloudAppSyncStats_Notification {
        <CClientMetrics_CloudAppSyncStats_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_CloudAppSyncStats_Notification {
    pub fn new() -> CClientMetrics_CloudAppSyncStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 platform_type = 2;

    pub fn platform_type(&self) -> u32 {
        self.platform_type.unwrap_or(0)
    }

    pub fn clear_platform_type(&mut self) {
        self.platform_type = ::std::option::Option::None;
    }

    pub fn has_platform_type(&self) -> bool {
        self.platform_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_type(&mut self, v: u32) {
        self.platform_type = ::std::option::Option::Some(v);
    }

    // optional bool preload = 3;

    pub fn preload(&self) -> bool {
        self.preload.unwrap_or(false)
    }

    pub fn clear_preload(&mut self) {
        self.preload = ::std::option::Option::None;
    }

    pub fn has_preload(&self) -> bool {
        self.preload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preload(&mut self, v: bool) {
        self.preload = ::std::option::Option::Some(v);
    }

    // optional bool blocking_app_launch = 4;

    pub fn blocking_app_launch(&self) -> bool {
        self.blocking_app_launch.unwrap_or(false)
    }

    pub fn clear_blocking_app_launch(&mut self) {
        self.blocking_app_launch = ::std::option::Option::None;
    }

    pub fn has_blocking_app_launch(&self) -> bool {
        self.blocking_app_launch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocking_app_launch(&mut self, v: bool) {
        self.blocking_app_launch = ::std::option::Option::Some(v);
    }

    // optional uint32 files_uploaded = 5;

    pub fn files_uploaded(&self) -> u32 {
        self.files_uploaded.unwrap_or(0)
    }

    pub fn clear_files_uploaded(&mut self) {
        self.files_uploaded = ::std::option::Option::None;
    }

    pub fn has_files_uploaded(&self) -> bool {
        self.files_uploaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_uploaded(&mut self, v: u32) {
        self.files_uploaded = ::std::option::Option::Some(v);
    }

    // optional uint32 files_downloaded = 6;

    pub fn files_downloaded(&self) -> u32 {
        self.files_downloaded.unwrap_or(0)
    }

    pub fn clear_files_downloaded(&mut self) {
        self.files_downloaded = ::std::option::Option::None;
    }

    pub fn has_files_downloaded(&self) -> bool {
        self.files_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_downloaded(&mut self, v: u32) {
        self.files_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint32 files_deleted = 7;

    pub fn files_deleted(&self) -> u32 {
        self.files_deleted.unwrap_or(0)
    }

    pub fn clear_files_deleted(&mut self) {
        self.files_deleted = ::std::option::Option::None;
    }

    pub fn has_files_deleted(&self) -> bool {
        self.files_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_deleted(&mut self, v: u32) {
        self.files_deleted = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_uploaded = 8;

    pub fn bytes_uploaded(&self) -> u64 {
        self.bytes_uploaded.unwrap_or(0)
    }

    pub fn clear_bytes_uploaded(&mut self) {
        self.bytes_uploaded = ::std::option::Option::None;
    }

    pub fn has_bytes_uploaded(&self) -> bool {
        self.bytes_uploaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_uploaded(&mut self, v: u64) {
        self.bytes_uploaded = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_downloaded = 9;

    pub fn bytes_downloaded(&self) -> u64 {
        self.bytes_downloaded.unwrap_or(0)
    }

    pub fn clear_bytes_downloaded(&mut self) {
        self.bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_bytes_downloaded(&self) -> bool {
        self.bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_downloaded(&mut self, v: u64) {
        self.bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_total = 10;

    pub fn microsec_total(&self) -> u64 {
        self.microsec_total.unwrap_or(0)
    }

    pub fn clear_microsec_total(&mut self) {
        self.microsec_total = ::std::option::Option::None;
    }

    pub fn has_microsec_total(&self) -> bool {
        self.microsec_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_total(&mut self, v: u64) {
        self.microsec_total = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_init_caches = 11;

    pub fn microsec_init_caches(&self) -> u64 {
        self.microsec_init_caches.unwrap_or(0)
    }

    pub fn clear_microsec_init_caches(&mut self) {
        self.microsec_init_caches = ::std::option::Option::None;
    }

    pub fn has_microsec_init_caches(&self) -> bool {
        self.microsec_init_caches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_init_caches(&mut self, v: u64) {
        self.microsec_init_caches = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_validate_state = 12;

    pub fn microsec_validate_state(&self) -> u64 {
        self.microsec_validate_state.unwrap_or(0)
    }

    pub fn clear_microsec_validate_state(&mut self) {
        self.microsec_validate_state = ::std::option::Option::None;
    }

    pub fn has_microsec_validate_state(&self) -> bool {
        self.microsec_validate_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_validate_state(&mut self, v: u64) {
        self.microsec_validate_state = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_ac_launch = 13;

    pub fn microsec_ac_launch(&self) -> u64 {
        self.microsec_ac_launch.unwrap_or(0)
    }

    pub fn clear_microsec_ac_launch(&mut self) {
        self.microsec_ac_launch = ::std::option::Option::None;
    }

    pub fn has_microsec_ac_launch(&self) -> bool {
        self.microsec_ac_launch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_ac_launch(&mut self, v: u64) {
        self.microsec_ac_launch = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_ac_prep_user_files = 14;

    pub fn microsec_ac_prep_user_files(&self) -> u64 {
        self.microsec_ac_prep_user_files.unwrap_or(0)
    }

    pub fn clear_microsec_ac_prep_user_files(&mut self) {
        self.microsec_ac_prep_user_files = ::std::option::Option::None;
    }

    pub fn has_microsec_ac_prep_user_files(&self) -> bool {
        self.microsec_ac_prep_user_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_ac_prep_user_files(&mut self, v: u64) {
        self.microsec_ac_prep_user_files = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_ac_exit = 15;

    pub fn microsec_ac_exit(&self) -> u64 {
        self.microsec_ac_exit.unwrap_or(0)
    }

    pub fn clear_microsec_ac_exit(&mut self) {
        self.microsec_ac_exit = ::std::option::Option::None;
    }

    pub fn has_microsec_ac_exit(&self) -> bool {
        self.microsec_ac_exit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_ac_exit(&mut self, v: u64) {
        self.microsec_ac_exit = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_build_sync_list = 16;

    pub fn microsec_build_sync_list(&self) -> u64 {
        self.microsec_build_sync_list.unwrap_or(0)
    }

    pub fn clear_microsec_build_sync_list(&mut self) {
        self.microsec_build_sync_list = ::std::option::Option::None;
    }

    pub fn has_microsec_build_sync_list(&self) -> bool {
        self.microsec_build_sync_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_build_sync_list(&mut self, v: u64) {
        self.microsec_build_sync_list = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_delete_files = 17;

    pub fn microsec_delete_files(&self) -> u64 {
        self.microsec_delete_files.unwrap_or(0)
    }

    pub fn clear_microsec_delete_files(&mut self) {
        self.microsec_delete_files = ::std::option::Option::None;
    }

    pub fn has_microsec_delete_files(&self) -> bool {
        self.microsec_delete_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_delete_files(&mut self, v: u64) {
        self.microsec_delete_files = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_download_files = 18;

    pub fn microsec_download_files(&self) -> u64 {
        self.microsec_download_files.unwrap_or(0)
    }

    pub fn clear_microsec_download_files(&mut self) {
        self.microsec_download_files = ::std::option::Option::None;
    }

    pub fn has_microsec_download_files(&self) -> bool {
        self.microsec_download_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_download_files(&mut self, v: u64) {
        self.microsec_download_files = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_upload_files = 19;

    pub fn microsec_upload_files(&self) -> u64 {
        self.microsec_upload_files.unwrap_or(0)
    }

    pub fn clear_microsec_upload_files(&mut self) {
        self.microsec_upload_files = ::std::option::Option::None;
    }

    pub fn has_microsec_upload_files(&self) -> bool {
        self.microsec_upload_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_upload_files(&mut self, v: u64) {
        self.microsec_upload_files = ::std::option::Option::Some(v);
    }

    // optional uint32 hardware_type = 20;

    pub fn hardware_type(&self) -> u32 {
        self.hardware_type.unwrap_or(0)
    }

    pub fn clear_hardware_type(&mut self) {
        self.hardware_type = ::std::option::Option::None;
    }

    pub fn has_hardware_type(&self) -> bool {
        self.hardware_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hardware_type(&mut self, v: u32) {
        self.hardware_type = ::std::option::Option::Some(v);
    }

    // optional uint32 files_managed = 21;

    pub fn files_managed(&self) -> u32 {
        self.files_managed.unwrap_or(0)
    }

    pub fn clear_files_managed(&mut self) {
        self.files_managed = ::std::option::Option::None;
    }

    pub fn has_files_managed(&self) -> bool {
        self.files_managed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_managed(&mut self, v: u32) {
        self.files_managed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.app_id },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_type",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.platform_type },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.platform_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "preload",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.preload },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.preload },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "blocking_app_launch",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.blocking_app_launch },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.blocking_app_launch },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "files_uploaded",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.files_uploaded },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.files_uploaded },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "files_downloaded",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.files_downloaded },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.files_downloaded },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "files_deleted",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.files_deleted },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.files_deleted },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_uploaded",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.bytes_uploaded },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.bytes_uploaded },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_downloaded",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.bytes_downloaded },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.bytes_downloaded },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_total",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_total },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_total },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_init_caches",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_init_caches },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_init_caches },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_validate_state",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_validate_state },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_validate_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_ac_launch",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_ac_launch },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_ac_launch },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_ac_prep_user_files",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_ac_prep_user_files },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_ac_prep_user_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_ac_exit",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_ac_exit },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_ac_exit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_build_sync_list",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_build_sync_list },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_build_sync_list },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_delete_files",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_delete_files },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_delete_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_download_files",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_download_files },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_download_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "microsec_upload_files",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.microsec_upload_files },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.microsec_upload_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hardware_type",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.hardware_type },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.hardware_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "files_managed",
            |m: &CClientMetrics_CloudAppSyncStats_Notification| { &m.files_managed },
            |m: &mut CClientMetrics_CloudAppSyncStats_Notification| { &mut m.files_managed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_CloudAppSyncStats_Notification>(
            "CClientMetrics_CloudAppSyncStats_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_CloudAppSyncStats_Notification {
    const NAME: &'static str = "CClientMetrics_CloudAppSyncStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.platform_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.preload = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.blocking_app_launch = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.files_uploaded = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.files_downloaded = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.files_deleted = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.bytes_uploaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.microsec_total = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.microsec_init_caches = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.microsec_validate_state = ::std::option::Option::Some(is.read_uint64()?);
                },
                104 => {
                    self.microsec_ac_launch = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.microsec_ac_prep_user_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                120 => {
                    self.microsec_ac_exit = ::std::option::Option::Some(is.read_uint64()?);
                },
                128 => {
                    self.microsec_build_sync_list = ::std::option::Option::Some(is.read_uint64()?);
                },
                136 => {
                    self.microsec_delete_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                144 => {
                    self.microsec_download_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.microsec_upload_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.hardware_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.files_managed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.platform_type {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.preload {
            my_size += 1 + 1;
        }
        if let Some(v) = self.blocking_app_launch {
            my_size += 1 + 1;
        }
        if let Some(v) = self.files_uploaded {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.files_downloaded {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.files_deleted {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bytes_uploaded {
            my_size += crate::rt::uint64_size(8, v);
        }
        if let Some(v) = self.bytes_downloaded {
            my_size += crate::rt::uint64_size(9, v);
        }
        if let Some(v) = self.microsec_total {
            my_size += crate::rt::uint64_size(10, v);
        }
        if let Some(v) = self.microsec_init_caches {
            my_size += crate::rt::uint64_size(11, v);
        }
        if let Some(v) = self.microsec_validate_state {
            my_size += crate::rt::uint64_size(12, v);
        }
        if let Some(v) = self.microsec_ac_launch {
            my_size += crate::rt::uint64_size(13, v);
        }
        if let Some(v) = self.microsec_ac_prep_user_files {
            my_size += crate::rt::uint64_size(14, v);
        }
        if let Some(v) = self.microsec_ac_exit {
            my_size += crate::rt::uint64_size(15, v);
        }
        if let Some(v) = self.microsec_build_sync_list {
            my_size += crate::rt::uint64_size(16, v);
        }
        if let Some(v) = self.microsec_delete_files {
            my_size += crate::rt::uint64_size(17, v);
        }
        if let Some(v) = self.microsec_download_files {
            my_size += crate::rt::uint64_size(18, v);
        }
        if let Some(v) = self.microsec_upload_files {
            my_size += crate::rt::uint64_size(19, v);
        }
        if let Some(v) = self.hardware_type {
            my_size += crate::rt::uint32_size(20, v);
        }
        if let Some(v) = self.files_managed {
            my_size += crate::rt::uint32_size(21, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.preload {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.blocking_app_launch {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.files_uploaded {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.files_downloaded {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.files_deleted {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_uploaded {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.bytes_downloaded {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.microsec_total {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.microsec_init_caches {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.microsec_validate_state {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.microsec_ac_launch {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.microsec_ac_prep_user_files {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.microsec_ac_exit {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.microsec_build_sync_list {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.microsec_delete_files {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.microsec_download_files {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.microsec_upload_files {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.hardware_type {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.files_managed {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_CloudAppSyncStats_Notification {
        CClientMetrics_CloudAppSyncStats_Notification::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.platform_type = ::std::option::Option::None;
        self.preload = ::std::option::Option::None;
        self.blocking_app_launch = ::std::option::Option::None;
        self.files_uploaded = ::std::option::Option::None;
        self.files_downloaded = ::std::option::Option::None;
        self.files_deleted = ::std::option::Option::None;
        self.bytes_uploaded = ::std::option::Option::None;
        self.bytes_downloaded = ::std::option::Option::None;
        self.microsec_total = ::std::option::Option::None;
        self.microsec_init_caches = ::std::option::Option::None;
        self.microsec_validate_state = ::std::option::Option::None;
        self.microsec_ac_launch = ::std::option::Option::None;
        self.microsec_ac_prep_user_files = ::std::option::Option::None;
        self.microsec_ac_exit = ::std::option::Option::None;
        self.microsec_build_sync_list = ::std::option::Option::None;
        self.microsec_delete_files = ::std::option::Option::None;
        self.microsec_download_files = ::std::option::Option::None;
        self.microsec_upload_files = ::std::option::Option::None;
        self.hardware_type = ::std::option::Option::None;
        self.files_managed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_CloudAppSyncStats_Notification {
        static instance: CClientMetrics_CloudAppSyncStats_Notification = CClientMetrics_CloudAppSyncStats_Notification {
            app_id: ::std::option::Option::None,
            platform_type: ::std::option::Option::None,
            preload: ::std::option::Option::None,
            blocking_app_launch: ::std::option::Option::None,
            files_uploaded: ::std::option::Option::None,
            files_downloaded: ::std::option::Option::None,
            files_deleted: ::std::option::Option::None,
            bytes_uploaded: ::std::option::Option::None,
            bytes_downloaded: ::std::option::Option::None,
            microsec_total: ::std::option::Option::None,
            microsec_init_caches: ::std::option::Option::None,
            microsec_validate_state: ::std::option::Option::None,
            microsec_ac_launch: ::std::option::Option::None,
            microsec_ac_prep_user_files: ::std::option::Option::None,
            microsec_ac_exit: ::std::option::Option::None,
            microsec_build_sync_list: ::std::option::Option::None,
            microsec_delete_files: ::std::option::Option::None,
            microsec_download_files: ::std::option::Option::None,
            microsec_upload_files: ::std::option::Option::None,
            hardware_type: ::std::option::Option::None,
            files_managed: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_CloudAppSyncStats_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_CloudAppSyncStats_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_CloudAppSyncStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_CloudAppSyncStats_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_ContentDownloadResponse_Counts_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ContentDownloadResponse_Counts_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ContentDownloadResponse_Counts_Notification.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentDownloadResponse_Counts_Notification.data)
    pub data: crate::MessageField<super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ContentDownloadResponse_Counts_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ContentDownloadResponse_Counts_Notification {
    fn default() -> &'a CClientMetrics_ContentDownloadResponse_Counts_Notification {
        <CClientMetrics_ContentDownloadResponse_Counts_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_ContentDownloadResponse_Counts_Notification {
    pub fn new() -> CClientMetrics_ContentDownloadResponse_Counts_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional .CClientMetrics_ContentDownloadResponse_Hosts data = 2;

    pub fn data(&self) -> &super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts {
        self.data.as_ref().unwrap_or_else(|| <super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts as crate::Message>::default_instance())
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts) {
        self.data = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts {
        self.data.mut_or_insert_default()
    }

    // Take field
    pub fn take_data(&mut self) -> super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts {
        self.data.take().unwrap_or_else(|| super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CClientMetrics_ContentDownloadResponse_Counts_Notification| { &m.cell_id },
            |m: &mut CClientMetrics_ContentDownloadResponse_Counts_Notification| { &mut m.cell_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts>(
            "data",
            |m: &CClientMetrics_ContentDownloadResponse_Counts_Notification| { &m.data },
            |m: &mut CClientMetrics_ContentDownloadResponse_Counts_Notification| { &mut m.data },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ContentDownloadResponse_Counts_Notification>(
            "CClientMetrics_ContentDownloadResponse_Counts_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_ContentDownloadResponse_Counts_Notification {
    const NAME: &'static str = "CClientMetrics_ContentDownloadResponse_Counts_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ContentDownloadResponse_Counts_Notification {
        CClientMetrics_ContentDownloadResponse_Counts_Notification::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ContentDownloadResponse_Counts_Notification {
        static instance: CClientMetrics_ContentDownloadResponse_Counts_Notification = CClientMetrics_ContentDownloadResponse_Counts_Notification {
            cell_id: ::std::option::Option::None,
            data: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_ContentDownloadResponse_Counts_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ContentDownloadResponse_Counts_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ContentDownloadResponse_Counts_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_ContentDownloadResponse_Counts_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_ReportClientArgs_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ReportClientArgs_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.client_args)
    pub client_args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.gpu_webview_regkey_disabled)
    pub gpu_webview_regkey_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.suppress_gpu_chrome)
    pub suppress_gpu_chrome: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.browser_not_supported)
    pub browser_not_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.hw_accel_video_regkey_disabled)
    pub hw_accel_video_regkey_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.mini_mode_enabled)
    pub mini_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.fps_counter_enabled)
    pub fps_counter_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.library_low_bandwidth_mode_enabled)
    pub library_low_bandwidth_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.library_low_perf_mode_enabled)
    pub library_low_perf_mode_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientArgs_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportClientArgs_Notification {
    fn default() -> &'a CClientMetrics_ReportClientArgs_Notification {
        <CClientMetrics_ReportClientArgs_Notification as crate::Message>::default_instance()
    }
}

impl CClientMetrics_ReportClientArgs_Notification {
    pub fn new() -> CClientMetrics_ReportClientArgs_Notification {
        ::std::default::Default::default()
    }

    // repeated string client_args = 1;

    pub fn client_args(&self) -> &[::std::string::String] {
        &self.client_args
    }

    pub fn clear_client_args(&mut self) {
        self.client_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_args(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.client_args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_args(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.client_args
    }

    // Take field
    pub fn take_client_args(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.client_args, ::std::vec::Vec::new())
    }

    // optional bool gpu_webview_regkey_disabled = 2;

    pub fn gpu_webview_regkey_disabled(&self) -> bool {
        self.gpu_webview_regkey_disabled.unwrap_or(false)
    }

    pub fn clear_gpu_webview_regkey_disabled(&mut self) {
        self.gpu_webview_regkey_disabled = ::std::option::Option::None;
    }

    pub fn has_gpu_webview_regkey_disabled(&self) -> bool {
        self.gpu_webview_regkey_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_webview_regkey_disabled(&mut self, v: bool) {
        self.gpu_webview_regkey_disabled = ::std::option::Option::Some(v);
    }

    // optional bool suppress_gpu_chrome = 3;

    pub fn suppress_gpu_chrome(&self) -> bool {
        self.suppress_gpu_chrome.unwrap_or(false)
    }

    pub fn clear_suppress_gpu_chrome(&mut self) {
        self.suppress_gpu_chrome = ::std::option::Option::None;
    }

    pub fn has_suppress_gpu_chrome(&self) -> bool {
        self.suppress_gpu_chrome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_gpu_chrome(&mut self, v: bool) {
        self.suppress_gpu_chrome = ::std::option::Option::Some(v);
    }

    // optional bool browser_not_supported = 4;

    pub fn browser_not_supported(&self) -> bool {
        self.browser_not_supported.unwrap_or(false)
    }

    pub fn clear_browser_not_supported(&mut self) {
        self.browser_not_supported = ::std::option::Option::None;
    }

    pub fn has_browser_not_supported(&self) -> bool {
        self.browser_not_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_not_supported(&mut self, v: bool) {
        self.browser_not_supported = ::std::option::Option::Some(v);
    }

    // optional bool hw_accel_video_regkey_disabled = 5;

    pub fn hw_accel_video_regkey_disabled(&self) -> bool {
        self.hw_accel_video_regkey_disabled.unwrap_or(false)
    }

    pub fn clear_hw_accel_video_regkey_disabled(&mut self) {
        self.hw_accel_video_regkey_disabled = ::std::option::Option::None;
    }

    pub fn has_hw_accel_video_regkey_disabled(&self) -> bool {
        self.hw_accel_video_regkey_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hw_accel_video_regkey_disabled(&mut self, v: bool) {
        self.hw_accel_video_regkey_disabled = ::std::option::Option::Some(v);
    }

    // optional bool mini_mode_enabled = 6;

    pub fn mini_mode_enabled(&self) -> bool {
        self.mini_mode_enabled.unwrap_or(false)
    }

    pub fn clear_mini_mode_enabled(&mut self) {
        self.mini_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_mini_mode_enabled(&self) -> bool {
        self.mini_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mini_mode_enabled(&mut self, v: bool) {
        self.mini_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional bool fps_counter_enabled = 7;

    pub fn fps_counter_enabled(&self) -> bool {
        self.fps_counter_enabled.unwrap_or(false)
    }

    pub fn clear_fps_counter_enabled(&mut self) {
        self.fps_counter_enabled = ::std::option::Option::None;
    }

    pub fn has_fps_counter_enabled(&self) -> bool {
        self.fps_counter_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_counter_enabled(&mut self, v: bool) {
        self.fps_counter_enabled = ::std::option::Option::Some(v);
    }

    // optional bool library_low_bandwidth_mode_enabled = 8;

    pub fn library_low_bandwidth_mode_enabled(&self) -> bool {
        self.library_low_bandwidth_mode_enabled.unwrap_or(false)
    }

    pub fn clear_library_low_bandwidth_mode_enabled(&mut self) {
        self.library_low_bandwidth_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_library_low_bandwidth_mode_enabled(&self) -> bool {
        self.library_low_bandwidth_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_bandwidth_mode_enabled(&mut self, v: bool) {
        self.library_low_bandwidth_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional bool library_low_perf_mode_enabled = 9;

    pub fn library_low_perf_mode_enabled(&self) -> bool {
        self.library_low_perf_mode_enabled.unwrap_or(false)
    }

    pub fn clear_library_low_perf_mode_enabled(&mut self) {
        self.library_low_perf_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_library_low_perf_mode_enabled(&self) -> bool {
        self.library_low_perf_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_perf_mode_enabled(&mut self, v: bool) {
        self.library_low_perf_mode_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_args",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.client_args },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.client_args },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_webview_regkey_disabled",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.gpu_webview_regkey_disabled },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.gpu_webview_regkey_disabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "suppress_gpu_chrome",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.suppress_gpu_chrome },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.suppress_gpu_chrome },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_not_supported",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.browser_not_supported },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.browser_not_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hw_accel_video_regkey_disabled",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.hw_accel_video_regkey_disabled },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.hw_accel_video_regkey_disabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mini_mode_enabled",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.mini_mode_enabled },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.mini_mode_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fps_counter_enabled",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.fps_counter_enabled },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.fps_counter_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_low_bandwidth_mode_enabled",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.library_low_bandwidth_mode_enabled },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.library_low_bandwidth_mode_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_low_perf_mode_enabled",
            |m: &CClientMetrics_ReportClientArgs_Notification| { &m.library_low_perf_mode_enabled },
            |m: &mut CClientMetrics_ReportClientArgs_Notification| { &mut m.library_low_perf_mode_enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ReportClientArgs_Notification>(
            "CClientMetrics_ReportClientArgs_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientMetrics_ReportClientArgs_Notification {
    const NAME: &'static str = "CClientMetrics_ReportClientArgs_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_args.push(is.read_string()?);
                },
                16 => {
                    self.gpu_webview_regkey_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.suppress_gpu_chrome = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.browser_not_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.hw_accel_video_regkey_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.mini_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.fps_counter_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.library_low_bandwidth_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.library_low_perf_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.client_args {
            my_size += crate::rt::string_size(1, &value);
        };
        if let Some(v) = self.gpu_webview_regkey_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.suppress_gpu_chrome {
            my_size += 1 + 1;
        }
        if let Some(v) = self.browser_not_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hw_accel_video_regkey_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mini_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fps_counter_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.library_low_bandwidth_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.library_low_perf_mode_enabled {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.client_args {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.gpu_webview_regkey_disabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.suppress_gpu_chrome {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.browser_not_supported {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.hw_accel_video_regkey_disabled {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.mini_mode_enabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.fps_counter_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.library_low_bandwidth_mode_enabled {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.library_low_perf_mode_enabled {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ReportClientArgs_Notification {
        CClientMetrics_ReportClientArgs_Notification::new()
    }

    fn clear(&mut self) {
        self.client_args.clear();
        self.gpu_webview_regkey_disabled = ::std::option::Option::None;
        self.suppress_gpu_chrome = ::std::option::Option::None;
        self.browser_not_supported = ::std::option::Option::None;
        self.hw_accel_video_regkey_disabled = ::std::option::Option::None;
        self.mini_mode_enabled = ::std::option::Option::None;
        self.fps_counter_enabled = ::std::option::Option::None;
        self.library_low_bandwidth_mode_enabled = ::std::option::Option::None;
        self.library_low_perf_mode_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ReportClientArgs_Notification {
        static instance: CClientMetrics_ReportClientArgs_Notification = CClientMetrics_ReportClientArgs_Notification {
            client_args: ::std::vec::Vec::new(),
            gpu_webview_regkey_disabled: ::std::option::Option::None,
            suppress_gpu_chrome: ::std::option::Option::None,
            browser_not_supported: ::std::option::Option::None,
            hw_accel_video_regkey_disabled: ::std::option::Option::None,
            mini_mode_enabled: ::std::option::Option::None,
            fps_counter_enabled: ::std::option::Option::None,
            library_low_bandwidth_mode_enabled: ::std::option::Option::None,
            library_low_perf_mode_enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientMetrics_ReportClientArgs_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ReportClientArgs_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ReportClientArgs_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientMetrics_ReportClientArgs_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamPipeWorkType)
pub enum ESteamPipeWorkType {
    // @@protoc_insertion_point(enum_value:ESteamPipeWorkType.k_ESteamPipeClientWorkType_Invalid)
    k_ESteamPipeClientWorkType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamPipeWorkType.k_ESteamPipeClientWorkType_StageFromChunkStores)
    k_ESteamPipeClientWorkType_StageFromChunkStores = 1,
}

impl crate::Enum for ESteamPipeWorkType {
    const NAME: &'static str = "ESteamPipeWorkType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeWorkType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamPipeWorkType> {
        match str {
            "k_ESteamPipeClientWorkType_Invalid" => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            "k_ESteamPipeClientWorkType_StageFromChunkStores" => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamPipeWorkType] = &[
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid,
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores,
    ];
}

impl crate::EnumFull for ESteamPipeWorkType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamPipeWorkType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamPipeWorkType {
    fn default() -> Self {
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid
    }
}

impl ESteamPipeWorkType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESteamPipeWorkType>("ESteamPipeWorkType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamPipeOperationType)
pub enum ESteamPipeOperationType {
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_Invalid)
    k_ESteamPipeOperationType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DecryptCPU)
    k_ESteamPipeOperationType_DecryptCPU = 1,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DiskRead)
    k_ESteamPipeOperationType_DiskRead = 2,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DiskWrite)
    k_ESteamPipeOperationType_DiskWrite = 3,
}

impl crate::Enum for ESteamPipeOperationType {
    const NAME: &'static str = "ESteamPipeOperationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeOperationType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU),
            2 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead),
            3 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamPipeOperationType> {
        match str {
            "k_ESteamPipeOperationType_Invalid" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            "k_ESteamPipeOperationType_DecryptCPU" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU),
            "k_ESteamPipeOperationType_DiskRead" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead),
            "k_ESteamPipeOperationType_DiskWrite" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamPipeOperationType] = &[
        ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite,
    ];
}

impl crate::EnumFull for ESteamPipeOperationType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamPipeOperationType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamPipeOperationType {
    fn default() -> Self {
        ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid
    }
}

impl ESteamPipeOperationType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESteamPipeOperationType>("ESteamPipeOperationType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_clientmetrics.steamclient.proto\x1a\x18steammessages_ba\
    se.proto\x1a,steammessages_unified_base.steamclient.proto\x1a\x13clientm\
    etrics.proto\"\x80\x01\n#CClientMetrics_AppInterfaceCreation\x12\x1f\n\
    \x0braw_version\x18\x01\x20\x01(\tR\nrawVersion\x128\n\x18requested_inte\
    rface_type\x18\x02\x20\x01(\tR\x16requestedInterfaceType\"\x90\x01\n'CCl\
    ientMetrics_AppInterfaceMethodCounts\x12%\n\x0einterface_name\x18\x01\
    \x20\x01(\tR\rinterfaceName\x12\x1f\n\x0bmethod_name\x18\x02\x20\x01(\tR\
    \nmethodName\x12\x1d\n\ncall_count\x18\x03\x20\x01(\rR\tcallCount\"\xa4\
    \x02\n-CClientMetrics_AppInterfaceStats_Notification\x12\x17\n\x07game_i\
    d\x18\x01\x20\x01(\x04R\x06gameId\x12S\n\x12interfaces_created\x18\x02\
    \x20\x03(\x0b2$.CClientMetrics_AppInterfaceCreationR\x11interfacesCreate\
    d\x12O\n\x0emethods_called\x18\x03\x20\x03(\x0b2(.CClientMetrics_AppInte\
    rfaceMethodCountsR\rmethodsCalled\x124\n\x16session_length_seconds\x18\
    \x04\x20\x01(\rR\x14sessionLengthSeconds\"\x80\x01\n&CClientMetrics_IPv6\
    Connectivity_Result\x12'\n\x0fprotocol_tested\x18\x01\x20\x01(\rR\x0epro\
    tocolTested\x12-\n\x12connectivity_state\x18\x02\x20\x01(\rR\x11connecti\
    vityState\"\xbd\x01\n,CClientMetrics_IPv6Connectivity_Notification\x12\
    \x17\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellId\x12A\n\x07results\x18\
    \x02\x20\x03(\x0b2'.CClientMetrics_IPv6Connectivity_ResultR\x07results\
    \x121\n\x15private_ip_is_rfc6598\x18\x03\x20\x01(\x08R\x12privateIpIsRfc\
    6598\"\xc8\x02\n+CClientMetrics_SteamPipeWorkStats_Operation\x12O\n\x04t\
    ype\x18\x01\x20\x01(\x0e2\x18.ESteamPipeOperationType:!k_ESteamPipeOpera\
    tionType_InvalidR\x04type\x12\x17\n\x07num_ops\x18\x02\x20\x01(\rR\x06nu\
    mOps\x12\x1b\n\tnum_bytes\x18\x03\x20\x01(\x04R\x08numBytes\x12\x20\n\
    \x0cbusy_time_ms\x18\x04\x20\x01(\x04R\nbusyTimeMs\x12\x20\n\x0cidle_tim\
    e_ms\x18\x05\x20\x01(\x04R\nidleTimeMs\x12%\n\x0fsum_run_time_ms\x18\x06\
    \x20\x01(\x04R\x0csumRunTimeMs\x12'\n\x10sum_wait_time_ms\x18\x07\x20\
    \x01(\x04R\rsumWaitTimeMs\"\xa9\x02\n.CClientMetrics_SteamPipeWorkStats_\
    Notification\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x18\n\
    \x07depotid\x18\x02\x20\x01(\rR\x07depotid\x12T\n\twork_type\x18\x03\x20\
    \x01(\x0e2\x13.ESteamPipeWorkType:\"k_ESteamPipeClientWorkType_InvalidR\
    \x08workType\x12L\n\noperations\x18\x04\x20\x03(\x0b2,.CClientMetrics_St\
    eamPipeWorkStats_OperationR\noperations\x12#\n\rhardware_type\x18\x05\
    \x20\x01(\rR\x0chardwareType\"\x9e\x04\n,CClientMetrics_ReportReactUsage\
    _Notification\x12\x18\n\x07product\x18\x01\x20\x01(\tR\x07product\x12\
    \x18\n\x07version\x18\x02\x20\x01(\tR\x07version\x12O\n\x06routes\x18\
    \x03\x20\x03(\x0b27.CClientMetrics_ReportReactUsage_Notification.RouteDa\
    taR\x06routes\x12[\n\ncomponents\x18\x04\x20\x03(\x0b2;.CClientMetrics_R\
    eportReactUsage_Notification.ComponentDataR\ncomponents\x12R\n\x07action\
    s\x18\x05\x20\x03(\x0b28.CClientMetrics_ReportReactUsage_Notification.Ac\
    tionDataR\x07actions\x1a7\n\tRouteData\x12\x14\n\x05route\x18\x01\x20\
    \x01(\tR\x05route\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05count\x1aC\n\
    \rComponentData\x12\x1c\n\tcomponent\x18\x01\x20\x01(\tR\tcomponent\x12\
    \x14\n\x05count\x18\x02\x20\x01(\rR\x05count\x1a:\n\nActionData\x12\x16\
    \n\x06action\x18\x01\x20\x01(\tR\x06action\x12\x14\n\x05count\x18\x02\
    \x20\x01(\rR\x05count\"\x8a\x02\n-CClientMetrics_ReportClientError_Notif\
    ication\x12\x18\n\x07product\x18\x01\x20\x01(\tR\x07product\x12\x18\n\
    \x07version\x18\x02\x20\x01(\tR\x07version\x12L\n\x06errors\x18\x03\x20\
    \x03(\x0b24.CClientMetrics_ReportClientError_Notification.ErrorR\x06erro\
    rs\x1aW\n\x05Error\x12\x1e\n\nidentifier\x18\x01\x20\x01(\tR\nidentifier\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12\x14\n\x05count\
    \x18\x03\x20\x01(\rR\x05count\"p\n+CClientMetrics_ClientBootstrap_Notifi\
    cation\x12A\n\x07summary\x18\x01\x20\x01(\x0b2'.CClientMetrics_ClientBoo\
    tstrap_SummaryR\x07summary\"\xb0\x04\n)CClientMetrics_DownloadRates_Noti\
    fication\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellId\x12J\n\x05st\
    ats\x18\x02\x20\x03(\x0b24.CClientMetrics_DownloadRates_Notification.Sta\
    tsInfoR\x05stats\x12'\n\x0fthrottling_kbps\x18\x03\x20\x01(\rR\x0ethrott\
    lingKbps\x1a\xf4\x02\n\tStatsInfo\x12\x1f\n\x0bsource_type\x18\x01\x20\
    \x01(\rR\nsourceType\x12\x1b\n\tsource_id\x18\x02\x20\x01(\rR\x08sourceI\
    d\x12\x14\n\x05bytes\x18\x03\x20\x01(\x04R\x05bytes\x12\x1b\n\thost_name\
    \x18\x04\x20\x01(\tR\x08hostName\x12\"\n\x0cmicroseconds\x18\x05\x20\x01\
    (\x04R\x0cmicroseconds\x12\x1b\n\tused_ipv6\x18\x06\x20\x01(\x08R\x08use\
    dIpv6\x12\x18\n\x07proxied\x18\x07\x20\x01(\x08R\x07proxied\x12\x1d\n\nu\
    sed_http2\x18\x08\x20\x01(\x08R\tusedHttp2\x12\x1d\n\ncache_hits\x18\t\
    \x20\x01(\rR\tcacheHits\x12!\n\x0ccache_misses\x18\n\x20\x01(\rR\x0bcach\
    eMisses\x12\x1b\n\thit_bytes\x18\x0b\x20\x01(\x04R\x08hitBytes\x12\x1d\n\
    \nmiss_bytes\x18\x0c\x20\x01(\x04R\tmissBytes\"\xb4\x03\n-CClientMetrics\
    _ContentValidation_Notification\x12+\n\x11validation_result\x18\x01\x20\
    \x01(\x05R\x10validationResult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\
    \x05appId\x12!\n\x0cstaged_files\x18\x03\x20\x01(\x08R\x0bstagedFiles\
    \x12%\n\x0euser_initiated\x18\x04\x20\x01(\x08R\ruserInitiated\x12\x1b\n\
    \tearly_out\x18\x05\x20\x01(\x08R\x08earlyOut\x12%\n\x0echunks_scanned\
    \x18\x06\x20\x01(\rR\rchunksScanned\x12%\n\x0echunks_corrupt\x18\x07\x20\
    \x01(\rR\rchunksCorrupt\x12#\n\rbytes_scanned\x18\x08\x20\x01(\x04R\x0cb\
    ytesScanned\x12.\n\x13chunk_bytes_corrupt\x18\t\x20\x01(\x04R\x11chunkBy\
    tesCorrupt\x125\n\x17total_file_size_corrupt\x18\n\x20\x01(\x04R\x14tota\
    lFileSizeCorrupt\"\xc8\x07\n-CClientMetrics_CloudAppSyncStats_Notificati\
    on\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12#\n\rplatform_typ\
    e\x18\x02\x20\x01(\rR\x0cplatformType\x12\x18\n\x07preload\x18\x03\x20\
    \x01(\x08R\x07preload\x12.\n\x13blocking_app_launch\x18\x04\x20\x01(\x08\
    R\x11blockingAppLaunch\x12%\n\x0efiles_uploaded\x18\x05\x20\x01(\rR\rfil\
    esUploaded\x12)\n\x10files_downloaded\x18\x06\x20\x01(\rR\x0ffilesDownlo\
    aded\x12#\n\rfiles_deleted\x18\x07\x20\x01(\rR\x0cfilesDeleted\x12%\n\
    \x0ebytes_uploaded\x18\x08\x20\x01(\x04R\rbytesUploaded\x12)\n\x10bytes_\
    downloaded\x18\t\x20\x01(\x04R\x0fbytesDownloaded\x12%\n\x0emicrosec_tot\
    al\x18\n\x20\x01(\x04R\rmicrosecTotal\x120\n\x14microsec_init_caches\x18\
    \x0b\x20\x01(\x04R\x12microsecInitCaches\x126\n\x17microsec_validate_sta\
    te\x18\x0c\x20\x01(\x04R\x15microsecValidateState\x12,\n\x12microsec_ac_\
    launch\x18\r\x20\x01(\x04R\x10microsecAcLaunch\x12<\n\x1bmicrosec_ac_pre\
    p_user_files\x18\x0e\x20\x01(\x04R\x17microsecAcPrepUserFiles\x12(\n\x10\
    microsec_ac_exit\x18\x0f\x20\x01(\x04R\x0emicrosecAcExit\x127\n\x18micro\
    sec_build_sync_list\x18\x10\x20\x01(\x04R\x15microsecBuildSyncList\x122\
    \n\x15microsec_delete_files\x18\x11\x20\x01(\x04R\x13microsecDeleteFiles\
    \x126\n\x17microsec_download_files\x18\x12\x20\x01(\x04R\x15microsecDown\
    loadFiles\x122\n\x15microsec_upload_files\x18\x13\x20\x01(\x04R\x13micro\
    secUploadFiles\x12#\n\rhardware_type\x18\x14\x20\x01(\rR\x0chardwareType\
    \x12#\n\rfiles_managed\x18\x15\x20\x01(\rR\x0cfilesManaged\"\x98\x01\n:C\
    ClientMetrics_ContentDownloadResponse_Counts_Notification\x12\x17\n\x07c\
    ell_id\x18\x01\x20\x01(\rR\x06cellId\x12A\n\x04data\x18\x02\x20\x01(\x0b\
    2-.CClientMetrics_ContentDownloadResponse_HostsR\x04data\"\xa0\x04\n,CCl\
    ientMetrics_ReportClientArgs_Notification\x12\x1f\n\x0bclient_args\x18\
    \x01\x20\x03(\tR\nclientArgs\x12=\n\x1bgpu_webview_regkey_disabled\x18\
    \x02\x20\x01(\x08R\x18gpuWebviewRegkeyDisabled\x12.\n\x13suppress_gpu_ch\
    rome\x18\x03\x20\x01(\x08R\x11suppressGpuChrome\x122\n\x15browser_not_su\
    pported\x18\x04\x20\x01(\x08R\x13browserNotSupported\x12B\n\x1ehw_accel_\
    video_regkey_disabled\x18\x05\x20\x01(\x08R\x1ahwAccelVideoRegkeyDisable\
    d\x12*\n\x11mini_mode_enabled\x18\x06\x20\x01(\x08R\x0fminiModeEnabled\
    \x12.\n\x13fps_counter_enabled\x18\x07\x20\x01(\x08R\x11fpsCounterEnable\
    d\x12J\n\"library_low_bandwidth_mode_enabled\x18\x08\x20\x01(\x08R\x1eli\
    braryLowBandwidthModeEnabled\x12@\n\x1dlibrary_low_perf_mode_enabled\x18\
    \t\x20\x01(\x08R\x19libraryLowPerfModeEnabled*q\n\x12ESteamPipeWorkType\
    \x12&\n\"k_ESteamPipeClientWorkType_Invalid\x10\0\x123\n/k_ESteamPipeCli\
    entWorkType_StageFromChunkStores\x10\x01*\xbb\x01\n\x17ESteamPipeOperati\
    onType\x12%\n!k_ESteamPipeOperationType_Invalid\x10\0\x12(\n$k_ESteamPip\
    eOperationType_DecryptCPU\x10\x01\x12&\n\"k_ESteamPipeOperationType_Disk\
    Read\x10\x02\x12'\n#k_ESteamPipeOperationType_DiskWrite\x10\x032\xe3\x07\
    \n\rClientMetrics\x12\\\n\x1dClientAppInterfaceStatsReport\x12..CClientM\
    etrics_AppInterfaceStats_Notification\x1a\x0b.NoResponse\x12Z\n\x1cClien\
    tIPv6ConnectivityReport\x12-.CClientMetrics_IPv6Connectivity_Notificatio\
    n\x1a\x0b.NoResponse\x12X\n\x18SteamPipeWorkStatsReport\x12/.CClientMetr\
    ics_SteamPipeWorkStats_Notification\x1a\x0b.NoResponse\x12N\n\x10ReportR\
    eactUsage\x12-.CClientMetrics_ReportReactUsage_Notification\x1a\x0b.NoRe\
    sponse\x12P\n\x11ReportClientError\x12..CClientMetrics_ReportClientError\
    _Notification\x1a\x0b.NoResponse\x12R\n\x15ClientBootstrapReport\x12,.CC\
    lientMetrics_ClientBootstrap_Notification\x1a\x0b.NoResponse\x12T\n\x19C\
    lientDownloadRatesReport\x12*.CClientMetrics_DownloadRates_Notification\
    \x1a\x0b.NoResponse\x12\\\n\x1dClientContentValidationReport\x12..CClien\
    tMetrics_ContentValidation_Notification\x1a\x0b.NoResponse\x12V\n\x17Cli\
    entCloudAppSyncStats\x12..CClientMetrics_CloudAppSyncStats_Notification\
    \x1a\x0b.NoResponse\x12l\n\x20ClientDownloadResponseCodeCounts\x12;.CCli\
    entMetrics_ContentDownloadResponse_Counts_Notification\x1a\x0b.NoRespons\
    e\x12N\n\x10ReportClientArgs\x12-.CClientMetrics_ReportClientArgs_Notifi\
    cation\x1a\x0b.NoResponseB\x03\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            deps.push(super::clientmetrics::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(20);
            messages.push(CClientMetrics_AppInterfaceCreation::generated_message_descriptor_data());
            messages.push(CClientMetrics_AppInterfaceMethodCounts::generated_message_descriptor_data());
            messages.push(CClientMetrics_AppInterfaceStats_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_IPv6Connectivity_Result::generated_message_descriptor_data());
            messages.push(CClientMetrics_IPv6Connectivity_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_SteamPipeWorkStats_Operation::generated_message_descriptor_data());
            messages.push(CClientMetrics_SteamPipeWorkStats_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ReportReactUsage_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ReportClientError_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ClientBootstrap_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_DownloadRates_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ContentValidation_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_CloudAppSyncStats_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ContentDownloadResponse_Counts_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ReportClientArgs_Notification::generated_message_descriptor_data());
            messages.push(cclient_metrics_report_react_usage_notification::RouteData::generated_message_descriptor_data());
            messages.push(cclient_metrics_report_react_usage_notification::ComponentData::generated_message_descriptor_data());
            messages.push(cclient_metrics_report_react_usage_notification::ActionData::generated_message_descriptor_data());
            messages.push(cclient_metrics_report_client_error_notification::Error::generated_message_descriptor_data());
            messages.push(cclient_metrics_download_rates_notification::StatsInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ESteamPipeWorkType::generated_enum_descriptor_data());
            enums.push(ESteamPipeOperationType::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
