// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_client_objects.proto`

// @@protoc_insertion_point(message:SteamMessagesClientIClientForcedEnumDependencies)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SteamMessagesClientIClientForcedEnumDependencies {
    // message fields
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.a)
    pub a: ::std::option::Option<crate::EnumOrUnknown<super::enums::EBluetoothDeviceType>>,
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.b)
    pub b: ::std::option::Option<crate::EnumOrUnknown<super::enums::EStorageBlockContentType>>,
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.c)
    pub c: ::std::option::Option<crate::EnumOrUnknown<super::enums::EStorageBlockFileSystemType>>,
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.d)
    pub d: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESDCardFormatStage>>,
    // special fields
    // @@protoc_insertion_point(special_field:SteamMessagesClientIClientForcedEnumDependencies.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SteamMessagesClientIClientForcedEnumDependencies {
    fn default() -> &'a SteamMessagesClientIClientForcedEnumDependencies {
        <SteamMessagesClientIClientForcedEnumDependencies as crate::Message>::default_instance()
    }
}

impl SteamMessagesClientIClientForcedEnumDependencies {
    pub fn new() -> SteamMessagesClientIClientForcedEnumDependencies {
        ::std::default::Default::default()
    }

    // optional .EBluetoothDeviceType a = 1;

    pub fn a(&self) -> super::enums::EBluetoothDeviceType {
        match self.a {
            Some(e) => e.enum_value_or(super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            None => super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid,
        }
    }

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: super::enums::EBluetoothDeviceType) {
        self.a = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EStorageBlockContentType b = 2;

    pub fn b(&self) -> super::enums::EStorageBlockContentType {
        match self.b {
            Some(e) => e.enum_value_or(super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            None => super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid,
        }
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: super::enums::EStorageBlockContentType) {
        self.b = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EStorageBlockFileSystemType c = 3;

    pub fn c(&self) -> super::enums::EStorageBlockFileSystemType {
        match self.c {
            Some(e) => e.enum_value_or(super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            None => super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid,
        }
    }

    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: super::enums::EStorageBlockFileSystemType) {
        self.c = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .ESDCardFormatStage d = 4;

    pub fn d(&self) -> super::enums::ESDCardFormatStage {
        match self.d {
            Some(e) => e.enum_value_or(super::enums::ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            None => super::enums::ESDCardFormatStage::k_ESDCardFormatStage_Invalid,
        }
    }

    pub fn clear_d(&mut self) {
        self.d = ::std::option::Option::None;
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: super::enums::ESDCardFormatStage) {
        self.d = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "a",
            |m: &SteamMessagesClientIClientForcedEnumDependencies| { &m.a },
            |m: &mut SteamMessagesClientIClientForcedEnumDependencies| { &mut m.a },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "b",
            |m: &SteamMessagesClientIClientForcedEnumDependencies| { &m.b },
            |m: &mut SteamMessagesClientIClientForcedEnumDependencies| { &mut m.b },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "c",
            |m: &SteamMessagesClientIClientForcedEnumDependencies| { &m.c },
            |m: &mut SteamMessagesClientIClientForcedEnumDependencies| { &mut m.c },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "d",
            |m: &SteamMessagesClientIClientForcedEnumDependencies| { &m.d },
            |m: &mut SteamMessagesClientIClientForcedEnumDependencies| { &mut m.d },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<SteamMessagesClientIClientForcedEnumDependencies>(
            "SteamMessagesClientIClientForcedEnumDependencies",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for SteamMessagesClientIClientForcedEnumDependencies {
    const NAME: &'static str = "SteamMessagesClientIClientForcedEnumDependencies";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.a = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.b = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.c = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.d = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.b {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.c {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.d {
            my_size += crate::rt::int32_size(4, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.a {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.b {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.c {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.d {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SteamMessagesClientIClientForcedEnumDependencies {
        SteamMessagesClientIClientForcedEnumDependencies::new()
    }

    fn clear(&mut self) {
        self.a = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.c = ::std::option::Option::None;
        self.d = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SteamMessagesClientIClientForcedEnumDependencies {
        static instance: SteamMessagesClientIClientForcedEnumDependencies = SteamMessagesClientIClientForcedEnumDependencies {
            a: ::std::option::Option::None,
            b: ::std::option::Option::None,
            c: ::std::option::Option::None,
            d: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for SteamMessagesClientIClientForcedEnumDependencies {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SteamMessagesClientIClientForcedEnumDependencies").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SteamMessagesClientIClientForcedEnumDependencies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for SteamMessagesClientIClientForcedEnumDependencies {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP4Address)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP4Address {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Address.ip)
    pub ip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Address.netmask)
    pub netmask: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP4Address.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP4Address {
    fn default() -> &'a CMsgNetworkDeviceIP4Address {
        <CMsgNetworkDeviceIP4Address as crate::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP4Address {
    pub fn new() -> CMsgNetworkDeviceIP4Address {
        ::std::default::Default::default()
    }

    // optional int32 ip = 1;

    pub fn ip(&self) -> i32 {
        self.ip.unwrap_or(0i32)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: i32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional int32 netmask = 2;

    pub fn netmask(&self) -> i32 {
        self.netmask.unwrap_or(0)
    }

    pub fn clear_netmask(&mut self) {
        self.netmask = ::std::option::Option::None;
    }

    pub fn has_netmask(&self) -> bool {
        self.netmask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_netmask(&mut self, v: i32) {
        self.netmask = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgNetworkDeviceIP4Address| { &m.ip },
            |m: &mut CMsgNetworkDeviceIP4Address| { &mut m.ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "netmask",
            |m: &CMsgNetworkDeviceIP4Address| { &m.netmask },
            |m: &mut CMsgNetworkDeviceIP4Address| { &mut m.netmask },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNetworkDeviceIP4Address>(
            "CMsgNetworkDeviceIP4Address",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNetworkDeviceIP4Address {
    const NAME: &'static str = "CMsgNetworkDeviceIP4Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ip = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.netmask = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.netmask {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.ip {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.netmask {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP4Address {
        CMsgNetworkDeviceIP4Address::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.netmask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP4Address {
        static instance: CMsgNetworkDeviceIP4Address = CMsgNetworkDeviceIP4Address {
            ip: ::std::option::Option::None,
            netmask: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNetworkDeviceIP4Address {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceIP4Address").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNetworkDeviceIP4Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNetworkDeviceIP4Address {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP4Config)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP4Config {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.addresses)
    pub addresses: ::std::vec::Vec<CMsgNetworkDeviceIP4Address>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.dns_ip)
    pub dns_ip: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.gateway_ip)
    pub gateway_ip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.is_dhcp_enabled)
    pub is_dhcp_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.is_default_route)
    pub is_default_route: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.is_enabled)
    pub is_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP4Config.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP4Config {
    fn default() -> &'a CMsgNetworkDeviceIP4Config {
        <CMsgNetworkDeviceIP4Config as crate::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP4Config {
    pub fn new() -> CMsgNetworkDeviceIP4Config {
        ::std::default::Default::default()
    }

    // repeated .CMsgNetworkDeviceIP4Address addresses = 1;

    pub fn addresses(&self) -> &[CMsgNetworkDeviceIP4Address] {
        &self.addresses
    }

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::std::vec::Vec<CMsgNetworkDeviceIP4Address>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::std::vec::Vec<CMsgNetworkDeviceIP4Address> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::std::vec::Vec<CMsgNetworkDeviceIP4Address> {
        ::std::mem::replace(&mut self.addresses, ::std::vec::Vec::new())
    }

    // repeated int32 dns_ip = 2;

    pub fn dns_ip(&self) -> &[i32] {
        &self.dns_ip
    }

    pub fn clear_dns_ip(&mut self) {
        self.dns_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_dns_ip(&mut self, v: ::std::vec::Vec<i32>) {
        self.dns_ip = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dns_ip(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.dns_ip
    }

    // Take field
    pub fn take_dns_ip(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.dns_ip, ::std::vec::Vec::new())
    }

    // optional int32 gateway_ip = 3;

    pub fn gateway_ip(&self) -> i32 {
        self.gateway_ip.unwrap_or(0)
    }

    pub fn clear_gateway_ip(&mut self) {
        self.gateway_ip = ::std::option::Option::None;
    }

    pub fn has_gateway_ip(&self) -> bool {
        self.gateway_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway_ip(&mut self, v: i32) {
        self.gateway_ip = ::std::option::Option::Some(v);
    }

    // optional bool is_dhcp_enabled = 4;

    pub fn is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.unwrap_or(false)
    }

    pub fn clear_is_dhcp_enabled(&mut self) {
        self.is_dhcp_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dhcp_enabled(&mut self, v: bool) {
        self.is_dhcp_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_default_route = 5;

    pub fn is_default_route(&self) -> bool {
        self.is_default_route.unwrap_or(false)
    }

    pub fn clear_is_default_route(&mut self) {
        self.is_default_route = ::std::option::Option::None;
    }

    pub fn has_is_default_route(&self) -> bool {
        self.is_default_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_default_route(&mut self, v: bool) {
        self.is_default_route = ::std::option::Option::Some(v);
    }

    // optional bool is_enabled = 6;

    pub fn is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }

    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &CMsgNetworkDeviceIP4Config| { &m.addresses },
            |m: &mut CMsgNetworkDeviceIP4Config| { &mut m.addresses },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dns_ip",
            |m: &CMsgNetworkDeviceIP4Config| { &m.dns_ip },
            |m: &mut CMsgNetworkDeviceIP4Config| { &mut m.dns_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gateway_ip",
            |m: &CMsgNetworkDeviceIP4Config| { &m.gateway_ip },
            |m: &mut CMsgNetworkDeviceIP4Config| { &mut m.gateway_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dhcp_enabled",
            |m: &CMsgNetworkDeviceIP4Config| { &m.is_dhcp_enabled },
            |m: &mut CMsgNetworkDeviceIP4Config| { &mut m.is_dhcp_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_default_route",
            |m: &CMsgNetworkDeviceIP4Config| { &m.is_default_route },
            |m: &mut CMsgNetworkDeviceIP4Config| { &mut m.is_default_route },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_enabled",
            |m: &CMsgNetworkDeviceIP4Config| { &m.is_enabled },
            |m: &mut CMsgNetworkDeviceIP4Config| { &mut m.is_enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNetworkDeviceIP4Config>(
            "CMsgNetworkDeviceIP4Config",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNetworkDeviceIP4Config {
    const NAME: &'static str = "CMsgNetworkDeviceIP4Config";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.dns_ip)?;
                },
                16 => {
                    self.dns_ip.push(is.read_int32()?);
                },
                24 => {
                    self.gateway_ip = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.is_dhcp_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_default_route = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dns_ip {
            my_size += crate::rt::int32_size(2, *value);
        };
        if let Some(v) = self.gateway_ip {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.is_dhcp_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_default_route {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_enabled {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.addresses {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.dns_ip {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.gateway_ip {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.is_dhcp_enabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_default_route {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_enabled {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP4Config {
        CMsgNetworkDeviceIP4Config::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.dns_ip.clear();
        self.gateway_ip = ::std::option::Option::None;
        self.is_dhcp_enabled = ::std::option::Option::None;
        self.is_default_route = ::std::option::Option::None;
        self.is_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP4Config {
        static instance: CMsgNetworkDeviceIP4Config = CMsgNetworkDeviceIP4Config {
            addresses: ::std::vec::Vec::new(),
            dns_ip: ::std::vec::Vec::new(),
            gateway_ip: ::std::option::Option::None,
            is_dhcp_enabled: ::std::option::Option::None,
            is_default_route: ::std::option::Option::None,
            is_enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNetworkDeviceIP4Config {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceIP4Config").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNetworkDeviceIP4Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNetworkDeviceIP4Config {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP6Address)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP6Address {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Address.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP6Address.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP6Address {
    fn default() -> &'a CMsgNetworkDeviceIP6Address {
        <CMsgNetworkDeviceIP6Address as crate::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP6Address {
    pub fn new() -> CMsgNetworkDeviceIP6Address {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgNetworkDeviceIP6Address| { &m.ip },
            |m: &mut CMsgNetworkDeviceIP6Address| { &mut m.ip },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNetworkDeviceIP6Address>(
            "CMsgNetworkDeviceIP6Address",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNetworkDeviceIP6Address {
    const NAME: &'static str = "CMsgNetworkDeviceIP6Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP6Address {
        CMsgNetworkDeviceIP6Address::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP6Address {
        static instance: CMsgNetworkDeviceIP6Address = CMsgNetworkDeviceIP6Address {
            ip: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNetworkDeviceIP6Address {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceIP6Address").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNetworkDeviceIP6Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNetworkDeviceIP6Address {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP6Config)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP6Config {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.addresses)
    pub addresses: ::std::vec::Vec<CMsgNetworkDeviceIP6Address>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.dns_ip)
    pub dns_ip: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.gateway_ip)
    pub gateway_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.is_dhcp_enabled)
    pub is_dhcp_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.is_default_route)
    pub is_default_route: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.is_enabled)
    pub is_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP6Config.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP6Config {
    fn default() -> &'a CMsgNetworkDeviceIP6Config {
        <CMsgNetworkDeviceIP6Config as crate::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP6Config {
    pub fn new() -> CMsgNetworkDeviceIP6Config {
        ::std::default::Default::default()
    }

    // repeated .CMsgNetworkDeviceIP6Address addresses = 1;

    pub fn addresses(&self) -> &[CMsgNetworkDeviceIP6Address] {
        &self.addresses
    }

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::std::vec::Vec<CMsgNetworkDeviceIP6Address>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::std::vec::Vec<CMsgNetworkDeviceIP6Address> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::std::vec::Vec<CMsgNetworkDeviceIP6Address> {
        ::std::mem::replace(&mut self.addresses, ::std::vec::Vec::new())
    }

    // repeated string dns_ip = 2;

    pub fn dns_ip(&self) -> &[::std::string::String] {
        &self.dns_ip
    }

    pub fn clear_dns_ip(&mut self) {
        self.dns_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_dns_ip(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.dns_ip = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dns_ip(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.dns_ip
    }

    // Take field
    pub fn take_dns_ip(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.dns_ip, ::std::vec::Vec::new())
    }

    // optional string gateway_ip = 3;

    pub fn gateway_ip(&self) -> &str {
        match self.gateway_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gateway_ip(&mut self) {
        self.gateway_ip = ::std::option::Option::None;
    }

    pub fn has_gateway_ip(&self) -> bool {
        self.gateway_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway_ip(&mut self, v: ::std::string::String) {
        self.gateway_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_ip(&mut self) -> &mut ::std::string::String {
        if self.gateway_ip.is_none() {
            self.gateway_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gateway_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway_ip(&mut self) -> ::std::string::String {
        self.gateway_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_dhcp_enabled = 4;

    pub fn is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.unwrap_or(false)
    }

    pub fn clear_is_dhcp_enabled(&mut self) {
        self.is_dhcp_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dhcp_enabled(&mut self, v: bool) {
        self.is_dhcp_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_default_route = 5;

    pub fn is_default_route(&self) -> bool {
        self.is_default_route.unwrap_or(false)
    }

    pub fn clear_is_default_route(&mut self) {
        self.is_default_route = ::std::option::Option::None;
    }

    pub fn has_is_default_route(&self) -> bool {
        self.is_default_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_default_route(&mut self, v: bool) {
        self.is_default_route = ::std::option::Option::Some(v);
    }

    // optional bool is_enabled = 6;

    pub fn is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }

    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &CMsgNetworkDeviceIP6Config| { &m.addresses },
            |m: &mut CMsgNetworkDeviceIP6Config| { &mut m.addresses },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dns_ip",
            |m: &CMsgNetworkDeviceIP6Config| { &m.dns_ip },
            |m: &mut CMsgNetworkDeviceIP6Config| { &mut m.dns_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gateway_ip",
            |m: &CMsgNetworkDeviceIP6Config| { &m.gateway_ip },
            |m: &mut CMsgNetworkDeviceIP6Config| { &mut m.gateway_ip },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dhcp_enabled",
            |m: &CMsgNetworkDeviceIP6Config| { &m.is_dhcp_enabled },
            |m: &mut CMsgNetworkDeviceIP6Config| { &mut m.is_dhcp_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_default_route",
            |m: &CMsgNetworkDeviceIP6Config| { &m.is_default_route },
            |m: &mut CMsgNetworkDeviceIP6Config| { &mut m.is_default_route },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_enabled",
            |m: &CMsgNetworkDeviceIP6Config| { &m.is_enabled },
            |m: &mut CMsgNetworkDeviceIP6Config| { &mut m.is_enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNetworkDeviceIP6Config>(
            "CMsgNetworkDeviceIP6Config",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNetworkDeviceIP6Config {
    const NAME: &'static str = "CMsgNetworkDeviceIP6Config";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_message()?);
                },
                18 => {
                    self.dns_ip.push(is.read_string()?);
                },
                26 => {
                    self.gateway_ip = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.is_dhcp_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_default_route = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dns_ip {
            my_size += crate::rt::string_size(2, &value);
        };
        if let Some(v) = self.gateway_ip.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.is_dhcp_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_default_route {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_enabled {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.addresses {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.dns_ip {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.gateway_ip.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.is_dhcp_enabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_default_route {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_enabled {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP6Config {
        CMsgNetworkDeviceIP6Config::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.dns_ip.clear();
        self.gateway_ip = ::std::option::Option::None;
        self.is_dhcp_enabled = ::std::option::Option::None;
        self.is_default_route = ::std::option::Option::None;
        self.is_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP6Config {
        static instance: CMsgNetworkDeviceIP6Config = CMsgNetworkDeviceIP6Config {
            addresses: ::std::vec::Vec::new(),
            dns_ip: ::std::vec::Vec::new(),
            gateway_ip: ::std::option::Option::None,
            is_dhcp_enabled: ::std::option::Option::None,
            is_default_route: ::std::option::Option::None,
            is_enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNetworkDeviceIP6Config {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceIP6Config").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNetworkDeviceIP6Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNetworkDeviceIP6Config {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNetworkDevicesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDevicesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDevicesData.devices)
    pub devices: ::std::vec::Vec<cmsg_network_devices_data::Device>,
    // @@protoc_insertion_point(field:CMsgNetworkDevicesData.is_wifi_enabled)
    pub is_wifi_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDevicesData.is_wifi_scanning_enabled)
    pub is_wifi_scanning_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDevicesData {
    fn default() -> &'a CMsgNetworkDevicesData {
        <CMsgNetworkDevicesData as crate::Message>::default_instance()
    }
}

impl CMsgNetworkDevicesData {
    pub fn new() -> CMsgNetworkDevicesData {
        ::std::default::Default::default()
    }

    // repeated .CMsgNetworkDevicesData.Device devices = 1;

    pub fn devices(&self) -> &[cmsg_network_devices_data::Device] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<cmsg_network_devices_data::Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<cmsg_network_devices_data::Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<cmsg_network_devices_data::Device> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    // optional bool is_wifi_enabled = 2;

    pub fn is_wifi_enabled(&self) -> bool {
        self.is_wifi_enabled.unwrap_or(false)
    }

    pub fn clear_is_wifi_enabled(&mut self) {
        self.is_wifi_enabled = ::std::option::Option::None;
    }

    pub fn has_is_wifi_enabled(&self) -> bool {
        self.is_wifi_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_wifi_enabled(&mut self, v: bool) {
        self.is_wifi_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_wifi_scanning_enabled = 3;

    pub fn is_wifi_scanning_enabled(&self) -> bool {
        self.is_wifi_scanning_enabled.unwrap_or(false)
    }

    pub fn clear_is_wifi_scanning_enabled(&mut self) {
        self.is_wifi_scanning_enabled = ::std::option::Option::None;
    }

    pub fn has_is_wifi_scanning_enabled(&self) -> bool {
        self.is_wifi_scanning_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_wifi_scanning_enabled(&mut self, v: bool) {
        self.is_wifi_scanning_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &CMsgNetworkDevicesData| { &m.devices },
            |m: &mut CMsgNetworkDevicesData| { &mut m.devices },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_wifi_enabled",
            |m: &CMsgNetworkDevicesData| { &m.is_wifi_enabled },
            |m: &mut CMsgNetworkDevicesData| { &mut m.is_wifi_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_wifi_scanning_enabled",
            |m: &CMsgNetworkDevicesData| { &m.is_wifi_scanning_enabled },
            |m: &mut CMsgNetworkDevicesData| { &mut m.is_wifi_scanning_enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNetworkDevicesData>(
            "CMsgNetworkDevicesData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNetworkDevicesData {
    const NAME: &'static str = "CMsgNetworkDevicesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.devices.push(is.read_message()?);
                },
                16 => {
                    self.is_wifi_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.is_wifi_scanning_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_wifi_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_wifi_scanning_enabled {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.devices {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_wifi_enabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.is_wifi_scanning_enabled {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDevicesData {
        CMsgNetworkDevicesData::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.is_wifi_enabled = ::std::option::Option::None;
        self.is_wifi_scanning_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDevicesData {
        static instance: CMsgNetworkDevicesData = CMsgNetworkDevicesData {
            devices: ::std::vec::Vec::new(),
            is_wifi_enabled: ::std::option::Option::None,
            is_wifi_scanning_enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNetworkDevicesData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNetworkDevicesData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNetworkDevicesData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNetworkDevicesData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgNetworkDevicesData`
pub mod cmsg_network_devices_data {
    // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Device {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.etype)
        pub etype: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.estate)
        pub estate: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.mac)
        pub mac: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.vendor)
        pub vendor: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.product)
        pub product: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.ip4)
        pub ip4: crate::MessageField<super::CMsgNetworkDeviceIP4Config>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.ip6)
        pub ip6: crate::MessageField<super::CMsgNetworkDeviceIP6Config>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.wired)
        pub wired: crate::MessageField<device::Wired>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.wireless)
        pub wireless: crate::MessageField<device::Wireless>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Device {
        fn default() -> &'a Device {
            <Device as crate::Message>::default_instance()
        }
    }

    impl Device {
        pub fn new() -> Device {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional int32 etype = 2;

        pub fn etype(&self) -> i32 {
            self.etype.unwrap_or(0)
        }

        pub fn clear_etype(&mut self) {
            self.etype = ::std::option::Option::None;
        }

        pub fn has_etype(&self) -> bool {
            self.etype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_etype(&mut self, v: i32) {
            self.etype = ::std::option::Option::Some(v);
        }

        // optional int32 estate = 3;

        pub fn estate(&self) -> i32 {
            self.estate.unwrap_or(0)
        }

        pub fn clear_estate(&mut self) {
            self.estate = ::std::option::Option::None;
        }

        pub fn has_estate(&self) -> bool {
            self.estate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_estate(&mut self, v: i32) {
            self.estate = ::std::option::Option::Some(v);
        }

        // optional string mac = 4;

        pub fn mac(&self) -> &str {
            match self.mac.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: ::std::string::String) {
            self.mac = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mac(&mut self) -> &mut ::std::string::String {
            if self.mac.is_none() {
                self.mac = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mac.as_mut().unwrap()
        }

        // Take field
        pub fn take_mac(&mut self) -> ::std::string::String {
            self.mac.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vendor = 5;

        pub fn vendor(&self) -> &str {
            match self.vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vendor(&mut self) {
            self.vendor = ::std::option::Option::None;
        }

        pub fn has_vendor(&self) -> bool {
            self.vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vendor(&mut self, v: ::std::string::String) {
            self.vendor = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
            if self.vendor.is_none() {
                self.vendor = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vendor(&mut self) -> ::std::string::String {
            self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string product = 6;

        pub fn product(&self) -> &str {
            match self.product.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_product(&mut self) {
            self.product = ::std::option::Option::None;
        }

        pub fn has_product(&self) -> bool {
            self.product.is_some()
        }

        // Param is passed by value, moved
        pub fn set_product(&mut self, v: ::std::string::String) {
            self.product = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_product(&mut self) -> &mut ::std::string::String {
            if self.product.is_none() {
                self.product = ::std::option::Option::Some(::std::string::String::new());
            }
            self.product.as_mut().unwrap()
        }

        // Take field
        pub fn take_product(&mut self) -> ::std::string::String {
            self.product.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .CMsgNetworkDeviceIP4Config ip4 = 7;

        pub fn ip4(&self) -> &super::CMsgNetworkDeviceIP4Config {
            self.ip4.as_ref().unwrap_or_else(|| <super::CMsgNetworkDeviceIP4Config as crate::Message>::default_instance())
        }

        pub fn clear_ip4(&mut self) {
            self.ip4.clear();
        }

        pub fn has_ip4(&self) -> bool {
            self.ip4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip4(&mut self, v: super::CMsgNetworkDeviceIP4Config) {
            self.ip4 = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ip4(&mut self) -> &mut super::CMsgNetworkDeviceIP4Config {
            self.ip4.mut_or_insert_default()
        }

        // Take field
        pub fn take_ip4(&mut self) -> super::CMsgNetworkDeviceIP4Config {
            self.ip4.take().unwrap_or_else(|| super::CMsgNetworkDeviceIP4Config::new())
        }

        // optional .CMsgNetworkDeviceIP6Config ip6 = 8;

        pub fn ip6(&self) -> &super::CMsgNetworkDeviceIP6Config {
            self.ip6.as_ref().unwrap_or_else(|| <super::CMsgNetworkDeviceIP6Config as crate::Message>::default_instance())
        }

        pub fn clear_ip6(&mut self) {
            self.ip6.clear();
        }

        pub fn has_ip6(&self) -> bool {
            self.ip6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip6(&mut self, v: super::CMsgNetworkDeviceIP6Config) {
            self.ip6 = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ip6(&mut self) -> &mut super::CMsgNetworkDeviceIP6Config {
            self.ip6.mut_or_insert_default()
        }

        // Take field
        pub fn take_ip6(&mut self) -> super::CMsgNetworkDeviceIP6Config {
            self.ip6.take().unwrap_or_else(|| super::CMsgNetworkDeviceIP6Config::new())
        }

        // optional .CMsgNetworkDevicesData.Device.Wired wired = 9;

        pub fn wired(&self) -> &device::Wired {
            self.wired.as_ref().unwrap_or_else(|| <device::Wired as crate::Message>::default_instance())
        }

        pub fn clear_wired(&mut self) {
            self.wired.clear();
        }

        pub fn has_wired(&self) -> bool {
            self.wired.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wired(&mut self, v: device::Wired) {
            self.wired = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_wired(&mut self) -> &mut device::Wired {
            self.wired.mut_or_insert_default()
        }

        // Take field
        pub fn take_wired(&mut self) -> device::Wired {
            self.wired.take().unwrap_or_else(|| device::Wired::new())
        }

        // optional .CMsgNetworkDevicesData.Device.Wireless wireless = 10;

        pub fn wireless(&self) -> &device::Wireless {
            self.wireless.as_ref().unwrap_or_else(|| <device::Wireless as crate::Message>::default_instance())
        }

        pub fn clear_wireless(&mut self) {
            self.wireless.clear();
        }

        pub fn has_wireless(&self) -> bool {
            self.wireless.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wireless(&mut self, v: device::Wireless) {
            self.wireless = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_wireless(&mut self) -> &mut device::Wireless {
            self.wireless.mut_or_insert_default()
        }

        // Take field
        pub fn take_wireless(&mut self) -> device::Wireless {
            self.wireless.take().unwrap_or_else(|| device::Wireless::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Device| { &m.id },
                |m: &mut Device| { &mut m.id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "etype",
                |m: &Device| { &m.etype },
                |m: &mut Device| { &mut m.etype },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "estate",
                |m: &Device| { &m.estate },
                |m: &mut Device| { &mut m.estate },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mac",
                |m: &Device| { &m.mac },
                |m: &mut Device| { &mut m.mac },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "vendor",
                |m: &Device| { &m.vendor },
                |m: &mut Device| { &mut m.vendor },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "product",
                |m: &Device| { &m.product },
                |m: &mut Device| { &mut m.product },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgNetworkDeviceIP4Config>(
                "ip4",
                |m: &Device| { &m.ip4 },
                |m: &mut Device| { &mut m.ip4 },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgNetworkDeviceIP6Config>(
                "ip6",
                |m: &Device| { &m.ip6 },
                |m: &mut Device| { &mut m.ip6 },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, device::Wired>(
                "wired",
                |m: &Device| { &m.wired },
                |m: &mut Device| { &mut m.wired },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, device::Wireless>(
                "wireless",
                |m: &Device| { &m.wireless },
                |m: &mut Device| { &mut m.wireless },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
                "CMsgNetworkDevicesData.Device",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Device {
        const NAME: &'static str = "Device";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.etype = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.estate = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.mac = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.vendor = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.product = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.ip4)?;
                    },
                    66 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.ip6)?;
                    },
                    74 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.wired)?;
                    },
                    82 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.wireless)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.etype {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.estate {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.mac.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.vendor.as_ref() {
                my_size += crate::rt::string_size(5, &v);
            }
            if let Some(v) = self.product.as_ref() {
                my_size += crate::rt::string_size(6, &v);
            }
            if let Some(v) = self.ip4.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.ip6.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.wired.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.wireless.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.etype {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.estate {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.mac.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.vendor.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.product.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.ip4.as_ref() {
                crate::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.ip6.as_ref() {
                crate::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            if let Some(v) = self.wired.as_ref() {
                crate::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            if let Some(v) = self.wireless.as_ref() {
                crate::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Device {
            Device::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.etype = ::std::option::Option::None;
            self.estate = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.vendor = ::std::option::Option::None;
            self.product = ::std::option::Option::None;
            self.ip4.clear();
            self.ip6.clear();
            self.wired.clear();
            self.wireless.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Device {
            static instance: Device = Device {
                id: ::std::option::Option::None,
                etype: ::std::option::Option::None,
                estate: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                vendor: ::std::option::Option::None,
                product: ::std::option::Option::None,
                ip4: crate::MessageField::none(),
                ip6: crate::MessageField::none(),
                wired: crate::MessageField::none(),
                wireless: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Device {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgNetworkDevicesData.Device").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Device {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Device {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Device`
    pub mod device {
        // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device.Wired)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Wired {
            // message fields
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wired.is_cable_present)
            pub is_cable_present: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wired.speed_mbit)
            pub speed_mbit: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wired.friendly_name)
            pub friendly_name: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.Wired.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Wired {
            fn default() -> &'a Wired {
                <Wired as crate::Message>::default_instance()
            }
        }

        impl Wired {
            pub fn new() -> Wired {
                ::std::default::Default::default()
            }

            // optional bool is_cable_present = 1;

            pub fn is_cable_present(&self) -> bool {
                self.is_cable_present.unwrap_or(false)
            }

            pub fn clear_is_cable_present(&mut self) {
                self.is_cable_present = ::std::option::Option::None;
            }

            pub fn has_is_cable_present(&self) -> bool {
                self.is_cable_present.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_cable_present(&mut self, v: bool) {
                self.is_cable_present = ::std::option::Option::Some(v);
            }

            // optional uint32 speed_mbit = 2;

            pub fn speed_mbit(&self) -> u32 {
                self.speed_mbit.unwrap_or(0)
            }

            pub fn clear_speed_mbit(&mut self) {
                self.speed_mbit = ::std::option::Option::None;
            }

            pub fn has_speed_mbit(&self) -> bool {
                self.speed_mbit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_speed_mbit(&mut self, v: u32) {
                self.speed_mbit = ::std::option::Option::Some(v);
            }

            // optional string friendly_name = 3;

            pub fn friendly_name(&self) -> &str {
                match self.friendly_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_friendly_name(&mut self) {
                self.friendly_name = ::std::option::Option::None;
            }

            pub fn has_friendly_name(&self) -> bool {
                self.friendly_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_friendly_name(&mut self, v: ::std::string::String) {
                self.friendly_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_friendly_name(&mut self) -> &mut ::std::string::String {
                if self.friendly_name.is_none() {
                    self.friendly_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.friendly_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_friendly_name(&mut self) -> ::std::string::String {
                self.friendly_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_cable_present",
                    |m: &Wired| { &m.is_cable_present },
                    |m: &mut Wired| { &mut m.is_cable_present },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "speed_mbit",
                    |m: &Wired| { &m.speed_mbit },
                    |m: &mut Wired| { &mut m.speed_mbit },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "friendly_name",
                    |m: &Wired| { &m.friendly_name },
                    |m: &mut Wired| { &mut m.friendly_name },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<Wired>(
                    "CMsgNetworkDevicesData.Device.Wired",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for Wired {
            const NAME: &'static str = "Wired";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.is_cable_present = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.speed_mbit = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        26 => {
                            self.friendly_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.is_cable_present {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.speed_mbit {
                    my_size += crate::rt::uint32_size(2, v);
                }
                if let Some(v) = self.friendly_name.as_ref() {
                    my_size += crate::rt::string_size(3, &v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.is_cable_present {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.speed_mbit {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.friendly_name.as_ref() {
                    os.write_string(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Wired {
                Wired::new()
            }

            fn clear(&mut self) {
                self.is_cable_present = ::std::option::Option::None;
                self.speed_mbit = ::std::option::Option::None;
                self.friendly_name = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Wired {
                static instance: Wired = Wired {
                    is_cable_present: ::std::option::Option::None,
                    speed_mbit: ::std::option::Option::None,
                    friendly_name: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for Wired {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgNetworkDevicesData.Device.Wired").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Wired {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for Wired {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device.Wireless)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Wireless {
            // message fields
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.aps)
            pub aps: ::std::vec::Vec<wireless::AP>,
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.esecurity_supported)
            pub esecurity_supported: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.Wireless.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Wireless {
            fn default() -> &'a Wireless {
                <Wireless as crate::Message>::default_instance()
            }
        }

        impl Wireless {
            pub fn new() -> Wireless {
                ::std::default::Default::default()
            }

            // repeated .CMsgNetworkDevicesData.Device.Wireless.AP aps = 1;

            pub fn aps(&self) -> &[wireless::AP] {
                &self.aps
            }

            pub fn clear_aps(&mut self) {
                self.aps.clear();
            }

            // Param is passed by value, moved
            pub fn set_aps(&mut self, v: ::std::vec::Vec<wireless::AP>) {
                self.aps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_aps(&mut self) -> &mut ::std::vec::Vec<wireless::AP> {
                &mut self.aps
            }

            // Take field
            pub fn take_aps(&mut self) -> ::std::vec::Vec<wireless::AP> {
                ::std::mem::replace(&mut self.aps, ::std::vec::Vec::new())
            }

            // optional int32 esecurity_supported = 2;

            pub fn esecurity_supported(&self) -> i32 {
                self.esecurity_supported.unwrap_or(0)
            }

            pub fn clear_esecurity_supported(&mut self) {
                self.esecurity_supported = ::std::option::Option::None;
            }

            pub fn has_esecurity_supported(&self) -> bool {
                self.esecurity_supported.is_some()
            }

            // Param is passed by value, moved
            pub fn set_esecurity_supported(&mut self, v: i32) {
                self.esecurity_supported = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "aps",
                    |m: &Wireless| { &m.aps },
                    |m: &mut Wireless| { &mut m.aps },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "esecurity_supported",
                    |m: &Wireless| { &m.esecurity_supported },
                    |m: &mut Wireless| { &mut m.esecurity_supported },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<Wireless>(
                    "CMsgNetworkDevicesData.Device.Wireless",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for Wireless {
            const NAME: &'static str = "Wireless";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.aps.push(is.read_message()?);
                        },
                        16 => {
                            self.esecurity_supported = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.aps {
                    let len = value.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.esecurity_supported {
                    my_size += crate::rt::int32_size(2, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                for v in &self.aps {
                    crate::rt::write_message_field_with_cached_size(1, v, os)?;
                };
                if let Some(v) = self.esecurity_supported {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Wireless {
                Wireless::new()
            }

            fn clear(&mut self) {
                self.aps.clear();
                self.esecurity_supported = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Wireless {
                static instance: Wireless = Wireless {
                    aps: ::std::vec::Vec::new(),
                    esecurity_supported: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for Wireless {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgNetworkDevicesData.Device.Wireless").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Wireless {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for Wireless {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `Wireless`
        pub mod wireless {
            // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device.Wireless.AP)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct AP {
                // message fields
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.id)
                pub id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.estrength)
                pub estrength: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.ssid)
                pub ssid: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.is_active)
                pub is_active: ::std::option::Option<bool>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.is_autoconnect)
                pub is_autoconnect: ::std::option::Option<bool>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.esecurity)
                pub esecurity: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.user_name)
                pub user_name: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.password)
                pub password: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.strength_raw)
                pub strength_raw: ::std::option::Option<i32>,
                // special fields
                // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.Wireless.AP.special_fields)
                pub special_fields: crate::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a AP {
                fn default() -> &'a AP {
                    <AP as crate::Message>::default_instance()
                }
            }

            impl AP {
                pub fn new() -> AP {
                    ::std::default::Default::default()
                }

                // optional uint32 id = 1;

                pub fn id(&self) -> u32 {
                    self.id.unwrap_or(0u32)
                }

                pub fn clear_id(&mut self) {
                    self.id = ::std::option::Option::None;
                }

                pub fn has_id(&self) -> bool {
                    self.id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_id(&mut self, v: u32) {
                    self.id = ::std::option::Option::Some(v);
                }

                // optional int32 estrength = 2;

                pub fn estrength(&self) -> i32 {
                    self.estrength.unwrap_or(0)
                }

                pub fn clear_estrength(&mut self) {
                    self.estrength = ::std::option::Option::None;
                }

                pub fn has_estrength(&self) -> bool {
                    self.estrength.is_some()
                }

                // Param is passed by value, moved
                pub fn set_estrength(&mut self, v: i32) {
                    self.estrength = ::std::option::Option::Some(v);
                }

                // optional string ssid = 3;

                pub fn ssid(&self) -> &str {
                    match self.ssid.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_ssid(&mut self) {
                    self.ssid = ::std::option::Option::None;
                }

                pub fn has_ssid(&self) -> bool {
                    self.ssid.is_some()
                }

                // Param is passed by value, moved
                pub fn set_ssid(&mut self, v: ::std::string::String) {
                    self.ssid = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_ssid(&mut self) -> &mut ::std::string::String {
                    if self.ssid.is_none() {
                        self.ssid = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.ssid.as_mut().unwrap()
                }

                // Take field
                pub fn take_ssid(&mut self) -> ::std::string::String {
                    self.ssid.take().unwrap_or_else(|| ::std::string::String::new())
                }

                // optional bool is_active = 4;

                pub fn is_active(&self) -> bool {
                    self.is_active.unwrap_or(false)
                }

                pub fn clear_is_active(&mut self) {
                    self.is_active = ::std::option::Option::None;
                }

                pub fn has_is_active(&self) -> bool {
                    self.is_active.is_some()
                }

                // Param is passed by value, moved
                pub fn set_is_active(&mut self, v: bool) {
                    self.is_active = ::std::option::Option::Some(v);
                }

                // optional bool is_autoconnect = 5;

                pub fn is_autoconnect(&self) -> bool {
                    self.is_autoconnect.unwrap_or(false)
                }

                pub fn clear_is_autoconnect(&mut self) {
                    self.is_autoconnect = ::std::option::Option::None;
                }

                pub fn has_is_autoconnect(&self) -> bool {
                    self.is_autoconnect.is_some()
                }

                // Param is passed by value, moved
                pub fn set_is_autoconnect(&mut self, v: bool) {
                    self.is_autoconnect = ::std::option::Option::Some(v);
                }

                // optional int32 esecurity = 6;

                pub fn esecurity(&self) -> i32 {
                    self.esecurity.unwrap_or(0)
                }

                pub fn clear_esecurity(&mut self) {
                    self.esecurity = ::std::option::Option::None;
                }

                pub fn has_esecurity(&self) -> bool {
                    self.esecurity.is_some()
                }

                // Param is passed by value, moved
                pub fn set_esecurity(&mut self, v: i32) {
                    self.esecurity = ::std::option::Option::Some(v);
                }

                // optional string user_name = 7;

                pub fn user_name(&self) -> &str {
                    match self.user_name.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_user_name(&mut self) {
                    self.user_name = ::std::option::Option::None;
                }

                pub fn has_user_name(&self) -> bool {
                    self.user_name.is_some()
                }

                // Param is passed by value, moved
                pub fn set_user_name(&mut self, v: ::std::string::String) {
                    self.user_name = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
                    if self.user_name.is_none() {
                        self.user_name = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.user_name.as_mut().unwrap()
                }

                // Take field
                pub fn take_user_name(&mut self) -> ::std::string::String {
                    self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
                }

                // optional string password = 8;

                pub fn password(&self) -> &str {
                    match self.password.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_password(&mut self) {
                    self.password = ::std::option::Option::None;
                }

                pub fn has_password(&self) -> bool {
                    self.password.is_some()
                }

                // Param is passed by value, moved
                pub fn set_password(&mut self, v: ::std::string::String) {
                    self.password = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_password(&mut self) -> &mut ::std::string::String {
                    if self.password.is_none() {
                        self.password = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.password.as_mut().unwrap()
                }

                // Take field
                pub fn take_password(&mut self) -> ::std::string::String {
                    self.password.take().unwrap_or_else(|| ::std::string::String::new())
                }

                // optional int32 strength_raw = 9;

                pub fn strength_raw(&self) -> i32 {
                    self.strength_raw.unwrap_or(0)
                }

                pub fn clear_strength_raw(&mut self) {
                    self.strength_raw = ::std::option::Option::None;
                }

                pub fn has_strength_raw(&self) -> bool {
                    self.strength_raw.is_some()
                }

                // Param is passed by value, moved
                pub fn set_strength_raw(&mut self, v: i32) {
                    self.strength_raw = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(9);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "id",
                        |m: &AP| { &m.id },
                        |m: &mut AP| { &mut m.id },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "estrength",
                        |m: &AP| { &m.estrength },
                        |m: &mut AP| { &mut m.estrength },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "ssid",
                        |m: &AP| { &m.ssid },
                        |m: &mut AP| { &mut m.ssid },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "is_active",
                        |m: &AP| { &m.is_active },
                        |m: &mut AP| { &mut m.is_active },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "is_autoconnect",
                        |m: &AP| { &m.is_autoconnect },
                        |m: &mut AP| { &mut m.is_autoconnect },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "esecurity",
                        |m: &AP| { &m.esecurity },
                        |m: &mut AP| { &mut m.esecurity },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "user_name",
                        |m: &AP| { &m.user_name },
                        |m: &mut AP| { &mut m.user_name },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "password",
                        |m: &AP| { &m.password },
                        |m: &mut AP| { &mut m.password },
                    ));
                    fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                        "strength_raw",
                        |m: &AP| { &m.strength_raw },
                        |m: &mut AP| { &mut m.strength_raw },
                    ));
                    crate::reflect::GeneratedMessageDescriptorData::new_2::<AP>(
                        "CMsgNetworkDevicesData.Device.Wireless.AP",
                        fields,
                        oneofs,
                    )
                }
            }

            impl crate::Message for AP {
                const NAME: &'static str = "AP";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.estrength = ::std::option::Option::Some(is.read_int32()?);
                            },
                            26 => {
                                self.ssid = ::std::option::Option::Some(is.read_string()?);
                            },
                            32 => {
                                self.is_active = ::std::option::Option::Some(is.read_bool()?);
                            },
                            40 => {
                                self.is_autoconnect = ::std::option::Option::Some(is.read_bool()?);
                            },
                            48 => {
                                self.esecurity = ::std::option::Option::Some(is.read_int32()?);
                            },
                            58 => {
                                self.user_name = ::std::option::Option::Some(is.read_string()?);
                            },
                            66 => {
                                self.password = ::std::option::Option::Some(is.read_string()?);
                            },
                            72 => {
                                self.strength_raw = ::std::option::Option::Some(is.read_int32()?);
                            },
                            tag => {
                                crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.id {
                        my_size += crate::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.estrength {
                        my_size += crate::rt::int32_size(2, v);
                    }
                    if let Some(v) = self.ssid.as_ref() {
                        my_size += crate::rt::string_size(3, &v);
                    }
                    if let Some(v) = self.is_active {
                        my_size += 1 + 1;
                    }
                    if let Some(v) = self.is_autoconnect {
                        my_size += 1 + 1;
                    }
                    if let Some(v) = self.esecurity {
                        my_size += crate::rt::int32_size(6, v);
                    }
                    if let Some(v) = self.user_name.as_ref() {
                        my_size += crate::rt::string_size(7, &v);
                    }
                    if let Some(v) = self.password.as_ref() {
                        my_size += crate::rt::string_size(8, &v);
                    }
                    if let Some(v) = self.strength_raw {
                        my_size += crate::rt::int32_size(9, v);
                    }
                    my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                    if let Some(v) = self.id {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.estrength {
                        os.write_int32(2, v)?;
                    }
                    if let Some(v) = self.ssid.as_ref() {
                        os.write_string(3, v)?;
                    }
                    if let Some(v) = self.is_active {
                        os.write_bool(4, v)?;
                    }
                    if let Some(v) = self.is_autoconnect {
                        os.write_bool(5, v)?;
                    }
                    if let Some(v) = self.esecurity {
                        os.write_int32(6, v)?;
                    }
                    if let Some(v) = self.user_name.as_ref() {
                        os.write_string(7, v)?;
                    }
                    if let Some(v) = self.password.as_ref() {
                        os.write_string(8, v)?;
                    }
                    if let Some(v) = self.strength_raw {
                        os.write_int32(9, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &crate::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> AP {
                    AP::new()
                }

                fn clear(&mut self) {
                    self.id = ::std::option::Option::None;
                    self.estrength = ::std::option::Option::None;
                    self.ssid = ::std::option::Option::None;
                    self.is_active = ::std::option::Option::None;
                    self.is_autoconnect = ::std::option::Option::None;
                    self.esecurity = ::std::option::Option::None;
                    self.user_name = ::std::option::Option::None;
                    self.password = ::std::option::Option::None;
                    self.strength_raw = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static AP {
                    static instance: AP = AP {
                        id: ::std::option::Option::None,
                        estrength: ::std::option::Option::None,
                        ssid: ::std::option::Option::None,
                        is_active: ::std::option::Option::None,
                        is_autoconnect: ::std::option::Option::None,
                        esecurity: ::std::option::Option::None,
                        user_name: ::std::option::Option::None,
                        password: ::std::option::Option::None,
                        strength_raw: ::std::option::Option::None,
                        special_fields: crate::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl crate::MessageFull for AP {
                fn descriptor() -> crate::reflect::MessageDescriptor {
                    static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("CMsgNetworkDevicesData.Device.Wireless.AP").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for AP {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    crate::text_format::fmt(self, f)
                }
            }

            impl crate::reflect::ProtobufValue for AP {
                type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceConnect {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.device_id)
    pub device_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.credentials)
    pub credentials: crate::MessageField<cmsg_network_device_connect::Credentials>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.ip4)
    pub ip4: crate::MessageField<CMsgNetworkDeviceIP4Config>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.ip6)
    pub ip6: crate::MessageField<CMsgNetworkDeviceIP6Config>,
    // message oneof groups
    pub ap_info: ::std::option::Option<cmsg_network_device_connect::Ap_info>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceConnect {
    fn default() -> &'a CMsgNetworkDeviceConnect {
        <CMsgNetworkDeviceConnect as crate::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceConnect {
    pub fn new() -> CMsgNetworkDeviceConnect {
        ::std::default::Default::default()
    }

    // optional uint32 device_id = 1;

    pub fn device_id(&self) -> u32 {
        self.device_id.unwrap_or(0u32)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u32) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgNetworkDeviceConnect.Credentials credentials = 4;

    pub fn credentials(&self) -> &cmsg_network_device_connect::Credentials {
        self.credentials.as_ref().unwrap_or_else(|| <cmsg_network_device_connect::Credentials as crate::Message>::default_instance())
    }

    pub fn clear_credentials(&mut self) {
        self.credentials.clear();
    }

    pub fn has_credentials(&self) -> bool {
        self.credentials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credentials(&mut self, v: cmsg_network_device_connect::Credentials) {
        self.credentials = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credentials(&mut self) -> &mut cmsg_network_device_connect::Credentials {
        self.credentials.mut_or_insert_default()
    }

    // Take field
    pub fn take_credentials(&mut self) -> cmsg_network_device_connect::Credentials {
        self.credentials.take().unwrap_or_else(|| cmsg_network_device_connect::Credentials::new())
    }

    // optional .CMsgNetworkDeviceIP4Config ip4 = 5;

    pub fn ip4(&self) -> &CMsgNetworkDeviceIP4Config {
        self.ip4.as_ref().unwrap_or_else(|| <CMsgNetworkDeviceIP4Config as crate::Message>::default_instance())
    }

    pub fn clear_ip4(&mut self) {
        self.ip4.clear();
    }

    pub fn has_ip4(&self) -> bool {
        self.ip4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip4(&mut self, v: CMsgNetworkDeviceIP4Config) {
        self.ip4 = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip4(&mut self) -> &mut CMsgNetworkDeviceIP4Config {
        self.ip4.mut_or_insert_default()
    }

    // Take field
    pub fn take_ip4(&mut self) -> CMsgNetworkDeviceIP4Config {
        self.ip4.take().unwrap_or_else(|| CMsgNetworkDeviceIP4Config::new())
    }

    // optional .CMsgNetworkDeviceIP6Config ip6 = 6;

    pub fn ip6(&self) -> &CMsgNetworkDeviceIP6Config {
        self.ip6.as_ref().unwrap_or_else(|| <CMsgNetworkDeviceIP6Config as crate::Message>::default_instance())
    }

    pub fn clear_ip6(&mut self) {
        self.ip6.clear();
    }

    pub fn has_ip6(&self) -> bool {
        self.ip6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip6(&mut self, v: CMsgNetworkDeviceIP6Config) {
        self.ip6 = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip6(&mut self) -> &mut CMsgNetworkDeviceIP6Config {
        self.ip6.mut_or_insert_default()
    }

    // Take field
    pub fn take_ip6(&mut self) -> CMsgNetworkDeviceIP6Config {
        self.ip6.take().unwrap_or_else(|| CMsgNetworkDeviceIP6Config::new())
    }

    // optional .CMsgNetworkDeviceConnect.KnownAP ap_known = 2;

    pub fn ap_known(&self) -> &cmsg_network_device_connect::KnownAP {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(ref v)) => v,
            _ => <cmsg_network_device_connect::KnownAP as crate::Message>::default_instance(),
        }
    }

    pub fn clear_ap_known(&mut self) {
        self.ap_info = ::std::option::Option::None;
    }

    pub fn has_ap_known(&self) -> bool {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ap_known(&mut self, v: cmsg_network_device_connect::KnownAP) {
        self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ap_known(&mut self) -> &mut cmsg_network_device_connect::KnownAP {
        if let ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(_)) = self.ap_info {
        } else {
            self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(cmsg_network_device_connect::KnownAP::new()));
        }
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ap_known(&mut self) -> cmsg_network_device_connect::KnownAP {
        if self.has_ap_known() {
            match self.ap_info.take() {
                ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(v)) => v,
                _ => panic!(),
            }
        } else {
            cmsg_network_device_connect::KnownAP::new()
        }
    }

    // optional .CMsgNetworkDeviceConnect.CustomAP ap_custom = 3;

    pub fn ap_custom(&self) -> &cmsg_network_device_connect::CustomAP {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(ref v)) => v,
            _ => <cmsg_network_device_connect::CustomAP as crate::Message>::default_instance(),
        }
    }

    pub fn clear_ap_custom(&mut self) {
        self.ap_info = ::std::option::Option::None;
    }

    pub fn has_ap_custom(&self) -> bool {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ap_custom(&mut self, v: cmsg_network_device_connect::CustomAP) {
        self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ap_custom(&mut self) -> &mut cmsg_network_device_connect::CustomAP {
        if let ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(_)) = self.ap_info {
        } else {
            self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(cmsg_network_device_connect::CustomAP::new()));
        }
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ap_custom(&mut self) -> cmsg_network_device_connect::CustomAP {
        if self.has_ap_custom() {
            match self.ap_info.take() {
                ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(v)) => v,
                _ => panic!(),
            }
        } else {
            cmsg_network_device_connect::CustomAP::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id",
            |m: &CMsgNetworkDeviceConnect| { &m.device_id },
            |m: &mut CMsgNetworkDeviceConnect| { &mut m.device_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cmsg_network_device_connect::Credentials>(
            "credentials",
            |m: &CMsgNetworkDeviceConnect| { &m.credentials },
            |m: &mut CMsgNetworkDeviceConnect| { &mut m.credentials },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgNetworkDeviceIP4Config>(
            "ip4",
            |m: &CMsgNetworkDeviceConnect| { &m.ip4 },
            |m: &mut CMsgNetworkDeviceConnect| { &mut m.ip4 },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgNetworkDeviceIP6Config>(
            "ip6",
            |m: &CMsgNetworkDeviceConnect| { &m.ip6 },
            |m: &mut CMsgNetworkDeviceConnect| { &mut m.ip6 },
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, cmsg_network_device_connect::KnownAP>(
            "ap_known",
            CMsgNetworkDeviceConnect::has_ap_known,
            CMsgNetworkDeviceConnect::ap_known,
            CMsgNetworkDeviceConnect::mut_ap_known,
            CMsgNetworkDeviceConnect::set_ap_known,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, cmsg_network_device_connect::CustomAP>(
            "ap_custom",
            CMsgNetworkDeviceConnect::has_ap_custom,
            CMsgNetworkDeviceConnect::ap_custom,
            CMsgNetworkDeviceConnect::mut_ap_custom,
            CMsgNetworkDeviceConnect::set_ap_custom,
        ));
        oneofs.push(cmsg_network_device_connect::Ap_info::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNetworkDeviceConnect>(
            "CMsgNetworkDeviceConnect",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgNetworkDeviceConnect {
    const NAME: &'static str = "CMsgNetworkDeviceConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.device_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.credentials)?;
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.ip4)?;
                },
                50 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.ip6)?;
                },
                18 => {
                    self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(is.read_message()?));
                },
                26 => {
                    self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(is.read_message()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ip4.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ip6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.ap_info {
            match v {
                &cmsg_network_device_connect::Ap_info::ApKnown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_network_device_connect::Ap_info::ApCustom(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.device_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.credentials.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.ip4.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.ip6.as_ref() {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.ap_info {
            match v {
                &cmsg_network_device_connect::Ap_info::ApKnown(ref v) => {
                    crate::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cmsg_network_device_connect::Ap_info::ApCustom(ref v) => {
                    crate::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceConnect {
        CMsgNetworkDeviceConnect::new()
    }

    fn clear(&mut self) {
        self.device_id = ::std::option::Option::None;
        self.credentials.clear();
        self.ip4.clear();
        self.ip6.clear();
        self.ap_info = ::std::option::Option::None;
        self.ap_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceConnect {
        static instance: CMsgNetworkDeviceConnect = CMsgNetworkDeviceConnect {
            device_id: ::std::option::Option::None,
            credentials: crate::MessageField::none(),
            ip4: crate::MessageField::none(),
            ip6: crate::MessageField::none(),
            ap_info: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgNetworkDeviceConnect {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceConnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNetworkDeviceConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgNetworkDeviceConnect {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgNetworkDeviceConnect`
pub mod cmsg_network_device_connect {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgNetworkDeviceConnect.ap_info)
    pub enum Ap_info {
        // @@protoc_insertion_point(oneof_field:CMsgNetworkDeviceConnect.ap_known)
        ApKnown(KnownAP),
        // @@protoc_insertion_point(oneof_field:CMsgNetworkDeviceConnect.ap_custom)
        ApCustom(CustomAP),
    }

    impl crate::Oneof for Ap_info {
    }

    impl crate::OneofFull for Ap_info {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::CMsgNetworkDeviceConnect as crate::MessageFull>::descriptor().oneof_by_name("ap_info").unwrap()).clone()
        }
    }

    impl Ap_info {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Ap_info>("ap_info")
        }
    }
    // @@protoc_insertion_point(message:CMsgNetworkDeviceConnect.KnownAP)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KnownAP {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.KnownAP.ap_id)
        pub ap_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.KnownAP.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KnownAP {
        fn default() -> &'a KnownAP {
            <KnownAP as crate::Message>::default_instance()
        }
    }

    impl KnownAP {
        pub fn new() -> KnownAP {
            ::std::default::Default::default()
        }

        // optional uint32 ap_id = 1;

        pub fn ap_id(&self) -> u32 {
            self.ap_id.unwrap_or(0)
        }

        pub fn clear_ap_id(&mut self) {
            self.ap_id = ::std::option::Option::None;
        }

        pub fn has_ap_id(&self) -> bool {
            self.ap_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ap_id(&mut self, v: u32) {
            self.ap_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ap_id",
                |m: &KnownAP| { &m.ap_id },
                |m: &mut KnownAP| { &mut m.ap_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<KnownAP>(
                "CMsgNetworkDeviceConnect.KnownAP",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for KnownAP {
        const NAME: &'static str = "KnownAP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.ap_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ap_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.ap_id {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KnownAP {
            KnownAP::new()
        }

        fn clear(&mut self) {
            self.ap_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KnownAP {
            static instance: KnownAP = KnownAP {
                ap_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for KnownAP {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceConnect.KnownAP").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KnownAP {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for KnownAP {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgNetworkDeviceConnect.CustomAP)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CustomAP {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.CustomAP.ssid)
        pub ssid: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.CustomAP.esecurity)
        pub esecurity: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.CustomAP.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CustomAP {
        fn default() -> &'a CustomAP {
            <CustomAP as crate::Message>::default_instance()
        }
    }

    impl CustomAP {
        pub fn new() -> CustomAP {
            ::std::default::Default::default()
        }

        // optional string ssid = 1;

        pub fn ssid(&self) -> &str {
            match self.ssid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ssid(&mut self) {
            self.ssid = ::std::option::Option::None;
        }

        pub fn has_ssid(&self) -> bool {
            self.ssid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ssid(&mut self, v: ::std::string::String) {
            self.ssid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ssid(&mut self) -> &mut ::std::string::String {
            if self.ssid.is_none() {
                self.ssid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ssid.as_mut().unwrap()
        }

        // Take field
        pub fn take_ssid(&mut self) -> ::std::string::String {
            self.ssid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 esecurity = 2;

        pub fn esecurity(&self) -> i32 {
            self.esecurity.unwrap_or(0)
        }

        pub fn clear_esecurity(&mut self) {
            self.esecurity = ::std::option::Option::None;
        }

        pub fn has_esecurity(&self) -> bool {
            self.esecurity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_esecurity(&mut self, v: i32) {
            self.esecurity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ssid",
                |m: &CustomAP| { &m.ssid },
                |m: &mut CustomAP| { &mut m.ssid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "esecurity",
                |m: &CustomAP| { &m.esecurity },
                |m: &mut CustomAP| { &mut m.esecurity },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<CustomAP>(
                "CMsgNetworkDeviceConnect.CustomAP",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for CustomAP {
        const NAME: &'static str = "CustomAP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.ssid = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.esecurity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ssid.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.esecurity {
                my_size += crate::rt::int32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.ssid.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.esecurity {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CustomAP {
            CustomAP::new()
        }

        fn clear(&mut self) {
            self.ssid = ::std::option::Option::None;
            self.esecurity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CustomAP {
            static instance: CustomAP = CustomAP {
                ssid: ::std::option::Option::None,
                esecurity: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for CustomAP {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceConnect.CustomAP").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CustomAP {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for CustomAP {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgNetworkDeviceConnect.Credentials)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Credentials {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.Credentials.username)
        pub username: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.Credentials.password)
        pub password: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.Credentials.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Credentials {
        fn default() -> &'a Credentials {
            <Credentials as crate::Message>::default_instance()
        }
    }

    impl Credentials {
        pub fn new() -> Credentials {
            ::std::default::Default::default()
        }

        // optional string username = 1;

        pub fn username(&self) -> &str {
            match self.username.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_username(&mut self) {
            self.username = ::std::option::Option::None;
        }

        pub fn has_username(&self) -> bool {
            self.username.is_some()
        }

        // Param is passed by value, moved
        pub fn set_username(&mut self, v: ::std::string::String) {
            self.username = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_username(&mut self) -> &mut ::std::string::String {
            if self.username.is_none() {
                self.username = ::std::option::Option::Some(::std::string::String::new());
            }
            self.username.as_mut().unwrap()
        }

        // Take field
        pub fn take_username(&mut self) -> ::std::string::String {
            self.username.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string password = 2;

        pub fn password(&self) -> &str {
            match self.password.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_password(&mut self) {
            self.password = ::std::option::Option::None;
        }

        pub fn has_password(&self) -> bool {
            self.password.is_some()
        }

        // Param is passed by value, moved
        pub fn set_password(&mut self, v: ::std::string::String) {
            self.password = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_password(&mut self) -> &mut ::std::string::String {
            if self.password.is_none() {
                self.password = ::std::option::Option::Some(::std::string::String::new());
            }
            self.password.as_mut().unwrap()
        }

        // Take field
        pub fn take_password(&mut self) -> ::std::string::String {
            self.password.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "username",
                |m: &Credentials| { &m.username },
                |m: &mut Credentials| { &mut m.username },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "password",
                |m: &Credentials| { &m.password },
                |m: &mut Credentials| { &mut m.password },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Credentials>(
                "CMsgNetworkDeviceConnect.Credentials",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Credentials {
        const NAME: &'static str = "Credentials";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.username = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.password = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.username.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.password.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.username.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.password.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Credentials {
            Credentials::new()
        }

        fn clear(&mut self) {
            self.username = ::std::option::Option::None;
            self.password = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Credentials {
            static instance: Credentials = Credentials {
                username: ::std::option::Option::None,
                password: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Credentials {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgNetworkDeviceConnect.Credentials").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Credentials {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Credentials {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgStorageDevicesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStorageDevicesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.drives)
    pub drives: ::std::vec::Vec<cmsg_storage_devices_data::Drive>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.block_devices)
    pub block_devices: ::std::vec::Vec<cmsg_storage_devices_data::BlockDevice>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.is_unmount_supported)
    pub is_unmount_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.is_trim_supported)
    pub is_trim_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.is_trim_running)
    pub is_trim_running: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStorageDevicesData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStorageDevicesData {
    fn default() -> &'a CMsgStorageDevicesData {
        <CMsgStorageDevicesData as crate::Message>::default_instance()
    }
}

impl CMsgStorageDevicesData {
    pub fn new() -> CMsgStorageDevicesData {
        ::std::default::Default::default()
    }

    // repeated .CMsgStorageDevicesData.Drive drives = 1;

    pub fn drives(&self) -> &[cmsg_storage_devices_data::Drive] {
        &self.drives
    }

    pub fn clear_drives(&mut self) {
        self.drives.clear();
    }

    // Param is passed by value, moved
    pub fn set_drives(&mut self, v: ::std::vec::Vec<cmsg_storage_devices_data::Drive>) {
        self.drives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drives(&mut self) -> &mut ::std::vec::Vec<cmsg_storage_devices_data::Drive> {
        &mut self.drives
    }

    // Take field
    pub fn take_drives(&mut self) -> ::std::vec::Vec<cmsg_storage_devices_data::Drive> {
        ::std::mem::replace(&mut self.drives, ::std::vec::Vec::new())
    }

    // repeated .CMsgStorageDevicesData.BlockDevice block_devices = 2;

    pub fn block_devices(&self) -> &[cmsg_storage_devices_data::BlockDevice] {
        &self.block_devices
    }

    pub fn clear_block_devices(&mut self) {
        self.block_devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_devices(&mut self, v: ::std::vec::Vec<cmsg_storage_devices_data::BlockDevice>) {
        self.block_devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_block_devices(&mut self) -> &mut ::std::vec::Vec<cmsg_storage_devices_data::BlockDevice> {
        &mut self.block_devices
    }

    // Take field
    pub fn take_block_devices(&mut self) -> ::std::vec::Vec<cmsg_storage_devices_data::BlockDevice> {
        ::std::mem::replace(&mut self.block_devices, ::std::vec::Vec::new())
    }

    // optional bool is_unmount_supported = 3;

    pub fn is_unmount_supported(&self) -> bool {
        self.is_unmount_supported.unwrap_or(false)
    }

    pub fn clear_is_unmount_supported(&mut self) {
        self.is_unmount_supported = ::std::option::Option::None;
    }

    pub fn has_is_unmount_supported(&self) -> bool {
        self.is_unmount_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unmount_supported(&mut self, v: bool) {
        self.is_unmount_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_trim_supported = 4;

    pub fn is_trim_supported(&self) -> bool {
        self.is_trim_supported.unwrap_or(false)
    }

    pub fn clear_is_trim_supported(&mut self) {
        self.is_trim_supported = ::std::option::Option::None;
    }

    pub fn has_is_trim_supported(&self) -> bool {
        self.is_trim_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_trim_supported(&mut self, v: bool) {
        self.is_trim_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_trim_running = 5;

    pub fn is_trim_running(&self) -> bool {
        self.is_trim_running.unwrap_or(false)
    }

    pub fn clear_is_trim_running(&mut self) {
        self.is_trim_running = ::std::option::Option::None;
    }

    pub fn has_is_trim_running(&self) -> bool {
        self.is_trim_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_trim_running(&mut self, v: bool) {
        self.is_trim_running = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "drives",
            |m: &CMsgStorageDevicesData| { &m.drives },
            |m: &mut CMsgStorageDevicesData| { &mut m.drives },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "block_devices",
            |m: &CMsgStorageDevicesData| { &m.block_devices },
            |m: &mut CMsgStorageDevicesData| { &mut m.block_devices },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_unmount_supported",
            |m: &CMsgStorageDevicesData| { &m.is_unmount_supported },
            |m: &mut CMsgStorageDevicesData| { &mut m.is_unmount_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_trim_supported",
            |m: &CMsgStorageDevicesData| { &m.is_trim_supported },
            |m: &mut CMsgStorageDevicesData| { &mut m.is_trim_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_trim_running",
            |m: &CMsgStorageDevicesData| { &m.is_trim_running },
            |m: &mut CMsgStorageDevicesData| { &mut m.is_trim_running },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStorageDevicesData>(
            "CMsgStorageDevicesData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgStorageDevicesData {
    const NAME: &'static str = "CMsgStorageDevicesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.drives.push(is.read_message()?);
                },
                18 => {
                    self.block_devices.push(is.read_message()?);
                },
                24 => {
                    self.is_unmount_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_trim_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_trim_running = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.drives {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.block_devices {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_unmount_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_trim_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_trim_running {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.drives {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.block_devices {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.is_unmount_supported {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_trim_supported {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_trim_running {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStorageDevicesData {
        CMsgStorageDevicesData::new()
    }

    fn clear(&mut self) {
        self.drives.clear();
        self.block_devices.clear();
        self.is_unmount_supported = ::std::option::Option::None;
        self.is_trim_supported = ::std::option::Option::None;
        self.is_trim_running = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStorageDevicesData {
        static instance: CMsgStorageDevicesData = CMsgStorageDevicesData {
            drives: ::std::vec::Vec::new(),
            block_devices: ::std::vec::Vec::new(),
            is_unmount_supported: ::std::option::Option::None,
            is_trim_supported: ::std::option::Option::None,
            is_trim_running: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgStorageDevicesData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStorageDevicesData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStorageDevicesData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgStorageDevicesData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgStorageDevicesData`
pub mod cmsg_storage_devices_data {
    // @@protoc_insertion_point(message:CMsgStorageDevicesData.Drive)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Drive {
        // message fields
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.model)
        pub model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.vendor)
        pub vendor: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.serial)
        pub serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.is_ejectable)
        pub is_ejectable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.size_bytes)
        pub size_bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.media_type)
        pub media_type: ::std::option::Option<crate::EnumOrUnknown<super::super::enums::EStorageDriveMediaType>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgStorageDevicesData.Drive.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Drive {
        fn default() -> &'a Drive {
            <Drive as crate::Message>::default_instance()
        }
    }

    impl Drive {
        pub fn new() -> Drive {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string model = 2;

        pub fn model(&self) -> &str {
            match self.model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_model(&mut self) {
            self.model = ::std::option::Option::None;
        }

        pub fn has_model(&self) -> bool {
            self.model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_model(&mut self, v: ::std::string::String) {
            self.model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_model(&mut self) -> &mut ::std::string::String {
            if self.model.is_none() {
                self.model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.model.as_mut().unwrap()
        }

        // Take field
        pub fn take_model(&mut self) -> ::std::string::String {
            self.model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vendor = 3;

        pub fn vendor(&self) -> &str {
            match self.vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vendor(&mut self) {
            self.vendor = ::std::option::Option::None;
        }

        pub fn has_vendor(&self) -> bool {
            self.vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vendor(&mut self, v: ::std::string::String) {
            self.vendor = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
            if self.vendor.is_none() {
                self.vendor = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vendor(&mut self) -> ::std::string::String {
            self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string serial = 4;

        pub fn serial(&self) -> &str {
            match self.serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_serial(&mut self) {
            self.serial = ::std::option::Option::None;
        }

        pub fn has_serial(&self) -> bool {
            self.serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_serial(&mut self, v: ::std::string::String) {
            self.serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_serial(&mut self) -> &mut ::std::string::String {
            if self.serial.is_none() {
                self.serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_serial(&mut self) -> ::std::string::String {
            self.serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_ejectable = 5;

        pub fn is_ejectable(&self) -> bool {
            self.is_ejectable.unwrap_or(false)
        }

        pub fn clear_is_ejectable(&mut self) {
            self.is_ejectable = ::std::option::Option::None;
        }

        pub fn has_is_ejectable(&self) -> bool {
            self.is_ejectable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_ejectable(&mut self, v: bool) {
            self.is_ejectable = ::std::option::Option::Some(v);
        }

        // optional uint64 size_bytes = 6;

        pub fn size_bytes(&self) -> u64 {
            self.size_bytes.unwrap_or(0)
        }

        pub fn clear_size_bytes(&mut self) {
            self.size_bytes = ::std::option::Option::None;
        }

        pub fn has_size_bytes(&self) -> bool {
            self.size_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size_bytes(&mut self, v: u64) {
            self.size_bytes = ::std::option::Option::Some(v);
        }

        // optional .EStorageDriveMediaType media_type = 7;

        pub fn media_type(&self) -> super::super::enums::EStorageDriveMediaType {
            match self.media_type {
                Some(e) => e.enum_value_or(super::super::enums::EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid),
                None => super::super::enums::EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid,
            }
        }

        pub fn clear_media_type(&mut self) {
            self.media_type = ::std::option::Option::None;
        }

        pub fn has_media_type(&self) -> bool {
            self.media_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_media_type(&mut self, v: super::super::enums::EStorageDriveMediaType) {
            self.media_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Drive| { &m.id },
                |m: &mut Drive| { &mut m.id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "model",
                |m: &Drive| { &m.model },
                |m: &mut Drive| { &mut m.model },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "vendor",
                |m: &Drive| { &m.vendor },
                |m: &mut Drive| { &mut m.vendor },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "serial",
                |m: &Drive| { &m.serial },
                |m: &mut Drive| { &mut m.serial },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_ejectable",
                |m: &Drive| { &m.is_ejectable },
                |m: &mut Drive| { &mut m.is_ejectable },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "size_bytes",
                |m: &Drive| { &m.size_bytes },
                |m: &mut Drive| { &mut m.size_bytes },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "media_type",
                |m: &Drive| { &m.media_type },
                |m: &mut Drive| { &mut m.media_type },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Drive>(
                "CMsgStorageDevicesData.Drive",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Drive {
        const NAME: &'static str = "Drive";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.model = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.vendor = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.is_ejectable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.size_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.media_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.model.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.vendor.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.serial.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.is_ejectable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.size_bytes {
                my_size += crate::rt::uint64_size(6, v);
            }
            if let Some(v) = self.media_type {
                my_size += crate::rt::int32_size(7, v.value());
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.model.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.vendor.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.serial.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.is_ejectable {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.size_bytes {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.media_type {
                os.write_enum(7, crate::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Drive {
            Drive::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.model = ::std::option::Option::None;
            self.vendor = ::std::option::Option::None;
            self.serial = ::std::option::Option::None;
            self.is_ejectable = ::std::option::Option::None;
            self.size_bytes = ::std::option::Option::None;
            self.media_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Drive {
            static instance: Drive = Drive {
                id: ::std::option::Option::None,
                model: ::std::option::Option::None,
                vendor: ::std::option::Option::None,
                serial: ::std::option::Option::None,
                is_ejectable: ::std::option::Option::None,
                size_bytes: ::std::option::Option::None,
                media_type: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Drive {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgStorageDevicesData.Drive").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Drive {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Drive {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgStorageDevicesData.BlockDevice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BlockDevice {
        // message fields
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.drive_id)
        pub drive_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.path)
        pub path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.friendly_path)
        pub friendly_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.label)
        pub label: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.size_bytes)
        pub size_bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.is_formattable)
        pub is_formattable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.is_read_only)
        pub is_read_only: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.is_root_device)
        pub is_root_device: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.content_type)
        pub content_type: ::std::option::Option<crate::EnumOrUnknown<super::super::enums::EStorageBlockContentType>>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.filesystem_type)
        pub filesystem_type: ::std::option::Option<crate::EnumOrUnknown<super::super::enums::EStorageBlockFileSystemType>>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.mount_path)
        pub mount_path: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgStorageDevicesData.BlockDevice.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BlockDevice {
        fn default() -> &'a BlockDevice {
            <BlockDevice as crate::Message>::default_instance()
        }
    }

    impl BlockDevice {
        pub fn new() -> BlockDevice {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 drive_id = 2;

        pub fn drive_id(&self) -> u32 {
            self.drive_id.unwrap_or(0u32)
        }

        pub fn clear_drive_id(&mut self) {
            self.drive_id = ::std::option::Option::None;
        }

        pub fn has_drive_id(&self) -> bool {
            self.drive_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_drive_id(&mut self, v: u32) {
            self.drive_id = ::std::option::Option::Some(v);
        }

        // optional string path = 3;

        pub fn path(&self) -> &str {
            match self.path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_path(&mut self) {
            self.path = ::std::option::Option::None;
        }

        pub fn has_path(&self) -> bool {
            self.path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path(&mut self, v: ::std::string::String) {
            self.path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_path(&mut self) -> &mut ::std::string::String {
            if self.path.is_none() {
                self.path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.path.as_mut().unwrap()
        }

        // Take field
        pub fn take_path(&mut self) -> ::std::string::String {
            self.path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string friendly_path = 4;

        pub fn friendly_path(&self) -> &str {
            match self.friendly_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_friendly_path(&mut self) {
            self.friendly_path = ::std::option::Option::None;
        }

        pub fn has_friendly_path(&self) -> bool {
            self.friendly_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friendly_path(&mut self, v: ::std::string::String) {
            self.friendly_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_friendly_path(&mut self) -> &mut ::std::string::String {
            if self.friendly_path.is_none() {
                self.friendly_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.friendly_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_friendly_path(&mut self) -> ::std::string::String {
            self.friendly_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string label = 5;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 size_bytes = 6;

        pub fn size_bytes(&self) -> u64 {
            self.size_bytes.unwrap_or(0)
        }

        pub fn clear_size_bytes(&mut self) {
            self.size_bytes = ::std::option::Option::None;
        }

        pub fn has_size_bytes(&self) -> bool {
            self.size_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size_bytes(&mut self, v: u64) {
            self.size_bytes = ::std::option::Option::Some(v);
        }

        // optional bool is_formattable = 7;

        pub fn is_formattable(&self) -> bool {
            self.is_formattable.unwrap_or(false)
        }

        pub fn clear_is_formattable(&mut self) {
            self.is_formattable = ::std::option::Option::None;
        }

        pub fn has_is_formattable(&self) -> bool {
            self.is_formattable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_formattable(&mut self, v: bool) {
            self.is_formattable = ::std::option::Option::Some(v);
        }

        // optional bool is_read_only = 8;

        pub fn is_read_only(&self) -> bool {
            self.is_read_only.unwrap_or(false)
        }

        pub fn clear_is_read_only(&mut self) {
            self.is_read_only = ::std::option::Option::None;
        }

        pub fn has_is_read_only(&self) -> bool {
            self.is_read_only.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_read_only(&mut self, v: bool) {
            self.is_read_only = ::std::option::Option::Some(v);
        }

        // optional bool is_root_device = 9;

        pub fn is_root_device(&self) -> bool {
            self.is_root_device.unwrap_or(false)
        }

        pub fn clear_is_root_device(&mut self) {
            self.is_root_device = ::std::option::Option::None;
        }

        pub fn has_is_root_device(&self) -> bool {
            self.is_root_device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_root_device(&mut self, v: bool) {
            self.is_root_device = ::std::option::Option::Some(v);
        }

        // optional .EStorageBlockContentType content_type = 10;

        pub fn content_type(&self) -> super::super::enums::EStorageBlockContentType {
            match self.content_type {
                Some(e) => e.enum_value_or(super::super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
                None => super::super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid,
            }
        }

        pub fn clear_content_type(&mut self) {
            self.content_type = ::std::option::Option::None;
        }

        pub fn has_content_type(&self) -> bool {
            self.content_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_content_type(&mut self, v: super::super::enums::EStorageBlockContentType) {
            self.content_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional .EStorageBlockFileSystemType filesystem_type = 11;

        pub fn filesystem_type(&self) -> super::super::enums::EStorageBlockFileSystemType {
            match self.filesystem_type {
                Some(e) => e.enum_value_or(super::super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
                None => super::super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid,
            }
        }

        pub fn clear_filesystem_type(&mut self) {
            self.filesystem_type = ::std::option::Option::None;
        }

        pub fn has_filesystem_type(&self) -> bool {
            self.filesystem_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filesystem_type(&mut self, v: super::super::enums::EStorageBlockFileSystemType) {
            self.filesystem_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional string mount_path = 12;

        pub fn mount_path(&self) -> &str {
            match self.mount_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mount_path(&mut self) {
            self.mount_path = ::std::option::Option::None;
        }

        pub fn has_mount_path(&self) -> bool {
            self.mount_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mount_path(&mut self, v: ::std::string::String) {
            self.mount_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mount_path(&mut self) -> &mut ::std::string::String {
            if self.mount_path.is_none() {
                self.mount_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mount_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_mount_path(&mut self) -> ::std::string::String {
            self.mount_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &BlockDevice| { &m.id },
                |m: &mut BlockDevice| { &mut m.id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "drive_id",
                |m: &BlockDevice| { &m.drive_id },
                |m: &mut BlockDevice| { &mut m.drive_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "path",
                |m: &BlockDevice| { &m.path },
                |m: &mut BlockDevice| { &mut m.path },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friendly_path",
                |m: &BlockDevice| { &m.friendly_path },
                |m: &mut BlockDevice| { &mut m.friendly_path },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "label",
                |m: &BlockDevice| { &m.label },
                |m: &mut BlockDevice| { &mut m.label },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "size_bytes",
                |m: &BlockDevice| { &m.size_bytes },
                |m: &mut BlockDevice| { &mut m.size_bytes },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_formattable",
                |m: &BlockDevice| { &m.is_formattable },
                |m: &mut BlockDevice| { &mut m.is_formattable },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_read_only",
                |m: &BlockDevice| { &m.is_read_only },
                |m: &mut BlockDevice| { &mut m.is_read_only },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_root_device",
                |m: &BlockDevice| { &m.is_root_device },
                |m: &mut BlockDevice| { &mut m.is_root_device },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "content_type",
                |m: &BlockDevice| { &m.content_type },
                |m: &mut BlockDevice| { &mut m.content_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "filesystem_type",
                |m: &BlockDevice| { &m.filesystem_type },
                |m: &mut BlockDevice| { &mut m.filesystem_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mount_path",
                |m: &BlockDevice| { &m.mount_path },
                |m: &mut BlockDevice| { &mut m.mount_path },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<BlockDevice>(
                "CMsgStorageDevicesData.BlockDevice",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for BlockDevice {
        const NAME: &'static str = "BlockDevice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.drive_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.path = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.friendly_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.size_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.is_formattable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.is_read_only = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.is_root_device = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.content_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    88 => {
                        self.filesystem_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    98 => {
                        self.mount_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.drive_id {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.path.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.friendly_path.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.label.as_ref() {
                my_size += crate::rt::string_size(5, &v);
            }
            if let Some(v) = self.size_bytes {
                my_size += crate::rt::uint64_size(6, v);
            }
            if let Some(v) = self.is_formattable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_read_only {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_root_device {
                my_size += 1 + 1;
            }
            if let Some(v) = self.content_type {
                my_size += crate::rt::int32_size(10, v.value());
            }
            if let Some(v) = self.filesystem_type {
                my_size += crate::rt::int32_size(11, v.value());
            }
            if let Some(v) = self.mount_path.as_ref() {
                my_size += crate::rt::string_size(12, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.drive_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.path.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.friendly_path.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.label.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.size_bytes {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.is_formattable {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.is_read_only {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.is_root_device {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.content_type {
                os.write_enum(10, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.filesystem_type {
                os.write_enum(11, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mount_path.as_ref() {
                os.write_string(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BlockDevice {
            BlockDevice::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.drive_id = ::std::option::Option::None;
            self.path = ::std::option::Option::None;
            self.friendly_path = ::std::option::Option::None;
            self.label = ::std::option::Option::None;
            self.size_bytes = ::std::option::Option::None;
            self.is_formattable = ::std::option::Option::None;
            self.is_read_only = ::std::option::Option::None;
            self.is_root_device = ::std::option::Option::None;
            self.content_type = ::std::option::Option::None;
            self.filesystem_type = ::std::option::Option::None;
            self.mount_path = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BlockDevice {
            static instance: BlockDevice = BlockDevice {
                id: ::std::option::Option::None,
                drive_id: ::std::option::Option::None,
                path: ::std::option::Option::None,
                friendly_path: ::std::option::Option::None,
                label: ::std::option::Option::None,
                size_bytes: ::std::option::Option::None,
                is_formattable: ::std::option::Option::None,
                is_read_only: ::std::option::Option::None,
                is_root_device: ::std::option::Option::None,
                content_type: ::std::option::Option::None,
                filesystem_type: ::std::option::Option::None,
                mount_path: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for BlockDevice {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgStorageDevicesData.BlockDevice").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BlockDevice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for BlockDevice {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCloud_PendingRemoteOperation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCloud_PendingRemoteOperation {
    // message fields
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.operation)
    pub operation: ::std::option::Option<crate::EnumOrUnknown<ECloudPendingRemoteOperation>>,
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.time_last_updated)
    pub time_last_updated: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCloud_PendingRemoteOperation.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCloud_PendingRemoteOperation {
    fn default() -> &'a CCloud_PendingRemoteOperation {
        <CCloud_PendingRemoteOperation as crate::Message>::default_instance()
    }
}

impl CCloud_PendingRemoteOperation {
    pub fn new() -> CCloud_PendingRemoteOperation {
        ::std::default::Default::default()
    }

    // optional .ECloudPendingRemoteOperation operation = 1;

    pub fn operation(&self) -> ECloudPendingRemoteOperation {
        match self.operation {
            Some(e) => e.enum_value_or(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone),
            None => ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ECloudPendingRemoteOperation) {
        self.operation = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string machine_name = 2;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 client_id = 3;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_updated = 4;

    pub fn time_last_updated(&self) -> u32 {
        self.time_last_updated.unwrap_or(0)
    }

    pub fn clear_time_last_updated(&mut self) {
        self.time_last_updated = ::std::option::Option::None;
    }

    pub fn has_time_last_updated(&self) -> bool {
        self.time_last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_updated(&mut self, v: u32) {
        self.time_last_updated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &CCloud_PendingRemoteOperation| { &m.operation },
            |m: &mut CCloud_PendingRemoteOperation| { &mut m.operation },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name",
            |m: &CCloud_PendingRemoteOperation| { &m.machine_name },
            |m: &mut CCloud_PendingRemoteOperation| { &mut m.machine_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_id",
            |m: &CCloud_PendingRemoteOperation| { &m.client_id },
            |m: &mut CCloud_PendingRemoteOperation| { &mut m.client_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_updated",
            |m: &CCloud_PendingRemoteOperation| { &m.time_last_updated },
            |m: &mut CCloud_PendingRemoteOperation| { &mut m.time_last_updated },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CCloud_PendingRemoteOperation>(
            "CCloud_PendingRemoteOperation",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CCloud_PendingRemoteOperation {
    const NAME: &'static str = "CCloud_PendingRemoteOperation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.time_last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.client_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.time_last_updated {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.client_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.time_last_updated {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCloud_PendingRemoteOperation {
        CCloud_PendingRemoteOperation::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.time_last_updated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCloud_PendingRemoteOperation {
        static instance: CCloud_PendingRemoteOperation = CCloud_PendingRemoteOperation {
            operation: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            client_id: ::std::option::Option::None,
            time_last_updated: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CCloud_PendingRemoteOperation {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCloud_PendingRemoteOperation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCloud_PendingRemoteOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CCloud_PendingRemoteOperation {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCloudPendingRemoteOperations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCloudPendingRemoteOperations {
    // message fields
    // @@protoc_insertion_point(field:CMsgCloudPendingRemoteOperations.operations)
    pub operations: ::std::vec::Vec<CCloud_PendingRemoteOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCloudPendingRemoteOperations.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCloudPendingRemoteOperations {
    fn default() -> &'a CMsgCloudPendingRemoteOperations {
        <CMsgCloudPendingRemoteOperations as crate::Message>::default_instance()
    }
}

impl CMsgCloudPendingRemoteOperations {
    pub fn new() -> CMsgCloudPendingRemoteOperations {
        ::std::default::Default::default()
    }

    // repeated .CCloud_PendingRemoteOperation operations = 1;

    pub fn operations(&self) -> &[CCloud_PendingRemoteOperation] {
        &self.operations
    }

    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::std::vec::Vec<CCloud_PendingRemoteOperation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::std::vec::Vec<CCloud_PendingRemoteOperation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::std::vec::Vec<CCloud_PendingRemoteOperation> {
        ::std::mem::replace(&mut self.operations, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operations",
            |m: &CMsgCloudPendingRemoteOperations| { &m.operations },
            |m: &mut CMsgCloudPendingRemoteOperations| { &mut m.operations },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCloudPendingRemoteOperations>(
            "CMsgCloudPendingRemoteOperations",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCloudPendingRemoteOperations {
    const NAME: &'static str = "CMsgCloudPendingRemoteOperations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operations.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.operations {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCloudPendingRemoteOperations {
        CMsgCloudPendingRemoteOperations::new()
    }

    fn clear(&mut self) {
        self.operations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCloudPendingRemoteOperations {
        static instance: CMsgCloudPendingRemoteOperations = CMsgCloudPendingRemoteOperations {
            operations: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCloudPendingRemoteOperations {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCloudPendingRemoteOperations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCloudPendingRemoteOperations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCloudPendingRemoteOperations {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBluetoothDevicesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBluetoothDevicesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.adapters)
    pub adapters: ::std::vec::Vec<cmsg_bluetooth_devices_data::Adapter>,
    // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.devices)
    pub devices: ::std::vec::Vec<cmsg_bluetooth_devices_data::Device>,
    // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.manager)
    pub manager: crate::MessageField<cmsg_bluetooth_devices_data::Manager>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBluetoothDevicesData {
    fn default() -> &'a CMsgBluetoothDevicesData {
        <CMsgBluetoothDevicesData as crate::Message>::default_instance()
    }
}

impl CMsgBluetoothDevicesData {
    pub fn new() -> CMsgBluetoothDevicesData {
        ::std::default::Default::default()
    }

    // repeated .CMsgBluetoothDevicesData.Adapter adapters = 1;

    pub fn adapters(&self) -> &[cmsg_bluetooth_devices_data::Adapter] {
        &self.adapters
    }

    pub fn clear_adapters(&mut self) {
        self.adapters.clear();
    }

    // Param is passed by value, moved
    pub fn set_adapters(&mut self, v: ::std::vec::Vec<cmsg_bluetooth_devices_data::Adapter>) {
        self.adapters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_adapters(&mut self) -> &mut ::std::vec::Vec<cmsg_bluetooth_devices_data::Adapter> {
        &mut self.adapters
    }

    // Take field
    pub fn take_adapters(&mut self) -> ::std::vec::Vec<cmsg_bluetooth_devices_data::Adapter> {
        ::std::mem::replace(&mut self.adapters, ::std::vec::Vec::new())
    }

    // repeated .CMsgBluetoothDevicesData.Device devices = 2;

    pub fn devices(&self) -> &[cmsg_bluetooth_devices_data::Device] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<cmsg_bluetooth_devices_data::Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<cmsg_bluetooth_devices_data::Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<cmsg_bluetooth_devices_data::Device> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    // optional .CMsgBluetoothDevicesData.Manager manager = 3;

    pub fn manager(&self) -> &cmsg_bluetooth_devices_data::Manager {
        self.manager.as_ref().unwrap_or_else(|| <cmsg_bluetooth_devices_data::Manager as crate::Message>::default_instance())
    }

    pub fn clear_manager(&mut self) {
        self.manager.clear();
    }

    pub fn has_manager(&self) -> bool {
        self.manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manager(&mut self, v: cmsg_bluetooth_devices_data::Manager) {
        self.manager = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manager(&mut self) -> &mut cmsg_bluetooth_devices_data::Manager {
        self.manager.mut_or_insert_default()
    }

    // Take field
    pub fn take_manager(&mut self) -> cmsg_bluetooth_devices_data::Manager {
        self.manager.take().unwrap_or_else(|| cmsg_bluetooth_devices_data::Manager::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "adapters",
            |m: &CMsgBluetoothDevicesData| { &m.adapters },
            |m: &mut CMsgBluetoothDevicesData| { &mut m.adapters },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &CMsgBluetoothDevicesData| { &m.devices },
            |m: &mut CMsgBluetoothDevicesData| { &mut m.devices },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cmsg_bluetooth_devices_data::Manager>(
            "manager",
            |m: &CMsgBluetoothDevicesData| { &m.manager },
            |m: &mut CMsgBluetoothDevicesData| { &mut m.manager },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBluetoothDevicesData>(
            "CMsgBluetoothDevicesData",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgBluetoothDevicesData {
    const NAME: &'static str = "CMsgBluetoothDevicesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.adapters.push(is.read_message()?);
                },
                18 => {
                    self.devices.push(is.read_message()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.manager)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.adapters {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.manager.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.adapters {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.devices {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.manager.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBluetoothDevicesData {
        CMsgBluetoothDevicesData::new()
    }

    fn clear(&mut self) {
        self.adapters.clear();
        self.devices.clear();
        self.manager.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBluetoothDevicesData {
        static instance: CMsgBluetoothDevicesData = CMsgBluetoothDevicesData {
            adapters: ::std::vec::Vec::new(),
            devices: ::std::vec::Vec::new(),
            manager: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgBluetoothDevicesData {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBluetoothDevicesData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBluetoothDevicesData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgBluetoothDevicesData {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgBluetoothDevicesData`
pub mod cmsg_bluetooth_devices_data {
    // @@protoc_insertion_point(message:CMsgBluetoothDevicesData.Adapter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Adapter {
        // message fields
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.mac)
        pub mac: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.is_enabled)
        pub is_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.is_discovering)
        pub is_discovering: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.Adapter.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Adapter {
        fn default() -> &'a Adapter {
            <Adapter as crate::Message>::default_instance()
        }
    }

    impl Adapter {
        pub fn new() -> Adapter {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string mac = 2;

        pub fn mac(&self) -> &str {
            match self.mac.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: ::std::string::String) {
            self.mac = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mac(&mut self) -> &mut ::std::string::String {
            if self.mac.is_none() {
                self.mac = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mac.as_mut().unwrap()
        }

        // Take field
        pub fn take_mac(&mut self) -> ::std::string::String {
            self.mac.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_enabled = 4;

        pub fn is_enabled(&self) -> bool {
            self.is_enabled.unwrap_or(false)
        }

        pub fn clear_is_enabled(&mut self) {
            self.is_enabled = ::std::option::Option::None;
        }

        pub fn has_is_enabled(&self) -> bool {
            self.is_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_enabled(&mut self, v: bool) {
            self.is_enabled = ::std::option::Option::Some(v);
        }

        // optional bool is_discovering = 5;

        pub fn is_discovering(&self) -> bool {
            self.is_discovering.unwrap_or(false)
        }

        pub fn clear_is_discovering(&mut self) {
            self.is_discovering = ::std::option::Option::None;
        }

        pub fn has_is_discovering(&self) -> bool {
            self.is_discovering.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_discovering(&mut self, v: bool) {
            self.is_discovering = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Adapter| { &m.id },
                |m: &mut Adapter| { &mut m.id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mac",
                |m: &Adapter| { &m.mac },
                |m: &mut Adapter| { &mut m.mac },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Adapter| { &m.name },
                |m: &mut Adapter| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_enabled",
                |m: &Adapter| { &m.is_enabled },
                |m: &mut Adapter| { &mut m.is_enabled },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_discovering",
                |m: &Adapter| { &m.is_discovering },
                |m: &mut Adapter| { &mut m.is_discovering },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Adapter>(
                "CMsgBluetoothDevicesData.Adapter",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Adapter {
        const NAME: &'static str = "Adapter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.mac = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.is_discovering = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.mac.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.is_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_discovering {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.mac.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.is_enabled {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.is_discovering {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Adapter {
            Adapter::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.is_enabled = ::std::option::Option::None;
            self.is_discovering = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Adapter {
            static instance: Adapter = Adapter {
                id: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                name: ::std::option::Option::None,
                is_enabled: ::std::option::Option::None,
                is_discovering: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Adapter {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBluetoothDevicesData.Adapter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Adapter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Adapter {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgBluetoothDevicesData.Device)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Device {
        // message fields
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.adapter_id)
        pub adapter_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.etype)
        pub etype: ::std::option::Option<crate::EnumOrUnknown<super::super::enums::EBluetoothDeviceType>>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.mac)
        pub mac: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.is_connected)
        pub is_connected: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.is_paired)
        pub is_paired: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.strength_raw)
        pub strength_raw: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.Device.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Device {
        fn default() -> &'a Device {
            <Device as crate::Message>::default_instance()
        }
    }

    impl Device {
        pub fn new() -> Device {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 adapter_id = 2;

        pub fn adapter_id(&self) -> u32 {
            self.adapter_id.unwrap_or(0u32)
        }

        pub fn clear_adapter_id(&mut self) {
            self.adapter_id = ::std::option::Option::None;
        }

        pub fn has_adapter_id(&self) -> bool {
            self.adapter_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_adapter_id(&mut self, v: u32) {
            self.adapter_id = ::std::option::Option::Some(v);
        }

        // optional .EBluetoothDeviceType etype = 3;

        pub fn etype(&self) -> super::super::enums::EBluetoothDeviceType {
            match self.etype {
                Some(e) => e.enum_value_or(super::super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
                None => super::super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid,
            }
        }

        pub fn clear_etype(&mut self) {
            self.etype = ::std::option::Option::None;
        }

        pub fn has_etype(&self) -> bool {
            self.etype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_etype(&mut self, v: super::super::enums::EBluetoothDeviceType) {
            self.etype = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional string mac = 4;

        pub fn mac(&self) -> &str {
            match self.mac.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: ::std::string::String) {
            self.mac = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mac(&mut self) -> &mut ::std::string::String {
            if self.mac.is_none() {
                self.mac = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mac.as_mut().unwrap()
        }

        // Take field
        pub fn take_mac(&mut self) -> ::std::string::String {
            self.mac.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 5;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_connected = 6;

        pub fn is_connected(&self) -> bool {
            self.is_connected.unwrap_or(false)
        }

        pub fn clear_is_connected(&mut self) {
            self.is_connected = ::std::option::Option::None;
        }

        pub fn has_is_connected(&self) -> bool {
            self.is_connected.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_connected(&mut self, v: bool) {
            self.is_connected = ::std::option::Option::Some(v);
        }

        // optional bool is_paired = 7;

        pub fn is_paired(&self) -> bool {
            self.is_paired.unwrap_or(false)
        }

        pub fn clear_is_paired(&mut self) {
            self.is_paired = ::std::option::Option::None;
        }

        pub fn has_is_paired(&self) -> bool {
            self.is_paired.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_paired(&mut self, v: bool) {
            self.is_paired = ::std::option::Option::Some(v);
        }

        // optional int32 strength_raw = 8;

        pub fn strength_raw(&self) -> i32 {
            self.strength_raw.unwrap_or(0)
        }

        pub fn clear_strength_raw(&mut self) {
            self.strength_raw = ::std::option::Option::None;
        }

        pub fn has_strength_raw(&self) -> bool {
            self.strength_raw.is_some()
        }

        // Param is passed by value, moved
        pub fn set_strength_raw(&mut self, v: i32) {
            self.strength_raw = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Device| { &m.id },
                |m: &mut Device| { &mut m.id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "adapter_id",
                |m: &Device| { &m.adapter_id },
                |m: &mut Device| { &mut m.adapter_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "etype",
                |m: &Device| { &m.etype },
                |m: &mut Device| { &mut m.etype },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mac",
                |m: &Device| { &m.mac },
                |m: &mut Device| { &mut m.mac },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Device| { &m.name },
                |m: &mut Device| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_connected",
                |m: &Device| { &m.is_connected },
                |m: &mut Device| { &mut m.is_connected },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_paired",
                |m: &Device| { &m.is_paired },
                |m: &mut Device| { &mut m.is_paired },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "strength_raw",
                |m: &Device| { &m.strength_raw },
                |m: &mut Device| { &mut m.strength_raw },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
                "CMsgBluetoothDevicesData.Device",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Device {
        const NAME: &'static str = "Device";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.adapter_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.etype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.mac = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.is_connected = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.is_paired = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.strength_raw = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.adapter_id {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.etype {
                my_size += crate::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.mac.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(5, &v);
            }
            if let Some(v) = self.is_connected {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_paired {
                my_size += 1 + 1;
            }
            if let Some(v) = self.strength_raw {
                my_size += crate::rt::int32_size(8, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.adapter_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.etype {
                os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mac.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.is_connected {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.is_paired {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.strength_raw {
                os.write_int32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Device {
            Device::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.adapter_id = ::std::option::Option::None;
            self.etype = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.is_connected = ::std::option::Option::None;
            self.is_paired = ::std::option::Option::None;
            self.strength_raw = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Device {
            static instance: Device = Device {
                id: ::std::option::Option::None,
                adapter_id: ::std::option::Option::None,
                etype: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                name: ::std::option::Option::None,
                is_connected: ::std::option::Option::None,
                is_paired: ::std::option::Option::None,
                strength_raw: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Device {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBluetoothDevicesData.Device").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Device {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Device {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgBluetoothDevicesData.Manager)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Manager {
        // message fields
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Manager.is_bluetooth_enabled)
        pub is_bluetooth_enabled: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.Manager.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Manager {
        fn default() -> &'a Manager {
            <Manager as crate::Message>::default_instance()
        }
    }

    impl Manager {
        pub fn new() -> Manager {
            ::std::default::Default::default()
        }

        // optional bool is_bluetooth_enabled = 1;

        pub fn is_bluetooth_enabled(&self) -> bool {
            self.is_bluetooth_enabled.unwrap_or(false)
        }

        pub fn clear_is_bluetooth_enabled(&mut self) {
            self.is_bluetooth_enabled = ::std::option::Option::None;
        }

        pub fn has_is_bluetooth_enabled(&self) -> bool {
            self.is_bluetooth_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_bluetooth_enabled(&mut self, v: bool) {
            self.is_bluetooth_enabled = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_bluetooth_enabled",
                |m: &Manager| { &m.is_bluetooth_enabled },
                |m: &mut Manager| { &mut m.is_bluetooth_enabled },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Manager>(
                "CMsgBluetoothDevicesData.Manager",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Manager {
        const NAME: &'static str = "Manager";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.is_bluetooth_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.is_bluetooth_enabled {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.is_bluetooth_enabled {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Manager {
            Manager::new()
        }

        fn clear(&mut self) {
            self.is_bluetooth_enabled = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Manager {
            static instance: Manager = Manager {
                is_bluetooth_enabled: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Manager {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBluetoothDevicesData.Manager").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Manager {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Manager {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfDiagnosticEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfDiagnosticEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticEntry.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticEntry.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfDiagnosticEntry.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfDiagnosticEntry {
    fn default() -> &'a CMsgSystemPerfDiagnosticEntry {
        <CMsgSystemPerfDiagnosticEntry as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfDiagnosticEntry {
    pub fn new() -> CMsgSystemPerfDiagnosticEntry {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSystemPerfDiagnosticEntry| { &m.name },
            |m: &mut CMsgSystemPerfDiagnosticEntry| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgSystemPerfDiagnosticEntry| { &m.value },
            |m: &mut CMsgSystemPerfDiagnosticEntry| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfDiagnosticEntry>(
            "CMsgSystemPerfDiagnosticEntry",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfDiagnosticEntry {
    const NAME: &'static str = "CMsgSystemPerfDiagnosticEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfDiagnosticEntry {
        CMsgSystemPerfDiagnosticEntry::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfDiagnosticEntry {
        static instance: CMsgSystemPerfDiagnosticEntry = CMsgSystemPerfDiagnosticEntry {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfDiagnosticEntry {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfDiagnosticEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfDiagnosticEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfDiagnosticEntry {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfNetworkInterface)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfNetworkInterface {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.timestamp)
    pub timestamp: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.tx_bytes_total)
    pub tx_bytes_total: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.rx_bytes_total)
    pub rx_bytes_total: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.tx_bytes_per_sec)
    pub tx_bytes_per_sec: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.rx_bytes_per_sec)
    pub rx_bytes_per_sec: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfNetworkInterface.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfNetworkInterface {
    fn default() -> &'a CMsgSystemPerfNetworkInterface {
        <CMsgSystemPerfNetworkInterface as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfNetworkInterface {
    pub fn new() -> CMsgSystemPerfNetworkInterface {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double timestamp = 2;

    pub fn timestamp(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 tx_bytes_total = 3;

    pub fn tx_bytes_total(&self) -> i64 {
        self.tx_bytes_total.unwrap_or(0)
    }

    pub fn clear_tx_bytes_total(&mut self) {
        self.tx_bytes_total = ::std::option::Option::None;
    }

    pub fn has_tx_bytes_total(&self) -> bool {
        self.tx_bytes_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes_total(&mut self, v: i64) {
        self.tx_bytes_total = ::std::option::Option::Some(v);
    }

    // optional int64 rx_bytes_total = 4;

    pub fn rx_bytes_total(&self) -> i64 {
        self.rx_bytes_total.unwrap_or(0)
    }

    pub fn clear_rx_bytes_total(&mut self) {
        self.rx_bytes_total = ::std::option::Option::None;
    }

    pub fn has_rx_bytes_total(&self) -> bool {
        self.rx_bytes_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes_total(&mut self, v: i64) {
        self.rx_bytes_total = ::std::option::Option::Some(v);
    }

    // optional int32 tx_bytes_per_sec = 5;

    pub fn tx_bytes_per_sec(&self) -> i32 {
        self.tx_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_tx_bytes_per_sec(&mut self) {
        self.tx_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_tx_bytes_per_sec(&self) -> bool {
        self.tx_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes_per_sec(&mut self, v: i32) {
        self.tx_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional int32 rx_bytes_per_sec = 6;

    pub fn rx_bytes_per_sec(&self) -> i32 {
        self.rx_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_rx_bytes_per_sec(&mut self) {
        self.rx_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_rx_bytes_per_sec(&self) -> bool {
        self.rx_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes_per_sec(&mut self, v: i32) {
        self.rx_bytes_per_sec = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSystemPerfNetworkInterface| { &m.name },
            |m: &mut CMsgSystemPerfNetworkInterface| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgSystemPerfNetworkInterface| { &m.timestamp },
            |m: &mut CMsgSystemPerfNetworkInterface| { &mut m.timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_bytes_total",
            |m: &CMsgSystemPerfNetworkInterface| { &m.tx_bytes_total },
            |m: &mut CMsgSystemPerfNetworkInterface| { &mut m.tx_bytes_total },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rx_bytes_total",
            |m: &CMsgSystemPerfNetworkInterface| { &m.rx_bytes_total },
            |m: &mut CMsgSystemPerfNetworkInterface| { &mut m.rx_bytes_total },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_bytes_per_sec",
            |m: &CMsgSystemPerfNetworkInterface| { &m.tx_bytes_per_sec },
            |m: &mut CMsgSystemPerfNetworkInterface| { &mut m.tx_bytes_per_sec },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rx_bytes_per_sec",
            |m: &CMsgSystemPerfNetworkInterface| { &m.rx_bytes_per_sec },
            |m: &mut CMsgSystemPerfNetworkInterface| { &mut m.rx_bytes_per_sec },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfNetworkInterface>(
            "CMsgSystemPerfNetworkInterface",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfNetworkInterface {
    const NAME: &'static str = "CMsgSystemPerfNetworkInterface";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.timestamp = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.tx_bytes_total = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.rx_bytes_total = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.tx_bytes_per_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.rx_bytes_per_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tx_bytes_total {
            my_size += crate::rt::int64_size(3, v);
        }
        if let Some(v) = self.rx_bytes_total {
            my_size += crate::rt::int64_size(4, v);
        }
        if let Some(v) = self.tx_bytes_per_sec {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.rx_bytes_per_sec {
            my_size += crate::rt::int32_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.tx_bytes_total {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.rx_bytes_total {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.tx_bytes_per_sec {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.rx_bytes_per_sec {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfNetworkInterface {
        CMsgSystemPerfNetworkInterface::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.tx_bytes_total = ::std::option::Option::None;
        self.rx_bytes_total = ::std::option::Option::None;
        self.tx_bytes_per_sec = ::std::option::Option::None;
        self.rx_bytes_per_sec = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfNetworkInterface {
        static instance: CMsgSystemPerfNetworkInterface = CMsgSystemPerfNetworkInterface {
            name: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            tx_bytes_total: ::std::option::Option::None,
            rx_bytes_total: ::std::option::Option::None,
            tx_bytes_per_sec: ::std::option::Option::None,
            rx_bytes_per_sec: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfNetworkInterface {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfNetworkInterface").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfNetworkInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfNetworkInterface {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfDiagnosticInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfDiagnosticInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticInfo.entries)
    pub entries: ::std::vec::Vec<CMsgSystemPerfDiagnosticEntry>,
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticInfo.interfaces)
    pub interfaces: ::std::vec::Vec<CMsgSystemPerfNetworkInterface>,
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticInfo.battery_temp_c)
    pub battery_temp_c: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfDiagnosticInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfDiagnosticInfo {
    fn default() -> &'a CMsgSystemPerfDiagnosticInfo {
        <CMsgSystemPerfDiagnosticInfo as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfDiagnosticInfo {
    pub fn new() -> CMsgSystemPerfDiagnosticInfo {
        ::std::default::Default::default()
    }

    // repeated .CMsgSystemPerfDiagnosticEntry entries = 1;

    pub fn entries(&self) -> &[CMsgSystemPerfDiagnosticEntry] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<CMsgSystemPerfDiagnosticEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<CMsgSystemPerfDiagnosticEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<CMsgSystemPerfDiagnosticEntry> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    // repeated .CMsgSystemPerfNetworkInterface interfaces = 2;

    pub fn interfaces(&self) -> &[CMsgSystemPerfNetworkInterface] {
        &self.interfaces
    }

    pub fn clear_interfaces(&mut self) {
        self.interfaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_interfaces(&mut self, v: ::std::vec::Vec<CMsgSystemPerfNetworkInterface>) {
        self.interfaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interfaces(&mut self) -> &mut ::std::vec::Vec<CMsgSystemPerfNetworkInterface> {
        &mut self.interfaces
    }

    // Take field
    pub fn take_interfaces(&mut self) -> ::std::vec::Vec<CMsgSystemPerfNetworkInterface> {
        ::std::mem::replace(&mut self.interfaces, ::std::vec::Vec::new())
    }

    // optional float battery_temp_c = 3;

    pub fn battery_temp_c(&self) -> f32 {
        self.battery_temp_c.unwrap_or(0.)
    }

    pub fn clear_battery_temp_c(&mut self) {
        self.battery_temp_c = ::std::option::Option::None;
    }

    pub fn has_battery_temp_c(&self) -> bool {
        self.battery_temp_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battery_temp_c(&mut self, v: f32) {
        self.battery_temp_c = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgSystemPerfDiagnosticInfo| { &m.entries },
            |m: &mut CMsgSystemPerfDiagnosticInfo| { &mut m.entries },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interfaces",
            |m: &CMsgSystemPerfDiagnosticInfo| { &m.interfaces },
            |m: &mut CMsgSystemPerfDiagnosticInfo| { &mut m.interfaces },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "battery_temp_c",
            |m: &CMsgSystemPerfDiagnosticInfo| { &m.battery_temp_c },
            |m: &mut CMsgSystemPerfDiagnosticInfo| { &mut m.battery_temp_c },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfDiagnosticInfo>(
            "CMsgSystemPerfDiagnosticInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfDiagnosticInfo {
    const NAME: &'static str = "CMsgSystemPerfDiagnosticInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                18 => {
                    self.interfaces.push(is.read_message()?);
                },
                29 => {
                    self.battery_temp_c = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.interfaces {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.battery_temp_c {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.interfaces {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.battery_temp_c {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfDiagnosticInfo {
        CMsgSystemPerfDiagnosticInfo::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.interfaces.clear();
        self.battery_temp_c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfDiagnosticInfo {
        static instance: CMsgSystemPerfDiagnosticInfo = CMsgSystemPerfDiagnosticInfo {
            entries: ::std::vec::Vec::new(),
            interfaces: ::std::vec::Vec::new(),
            battery_temp_c: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfDiagnosticInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfDiagnosticInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfDiagnosticInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfDiagnosticInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfLimits)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfLimits {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.cpu_governor_manual_min_mhz)
    pub cpu_governor_manual_min_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.cpu_governor_manual_max_mhz)
    pub cpu_governor_manual_max_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fsr_sharpness_min)
    pub fsr_sharpness_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fsr_sharpness_max)
    pub fsr_sharpness_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.gpu_performance_manual_min_mhz)
    pub gpu_performance_manual_min_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.gpu_performance_manual_max_mhz)
    pub gpu_performance_manual_max_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.perf_overlay_is_standalone)
    pub perf_overlay_is_standalone: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_dynamic_vrs_available)
    pub is_dynamic_vrs_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_manual_display_refresh_rate_available)
    pub is_manual_display_refresh_rate_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.gpu_performance_levels_available)
    pub gpu_performance_levels_available: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EGPUPerformanceLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_refresh_manual_hz_min)
    pub display_refresh_manual_hz_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_refresh_manual_hz_max)
    pub display_refresh_manual_hz_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fps_limit_options)
    pub fps_limit_options: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.tdp_limit_min)
    pub tdp_limit_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.tdp_limit_max)
    pub tdp_limit_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_nis_supported)
    pub is_nis_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.nis_sharpness_min)
    pub nis_sharpness_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.nis_sharpness_max)
    pub nis_sharpness_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_external_refresh_manual_hz_min)
    pub display_external_refresh_manual_hz_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_external_refresh_manual_hz_max)
    pub display_external_refresh_manual_hz_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fps_limit_options_external)
    pub fps_limit_options_external: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_tearing_supported)
    pub is_tearing_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_vrr_supported)
    pub is_vrr_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_dynamic_refresh_rate_in_steam_supported)
    pub is_dynamic_refresh_rate_in_steam_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_split_scaling_and_filtering_supported)
    pub is_split_scaling_and_filtering_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.split_scaling_filters_available)
    pub split_scaling_filters_available: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingFilter>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.split_scaling_scalers_available)
    pub split_scaling_scalers_available: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingScaler>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_hdr_supported)
    pub is_hdr_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_refresh_manual_hz_oc_max)
    pub display_refresh_manual_hz_oc_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.disable_refresh_rate_management)
    pub disable_refresh_rate_management: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfLimits.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfLimits {
    fn default() -> &'a CMsgSystemPerfLimits {
        <CMsgSystemPerfLimits as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfLimits {
    pub fn new() -> CMsgSystemPerfLimits {
        ::std::default::Default::default()
    }

    // optional int32 cpu_governor_manual_min_mhz = 1;

    pub fn cpu_governor_manual_min_mhz(&self) -> i32 {
        self.cpu_governor_manual_min_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_min_mhz(&mut self) {
        self.cpu_governor_manual_min_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_min_mhz(&self) -> bool {
        self.cpu_governor_manual_min_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_min_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_min_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 cpu_governor_manual_max_mhz = 2;

    pub fn cpu_governor_manual_max_mhz(&self) -> i32 {
        self.cpu_governor_manual_max_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_max_mhz(&mut self) {
        self.cpu_governor_manual_max_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_max_mhz(&self) -> bool {
        self.cpu_governor_manual_max_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_max_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_max_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness_min = 3;

    pub fn fsr_sharpness_min(&self) -> i32 {
        self.fsr_sharpness_min.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness_min(&mut self) {
        self.fsr_sharpness_min = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness_min(&self) -> bool {
        self.fsr_sharpness_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness_min(&mut self, v: i32) {
        self.fsr_sharpness_min = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness_max = 4;

    pub fn fsr_sharpness_max(&self) -> i32 {
        self.fsr_sharpness_max.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness_max(&mut self) {
        self.fsr_sharpness_max = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness_max(&self) -> bool {
        self.fsr_sharpness_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness_max(&mut self, v: i32) {
        self.fsr_sharpness_max = ::std::option::Option::Some(v);
    }

    // optional int32 gpu_performance_manual_min_mhz = 5;

    pub fn gpu_performance_manual_min_mhz(&self) -> i32 {
        self.gpu_performance_manual_min_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_min_mhz(&mut self) {
        self.gpu_performance_manual_min_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_min_mhz(&self) -> bool {
        self.gpu_performance_manual_min_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_min_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_min_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 gpu_performance_manual_max_mhz = 6;

    pub fn gpu_performance_manual_max_mhz(&self) -> i32 {
        self.gpu_performance_manual_max_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_max_mhz(&mut self) {
        self.gpu_performance_manual_max_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_max_mhz(&self) -> bool {
        self.gpu_performance_manual_max_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_max_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_max_mhz = ::std::option::Option::Some(v);
    }

    // optional bool perf_overlay_is_standalone = 7;

    pub fn perf_overlay_is_standalone(&self) -> bool {
        self.perf_overlay_is_standalone.unwrap_or(false)
    }

    pub fn clear_perf_overlay_is_standalone(&mut self) {
        self.perf_overlay_is_standalone = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_is_standalone(&self) -> bool {
        self.perf_overlay_is_standalone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_is_standalone(&mut self, v: bool) {
        self.perf_overlay_is_standalone = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_vrs_available = 8;

    pub fn is_dynamic_vrs_available(&self) -> bool {
        self.is_dynamic_vrs_available.unwrap_or(false)
    }

    pub fn clear_is_dynamic_vrs_available(&mut self) {
        self.is_dynamic_vrs_available = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_vrs_available(&self) -> bool {
        self.is_dynamic_vrs_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_vrs_available(&mut self, v: bool) {
        self.is_dynamic_vrs_available = ::std::option::Option::Some(v);
    }

    // optional bool is_manual_display_refresh_rate_available = 9;

    pub fn is_manual_display_refresh_rate_available(&self) -> bool {
        self.is_manual_display_refresh_rate_available.unwrap_or(false)
    }

    pub fn clear_is_manual_display_refresh_rate_available(&mut self) {
        self.is_manual_display_refresh_rate_available = ::std::option::Option::None;
    }

    pub fn has_is_manual_display_refresh_rate_available(&self) -> bool {
        self.is_manual_display_refresh_rate_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_manual_display_refresh_rate_available(&mut self, v: bool) {
        self.is_manual_display_refresh_rate_available = ::std::option::Option::Some(v);
    }

    // repeated .EGPUPerformanceLevel gpu_performance_levels_available = 10;

    pub fn gpu_performance_levels_available(&self) -> &[crate::EnumOrUnknown<super::enums::EGPUPerformanceLevel>] {
        &self.gpu_performance_levels_available
    }

    pub fn clear_gpu_performance_levels_available(&mut self) {
        self.gpu_performance_levels_available.clear();
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_levels_available(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EGPUPerformanceLevel>>) {
        self.gpu_performance_levels_available = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gpu_performance_levels_available(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EGPUPerformanceLevel>> {
        &mut self.gpu_performance_levels_available
    }

    // Take field
    pub fn take_gpu_performance_levels_available(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EGPUPerformanceLevel>> {
        ::std::mem::replace(&mut self.gpu_performance_levels_available, ::std::vec::Vec::new())
    }

    // optional int32 display_refresh_manual_hz_min = 11;

    pub fn display_refresh_manual_hz_min(&self) -> i32 {
        self.display_refresh_manual_hz_min.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz_min(&mut self) {
        self.display_refresh_manual_hz_min = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz_min(&self) -> bool {
        self.display_refresh_manual_hz_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz_min(&mut self, v: i32) {
        self.display_refresh_manual_hz_min = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz_max = 12;

    pub fn display_refresh_manual_hz_max(&self) -> i32 {
        self.display_refresh_manual_hz_max.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz_max(&mut self) {
        self.display_refresh_manual_hz_max = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz_max(&self) -> bool {
        self.display_refresh_manual_hz_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz_max(&mut self, v: i32) {
        self.display_refresh_manual_hz_max = ::std::option::Option::Some(v);
    }

    // repeated int32 fps_limit_options = 13;

    pub fn fps_limit_options(&self) -> &[i32] {
        &self.fps_limit_options
    }

    pub fn clear_fps_limit_options(&mut self) {
        self.fps_limit_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_fps_limit_options(&mut self, v: ::std::vec::Vec<i32>) {
        self.fps_limit_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fps_limit_options(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.fps_limit_options
    }

    // Take field
    pub fn take_fps_limit_options(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.fps_limit_options, ::std::vec::Vec::new())
    }

    // optional int32 tdp_limit_min = 14;

    pub fn tdp_limit_min(&self) -> i32 {
        self.tdp_limit_min.unwrap_or(0)
    }

    pub fn clear_tdp_limit_min(&mut self) {
        self.tdp_limit_min = ::std::option::Option::None;
    }

    pub fn has_tdp_limit_min(&self) -> bool {
        self.tdp_limit_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit_min(&mut self, v: i32) {
        self.tdp_limit_min = ::std::option::Option::Some(v);
    }

    // optional int32 tdp_limit_max = 15;

    pub fn tdp_limit_max(&self) -> i32 {
        self.tdp_limit_max.unwrap_or(0)
    }

    pub fn clear_tdp_limit_max(&mut self) {
        self.tdp_limit_max = ::std::option::Option::None;
    }

    pub fn has_tdp_limit_max(&self) -> bool {
        self.tdp_limit_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit_max(&mut self, v: i32) {
        self.tdp_limit_max = ::std::option::Option::Some(v);
    }

    // optional bool is_nis_supported = 16;

    pub fn is_nis_supported(&self) -> bool {
        self.is_nis_supported.unwrap_or(false)
    }

    pub fn clear_is_nis_supported(&mut self) {
        self.is_nis_supported = ::std::option::Option::None;
    }

    pub fn has_is_nis_supported(&self) -> bool {
        self.is_nis_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_nis_supported(&mut self, v: bool) {
        self.is_nis_supported = ::std::option::Option::Some(v);
    }

    // optional int32 nis_sharpness_min = 17;

    pub fn nis_sharpness_min(&self) -> i32 {
        self.nis_sharpness_min.unwrap_or(0)
    }

    pub fn clear_nis_sharpness_min(&mut self) {
        self.nis_sharpness_min = ::std::option::Option::None;
    }

    pub fn has_nis_sharpness_min(&self) -> bool {
        self.nis_sharpness_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nis_sharpness_min(&mut self, v: i32) {
        self.nis_sharpness_min = ::std::option::Option::Some(v);
    }

    // optional int32 nis_sharpness_max = 18;

    pub fn nis_sharpness_max(&self) -> i32 {
        self.nis_sharpness_max.unwrap_or(0)
    }

    pub fn clear_nis_sharpness_max(&mut self) {
        self.nis_sharpness_max = ::std::option::Option::None;
    }

    pub fn has_nis_sharpness_max(&self) -> bool {
        self.nis_sharpness_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nis_sharpness_max(&mut self, v: i32) {
        self.nis_sharpness_max = ::std::option::Option::Some(v);
    }

    // optional int32 display_external_refresh_manual_hz_min = 19;

    pub fn display_external_refresh_manual_hz_min(&self) -> i32 {
        self.display_external_refresh_manual_hz_min.unwrap_or(0)
    }

    pub fn clear_display_external_refresh_manual_hz_min(&mut self) {
        self.display_external_refresh_manual_hz_min = ::std::option::Option::None;
    }

    pub fn has_display_external_refresh_manual_hz_min(&self) -> bool {
        self.display_external_refresh_manual_hz_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_external_refresh_manual_hz_min(&mut self, v: i32) {
        self.display_external_refresh_manual_hz_min = ::std::option::Option::Some(v);
    }

    // optional int32 display_external_refresh_manual_hz_max = 20;

    pub fn display_external_refresh_manual_hz_max(&self) -> i32 {
        self.display_external_refresh_manual_hz_max.unwrap_or(0)
    }

    pub fn clear_display_external_refresh_manual_hz_max(&mut self) {
        self.display_external_refresh_manual_hz_max = ::std::option::Option::None;
    }

    pub fn has_display_external_refresh_manual_hz_max(&self) -> bool {
        self.display_external_refresh_manual_hz_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_external_refresh_manual_hz_max(&mut self, v: i32) {
        self.display_external_refresh_manual_hz_max = ::std::option::Option::Some(v);
    }

    // repeated int32 fps_limit_options_external = 21;

    pub fn fps_limit_options_external(&self) -> &[i32] {
        &self.fps_limit_options_external
    }

    pub fn clear_fps_limit_options_external(&mut self) {
        self.fps_limit_options_external.clear();
    }

    // Param is passed by value, moved
    pub fn set_fps_limit_options_external(&mut self, v: ::std::vec::Vec<i32>) {
        self.fps_limit_options_external = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fps_limit_options_external(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.fps_limit_options_external
    }

    // Take field
    pub fn take_fps_limit_options_external(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.fps_limit_options_external, ::std::vec::Vec::new())
    }

    // optional bool is_tearing_supported = 22;

    pub fn is_tearing_supported(&self) -> bool {
        self.is_tearing_supported.unwrap_or(false)
    }

    pub fn clear_is_tearing_supported(&mut self) {
        self.is_tearing_supported = ::std::option::Option::None;
    }

    pub fn has_is_tearing_supported(&self) -> bool {
        self.is_tearing_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tearing_supported(&mut self, v: bool) {
        self.is_tearing_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_supported = 23;

    pub fn is_vrr_supported(&self) -> bool {
        self.is_vrr_supported.unwrap_or(false)
    }

    pub fn clear_is_vrr_supported(&mut self) {
        self.is_vrr_supported = ::std::option::Option::None;
    }

    pub fn has_is_vrr_supported(&self) -> bool {
        self.is_vrr_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_supported(&mut self, v: bool) {
        self.is_vrr_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_refresh_rate_in_steam_supported = 24;

    pub fn is_dynamic_refresh_rate_in_steam_supported(&self) -> bool {
        self.is_dynamic_refresh_rate_in_steam_supported.unwrap_or(false)
    }

    pub fn clear_is_dynamic_refresh_rate_in_steam_supported(&mut self) {
        self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_refresh_rate_in_steam_supported(&self) -> bool {
        self.is_dynamic_refresh_rate_in_steam_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_refresh_rate_in_steam_supported(&mut self, v: bool) {
        self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_split_scaling_and_filtering_supported = 25;

    pub fn is_split_scaling_and_filtering_supported(&self) -> bool {
        self.is_split_scaling_and_filtering_supported.unwrap_or(false)
    }

    pub fn clear_is_split_scaling_and_filtering_supported(&mut self) {
        self.is_split_scaling_and_filtering_supported = ::std::option::Option::None;
    }

    pub fn has_is_split_scaling_and_filtering_supported(&self) -> bool {
        self.is_split_scaling_and_filtering_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_split_scaling_and_filtering_supported(&mut self, v: bool) {
        self.is_split_scaling_and_filtering_supported = ::std::option::Option::Some(v);
    }

    // repeated .ESplitScalingFilter split_scaling_filters_available = 26;

    pub fn split_scaling_filters_available(&self) -> &[crate::EnumOrUnknown<super::enums::ESplitScalingFilter>] {
        &self.split_scaling_filters_available
    }

    pub fn clear_split_scaling_filters_available(&mut self) {
        self.split_scaling_filters_available.clear();
    }

    // Param is passed by value, moved
    pub fn set_split_scaling_filters_available(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingFilter>>) {
        self.split_scaling_filters_available = v;
    }

    // Mutable pointer to the field.
    pub fn mut_split_scaling_filters_available(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingFilter>> {
        &mut self.split_scaling_filters_available
    }

    // Take field
    pub fn take_split_scaling_filters_available(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingFilter>> {
        ::std::mem::replace(&mut self.split_scaling_filters_available, ::std::vec::Vec::new())
    }

    // repeated .ESplitScalingScaler split_scaling_scalers_available = 27;

    pub fn split_scaling_scalers_available(&self) -> &[crate::EnumOrUnknown<super::enums::ESplitScalingScaler>] {
        &self.split_scaling_scalers_available
    }

    pub fn clear_split_scaling_scalers_available(&mut self) {
        self.split_scaling_scalers_available.clear();
    }

    // Param is passed by value, moved
    pub fn set_split_scaling_scalers_available(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingScaler>>) {
        self.split_scaling_scalers_available = v;
    }

    // Mutable pointer to the field.
    pub fn mut_split_scaling_scalers_available(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingScaler>> {
        &mut self.split_scaling_scalers_available
    }

    // Take field
    pub fn take_split_scaling_scalers_available(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<super::enums::ESplitScalingScaler>> {
        ::std::mem::replace(&mut self.split_scaling_scalers_available, ::std::vec::Vec::new())
    }

    // optional bool is_hdr_supported = 28;

    pub fn is_hdr_supported(&self) -> bool {
        self.is_hdr_supported.unwrap_or(false)
    }

    pub fn clear_is_hdr_supported(&mut self) {
        self.is_hdr_supported = ::std::option::Option::None;
    }

    pub fn has_is_hdr_supported(&self) -> bool {
        self.is_hdr_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_supported(&mut self, v: bool) {
        self.is_hdr_supported = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz_oc_max = 29;

    pub fn display_refresh_manual_hz_oc_max(&self) -> i32 {
        self.display_refresh_manual_hz_oc_max.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz_oc_max(&mut self) {
        self.display_refresh_manual_hz_oc_max = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz_oc_max(&self) -> bool {
        self.display_refresh_manual_hz_oc_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz_oc_max(&mut self, v: i32) {
        self.display_refresh_manual_hz_oc_max = ::std::option::Option::Some(v);
    }

    // optional bool disable_refresh_rate_management = 30;

    pub fn disable_refresh_rate_management(&self) -> bool {
        self.disable_refresh_rate_management.unwrap_or(false)
    }

    pub fn clear_disable_refresh_rate_management(&mut self) {
        self.disable_refresh_rate_management = ::std::option::Option::None;
    }

    pub fn has_disable_refresh_rate_management(&self) -> bool {
        self.disable_refresh_rate_management.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_refresh_rate_management(&mut self, v: bool) {
        self.disable_refresh_rate_management = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(30);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_governor_manual_min_mhz",
            |m: &CMsgSystemPerfLimits| { &m.cpu_governor_manual_min_mhz },
            |m: &mut CMsgSystemPerfLimits| { &mut m.cpu_governor_manual_min_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_governor_manual_max_mhz",
            |m: &CMsgSystemPerfLimits| { &m.cpu_governor_manual_max_mhz },
            |m: &mut CMsgSystemPerfLimits| { &mut m.cpu_governor_manual_max_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsr_sharpness_min",
            |m: &CMsgSystemPerfLimits| { &m.fsr_sharpness_min },
            |m: &mut CMsgSystemPerfLimits| { &mut m.fsr_sharpness_min },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsr_sharpness_max",
            |m: &CMsgSystemPerfLimits| { &m.fsr_sharpness_max },
            |m: &mut CMsgSystemPerfLimits| { &mut m.fsr_sharpness_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_performance_manual_min_mhz",
            |m: &CMsgSystemPerfLimits| { &m.gpu_performance_manual_min_mhz },
            |m: &mut CMsgSystemPerfLimits| { &mut m.gpu_performance_manual_min_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_performance_manual_max_mhz",
            |m: &CMsgSystemPerfLimits| { &m.gpu_performance_manual_max_mhz },
            |m: &mut CMsgSystemPerfLimits| { &mut m.gpu_performance_manual_max_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "perf_overlay_is_standalone",
            |m: &CMsgSystemPerfLimits| { &m.perf_overlay_is_standalone },
            |m: &mut CMsgSystemPerfLimits| { &mut m.perf_overlay_is_standalone },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dynamic_vrs_available",
            |m: &CMsgSystemPerfLimits| { &m.is_dynamic_vrs_available },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_dynamic_vrs_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_manual_display_refresh_rate_available",
            |m: &CMsgSystemPerfLimits| { &m.is_manual_display_refresh_rate_available },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_manual_display_refresh_rate_available },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gpu_performance_levels_available",
            |m: &CMsgSystemPerfLimits| { &m.gpu_performance_levels_available },
            |m: &mut CMsgSystemPerfLimits| { &mut m.gpu_performance_levels_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_refresh_manual_hz_min",
            |m: &CMsgSystemPerfLimits| { &m.display_refresh_manual_hz_min },
            |m: &mut CMsgSystemPerfLimits| { &mut m.display_refresh_manual_hz_min },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_refresh_manual_hz_max",
            |m: &CMsgSystemPerfLimits| { &m.display_refresh_manual_hz_max },
            |m: &mut CMsgSystemPerfLimits| { &mut m.display_refresh_manual_hz_max },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fps_limit_options",
            |m: &CMsgSystemPerfLimits| { &m.fps_limit_options },
            |m: &mut CMsgSystemPerfLimits| { &mut m.fps_limit_options },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tdp_limit_min",
            |m: &CMsgSystemPerfLimits| { &m.tdp_limit_min },
            |m: &mut CMsgSystemPerfLimits| { &mut m.tdp_limit_min },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tdp_limit_max",
            |m: &CMsgSystemPerfLimits| { &m.tdp_limit_max },
            |m: &mut CMsgSystemPerfLimits| { &mut m.tdp_limit_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_nis_supported",
            |m: &CMsgSystemPerfLimits| { &m.is_nis_supported },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_nis_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nis_sharpness_min",
            |m: &CMsgSystemPerfLimits| { &m.nis_sharpness_min },
            |m: &mut CMsgSystemPerfLimits| { &mut m.nis_sharpness_min },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nis_sharpness_max",
            |m: &CMsgSystemPerfLimits| { &m.nis_sharpness_max },
            |m: &mut CMsgSystemPerfLimits| { &mut m.nis_sharpness_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_external_refresh_manual_hz_min",
            |m: &CMsgSystemPerfLimits| { &m.display_external_refresh_manual_hz_min },
            |m: &mut CMsgSystemPerfLimits| { &mut m.display_external_refresh_manual_hz_min },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_external_refresh_manual_hz_max",
            |m: &CMsgSystemPerfLimits| { &m.display_external_refresh_manual_hz_max },
            |m: &mut CMsgSystemPerfLimits| { &mut m.display_external_refresh_manual_hz_max },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fps_limit_options_external",
            |m: &CMsgSystemPerfLimits| { &m.fps_limit_options_external },
            |m: &mut CMsgSystemPerfLimits| { &mut m.fps_limit_options_external },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_tearing_supported",
            |m: &CMsgSystemPerfLimits| { &m.is_tearing_supported },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_tearing_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_vrr_supported",
            |m: &CMsgSystemPerfLimits| { &m.is_vrr_supported },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_vrr_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dynamic_refresh_rate_in_steam_supported",
            |m: &CMsgSystemPerfLimits| { &m.is_dynamic_refresh_rate_in_steam_supported },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_dynamic_refresh_rate_in_steam_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_split_scaling_and_filtering_supported",
            |m: &CMsgSystemPerfLimits| { &m.is_split_scaling_and_filtering_supported },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_split_scaling_and_filtering_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "split_scaling_filters_available",
            |m: &CMsgSystemPerfLimits| { &m.split_scaling_filters_available },
            |m: &mut CMsgSystemPerfLimits| { &mut m.split_scaling_filters_available },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "split_scaling_scalers_available",
            |m: &CMsgSystemPerfLimits| { &m.split_scaling_scalers_available },
            |m: &mut CMsgSystemPerfLimits| { &mut m.split_scaling_scalers_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hdr_supported",
            |m: &CMsgSystemPerfLimits| { &m.is_hdr_supported },
            |m: &mut CMsgSystemPerfLimits| { &mut m.is_hdr_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_refresh_manual_hz_oc_max",
            |m: &CMsgSystemPerfLimits| { &m.display_refresh_manual_hz_oc_max },
            |m: &mut CMsgSystemPerfLimits| { &mut m.display_refresh_manual_hz_oc_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_refresh_rate_management",
            |m: &CMsgSystemPerfLimits| { &m.disable_refresh_rate_management },
            |m: &mut CMsgSystemPerfLimits| { &mut m.disable_refresh_rate_management },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfLimits>(
            "CMsgSystemPerfLimits",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfLimits {
    const NAME: &'static str = "CMsgSystemPerfLimits";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cpu_governor_manual_min_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.cpu_governor_manual_max_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.fsr_sharpness_min = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.fsr_sharpness_max = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.gpu_performance_manual_min_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.gpu_performance_manual_max_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.perf_overlay_is_standalone = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.is_dynamic_vrs_available = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_manual_display_refresh_rate_available = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.gpu_performance_levels_available.push(is.read_enum_or_unknown()?);
                },
                82 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.gpu_performance_levels_available)?
                },
                88 => {
                    self.display_refresh_manual_hz_min = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.display_refresh_manual_hz_max = ::std::option::Option::Some(is.read_int32()?);
                },
                106 => {
                    is.read_repeated_packed_int32_into(&mut self.fps_limit_options)?;
                },
                104 => {
                    self.fps_limit_options.push(is.read_int32()?);
                },
                112 => {
                    self.tdp_limit_min = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.tdp_limit_max = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.is_nis_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.nis_sharpness_min = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.nis_sharpness_max = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.display_external_refresh_manual_hz_min = ::std::option::Option::Some(is.read_int32()?);
                },
                160 => {
                    self.display_external_refresh_manual_hz_max = ::std::option::Option::Some(is.read_int32()?);
                },
                170 => {
                    is.read_repeated_packed_int32_into(&mut self.fps_limit_options_external)?;
                },
                168 => {
                    self.fps_limit_options_external.push(is.read_int32()?);
                },
                176 => {
                    self.is_tearing_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.is_vrr_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                200 => {
                    self.is_split_scaling_and_filtering_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                208 => {
                    self.split_scaling_filters_available.push(is.read_enum_or_unknown()?);
                },
                210 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.split_scaling_filters_available)?
                },
                216 => {
                    self.split_scaling_scalers_available.push(is.read_enum_or_unknown()?);
                },
                218 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.split_scaling_scalers_available)?
                },
                224 => {
                    self.is_hdr_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                232 => {
                    self.display_refresh_manual_hz_oc_max = ::std::option::Option::Some(is.read_int32()?);
                },
                240 => {
                    self.disable_refresh_rate_management = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_governor_manual_min_mhz {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.cpu_governor_manual_max_mhz {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.fsr_sharpness_min {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.fsr_sharpness_max {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.gpu_performance_manual_min_mhz {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.gpu_performance_manual_max_mhz {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.perf_overlay_is_standalone {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_dynamic_vrs_available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_manual_display_refresh_rate_available {
            my_size += 1 + 1;
        }
        for value in &self.gpu_performance_levels_available {
            my_size += crate::rt::int32_size(10, value.value());
        };
        if let Some(v) = self.display_refresh_manual_hz_min {
            my_size += crate::rt::int32_size(11, v);
        }
        if let Some(v) = self.display_refresh_manual_hz_max {
            my_size += crate::rt::int32_size(12, v);
        }
        for value in &self.fps_limit_options {
            my_size += crate::rt::int32_size(13, *value);
        };
        if let Some(v) = self.tdp_limit_min {
            my_size += crate::rt::int32_size(14, v);
        }
        if let Some(v) = self.tdp_limit_max {
            my_size += crate::rt::int32_size(15, v);
        }
        if let Some(v) = self.is_nis_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.nis_sharpness_min {
            my_size += crate::rt::int32_size(17, v);
        }
        if let Some(v) = self.nis_sharpness_max {
            my_size += crate::rt::int32_size(18, v);
        }
        if let Some(v) = self.display_external_refresh_manual_hz_min {
            my_size += crate::rt::int32_size(19, v);
        }
        if let Some(v) = self.display_external_refresh_manual_hz_max {
            my_size += crate::rt::int32_size(20, v);
        }
        for value in &self.fps_limit_options_external {
            my_size += crate::rt::int32_size(21, *value);
        };
        if let Some(v) = self.is_tearing_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_vrr_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_in_steam_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_split_scaling_and_filtering_supported {
            my_size += 2 + 1;
        }
        for value in &self.split_scaling_filters_available {
            my_size += crate::rt::int32_size(26, value.value());
        };
        for value in &self.split_scaling_scalers_available {
            my_size += crate::rt::int32_size(27, value.value());
        };
        if let Some(v) = self.is_hdr_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_refresh_manual_hz_oc_max {
            my_size += crate::rt::int32_size(29, v);
        }
        if let Some(v) = self.disable_refresh_rate_management {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cpu_governor_manual_min_mhz {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cpu_governor_manual_max_mhz {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.fsr_sharpness_min {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.fsr_sharpness_max {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.gpu_performance_manual_min_mhz {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.gpu_performance_manual_max_mhz {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.perf_overlay_is_standalone {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_dynamic_vrs_available {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_manual_display_refresh_rate_available {
            os.write_bool(9, v)?;
        }
        for v in &self.gpu_performance_levels_available {
            os.write_enum(10, crate::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.display_refresh_manual_hz_min {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz_max {
            os.write_int32(12, v)?;
        }
        for v in &self.fps_limit_options {
            os.write_int32(13, *v)?;
        };
        if let Some(v) = self.tdp_limit_min {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.tdp_limit_max {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.is_nis_supported {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.nis_sharpness_min {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.nis_sharpness_max {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.display_external_refresh_manual_hz_min {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.display_external_refresh_manual_hz_max {
            os.write_int32(20, v)?;
        }
        for v in &self.fps_limit_options_external {
            os.write_int32(21, *v)?;
        };
        if let Some(v) = self.is_tearing_supported {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.is_vrr_supported {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_in_steam_supported {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.is_split_scaling_and_filtering_supported {
            os.write_bool(25, v)?;
        }
        for v in &self.split_scaling_filters_available {
            os.write_enum(26, crate::EnumOrUnknown::value(v))?;
        };
        for v in &self.split_scaling_scalers_available {
            os.write_enum(27, crate::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.is_hdr_supported {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz_oc_max {
            os.write_int32(29, v)?;
        }
        if let Some(v) = self.disable_refresh_rate_management {
            os.write_bool(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfLimits {
        CMsgSystemPerfLimits::new()
    }

    fn clear(&mut self) {
        self.cpu_governor_manual_min_mhz = ::std::option::Option::None;
        self.cpu_governor_manual_max_mhz = ::std::option::Option::None;
        self.fsr_sharpness_min = ::std::option::Option::None;
        self.fsr_sharpness_max = ::std::option::Option::None;
        self.gpu_performance_manual_min_mhz = ::std::option::Option::None;
        self.gpu_performance_manual_max_mhz = ::std::option::Option::None;
        self.perf_overlay_is_standalone = ::std::option::Option::None;
        self.is_dynamic_vrs_available = ::std::option::Option::None;
        self.is_manual_display_refresh_rate_available = ::std::option::Option::None;
        self.gpu_performance_levels_available.clear();
        self.display_refresh_manual_hz_min = ::std::option::Option::None;
        self.display_refresh_manual_hz_max = ::std::option::Option::None;
        self.fps_limit_options.clear();
        self.tdp_limit_min = ::std::option::Option::None;
        self.tdp_limit_max = ::std::option::Option::None;
        self.is_nis_supported = ::std::option::Option::None;
        self.nis_sharpness_min = ::std::option::Option::None;
        self.nis_sharpness_max = ::std::option::Option::None;
        self.display_external_refresh_manual_hz_min = ::std::option::Option::None;
        self.display_external_refresh_manual_hz_max = ::std::option::Option::None;
        self.fps_limit_options_external.clear();
        self.is_tearing_supported = ::std::option::Option::None;
        self.is_vrr_supported = ::std::option::Option::None;
        self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::None;
        self.is_split_scaling_and_filtering_supported = ::std::option::Option::None;
        self.split_scaling_filters_available.clear();
        self.split_scaling_scalers_available.clear();
        self.is_hdr_supported = ::std::option::Option::None;
        self.display_refresh_manual_hz_oc_max = ::std::option::Option::None;
        self.disable_refresh_rate_management = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfLimits {
        static instance: CMsgSystemPerfLimits = CMsgSystemPerfLimits {
            cpu_governor_manual_min_mhz: ::std::option::Option::None,
            cpu_governor_manual_max_mhz: ::std::option::Option::None,
            fsr_sharpness_min: ::std::option::Option::None,
            fsr_sharpness_max: ::std::option::Option::None,
            gpu_performance_manual_min_mhz: ::std::option::Option::None,
            gpu_performance_manual_max_mhz: ::std::option::Option::None,
            perf_overlay_is_standalone: ::std::option::Option::None,
            is_dynamic_vrs_available: ::std::option::Option::None,
            is_manual_display_refresh_rate_available: ::std::option::Option::None,
            gpu_performance_levels_available: ::std::vec::Vec::new(),
            display_refresh_manual_hz_min: ::std::option::Option::None,
            display_refresh_manual_hz_max: ::std::option::Option::None,
            fps_limit_options: ::std::vec::Vec::new(),
            tdp_limit_min: ::std::option::Option::None,
            tdp_limit_max: ::std::option::Option::None,
            is_nis_supported: ::std::option::Option::None,
            nis_sharpness_min: ::std::option::Option::None,
            nis_sharpness_max: ::std::option::Option::None,
            display_external_refresh_manual_hz_min: ::std::option::Option::None,
            display_external_refresh_manual_hz_max: ::std::option::Option::None,
            fps_limit_options_external: ::std::vec::Vec::new(),
            is_tearing_supported: ::std::option::Option::None,
            is_vrr_supported: ::std::option::Option::None,
            is_dynamic_refresh_rate_in_steam_supported: ::std::option::Option::None,
            is_split_scaling_and_filtering_supported: ::std::option::Option::None,
            split_scaling_filters_available: ::std::vec::Vec::new(),
            split_scaling_scalers_available: ::std::vec::Vec::new(),
            is_hdr_supported: ::std::option::Option::None,
            display_refresh_manual_hz_oc_max: ::std::option::Option::None,
            disable_refresh_rate_management: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfLimits {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfLimits").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfLimits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfLimits {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettingsGlobal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettingsGlobal {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.diagnostic_update_rate)
    pub diagnostic_update_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.system_trace_service_state)
    pub system_trace_service_state: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.graphics_profiling_service_state)
    pub graphics_profiling_service_state: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.perf_overlay_service_state)
    pub perf_overlay_service_state: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.perf_overlay_level)
    pub perf_overlay_level: ::std::option::Option<crate::EnumOrUnknown<super::enums::EGraphicsPerfOverlayLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_show_perf_overlay_over_steam_enabled)
    pub is_show_perf_overlay_over_steam_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_advanced_settings_enabled)
    pub is_advanced_settings_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.allow_external_display_refresh_control)
    pub allow_external_display_refresh_control: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_hdr_enabled)
    pub is_hdr_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.hdr_on_sdr_tonemap_operator)
    pub hdr_on_sdr_tonemap_operator: ::std::option::Option<crate::EnumOrUnknown<super::enums::EHDRToneMapOperator>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_hdr_debug_heatmap_enabled)
    pub is_hdr_debug_heatmap_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.force_hdr_wide_gammut_for_sdr)
    pub force_hdr_wide_gammut_for_sdr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.allow_experimental_hdr)
    pub allow_experimental_hdr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.sdr_to_hdr_brightness)
    pub sdr_to_hdr_brightness: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.debug_force_hdr_support)
    pub debug_force_hdr_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.force_hdr_10pq_output_debug)
    pub force_hdr_10pq_output_debug: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_display_oc_enabled)
    pub is_display_oc_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_color_management_enabled)
    pub is_color_management_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettingsGlobal.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettingsGlobal {
    fn default() -> &'a CMsgSystemPerfSettingsGlobal {
        <CMsgSystemPerfSettingsGlobal as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettingsGlobal {
    pub fn new() -> CMsgSystemPerfSettingsGlobal {
        ::std::default::Default::default()
    }

    // optional float diagnostic_update_rate = 1;

    pub fn diagnostic_update_rate(&self) -> f32 {
        self.diagnostic_update_rate.unwrap_or(0.)
    }

    pub fn clear_diagnostic_update_rate(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
    }

    pub fn has_diagnostic_update_rate(&self) -> bool {
        self.diagnostic_update_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic_update_rate(&mut self, v: f32) {
        self.diagnostic_update_rate = ::std::option::Option::Some(v);
    }

    // optional .ESystemServiceState system_trace_service_state = 2;

    pub fn system_trace_service_state(&self) -> super::enums::ESystemServiceState {
        match self.system_trace_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_system_trace_service_state(&mut self) {
        self.system_trace_service_state = ::std::option::Option::None;
    }

    pub fn has_system_trace_service_state(&self) -> bool {
        self.system_trace_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_trace_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.system_trace_service_state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState graphics_profiling_service_state = 3;

    pub fn graphics_profiling_service_state(&self) -> super::enums::ESystemServiceState {
        match self.graphics_profiling_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_graphics_profiling_service_state(&mut self) {
        self.graphics_profiling_service_state = ::std::option::Option::None;
    }

    pub fn has_graphics_profiling_service_state(&self) -> bool {
        self.graphics_profiling_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graphics_profiling_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.graphics_profiling_service_state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState perf_overlay_service_state = 4;

    pub fn perf_overlay_service_state(&self) -> super::enums::ESystemServiceState {
        match self.perf_overlay_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_perf_overlay_service_state(&mut self) {
        self.perf_overlay_service_state = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_service_state(&self) -> bool {
        self.perf_overlay_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.perf_overlay_service_state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5;

    pub fn perf_overlay_level(&self) -> super::enums::EGraphicsPerfOverlayLevel {
        match self.perf_overlay_level {
            Some(e) => e.enum_value_or(super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            None => super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden,
        }
    }

    pub fn clear_perf_overlay_level(&mut self) {
        self.perf_overlay_level = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_level(&self) -> bool {
        self.perf_overlay_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_level(&mut self, v: super::enums::EGraphicsPerfOverlayLevel) {
        self.perf_overlay_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool is_show_perf_overlay_over_steam_enabled = 6;

    pub fn is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.unwrap_or(false)
    }

    pub fn clear_is_show_perf_overlay_over_steam_enabled(&mut self) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
    }

    pub fn has_is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_show_perf_overlay_over_steam_enabled(&mut self, v: bool) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_advanced_settings_enabled = 7;

    pub fn is_advanced_settings_enabled(&self) -> bool {
        self.is_advanced_settings_enabled.unwrap_or(false)
    }

    pub fn clear_is_advanced_settings_enabled(&mut self) {
        self.is_advanced_settings_enabled = ::std::option::Option::None;
    }

    pub fn has_is_advanced_settings_enabled(&self) -> bool {
        self.is_advanced_settings_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_advanced_settings_enabled(&mut self, v: bool) {
        self.is_advanced_settings_enabled = ::std::option::Option::Some(v);
    }

    // optional bool allow_external_display_refresh_control = 8;

    pub fn allow_external_display_refresh_control(&self) -> bool {
        self.allow_external_display_refresh_control.unwrap_or(false)
    }

    pub fn clear_allow_external_display_refresh_control(&mut self) {
        self.allow_external_display_refresh_control = ::std::option::Option::None;
    }

    pub fn has_allow_external_display_refresh_control(&self) -> bool {
        self.allow_external_display_refresh_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_external_display_refresh_control(&mut self, v: bool) {
        self.allow_external_display_refresh_control = ::std::option::Option::Some(v);
    }

    // optional bool is_hdr_enabled = 9;

    pub fn is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.unwrap_or(false)
    }

    pub fn clear_is_hdr_enabled(&mut self) {
        self.is_hdr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_enabled(&mut self, v: bool) {
        self.is_hdr_enabled = ::std::option::Option::Some(v);
    }

    // optional .EHDRToneMapOperator hdr_on_sdr_tonemap_operator = 12;

    pub fn hdr_on_sdr_tonemap_operator(&self) -> super::enums::EHDRToneMapOperator {
        match self.hdr_on_sdr_tonemap_operator {
            Some(e) => e.enum_value_or(super::enums::EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid),
            None => super::enums::EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid,
        }
    }

    pub fn clear_hdr_on_sdr_tonemap_operator(&mut self) {
        self.hdr_on_sdr_tonemap_operator = ::std::option::Option::None;
    }

    pub fn has_hdr_on_sdr_tonemap_operator(&self) -> bool {
        self.hdr_on_sdr_tonemap_operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hdr_on_sdr_tonemap_operator(&mut self, v: super::enums::EHDRToneMapOperator) {
        self.hdr_on_sdr_tonemap_operator = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool is_hdr_debug_heatmap_enabled = 13;

    pub fn is_hdr_debug_heatmap_enabled(&self) -> bool {
        self.is_hdr_debug_heatmap_enabled.unwrap_or(false)
    }

    pub fn clear_is_hdr_debug_heatmap_enabled(&mut self) {
        self.is_hdr_debug_heatmap_enabled = ::std::option::Option::None;
    }

    pub fn has_is_hdr_debug_heatmap_enabled(&self) -> bool {
        self.is_hdr_debug_heatmap_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_debug_heatmap_enabled(&mut self, v: bool) {
        self.is_hdr_debug_heatmap_enabled = ::std::option::Option::Some(v);
    }

    // optional bool force_hdr_wide_gammut_for_sdr = 15;

    pub fn force_hdr_wide_gammut_for_sdr(&self) -> bool {
        self.force_hdr_wide_gammut_for_sdr.unwrap_or(true)
    }

    pub fn clear_force_hdr_wide_gammut_for_sdr(&mut self) {
        self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::None;
    }

    pub fn has_force_hdr_wide_gammut_for_sdr(&self) -> bool {
        self.force_hdr_wide_gammut_for_sdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_hdr_wide_gammut_for_sdr(&mut self, v: bool) {
        self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::Some(v);
    }

    // optional bool allow_experimental_hdr = 16;

    pub fn allow_experimental_hdr(&self) -> bool {
        self.allow_experimental_hdr.unwrap_or(false)
    }

    pub fn clear_allow_experimental_hdr(&mut self) {
        self.allow_experimental_hdr = ::std::option::Option::None;
    }

    pub fn has_allow_experimental_hdr(&self) -> bool {
        self.allow_experimental_hdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_experimental_hdr(&mut self, v: bool) {
        self.allow_experimental_hdr = ::std::option::Option::Some(v);
    }

    // optional float sdr_to_hdr_brightness = 22;

    pub fn sdr_to_hdr_brightness(&self) -> f32 {
        self.sdr_to_hdr_brightness.unwrap_or(0.)
    }

    pub fn clear_sdr_to_hdr_brightness(&mut self) {
        self.sdr_to_hdr_brightness = ::std::option::Option::None;
    }

    pub fn has_sdr_to_hdr_brightness(&self) -> bool {
        self.sdr_to_hdr_brightness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_to_hdr_brightness(&mut self, v: f32) {
        self.sdr_to_hdr_brightness = ::std::option::Option::Some(v);
    }

    // optional bool debug_force_hdr_support = 18;

    pub fn debug_force_hdr_support(&self) -> bool {
        self.debug_force_hdr_support.unwrap_or(false)
    }

    pub fn clear_debug_force_hdr_support(&mut self) {
        self.debug_force_hdr_support = ::std::option::Option::None;
    }

    pub fn has_debug_force_hdr_support(&self) -> bool {
        self.debug_force_hdr_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_force_hdr_support(&mut self, v: bool) {
        self.debug_force_hdr_support = ::std::option::Option::Some(v);
    }

    // optional bool force_hdr_10pq_output_debug = 19;

    pub fn force_hdr_10pq_output_debug(&self) -> bool {
        self.force_hdr_10pq_output_debug.unwrap_or(false)
    }

    pub fn clear_force_hdr_10pq_output_debug(&mut self) {
        self.force_hdr_10pq_output_debug = ::std::option::Option::None;
    }

    pub fn has_force_hdr_10pq_output_debug(&self) -> bool {
        self.force_hdr_10pq_output_debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_hdr_10pq_output_debug(&mut self, v: bool) {
        self.force_hdr_10pq_output_debug = ::std::option::Option::Some(v);
    }

    // optional bool is_display_oc_enabled = 20;

    pub fn is_display_oc_enabled(&self) -> bool {
        self.is_display_oc_enabled.unwrap_or(false)
    }

    pub fn clear_is_display_oc_enabled(&mut self) {
        self.is_display_oc_enabled = ::std::option::Option::None;
    }

    pub fn has_is_display_oc_enabled(&self) -> bool {
        self.is_display_oc_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_display_oc_enabled(&mut self, v: bool) {
        self.is_display_oc_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_color_management_enabled = 21;

    pub fn is_color_management_enabled(&self) -> bool {
        self.is_color_management_enabled.unwrap_or(false)
    }

    pub fn clear_is_color_management_enabled(&mut self) {
        self.is_color_management_enabled = ::std::option::Option::None;
    }

    pub fn has_is_color_management_enabled(&self) -> bool {
        self.is_color_management_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_color_management_enabled(&mut self, v: bool) {
        self.is_color_management_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic_update_rate",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.diagnostic_update_rate },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.diagnostic_update_rate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_trace_service_state",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.system_trace_service_state },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.system_trace_service_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "graphics_profiling_service_state",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.graphics_profiling_service_state },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.graphics_profiling_service_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "perf_overlay_service_state",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.perf_overlay_service_state },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.perf_overlay_service_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "perf_overlay_level",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.perf_overlay_level },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.perf_overlay_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_show_perf_overlay_over_steam_enabled",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.is_show_perf_overlay_over_steam_enabled },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.is_show_perf_overlay_over_steam_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_advanced_settings_enabled",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.is_advanced_settings_enabled },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.is_advanced_settings_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_external_display_refresh_control",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.allow_external_display_refresh_control },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.allow_external_display_refresh_control },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hdr_enabled",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.is_hdr_enabled },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.is_hdr_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hdr_on_sdr_tonemap_operator",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.hdr_on_sdr_tonemap_operator },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.hdr_on_sdr_tonemap_operator },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hdr_debug_heatmap_enabled",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.is_hdr_debug_heatmap_enabled },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.is_hdr_debug_heatmap_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_hdr_wide_gammut_for_sdr",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.force_hdr_wide_gammut_for_sdr },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.force_hdr_wide_gammut_for_sdr },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_experimental_hdr",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.allow_experimental_hdr },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.allow_experimental_hdr },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdr_to_hdr_brightness",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.sdr_to_hdr_brightness },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.sdr_to_hdr_brightness },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_force_hdr_support",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.debug_force_hdr_support },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.debug_force_hdr_support },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_hdr_10pq_output_debug",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.force_hdr_10pq_output_debug },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.force_hdr_10pq_output_debug },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_display_oc_enabled",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.is_display_oc_enabled },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.is_display_oc_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_color_management_enabled",
            |m: &CMsgSystemPerfSettingsGlobal| { &m.is_color_management_enabled },
            |m: &mut CMsgSystemPerfSettingsGlobal| { &mut m.is_color_management_enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfSettingsGlobal>(
            "CMsgSystemPerfSettingsGlobal",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfSettingsGlobal {
    const NAME: &'static str = "CMsgSystemPerfSettingsGlobal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.diagnostic_update_rate = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.system_trace_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.graphics_profiling_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.perf_overlay_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.perf_overlay_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.is_advanced_settings_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.allow_external_display_refresh_control = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_hdr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.hdr_on_sdr_tonemap_operator = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.is_hdr_debug_heatmap_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.allow_experimental_hdr = ::std::option::Option::Some(is.read_bool()?);
                },
                181 => {
                    self.sdr_to_hdr_brightness = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.debug_force_hdr_support = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.force_hdr_10pq_output_debug = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.is_display_oc_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.is_color_management_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diagnostic_update_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.system_trace_service_state {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.graphics_profiling_service_state {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.perf_overlay_service_state {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.perf_overlay_level {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_advanced_settings_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_external_display_refresh_control {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hdr_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hdr_on_sdr_tonemap_operator {
            my_size += crate::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.is_hdr_debug_heatmap_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.force_hdr_wide_gammut_for_sdr {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_experimental_hdr {
            my_size += 2 + 1;
        }
        if let Some(v) = self.sdr_to_hdr_brightness {
            my_size += 2 + 4;
        }
        if let Some(v) = self.debug_force_hdr_support {
            my_size += 2 + 1;
        }
        if let Some(v) = self.force_hdr_10pq_output_debug {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_display_oc_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_color_management_enabled {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.diagnostic_update_rate {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.system_trace_service_state {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.graphics_profiling_service_state {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_service_state {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_level {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.is_advanced_settings_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.allow_external_display_refresh_control {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_hdr_enabled {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.hdr_on_sdr_tonemap_operator {
            os.write_enum(12, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_hdr_debug_heatmap_enabled {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.force_hdr_wide_gammut_for_sdr {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.allow_experimental_hdr {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.sdr_to_hdr_brightness {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.debug_force_hdr_support {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.force_hdr_10pq_output_debug {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.is_display_oc_enabled {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.is_color_management_enabled {
            os.write_bool(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettingsGlobal {
        CMsgSystemPerfSettingsGlobal::new()
    }

    fn clear(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
        self.system_trace_service_state = ::std::option::Option::None;
        self.graphics_profiling_service_state = ::std::option::Option::None;
        self.perf_overlay_service_state = ::std::option::Option::None;
        self.perf_overlay_level = ::std::option::Option::None;
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
        self.is_advanced_settings_enabled = ::std::option::Option::None;
        self.allow_external_display_refresh_control = ::std::option::Option::None;
        self.is_hdr_enabled = ::std::option::Option::None;
        self.hdr_on_sdr_tonemap_operator = ::std::option::Option::None;
        self.is_hdr_debug_heatmap_enabled = ::std::option::Option::None;
        self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::None;
        self.allow_experimental_hdr = ::std::option::Option::None;
        self.sdr_to_hdr_brightness = ::std::option::Option::None;
        self.debug_force_hdr_support = ::std::option::Option::None;
        self.force_hdr_10pq_output_debug = ::std::option::Option::None;
        self.is_display_oc_enabled = ::std::option::Option::None;
        self.is_color_management_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettingsGlobal {
        static instance: CMsgSystemPerfSettingsGlobal = CMsgSystemPerfSettingsGlobal {
            diagnostic_update_rate: ::std::option::Option::None,
            system_trace_service_state: ::std::option::Option::None,
            graphics_profiling_service_state: ::std::option::Option::None,
            perf_overlay_service_state: ::std::option::Option::None,
            perf_overlay_level: ::std::option::Option::None,
            is_show_perf_overlay_over_steam_enabled: ::std::option::Option::None,
            is_advanced_settings_enabled: ::std::option::Option::None,
            allow_external_display_refresh_control: ::std::option::Option::None,
            is_hdr_enabled: ::std::option::Option::None,
            hdr_on_sdr_tonemap_operator: ::std::option::Option::None,
            is_hdr_debug_heatmap_enabled: ::std::option::Option::None,
            force_hdr_wide_gammut_for_sdr: ::std::option::Option::None,
            allow_experimental_hdr: ::std::option::Option::None,
            sdr_to_hdr_brightness: ::std::option::Option::None,
            debug_force_hdr_support: ::std::option::Option::None,
            force_hdr_10pq_output_debug: ::std::option::Option::None,
            is_display_oc_enabled: ::std::option::Option::None,
            is_color_management_enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfSettingsGlobal {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfSettingsGlobal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfSettingsGlobal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfSettingsGlobal {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettingsPerApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettingsPerApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.gpu_performance_manual_mhz)
    pub gpu_performance_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.fps_limit)
    pub fps_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_variable_resolution_enabled)
    pub is_variable_resolution_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_dynamic_refresh_rate_enabled)
    pub is_dynamic_refresh_rate_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.tdp_limit)
    pub tdp_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.cpu_governor)
    pub cpu_governor: ::std::option::Option<crate::EnumOrUnknown<super::enums::ECPUGovernor>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.cpu_governor_manual_mhz)
    pub cpu_governor_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.scaling_filter)
    pub scaling_filter: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.fsr_sharpness)
    pub fsr_sharpness: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_fps_limit_enabled)
    pub is_fps_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_tdp_limit_enabled)
    pub is_tdp_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_low_latency_mode_enabled)
    pub is_low_latency_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.display_refresh_manual_hz)
    pub display_refresh_manual_hz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_game_perf_profile_enabled)
    pub is_game_perf_profile_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.gpu_performance_level)
    pub gpu_performance_level: ::std::option::Option<crate::EnumOrUnknown<super::enums::EGPUPerformanceLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.nis_sharpness)
    pub nis_sharpness: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.display_external_refresh_manual_hz)
    pub display_external_refresh_manual_hz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.fps_limit_external)
    pub fps_limit_external: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_tearing_enabled)
    pub is_tearing_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_vrr_enabled)
    pub is_vrr_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_composite_debug_enabled)
    pub is_composite_debug_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.force_composite)
    pub force_composite: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.use_dynamic_refresh_rate_in_steam)
    pub use_dynamic_refresh_rate_in_steam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.split_scaling_filter)
    pub split_scaling_filter: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESplitScalingFilter>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.split_scaling_scaler)
    pub split_scaling_scaler: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESplitScalingScaler>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettingsPerApp.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettingsPerApp {
    fn default() -> &'a CMsgSystemPerfSettingsPerApp {
        <CMsgSystemPerfSettingsPerApp as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettingsPerApp {
    pub fn new() -> CMsgSystemPerfSettingsPerApp {
        ::std::default::Default::default()
    }

    // optional int32 gpu_performance_manual_mhz = 1;

    pub fn gpu_performance_manual_mhz(&self) -> i32 {
        self.gpu_performance_manual_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_mhz(&mut self) {
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_mhz(&self) -> bool {
        self.gpu_performance_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 fps_limit = 2;

    pub fn fps_limit(&self) -> i32 {
        self.fps_limit.unwrap_or(0)
    }

    pub fn clear_fps_limit(&mut self) {
        self.fps_limit = ::std::option::Option::None;
    }

    pub fn has_fps_limit(&self) -> bool {
        self.fps_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_limit(&mut self, v: i32) {
        self.fps_limit = ::std::option::Option::Some(v);
    }

    // optional bool is_variable_resolution_enabled = 3;

    pub fn is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.unwrap_or(false)
    }

    pub fn clear_is_variable_resolution_enabled(&mut self) {
        self.is_variable_resolution_enabled = ::std::option::Option::None;
    }

    pub fn has_is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_variable_resolution_enabled(&mut self, v: bool) {
        self.is_variable_resolution_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_refresh_rate_enabled = 4;

    pub fn is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.unwrap_or(false)
    }

    pub fn clear_is_dynamic_refresh_rate_enabled(&mut self) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_refresh_rate_enabled(&mut self, v: bool) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 tdp_limit = 5;

    pub fn tdp_limit(&self) -> i32 {
        self.tdp_limit.unwrap_or(0)
    }

    pub fn clear_tdp_limit(&mut self) {
        self.tdp_limit = ::std::option::Option::None;
    }

    pub fn has_tdp_limit(&self) -> bool {
        self.tdp_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit(&mut self, v: i32) {
        self.tdp_limit = ::std::option::Option::Some(v);
    }

    // optional .ECPUGovernor cpu_governor = 6;

    pub fn cpu_governor(&self) -> super::enums::ECPUGovernor {
        match self.cpu_governor {
            Some(e) => e.enum_value_or(super::enums::ECPUGovernor::k_ECPUGovernor_Invalid),
            None => super::enums::ECPUGovernor::k_ECPUGovernor_Invalid,
        }
    }

    pub fn clear_cpu_governor(&mut self) {
        self.cpu_governor = ::std::option::Option::None;
    }

    pub fn has_cpu_governor(&self) -> bool {
        self.cpu_governor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor(&mut self, v: super::enums::ECPUGovernor) {
        self.cpu_governor = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 cpu_governor_manual_mhz = 7;

    pub fn cpu_governor_manual_mhz(&self) -> i32 {
        self.cpu_governor_manual_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_mhz(&mut self) {
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_mhz(&self) -> bool {
        self.cpu_governor_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 scaling_filter = 8;

    pub fn scaling_filter(&self) -> i32 {
        self.scaling_filter.unwrap_or(0)
    }

    pub fn clear_scaling_filter(&mut self) {
        self.scaling_filter = ::std::option::Option::None;
    }

    pub fn has_scaling_filter(&self) -> bool {
        self.scaling_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaling_filter(&mut self, v: i32) {
        self.scaling_filter = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness = 9;

    pub fn fsr_sharpness(&self) -> i32 {
        self.fsr_sharpness.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness(&mut self) {
        self.fsr_sharpness = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness(&self) -> bool {
        self.fsr_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness(&mut self, v: i32) {
        self.fsr_sharpness = ::std::option::Option::Some(v);
    }

    // optional bool is_fps_limit_enabled = 10;

    pub fn is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_fps_limit_enabled(&mut self) {
        self.is_fps_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fps_limit_enabled(&mut self, v: bool) {
        self.is_fps_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_tdp_limit_enabled = 11;

    pub fn is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_tdp_limit_enabled(&mut self) {
        self.is_tdp_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tdp_limit_enabled(&mut self, v: bool) {
        self.is_tdp_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_low_latency_mode_enabled = 12;

    pub fn is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.unwrap_or(false)
    }

    pub fn clear_is_low_latency_mode_enabled(&mut self) {
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_low_latency_mode_enabled(&mut self, v: bool) {
        self.is_low_latency_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz = 13;

    pub fn display_refresh_manual_hz(&self) -> i32 {
        self.display_refresh_manual_hz.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz(&mut self) {
        self.display_refresh_manual_hz = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz(&self) -> bool {
        self.display_refresh_manual_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz(&mut self, v: i32) {
        self.display_refresh_manual_hz = ::std::option::Option::Some(v);
    }

    // optional bool is_game_perf_profile_enabled = 14;

    pub fn is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.unwrap_or(false)
    }

    pub fn clear_is_game_perf_profile_enabled(&mut self) {
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
    }

    pub fn has_is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_game_perf_profile_enabled(&mut self, v: bool) {
        self.is_game_perf_profile_enabled = ::std::option::Option::Some(v);
    }

    // optional .EGPUPerformanceLevel gpu_performance_level = 15;

    pub fn gpu_performance_level(&self) -> super::enums::EGPUPerformanceLevel {
        match self.gpu_performance_level {
            Some(e) => e.enum_value_or(super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            None => super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid,
        }
    }

    pub fn clear_gpu_performance_level(&mut self) {
        self.gpu_performance_level = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_level(&self) -> bool {
        self.gpu_performance_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_level(&mut self, v: super::enums::EGPUPerformanceLevel) {
        self.gpu_performance_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 nis_sharpness = 16;

    pub fn nis_sharpness(&self) -> i32 {
        self.nis_sharpness.unwrap_or(0)
    }

    pub fn clear_nis_sharpness(&mut self) {
        self.nis_sharpness = ::std::option::Option::None;
    }

    pub fn has_nis_sharpness(&self) -> bool {
        self.nis_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nis_sharpness(&mut self, v: i32) {
        self.nis_sharpness = ::std::option::Option::Some(v);
    }

    // optional int32 display_external_refresh_manual_hz = 17;

    pub fn display_external_refresh_manual_hz(&self) -> i32 {
        self.display_external_refresh_manual_hz.unwrap_or(0)
    }

    pub fn clear_display_external_refresh_manual_hz(&mut self) {
        self.display_external_refresh_manual_hz = ::std::option::Option::None;
    }

    pub fn has_display_external_refresh_manual_hz(&self) -> bool {
        self.display_external_refresh_manual_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_external_refresh_manual_hz(&mut self, v: i32) {
        self.display_external_refresh_manual_hz = ::std::option::Option::Some(v);
    }

    // optional int32 fps_limit_external = 18;

    pub fn fps_limit_external(&self) -> i32 {
        self.fps_limit_external.unwrap_or(0)
    }

    pub fn clear_fps_limit_external(&mut self) {
        self.fps_limit_external = ::std::option::Option::None;
    }

    pub fn has_fps_limit_external(&self) -> bool {
        self.fps_limit_external.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_limit_external(&mut self, v: i32) {
        self.fps_limit_external = ::std::option::Option::Some(v);
    }

    // optional bool is_tearing_enabled = 19;

    pub fn is_tearing_enabled(&self) -> bool {
        self.is_tearing_enabled.unwrap_or(false)
    }

    pub fn clear_is_tearing_enabled(&mut self) {
        self.is_tearing_enabled = ::std::option::Option::None;
    }

    pub fn has_is_tearing_enabled(&self) -> bool {
        self.is_tearing_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tearing_enabled(&mut self, v: bool) {
        self.is_tearing_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_enabled = 20;

    pub fn is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.unwrap_or(false)
    }

    pub fn clear_is_vrr_enabled(&mut self) {
        self.is_vrr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_enabled(&mut self, v: bool) {
        self.is_vrr_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_composite_debug_enabled = 21;

    pub fn is_composite_debug_enabled(&self) -> bool {
        self.is_composite_debug_enabled.unwrap_or(false)
    }

    pub fn clear_is_composite_debug_enabled(&mut self) {
        self.is_composite_debug_enabled = ::std::option::Option::None;
    }

    pub fn has_is_composite_debug_enabled(&self) -> bool {
        self.is_composite_debug_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_composite_debug_enabled(&mut self, v: bool) {
        self.is_composite_debug_enabled = ::std::option::Option::Some(v);
    }

    // optional bool force_composite = 22;

    pub fn force_composite(&self) -> bool {
        self.force_composite.unwrap_or(false)
    }

    pub fn clear_force_composite(&mut self) {
        self.force_composite = ::std::option::Option::None;
    }

    pub fn has_force_composite(&self) -> bool {
        self.force_composite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_composite(&mut self, v: bool) {
        self.force_composite = ::std::option::Option::Some(v);
    }

    // optional bool use_dynamic_refresh_rate_in_steam = 23;

    pub fn use_dynamic_refresh_rate_in_steam(&self) -> bool {
        self.use_dynamic_refresh_rate_in_steam.unwrap_or(false)
    }

    pub fn clear_use_dynamic_refresh_rate_in_steam(&mut self) {
        self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::None;
    }

    pub fn has_use_dynamic_refresh_rate_in_steam(&self) -> bool {
        self.use_dynamic_refresh_rate_in_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_dynamic_refresh_rate_in_steam(&mut self, v: bool) {
        self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::Some(v);
    }

    // optional .ESplitScalingFilter split_scaling_filter = 24;

    pub fn split_scaling_filter(&self) -> super::enums::ESplitScalingFilter {
        match self.split_scaling_filter {
            Some(e) => e.enum_value_or(super::enums::ESplitScalingFilter::k_ESplitScalingFilter_Invalid),
            None => super::enums::ESplitScalingFilter::k_ESplitScalingFilter_Invalid,
        }
    }

    pub fn clear_split_scaling_filter(&mut self) {
        self.split_scaling_filter = ::std::option::Option::None;
    }

    pub fn has_split_scaling_filter(&self) -> bool {
        self.split_scaling_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_scaling_filter(&mut self, v: super::enums::ESplitScalingFilter) {
        self.split_scaling_filter = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .ESplitScalingScaler split_scaling_scaler = 25;

    pub fn split_scaling_scaler(&self) -> super::enums::ESplitScalingScaler {
        match self.split_scaling_scaler {
            Some(e) => e.enum_value_or(super::enums::ESplitScalingScaler::k_ESplitScalingScaler_Invalid),
            None => super::enums::ESplitScalingScaler::k_ESplitScalingScaler_Invalid,
        }
    }

    pub fn clear_split_scaling_scaler(&mut self) {
        self.split_scaling_scaler = ::std::option::Option::None;
    }

    pub fn has_split_scaling_scaler(&self) -> bool {
        self.split_scaling_scaler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_scaling_scaler(&mut self, v: super::enums::ESplitScalingScaler) {
        self.split_scaling_scaler = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_performance_manual_mhz",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.gpu_performance_manual_mhz },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.gpu_performance_manual_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fps_limit",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.fps_limit },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.fps_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_variable_resolution_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_variable_resolution_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_variable_resolution_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dynamic_refresh_rate_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_dynamic_refresh_rate_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_dynamic_refresh_rate_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tdp_limit",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.tdp_limit },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.tdp_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_governor",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.cpu_governor },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.cpu_governor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_governor_manual_mhz",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.cpu_governor_manual_mhz },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.cpu_governor_manual_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scaling_filter",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.scaling_filter },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.scaling_filter },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsr_sharpness",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.fsr_sharpness },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.fsr_sharpness },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_fps_limit_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_fps_limit_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_fps_limit_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_tdp_limit_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_tdp_limit_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_tdp_limit_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_low_latency_mode_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_low_latency_mode_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_low_latency_mode_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_refresh_manual_hz",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.display_refresh_manual_hz },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.display_refresh_manual_hz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_game_perf_profile_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_game_perf_profile_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_game_perf_profile_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_performance_level",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.gpu_performance_level },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.gpu_performance_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nis_sharpness",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.nis_sharpness },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.nis_sharpness },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_external_refresh_manual_hz",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.display_external_refresh_manual_hz },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.display_external_refresh_manual_hz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fps_limit_external",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.fps_limit_external },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.fps_limit_external },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_tearing_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_tearing_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_tearing_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_vrr_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_vrr_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_vrr_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_composite_debug_enabled",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.is_composite_debug_enabled },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.is_composite_debug_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_composite",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.force_composite },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.force_composite },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_dynamic_refresh_rate_in_steam",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.use_dynamic_refresh_rate_in_steam },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.use_dynamic_refresh_rate_in_steam },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "split_scaling_filter",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.split_scaling_filter },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.split_scaling_filter },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "split_scaling_scaler",
            |m: &CMsgSystemPerfSettingsPerApp| { &m.split_scaling_scaler },
            |m: &mut CMsgSystemPerfSettingsPerApp| { &mut m.split_scaling_scaler },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfSettingsPerApp>(
            "CMsgSystemPerfSettingsPerApp",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfSettingsPerApp {
    const NAME: &'static str = "CMsgSystemPerfSettingsPerApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gpu_performance_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.fps_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_variable_resolution_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.tdp_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.cpu_governor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.cpu_governor_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.scaling_filter = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.fsr_sharpness = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.is_fps_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.is_tdp_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_low_latency_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.display_refresh_manual_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.is_game_perf_profile_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.gpu_performance_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                128 => {
                    self.nis_sharpness = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.display_external_refresh_manual_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.fps_limit_external = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.is_tearing_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.is_vrr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.is_composite_debug_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.force_composite = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.split_scaling_filter = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.split_scaling_scaler = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gpu_performance_manual_mhz {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.fps_limit {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tdp_limit {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.cpu_governor {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            my_size += crate::rt::int32_size(7, v);
        }
        if let Some(v) = self.scaling_filter {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.fsr_sharpness {
            my_size += crate::rt::int32_size(9, v);
        }
        if let Some(v) = self.is_fps_limit_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            my_size += crate::rt::int32_size(13, v);
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.gpu_performance_level {
            my_size += crate::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.nis_sharpness {
            my_size += crate::rt::int32_size(16, v);
        }
        if let Some(v) = self.display_external_refresh_manual_hz {
            my_size += crate::rt::int32_size(17, v);
        }
        if let Some(v) = self.fps_limit_external {
            my_size += crate::rt::int32_size(18, v);
        }
        if let Some(v) = self.is_tearing_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_vrr_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_composite_debug_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.force_composite {
            my_size += 2 + 1;
        }
        if let Some(v) = self.use_dynamic_refresh_rate_in_steam {
            my_size += 2 + 1;
        }
        if let Some(v) = self.split_scaling_filter {
            my_size += crate::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.split_scaling_scaler {
            my_size += crate::rt::int32_size(25, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gpu_performance_manual_mhz {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fps_limit {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.tdp_limit {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cpu_governor {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.scaling_filter {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.fsr_sharpness {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.is_fps_limit_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.gpu_performance_level {
            os.write_enum(15, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.nis_sharpness {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.display_external_refresh_manual_hz {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.fps_limit_external {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.is_tearing_enabled {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.is_vrr_enabled {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.is_composite_debug_enabled {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.force_composite {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.use_dynamic_refresh_rate_in_steam {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.split_scaling_filter {
            os.write_enum(24, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.split_scaling_scaler {
            os.write_enum(25, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettingsPerApp {
        CMsgSystemPerfSettingsPerApp::new()
    }

    fn clear(&mut self) {
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
        self.fps_limit = ::std::option::Option::None;
        self.is_variable_resolution_enabled = ::std::option::Option::None;
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
        self.tdp_limit = ::std::option::Option::None;
        self.cpu_governor = ::std::option::Option::None;
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
        self.scaling_filter = ::std::option::Option::None;
        self.fsr_sharpness = ::std::option::Option::None;
        self.is_fps_limit_enabled = ::std::option::Option::None;
        self.is_tdp_limit_enabled = ::std::option::Option::None;
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
        self.display_refresh_manual_hz = ::std::option::Option::None;
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
        self.gpu_performance_level = ::std::option::Option::None;
        self.nis_sharpness = ::std::option::Option::None;
        self.display_external_refresh_manual_hz = ::std::option::Option::None;
        self.fps_limit_external = ::std::option::Option::None;
        self.is_tearing_enabled = ::std::option::Option::None;
        self.is_vrr_enabled = ::std::option::Option::None;
        self.is_composite_debug_enabled = ::std::option::Option::None;
        self.force_composite = ::std::option::Option::None;
        self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::None;
        self.split_scaling_filter = ::std::option::Option::None;
        self.split_scaling_scaler = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettingsPerApp {
        static instance: CMsgSystemPerfSettingsPerApp = CMsgSystemPerfSettingsPerApp {
            gpu_performance_manual_mhz: ::std::option::Option::None,
            fps_limit: ::std::option::Option::None,
            is_variable_resolution_enabled: ::std::option::Option::None,
            is_dynamic_refresh_rate_enabled: ::std::option::Option::None,
            tdp_limit: ::std::option::Option::None,
            cpu_governor: ::std::option::Option::None,
            cpu_governor_manual_mhz: ::std::option::Option::None,
            scaling_filter: ::std::option::Option::None,
            fsr_sharpness: ::std::option::Option::None,
            is_fps_limit_enabled: ::std::option::Option::None,
            is_tdp_limit_enabled: ::std::option::Option::None,
            is_low_latency_mode_enabled: ::std::option::Option::None,
            display_refresh_manual_hz: ::std::option::Option::None,
            is_game_perf_profile_enabled: ::std::option::Option::None,
            gpu_performance_level: ::std::option::Option::None,
            nis_sharpness: ::std::option::Option::None,
            display_external_refresh_manual_hz: ::std::option::Option::None,
            fps_limit_external: ::std::option::Option::None,
            is_tearing_enabled: ::std::option::Option::None,
            is_vrr_enabled: ::std::option::Option::None,
            is_composite_debug_enabled: ::std::option::Option::None,
            force_composite: ::std::option::Option::None,
            use_dynamic_refresh_rate_in_steam: ::std::option::Option::None,
            split_scaling_filter: ::std::option::Option::None,
            split_scaling_scaler: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfSettingsPerApp {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfSettingsPerApp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfSettingsPerApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfSettingsPerApp {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettings.global)
    pub global: crate::MessageField<CMsgSystemPerfSettingsGlobal>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettings.per_app)
    pub per_app: crate::MessageField<CMsgSystemPerfSettingsPerApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettings.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettings {
    fn default() -> &'a CMsgSystemPerfSettings {
        <CMsgSystemPerfSettings as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettings {
    pub fn new() -> CMsgSystemPerfSettings {
        ::std::default::Default::default()
    }

    // optional .CMsgSystemPerfSettingsGlobal global = 1;

    pub fn global(&self) -> &CMsgSystemPerfSettingsGlobal {
        self.global.as_ref().unwrap_or_else(|| <CMsgSystemPerfSettingsGlobal as crate::Message>::default_instance())
    }

    pub fn clear_global(&mut self) {
        self.global.clear();
    }

    pub fn has_global(&self) -> bool {
        self.global.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global(&mut self, v: CMsgSystemPerfSettingsGlobal) {
        self.global = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global(&mut self) -> &mut CMsgSystemPerfSettingsGlobal {
        self.global.mut_or_insert_default()
    }

    // Take field
    pub fn take_global(&mut self) -> CMsgSystemPerfSettingsGlobal {
        self.global.take().unwrap_or_else(|| CMsgSystemPerfSettingsGlobal::new())
    }

    // optional .CMsgSystemPerfSettingsPerApp per_app = 2;

    pub fn per_app(&self) -> &CMsgSystemPerfSettingsPerApp {
        self.per_app.as_ref().unwrap_or_else(|| <CMsgSystemPerfSettingsPerApp as crate::Message>::default_instance())
    }

    pub fn clear_per_app(&mut self) {
        self.per_app.clear();
    }

    pub fn has_per_app(&self) -> bool {
        self.per_app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_app(&mut self, v: CMsgSystemPerfSettingsPerApp) {
        self.per_app = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_app(&mut self) -> &mut CMsgSystemPerfSettingsPerApp {
        self.per_app.mut_or_insert_default()
    }

    // Take field
    pub fn take_per_app(&mut self) -> CMsgSystemPerfSettingsPerApp {
        self.per_app.take().unwrap_or_else(|| CMsgSystemPerfSettingsPerApp::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemPerfSettingsGlobal>(
            "global",
            |m: &CMsgSystemPerfSettings| { &m.global },
            |m: &mut CMsgSystemPerfSettings| { &mut m.global },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemPerfSettingsPerApp>(
            "per_app",
            |m: &CMsgSystemPerfSettings| { &m.per_app },
            |m: &mut CMsgSystemPerfSettings| { &mut m.per_app },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfSettings>(
            "CMsgSystemPerfSettings",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfSettings {
    const NAME: &'static str = "CMsgSystemPerfSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.global)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.per_app)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.global.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.per_app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.global.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.per_app.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettings {
        CMsgSystemPerfSettings::new()
    }

    fn clear(&mut self) {
        self.global.clear();
        self.per_app.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettings {
        static instance: CMsgSystemPerfSettings = CMsgSystemPerfSettings {
            global: crate::MessageField::none(),
            per_app: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfSettings {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfSettings {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettingsV1)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettingsV1 {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.diagnostic_update_rate)
    pub diagnostic_update_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.system_trace_service_state)
    pub system_trace_service_state: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.graphics_profiling_service_state)
    pub graphics_profiling_service_state: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.perf_overlay_service_state)
    pub perf_overlay_service_state: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.perf_overlay_level)
    pub perf_overlay_level: ::std::option::Option<crate::EnumOrUnknown<super::enums::EGraphicsPerfOverlayLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.gpu_performance_level)
    pub gpu_performance_level: ::std::option::Option<crate::EnumOrUnknown<super::enums::EGPUPerformanceLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.gpu_performance_manual_mhz)
    pub gpu_performance_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.fps_limit)
    pub fps_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_variable_resolution_enabled)
    pub is_variable_resolution_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_dynamic_refresh_rate_enabled)
    pub is_dynamic_refresh_rate_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.tdp_limit)
    pub tdp_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.cpu_governor)
    pub cpu_governor: ::std::option::Option<crate::EnumOrUnknown<super::enums::ECPUGovernor>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.cpu_governor_manual_mhz)
    pub cpu_governor_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.scaling_filter)
    pub scaling_filter: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.fsr_sharpness)
    pub fsr_sharpness: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_fps_limit_enabled)
    pub is_fps_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_tdp_limit_enabled)
    pub is_tdp_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_show_perf_overlay_over_steam_enabled)
    pub is_show_perf_overlay_over_steam_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_low_latency_mode_enabled)
    pub is_low_latency_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.display_refresh_manual_hz)
    pub display_refresh_manual_hz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_game_perf_profile_enabled)
    pub is_game_perf_profile_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettingsV1.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettingsV1 {
    fn default() -> &'a CMsgSystemPerfSettingsV1 {
        <CMsgSystemPerfSettingsV1 as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettingsV1 {
    pub fn new() -> CMsgSystemPerfSettingsV1 {
        ::std::default::Default::default()
    }

    // optional float diagnostic_update_rate = 1;

    pub fn diagnostic_update_rate(&self) -> f32 {
        self.diagnostic_update_rate.unwrap_or(0.)
    }

    pub fn clear_diagnostic_update_rate(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
    }

    pub fn has_diagnostic_update_rate(&self) -> bool {
        self.diagnostic_update_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic_update_rate(&mut self, v: f32) {
        self.diagnostic_update_rate = ::std::option::Option::Some(v);
    }

    // optional .ESystemServiceState system_trace_service_state = 2;

    pub fn system_trace_service_state(&self) -> super::enums::ESystemServiceState {
        match self.system_trace_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_system_trace_service_state(&mut self) {
        self.system_trace_service_state = ::std::option::Option::None;
    }

    pub fn has_system_trace_service_state(&self) -> bool {
        self.system_trace_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_trace_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.system_trace_service_state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState graphics_profiling_service_state = 3;

    pub fn graphics_profiling_service_state(&self) -> super::enums::ESystemServiceState {
        match self.graphics_profiling_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_graphics_profiling_service_state(&mut self) {
        self.graphics_profiling_service_state = ::std::option::Option::None;
    }

    pub fn has_graphics_profiling_service_state(&self) -> bool {
        self.graphics_profiling_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graphics_profiling_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.graphics_profiling_service_state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState perf_overlay_service_state = 4;

    pub fn perf_overlay_service_state(&self) -> super::enums::ESystemServiceState {
        match self.perf_overlay_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_perf_overlay_service_state(&mut self) {
        self.perf_overlay_service_state = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_service_state(&self) -> bool {
        self.perf_overlay_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.perf_overlay_service_state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5;

    pub fn perf_overlay_level(&self) -> super::enums::EGraphicsPerfOverlayLevel {
        match self.perf_overlay_level {
            Some(e) => e.enum_value_or(super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            None => super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden,
        }
    }

    pub fn clear_perf_overlay_level(&mut self) {
        self.perf_overlay_level = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_level(&self) -> bool {
        self.perf_overlay_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_level(&mut self, v: super::enums::EGraphicsPerfOverlayLevel) {
        self.perf_overlay_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EGPUPerformanceLevel gpu_performance_level = 6;

    pub fn gpu_performance_level(&self) -> super::enums::EGPUPerformanceLevel {
        match self.gpu_performance_level {
            Some(e) => e.enum_value_or(super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            None => super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid,
        }
    }

    pub fn clear_gpu_performance_level(&mut self) {
        self.gpu_performance_level = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_level(&self) -> bool {
        self.gpu_performance_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_level(&mut self, v: super::enums::EGPUPerformanceLevel) {
        self.gpu_performance_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 gpu_performance_manual_mhz = 7;

    pub fn gpu_performance_manual_mhz(&self) -> i32 {
        self.gpu_performance_manual_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_mhz(&mut self) {
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_mhz(&self) -> bool {
        self.gpu_performance_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 fps_limit = 8;

    pub fn fps_limit(&self) -> i32 {
        self.fps_limit.unwrap_or(0)
    }

    pub fn clear_fps_limit(&mut self) {
        self.fps_limit = ::std::option::Option::None;
    }

    pub fn has_fps_limit(&self) -> bool {
        self.fps_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_limit(&mut self, v: i32) {
        self.fps_limit = ::std::option::Option::Some(v);
    }

    // optional bool is_variable_resolution_enabled = 9;

    pub fn is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.unwrap_or(false)
    }

    pub fn clear_is_variable_resolution_enabled(&mut self) {
        self.is_variable_resolution_enabled = ::std::option::Option::None;
    }

    pub fn has_is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_variable_resolution_enabled(&mut self, v: bool) {
        self.is_variable_resolution_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_refresh_rate_enabled = 10;

    pub fn is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.unwrap_or(false)
    }

    pub fn clear_is_dynamic_refresh_rate_enabled(&mut self) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_refresh_rate_enabled(&mut self, v: bool) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 tdp_limit = 11;

    pub fn tdp_limit(&self) -> i32 {
        self.tdp_limit.unwrap_or(0)
    }

    pub fn clear_tdp_limit(&mut self) {
        self.tdp_limit = ::std::option::Option::None;
    }

    pub fn has_tdp_limit(&self) -> bool {
        self.tdp_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit(&mut self, v: i32) {
        self.tdp_limit = ::std::option::Option::Some(v);
    }

    // optional .ECPUGovernor cpu_governor = 12;

    pub fn cpu_governor(&self) -> super::enums::ECPUGovernor {
        match self.cpu_governor {
            Some(e) => e.enum_value_or(super::enums::ECPUGovernor::k_ECPUGovernor_Invalid),
            None => super::enums::ECPUGovernor::k_ECPUGovernor_Invalid,
        }
    }

    pub fn clear_cpu_governor(&mut self) {
        self.cpu_governor = ::std::option::Option::None;
    }

    pub fn has_cpu_governor(&self) -> bool {
        self.cpu_governor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor(&mut self, v: super::enums::ECPUGovernor) {
        self.cpu_governor = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 cpu_governor_manual_mhz = 13;

    pub fn cpu_governor_manual_mhz(&self) -> i32 {
        self.cpu_governor_manual_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_mhz(&mut self) {
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_mhz(&self) -> bool {
        self.cpu_governor_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 scaling_filter = 14;

    pub fn scaling_filter(&self) -> i32 {
        self.scaling_filter.unwrap_or(0)
    }

    pub fn clear_scaling_filter(&mut self) {
        self.scaling_filter = ::std::option::Option::None;
    }

    pub fn has_scaling_filter(&self) -> bool {
        self.scaling_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaling_filter(&mut self, v: i32) {
        self.scaling_filter = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness = 15;

    pub fn fsr_sharpness(&self) -> i32 {
        self.fsr_sharpness.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness(&mut self) {
        self.fsr_sharpness = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness(&self) -> bool {
        self.fsr_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness(&mut self, v: i32) {
        self.fsr_sharpness = ::std::option::Option::Some(v);
    }

    // optional bool is_fps_limit_enabled = 16;

    pub fn is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_fps_limit_enabled(&mut self) {
        self.is_fps_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fps_limit_enabled(&mut self, v: bool) {
        self.is_fps_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_tdp_limit_enabled = 17;

    pub fn is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_tdp_limit_enabled(&mut self) {
        self.is_tdp_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tdp_limit_enabled(&mut self, v: bool) {
        self.is_tdp_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_show_perf_overlay_over_steam_enabled = 18;

    pub fn is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.unwrap_or(false)
    }

    pub fn clear_is_show_perf_overlay_over_steam_enabled(&mut self) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
    }

    pub fn has_is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_show_perf_overlay_over_steam_enabled(&mut self, v: bool) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_low_latency_mode_enabled = 19;

    pub fn is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.unwrap_or(false)
    }

    pub fn clear_is_low_latency_mode_enabled(&mut self) {
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_low_latency_mode_enabled(&mut self, v: bool) {
        self.is_low_latency_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz = 20;

    pub fn display_refresh_manual_hz(&self) -> i32 {
        self.display_refresh_manual_hz.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz(&mut self) {
        self.display_refresh_manual_hz = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz(&self) -> bool {
        self.display_refresh_manual_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz(&mut self, v: i32) {
        self.display_refresh_manual_hz = ::std::option::Option::Some(v);
    }

    // optional bool is_game_perf_profile_enabled = 21;

    pub fn is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.unwrap_or(false)
    }

    pub fn clear_is_game_perf_profile_enabled(&mut self) {
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
    }

    pub fn has_is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_game_perf_profile_enabled(&mut self, v: bool) {
        self.is_game_perf_profile_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic_update_rate",
            |m: &CMsgSystemPerfSettingsV1| { &m.diagnostic_update_rate },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.diagnostic_update_rate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_trace_service_state",
            |m: &CMsgSystemPerfSettingsV1| { &m.system_trace_service_state },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.system_trace_service_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "graphics_profiling_service_state",
            |m: &CMsgSystemPerfSettingsV1| { &m.graphics_profiling_service_state },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.graphics_profiling_service_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "perf_overlay_service_state",
            |m: &CMsgSystemPerfSettingsV1| { &m.perf_overlay_service_state },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.perf_overlay_service_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "perf_overlay_level",
            |m: &CMsgSystemPerfSettingsV1| { &m.perf_overlay_level },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.perf_overlay_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_performance_level",
            |m: &CMsgSystemPerfSettingsV1| { &m.gpu_performance_level },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.gpu_performance_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_performance_manual_mhz",
            |m: &CMsgSystemPerfSettingsV1| { &m.gpu_performance_manual_mhz },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.gpu_performance_manual_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fps_limit",
            |m: &CMsgSystemPerfSettingsV1| { &m.fps_limit },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.fps_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_variable_resolution_enabled",
            |m: &CMsgSystemPerfSettingsV1| { &m.is_variable_resolution_enabled },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.is_variable_resolution_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dynamic_refresh_rate_enabled",
            |m: &CMsgSystemPerfSettingsV1| { &m.is_dynamic_refresh_rate_enabled },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.is_dynamic_refresh_rate_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tdp_limit",
            |m: &CMsgSystemPerfSettingsV1| { &m.tdp_limit },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.tdp_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_governor",
            |m: &CMsgSystemPerfSettingsV1| { &m.cpu_governor },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.cpu_governor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_governor_manual_mhz",
            |m: &CMsgSystemPerfSettingsV1| { &m.cpu_governor_manual_mhz },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.cpu_governor_manual_mhz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scaling_filter",
            |m: &CMsgSystemPerfSettingsV1| { &m.scaling_filter },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.scaling_filter },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsr_sharpness",
            |m: &CMsgSystemPerfSettingsV1| { &m.fsr_sharpness },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.fsr_sharpness },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_fps_limit_enabled",
            |m: &CMsgSystemPerfSettingsV1| { &m.is_fps_limit_enabled },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.is_fps_limit_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_tdp_limit_enabled",
            |m: &CMsgSystemPerfSettingsV1| { &m.is_tdp_limit_enabled },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.is_tdp_limit_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_show_perf_overlay_over_steam_enabled",
            |m: &CMsgSystemPerfSettingsV1| { &m.is_show_perf_overlay_over_steam_enabled },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.is_show_perf_overlay_over_steam_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_low_latency_mode_enabled",
            |m: &CMsgSystemPerfSettingsV1| { &m.is_low_latency_mode_enabled },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.is_low_latency_mode_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_refresh_manual_hz",
            |m: &CMsgSystemPerfSettingsV1| { &m.display_refresh_manual_hz },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.display_refresh_manual_hz },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_game_perf_profile_enabled",
            |m: &CMsgSystemPerfSettingsV1| { &m.is_game_perf_profile_enabled },
            |m: &mut CMsgSystemPerfSettingsV1| { &mut m.is_game_perf_profile_enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfSettingsV1>(
            "CMsgSystemPerfSettingsV1",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfSettingsV1 {
    const NAME: &'static str = "CMsgSystemPerfSettingsV1";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.diagnostic_update_rate = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.system_trace_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.graphics_profiling_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.perf_overlay_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.perf_overlay_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.gpu_performance_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.gpu_performance_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.fps_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.is_variable_resolution_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.tdp_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.cpu_governor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.cpu_governor_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.scaling_filter = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.fsr_sharpness = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.is_fps_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_tdp_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.is_low_latency_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.display_refresh_manual_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                168 => {
                    self.is_game_perf_profile_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diagnostic_update_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.system_trace_service_state {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.graphics_profiling_service_state {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.perf_overlay_service_state {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.perf_overlay_level {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.gpu_performance_level {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.gpu_performance_manual_mhz {
            my_size += crate::rt::int32_size(7, v);
        }
        if let Some(v) = self.fps_limit {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tdp_limit {
            my_size += crate::rt::int32_size(11, v);
        }
        if let Some(v) = self.cpu_governor {
            my_size += crate::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            my_size += crate::rt::int32_size(13, v);
        }
        if let Some(v) = self.scaling_filter {
            my_size += crate::rt::int32_size(14, v);
        }
        if let Some(v) = self.fsr_sharpness {
            my_size += crate::rt::int32_size(15, v);
        }
        if let Some(v) = self.is_fps_limit_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            my_size += crate::rt::int32_size(20, v);
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.diagnostic_update_rate {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.system_trace_service_state {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.graphics_profiling_service_state {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_service_state {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_level {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gpu_performance_level {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gpu_performance_manual_mhz {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.fps_limit {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.tdp_limit {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.cpu_governor {
            os.write_enum(12, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.scaling_filter {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.fsr_sharpness {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.is_fps_limit_enabled {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            os.write_bool(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettingsV1 {
        CMsgSystemPerfSettingsV1::new()
    }

    fn clear(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
        self.system_trace_service_state = ::std::option::Option::None;
        self.graphics_profiling_service_state = ::std::option::Option::None;
        self.perf_overlay_service_state = ::std::option::Option::None;
        self.perf_overlay_level = ::std::option::Option::None;
        self.gpu_performance_level = ::std::option::Option::None;
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
        self.fps_limit = ::std::option::Option::None;
        self.is_variable_resolution_enabled = ::std::option::Option::None;
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
        self.tdp_limit = ::std::option::Option::None;
        self.cpu_governor = ::std::option::Option::None;
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
        self.scaling_filter = ::std::option::Option::None;
        self.fsr_sharpness = ::std::option::Option::None;
        self.is_fps_limit_enabled = ::std::option::Option::None;
        self.is_tdp_limit_enabled = ::std::option::Option::None;
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
        self.display_refresh_manual_hz = ::std::option::Option::None;
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettingsV1 {
        static instance: CMsgSystemPerfSettingsV1 = CMsgSystemPerfSettingsV1 {
            diagnostic_update_rate: ::std::option::Option::None,
            system_trace_service_state: ::std::option::Option::None,
            graphics_profiling_service_state: ::std::option::Option::None,
            perf_overlay_service_state: ::std::option::Option::None,
            perf_overlay_level: ::std::option::Option::None,
            gpu_performance_level: ::std::option::Option::None,
            gpu_performance_manual_mhz: ::std::option::Option::None,
            fps_limit: ::std::option::Option::None,
            is_variable_resolution_enabled: ::std::option::Option::None,
            is_dynamic_refresh_rate_enabled: ::std::option::Option::None,
            tdp_limit: ::std::option::Option::None,
            cpu_governor: ::std::option::Option::None,
            cpu_governor_manual_mhz: ::std::option::Option::None,
            scaling_filter: ::std::option::Option::None,
            fsr_sharpness: ::std::option::Option::None,
            is_fps_limit_enabled: ::std::option::Option::None,
            is_tdp_limit_enabled: ::std::option::Option::None,
            is_show_perf_overlay_over_steam_enabled: ::std::option::Option::None,
            is_low_latency_mode_enabled: ::std::option::Option::None,
            display_refresh_manual_hz: ::std::option::Option::None,
            is_game_perf_profile_enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfSettingsV1 {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfSettingsV1").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfSettingsV1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfSettingsV1 {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfState.limits)
    pub limits: crate::MessageField<CMsgSystemPerfLimits>,
    // @@protoc_insertion_point(field:CMsgSystemPerfState.settings)
    pub settings: crate::MessageField<CMsgSystemPerfSettings>,
    // @@protoc_insertion_point(field:CMsgSystemPerfState.current_game_id)
    pub current_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfState.active_profile_game_id)
    pub active_profile_game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfState {
    fn default() -> &'a CMsgSystemPerfState {
        <CMsgSystemPerfState as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfState {
    pub fn new() -> CMsgSystemPerfState {
        ::std::default::Default::default()
    }

    // optional .CMsgSystemPerfLimits limits = 1;

    pub fn limits(&self) -> &CMsgSystemPerfLimits {
        self.limits.as_ref().unwrap_or_else(|| <CMsgSystemPerfLimits as crate::Message>::default_instance())
    }

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    pub fn has_limits(&self) -> bool {
        self.limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: CMsgSystemPerfLimits) {
        self.limits = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limits(&mut self) -> &mut CMsgSystemPerfLimits {
        self.limits.mut_or_insert_default()
    }

    // Take field
    pub fn take_limits(&mut self) -> CMsgSystemPerfLimits {
        self.limits.take().unwrap_or_else(|| CMsgSystemPerfLimits::new())
    }

    // optional .CMsgSystemPerfSettings settings = 2;

    pub fn settings(&self) -> &CMsgSystemPerfSettings {
        self.settings.as_ref().unwrap_or_else(|| <CMsgSystemPerfSettings as crate::Message>::default_instance())
    }

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    pub fn has_settings(&self) -> bool {
        self.settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: CMsgSystemPerfSettings) {
        self.settings = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut CMsgSystemPerfSettings {
        self.settings.mut_or_insert_default()
    }

    // Take field
    pub fn take_settings(&mut self) -> CMsgSystemPerfSettings {
        self.settings.take().unwrap_or_else(|| CMsgSystemPerfSettings::new())
    }

    // optional uint64 current_game_id = 3;

    pub fn current_game_id(&self) -> u64 {
        self.current_game_id.unwrap_or(0)
    }

    pub fn clear_current_game_id(&mut self) {
        self.current_game_id = ::std::option::Option::None;
    }

    pub fn has_current_game_id(&self) -> bool {
        self.current_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_game_id(&mut self, v: u64) {
        self.current_game_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_profile_game_id = 4;

    pub fn active_profile_game_id(&self) -> u64 {
        self.active_profile_game_id.unwrap_or(0)
    }

    pub fn clear_active_profile_game_id(&mut self) {
        self.active_profile_game_id = ::std::option::Option::None;
    }

    pub fn has_active_profile_game_id(&self) -> bool {
        self.active_profile_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_profile_game_id(&mut self, v: u64) {
        self.active_profile_game_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemPerfLimits>(
            "limits",
            |m: &CMsgSystemPerfState| { &m.limits },
            |m: &mut CMsgSystemPerfState| { &mut m.limits },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemPerfSettings>(
            "settings",
            |m: &CMsgSystemPerfState| { &m.settings },
            |m: &mut CMsgSystemPerfState| { &mut m.settings },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_game_id",
            |m: &CMsgSystemPerfState| { &m.current_game_id },
            |m: &mut CMsgSystemPerfState| { &mut m.current_game_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_profile_game_id",
            |m: &CMsgSystemPerfState| { &m.active_profile_game_id },
            |m: &mut CMsgSystemPerfState| { &mut m.active_profile_game_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfState>(
            "CMsgSystemPerfState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfState {
    const NAME: &'static str = "CMsgSystemPerfState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.limits)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                24 => {
                    self.current_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.active_profile_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_game_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.active_profile_game_id {
            my_size += crate::rt::uint64_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.limits.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.settings.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.current_game_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.active_profile_game_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfState {
        CMsgSystemPerfState::new()
    }

    fn clear(&mut self) {
        self.limits.clear();
        self.settings.clear();
        self.current_game_id = ::std::option::Option::None;
        self.active_profile_game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfState {
        static instance: CMsgSystemPerfState = CMsgSystemPerfState {
            limits: crate::MessageField::none(),
            settings: crate::MessageField::none(),
            current_game_id: ::std::option::Option::None,
            active_profile_game_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemPerfUpdateSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfUpdateSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfUpdateSettings.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfUpdateSettings.skip_storage_update)
    pub skip_storage_update: ::std::option::Option<bool>,
    // message oneof groups
    pub update: ::std::option::Option<cmsg_system_perf_update_settings::Update>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfUpdateSettings.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfUpdateSettings {
    fn default() -> &'a CMsgSystemPerfUpdateSettings {
        <CMsgSystemPerfUpdateSettings as crate::Message>::default_instance()
    }
}

impl CMsgSystemPerfUpdateSettings {
    pub fn new() -> CMsgSystemPerfUpdateSettings {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional bool skip_storage_update = 4;

    pub fn skip_storage_update(&self) -> bool {
        self.skip_storage_update.unwrap_or(false)
    }

    pub fn clear_skip_storage_update(&mut self) {
        self.skip_storage_update = ::std::option::Option::None;
    }

    pub fn has_skip_storage_update(&self) -> bool {
        self.skip_storage_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_storage_update(&mut self, v: bool) {
        self.skip_storage_update = ::std::option::Option::Some(v);
    }

    // optional bool reset_to_default = 2;

    pub fn reset_to_default(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(v)) => v,
            _ => false,
        }
    }

    pub fn clear_reset_to_default(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_reset_to_default(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reset_to_default(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(v))
    }

    // optional .CMsgSystemPerfSettings settings_delta = 3;

    pub fn settings_delta(&self) -> &CMsgSystemPerfSettings {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(ref v)) => v,
            _ => <CMsgSystemPerfSettings as crate::Message>::default_instance(),
        }
    }

    pub fn clear_settings_delta(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_settings_delta(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_settings_delta(&mut self, v: CMsgSystemPerfSettings) {
        self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(v))
    }

    // Mutable pointer to the field.
    pub fn mut_settings_delta(&mut self) -> &mut CMsgSystemPerfSettings {
        if let ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(CMsgSystemPerfSettings::new()));
        }
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_settings_delta(&mut self) -> CMsgSystemPerfSettings {
        if self.has_settings_delta() {
            match self.update.take() {
                ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgSystemPerfSettings::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgSystemPerfUpdateSettings| { &m.gameid },
            |m: &mut CMsgSystemPerfUpdateSettings| { &mut m.gameid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_storage_update",
            |m: &CMsgSystemPerfUpdateSettings| { &m.skip_storage_update },
            |m: &mut CMsgSystemPerfUpdateSettings| { &mut m.skip_storage_update },
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "reset_to_default",
            CMsgSystemPerfUpdateSettings::has_reset_to_default,
            CMsgSystemPerfUpdateSettings::reset_to_default,
            CMsgSystemPerfUpdateSettings::set_reset_to_default,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CMsgSystemPerfSettings>(
            "settings_delta",
            CMsgSystemPerfUpdateSettings::has_settings_delta,
            CMsgSystemPerfUpdateSettings::settings_delta,
            CMsgSystemPerfUpdateSettings::mut_settings_delta,
            CMsgSystemPerfUpdateSettings::set_settings_delta,
        ));
        oneofs.push(cmsg_system_perf_update_settings::Update::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemPerfUpdateSettings>(
            "CMsgSystemPerfUpdateSettings",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemPerfUpdateSettings {
    const NAME: &'static str = "CMsgSystemPerfUpdateSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.skip_storage_update = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(is.read_bool()?));
                },
                26 => {
                    self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(is.read_message()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.skip_storage_update {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &cmsg_system_perf_update_settings::Update::ResetToDefault(v) => {
                    my_size += 1 + 1;
                },
                &cmsg_system_perf_update_settings::Update::SettingsDelta(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.skip_storage_update {
            os.write_bool(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &cmsg_system_perf_update_settings::Update::ResetToDefault(v) => {
                    os.write_bool(2, v)?;
                },
                &cmsg_system_perf_update_settings::Update::SettingsDelta(ref v) => {
                    crate::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfUpdateSettings {
        CMsgSystemPerfUpdateSettings::new()
    }

    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.skip_storage_update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfUpdateSettings {
        static instance: CMsgSystemPerfUpdateSettings = CMsgSystemPerfUpdateSettings {
            gameid: ::std::option::Option::None,
            skip_storage_update: ::std::option::Option::None,
            update: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemPerfUpdateSettings {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemPerfUpdateSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemPerfUpdateSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemPerfUpdateSettings {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSystemPerfUpdateSettings`
pub mod cmsg_system_perf_update_settings {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgSystemPerfUpdateSettings.update)
    pub enum Update {
        // @@protoc_insertion_point(oneof_field:CMsgSystemPerfUpdateSettings.reset_to_default)
        ResetToDefault(bool),
        // @@protoc_insertion_point(oneof_field:CMsgSystemPerfUpdateSettings.settings_delta)
        SettingsDelta(super::CMsgSystemPerfSettings),
    }

    impl crate::Oneof for Update {
    }

    impl crate::OneofFull for Update {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::CMsgSystemPerfUpdateSettings as crate::MessageFull>::descriptor().oneof_by_name("update").unwrap()).clone()
        }
    }

    impl Update {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Update>("update")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSystemDockUpdateState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDockUpdateState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.state)
    pub state: ::std::option::Option<crate::EnumOrUnknown<super::enums::EUpdaterState>>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.rtime_last_checked)
    pub rtime_last_checked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.version_current)
    pub version_current: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.version_available)
    pub version_available: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.stage_progress)
    pub stage_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.rtime_estimated_completion)
    pub rtime_estimated_completion: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.old_fw_workaround)
    pub old_fw_workaround: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDockUpdateState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDockUpdateState {
    fn default() -> &'a CMsgSystemDockUpdateState {
        <CMsgSystemDockUpdateState as crate::Message>::default_instance()
    }
}

impl CMsgSystemDockUpdateState {
    pub fn new() -> CMsgSystemDockUpdateState {
        ::std::default::Default::default()
    }

    // optional .EUpdaterState state = 1;

    pub fn state(&self) -> super::enums::EUpdaterState {
        match self.state {
            Some(e) => e.enum_value_or(super::enums::EUpdaterState::k_EUpdaterState_Invalid),
            None => super::enums::EUpdaterState::k_EUpdaterState_Invalid,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::enums::EUpdaterState) {
        self.state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional fixed32 rtime_last_checked = 2;

    pub fn rtime_last_checked(&self) -> u32 {
        self.rtime_last_checked.unwrap_or(0)
    }

    pub fn clear_rtime_last_checked(&mut self) {
        self.rtime_last_checked = ::std::option::Option::None;
    }

    pub fn has_rtime_last_checked(&self) -> bool {
        self.rtime_last_checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_last_checked(&mut self, v: u32) {
        self.rtime_last_checked = ::std::option::Option::Some(v);
    }

    // optional string version_current = 3;

    pub fn version_current(&self) -> &str {
        match self.version_current.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_current(&mut self) {
        self.version_current = ::std::option::Option::None;
    }

    pub fn has_version_current(&self) -> bool {
        self.version_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_current(&mut self, v: ::std::string::String) {
        self.version_current = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_current(&mut self) -> &mut ::std::string::String {
        if self.version_current.is_none() {
            self.version_current = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_current.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_current(&mut self) -> ::std::string::String {
        self.version_current.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version_available = 4;

    pub fn version_available(&self) -> &str {
        match self.version_available.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_available(&mut self) {
        self.version_available = ::std::option::Option::None;
    }

    pub fn has_version_available(&self) -> bool {
        self.version_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_available(&mut self, v: ::std::string::String) {
        self.version_available = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_available(&mut self) -> &mut ::std::string::String {
        if self.version_available.is_none() {
            self.version_available = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_available.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_available(&mut self) -> ::std::string::String {
        self.version_available.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float stage_progress = 5;

    pub fn stage_progress(&self) -> f32 {
        self.stage_progress.unwrap_or(0.)
    }

    pub fn clear_stage_progress(&mut self) {
        self.stage_progress = ::std::option::Option::None;
    }

    pub fn has_stage_progress(&self) -> bool {
        self.stage_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage_progress(&mut self, v: f32) {
        self.stage_progress = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_estimated_completion = 6;

    pub fn rtime_estimated_completion(&self) -> u32 {
        self.rtime_estimated_completion.unwrap_or(0)
    }

    pub fn clear_rtime_estimated_completion(&mut self) {
        self.rtime_estimated_completion = ::std::option::Option::None;
    }

    pub fn has_rtime_estimated_completion(&self) -> bool {
        self.rtime_estimated_completion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_estimated_completion(&mut self, v: u32) {
        self.rtime_estimated_completion = ::std::option::Option::Some(v);
    }

    // optional int32 old_fw_workaround = 7;

    pub fn old_fw_workaround(&self) -> i32 {
        self.old_fw_workaround.unwrap_or(0)
    }

    pub fn clear_old_fw_workaround(&mut self) {
        self.old_fw_workaround = ::std::option::Option::None;
    }

    pub fn has_old_fw_workaround(&self) -> bool {
        self.old_fw_workaround.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_fw_workaround(&mut self, v: i32) {
        self.old_fw_workaround = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CMsgSystemDockUpdateState| { &m.state },
            |m: &mut CMsgSystemDockUpdateState| { &mut m.state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_last_checked",
            |m: &CMsgSystemDockUpdateState| { &m.rtime_last_checked },
            |m: &mut CMsgSystemDockUpdateState| { &mut m.rtime_last_checked },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_current",
            |m: &CMsgSystemDockUpdateState| { &m.version_current },
            |m: &mut CMsgSystemDockUpdateState| { &mut m.version_current },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_available",
            |m: &CMsgSystemDockUpdateState| { &m.version_available },
            |m: &mut CMsgSystemDockUpdateState| { &mut m.version_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stage_progress",
            |m: &CMsgSystemDockUpdateState| { &m.stage_progress },
            |m: &mut CMsgSystemDockUpdateState| { &mut m.stage_progress },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_estimated_completion",
            |m: &CMsgSystemDockUpdateState| { &m.rtime_estimated_completion },
            |m: &mut CMsgSystemDockUpdateState| { &mut m.rtime_estimated_completion },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "old_fw_workaround",
            |m: &CMsgSystemDockUpdateState| { &m.old_fw_workaround },
            |m: &mut CMsgSystemDockUpdateState| { &mut m.old_fw_workaround },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemDockUpdateState>(
            "CMsgSystemDockUpdateState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemDockUpdateState {
    const NAME: &'static str = "CMsgSystemDockUpdateState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.rtime_last_checked = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.version_current = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.version_available = ::std::option::Option::Some(is.read_string()?);
                },
                45 => {
                    self.stage_progress = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.rtime_estimated_completion = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.old_fw_workaround = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.rtime_last_checked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.version_current.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.version_available.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.stage_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rtime_estimated_completion {
            my_size += 1 + 4;
        }
        if let Some(v) = self.old_fw_workaround {
            my_size += crate::rt::int32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rtime_last_checked {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.version_current.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.version_available.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.stage_progress {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.rtime_estimated_completion {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.old_fw_workaround {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDockUpdateState {
        CMsgSystemDockUpdateState::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.rtime_last_checked = ::std::option::Option::None;
        self.version_current = ::std::option::Option::None;
        self.version_available = ::std::option::Option::None;
        self.stage_progress = ::std::option::Option::None;
        self.rtime_estimated_completion = ::std::option::Option::None;
        self.old_fw_workaround = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDockUpdateState {
        static instance: CMsgSystemDockUpdateState = CMsgSystemDockUpdateState {
            state: ::std::option::Option::None,
            rtime_last_checked: ::std::option::Option::None,
            version_current: ::std::option::Option::None,
            version_available: ::std::option::Option::None,
            stage_progress: ::std::option::Option::None,
            rtime_estimated_completion: ::std::option::Option::None,
            old_fw_workaround: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemDockUpdateState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemDockUpdateState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemDockUpdateState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemDockUpdateState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemDockState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDockState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDockState.update_state)
    pub update_state: crate::MessageField<CMsgSystemDockUpdateState>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDockState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDockState {
    fn default() -> &'a CMsgSystemDockState {
        <CMsgSystemDockState as crate::Message>::default_instance()
    }
}

impl CMsgSystemDockState {
    pub fn new() -> CMsgSystemDockState {
        ::std::default::Default::default()
    }

    // optional .CMsgSystemDockUpdateState update_state = 1;

    pub fn update_state(&self) -> &CMsgSystemDockUpdateState {
        self.update_state.as_ref().unwrap_or_else(|| <CMsgSystemDockUpdateState as crate::Message>::default_instance())
    }

    pub fn clear_update_state(&mut self) {
        self.update_state.clear();
    }

    pub fn has_update_state(&self) -> bool {
        self.update_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_state(&mut self, v: CMsgSystemDockUpdateState) {
        self.update_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_state(&mut self) -> &mut CMsgSystemDockUpdateState {
        self.update_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_update_state(&mut self) -> CMsgSystemDockUpdateState {
        self.update_state.take().unwrap_or_else(|| CMsgSystemDockUpdateState::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemDockUpdateState>(
            "update_state",
            |m: &CMsgSystemDockState| { &m.update_state },
            |m: &mut CMsgSystemDockState| { &mut m.update_state },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemDockState>(
            "CMsgSystemDockState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemDockState {
    const NAME: &'static str = "CMsgSystemDockState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.update_state)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.update_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.update_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDockState {
        CMsgSystemDockState::new()
    }

    fn clear(&mut self) {
        self.update_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDockState {
        static instance: CMsgSystemDockState = CMsgSystemDockState {
            update_state: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemDockState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemDockState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemDockState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemDockState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemDockUpdateFirmware)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDockUpdateFirmware {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateFirmware.check_only)
    pub check_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDockUpdateFirmware.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDockUpdateFirmware {
    fn default() -> &'a CMsgSystemDockUpdateFirmware {
        <CMsgSystemDockUpdateFirmware as crate::Message>::default_instance()
    }
}

impl CMsgSystemDockUpdateFirmware {
    pub fn new() -> CMsgSystemDockUpdateFirmware {
        ::std::default::Default::default()
    }

    // optional bool check_only = 1;

    pub fn check_only(&self) -> bool {
        self.check_only.unwrap_or(false)
    }

    pub fn clear_check_only(&mut self) {
        self.check_only = ::std::option::Option::None;
    }

    pub fn has_check_only(&self) -> bool {
        self.check_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check_only(&mut self, v: bool) {
        self.check_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "check_only",
            |m: &CMsgSystemDockUpdateFirmware| { &m.check_only },
            |m: &mut CMsgSystemDockUpdateFirmware| { &mut m.check_only },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemDockUpdateFirmware>(
            "CMsgSystemDockUpdateFirmware",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemDockUpdateFirmware {
    const NAME: &'static str = "CMsgSystemDockUpdateFirmware";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.check_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.check_only {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.check_only {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDockUpdateFirmware {
        CMsgSystemDockUpdateFirmware::new()
    }

    fn clear(&mut self) {
        self.check_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDockUpdateFirmware {
        static instance: CMsgSystemDockUpdateFirmware = CMsgSystemDockUpdateFirmware {
            check_only: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemDockUpdateFirmware {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemDockUpdateFirmware").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemDockUpdateFirmware {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemDockUpdateFirmware {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioVolume)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioVolume {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioVolume.entries)
    pub entries: ::std::vec::Vec<cmsg_system_audio_volume::ChannelEntry>,
    // @@protoc_insertion_point(field:CMsgSystemAudioVolume.is_muted)
    pub is_muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioVolume.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioVolume {
    fn default() -> &'a CMsgSystemAudioVolume {
        <CMsgSystemAudioVolume as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioVolume {
    pub fn new() -> CMsgSystemAudioVolume {
        ::std::default::Default::default()
    }

    // repeated .CMsgSystemAudioVolume.ChannelEntry entries = 1;

    pub fn entries(&self) -> &[cmsg_system_audio_volume::ChannelEntry] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<cmsg_system_audio_volume::ChannelEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<cmsg_system_audio_volume::ChannelEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<cmsg_system_audio_volume::ChannelEntry> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    // optional bool is_muted = 2;

    pub fn is_muted(&self) -> bool {
        self.is_muted.unwrap_or(false)
    }

    pub fn clear_is_muted(&mut self) {
        self.is_muted = ::std::option::Option::None;
    }

    pub fn has_is_muted(&self) -> bool {
        self.is_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_muted(&mut self, v: bool) {
        self.is_muted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgSystemAudioVolume| { &m.entries },
            |m: &mut CMsgSystemAudioVolume| { &mut m.entries },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_muted",
            |m: &CMsgSystemAudioVolume| { &m.is_muted },
            |m: &mut CMsgSystemAudioVolume| { &mut m.is_muted },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioVolume>(
            "CMsgSystemAudioVolume",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioVolume {
    const NAME: &'static str = "CMsgSystemAudioVolume";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                16 => {
                    self.is_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_muted {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_muted {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioVolume {
        CMsgSystemAudioVolume::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.is_muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioVolume {
        static instance: CMsgSystemAudioVolume = CMsgSystemAudioVolume {
            entries: ::std::vec::Vec::new(),
            is_muted: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioVolume {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioVolume").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioVolume {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSystemAudioVolume`
pub mod cmsg_system_audio_volume {
    // @@protoc_insertion_point(message:CMsgSystemAudioVolume.ChannelEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChannelEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgSystemAudioVolume.ChannelEntry.echannel)
        pub echannel: ::std::option::Option<crate::EnumOrUnknown<super::super::enums::ESystemAudioChannel>>,
        // @@protoc_insertion_point(field:CMsgSystemAudioVolume.ChannelEntry.volume)
        pub volume: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSystemAudioVolume.ChannelEntry.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChannelEntry {
        fn default() -> &'a ChannelEntry {
            <ChannelEntry as crate::Message>::default_instance()
        }
    }

    impl ChannelEntry {
        pub fn new() -> ChannelEntry {
            ::std::default::Default::default()
        }

        // optional .ESystemAudioChannel echannel = 1;

        pub fn echannel(&self) -> super::super::enums::ESystemAudioChannel {
            match self.echannel {
                Some(e) => e.enum_value_or(super::super::enums::ESystemAudioChannel::k_SystemAudioChannel_Invalid),
                None => super::super::enums::ESystemAudioChannel::k_SystemAudioChannel_Invalid,
            }
        }

        pub fn clear_echannel(&mut self) {
            self.echannel = ::std::option::Option::None;
        }

        pub fn has_echannel(&self) -> bool {
            self.echannel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_echannel(&mut self, v: super::super::enums::ESystemAudioChannel) {
            self.echannel = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional float volume = 2;

        pub fn volume(&self) -> f32 {
            self.volume.unwrap_or(0.)
        }

        pub fn clear_volume(&mut self) {
            self.volume = ::std::option::Option::None;
        }

        pub fn has_volume(&self) -> bool {
            self.volume.is_some()
        }

        // Param is passed by value, moved
        pub fn set_volume(&mut self, v: f32) {
            self.volume = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "echannel",
                |m: &ChannelEntry| { &m.echannel },
                |m: &mut ChannelEntry| { &mut m.echannel },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "volume",
                |m: &ChannelEntry| { &m.volume },
                |m: &mut ChannelEntry| { &mut m.volume },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ChannelEntry>(
                "CMsgSystemAudioVolume.ChannelEntry",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ChannelEntry {
        const NAME: &'static str = "ChannelEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.echannel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    21 => {
                        self.volume = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.echannel {
                my_size += crate::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.volume {
                my_size += 1 + 4;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.echannel {
                os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.volume {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChannelEntry {
            ChannelEntry::new()
        }

        fn clear(&mut self) {
            self.echannel = ::std::option::Option::None;
            self.volume = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChannelEntry {
            static instance: ChannelEntry = ChannelEntry {
                echannel: ::std::option::Option::None,
                volume: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ChannelEntry {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSystemAudioVolume.ChannelEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChannelEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ChannelEntry {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerObject.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerObject.rtime_last_update)
    pub rtime_last_update: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerObject.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerObject {
    fn default() -> &'a CMsgSystemAudioManagerObject {
        <CMsgSystemAudioManagerObject as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerObject {
    pub fn new() -> CMsgSystemAudioManagerObject {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_last_update = 2;

    pub fn rtime_last_update(&self) -> u32 {
        self.rtime_last_update.unwrap_or(0)
    }

    pub fn clear_rtime_last_update(&mut self) {
        self.rtime_last_update = ::std::option::Option::None;
    }

    pub fn has_rtime_last_update(&self) -> bool {
        self.rtime_last_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_last_update(&mut self, v: u32) {
        self.rtime_last_update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgSystemAudioManagerObject| { &m.id },
            |m: &mut CMsgSystemAudioManagerObject| { &mut m.id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_last_update",
            |m: &CMsgSystemAudioManagerObject| { &m.rtime_last_update },
            |m: &mut CMsgSystemAudioManagerObject| { &mut m.rtime_last_update },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerObject>(
            "CMsgSystemAudioManagerObject",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerObject {
    const NAME: &'static str = "CMsgSystemAudioManagerObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.rtime_last_update = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rtime_last_update {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rtime_last_update {
            os.write_fixed32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerObject {
        CMsgSystemAudioManagerObject::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.rtime_last_update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerObject {
        static instance: CMsgSystemAudioManagerObject = CMsgSystemAudioManagerObject {
            id: ::std::option::Option::None,
            rtime_last_update: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerObject {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerObject {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.base)
    pub base: crate::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.nick)
    pub nick: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.api)
    pub api: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerDevice.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerDevice {
    fn default() -> &'a CMsgSystemAudioManagerDevice {
        <CMsgSystemAudioManagerDevice as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerDevice {
    pub fn new() -> CMsgSystemAudioManagerDevice {
        ::std::default::Default::default()
    }

    // optional .CMsgSystemAudioManagerObject base = 1;

    pub fn base(&self) -> &CMsgSystemAudioManagerObject {
        self.base.as_ref().unwrap_or_else(|| <CMsgSystemAudioManagerObject as crate::Message>::default_instance())
    }

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: CMsgSystemAudioManagerObject) {
        self.base = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut CMsgSystemAudioManagerObject {
        self.base.mut_or_insert_default()
    }

    // Take field
    pub fn take_base(&mut self) -> CMsgSystemAudioManagerObject {
        self.base.take().unwrap_or_else(|| CMsgSystemAudioManagerObject::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nick = 3;

    pub fn nick(&self) -> &str {
        match self.nick.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nick(&mut self) {
        self.nick = ::std::option::Option::None;
    }

    pub fn has_nick(&self) -> bool {
        self.nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nick(&mut self, v: ::std::string::String) {
        self.nick = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nick(&mut self) -> &mut ::std::string::String {
        if self.nick.is_none() {
            self.nick = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_nick(&mut self) -> ::std::string::String {
        self.nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string api = 5;

    pub fn api(&self) -> &str {
        match self.api.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_api(&mut self) {
        self.api = ::std::option::Option::None;
    }

    pub fn has_api(&self) -> bool {
        self.api.is_some()
    }

    // Param is passed by value, moved
    pub fn set_api(&mut self, v: ::std::string::String) {
        self.api = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_api(&mut self) -> &mut ::std::string::String {
        if self.api.is_none() {
            self.api = ::std::option::Option::Some(::std::string::String::new());
        }
        self.api.as_mut().unwrap()
    }

    // Take field
    pub fn take_api(&mut self) -> ::std::string::String {
        self.api.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemAudioManagerObject>(
            "base",
            |m: &CMsgSystemAudioManagerDevice| { &m.base },
            |m: &mut CMsgSystemAudioManagerDevice| { &mut m.base },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSystemAudioManagerDevice| { &m.name },
            |m: &mut CMsgSystemAudioManagerDevice| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nick",
            |m: &CMsgSystemAudioManagerDevice| { &m.nick },
            |m: &mut CMsgSystemAudioManagerDevice| { &mut m.nick },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgSystemAudioManagerDevice| { &m.description },
            |m: &mut CMsgSystemAudioManagerDevice| { &mut m.description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "api",
            |m: &CMsgSystemAudioManagerDevice| { &m.api },
            |m: &mut CMsgSystemAudioManagerDevice| { &mut m.api },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerDevice>(
            "CMsgSystemAudioManagerDevice",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerDevice {
    const NAME: &'static str = "CMsgSystemAudioManagerDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.nick = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.api = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.nick.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.api.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.base.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.nick.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.api.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerDevice {
        CMsgSystemAudioManagerDevice::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.name = ::std::option::Option::None;
        self.nick = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.api = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerDevice {
        static instance: CMsgSystemAudioManagerDevice = CMsgSystemAudioManagerDevice {
            base: crate::MessageField::none(),
            name: ::std::option::Option::None,
            nick: ::std::option::Option::None,
            description: ::std::option::Option::None,
            api: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerDevice {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerDevice {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.base)
    pub base: crate::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.device_id)
    pub device_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.nick)
    pub nick: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.edirection)
    pub edirection: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemAudioDirection>>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.volume)
    pub volume: crate::MessageField<CMsgSystemAudioVolume>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerNode.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerNode {
    fn default() -> &'a CMsgSystemAudioManagerNode {
        <CMsgSystemAudioManagerNode as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerNode {
    pub fn new() -> CMsgSystemAudioManagerNode {
        ::std::default::Default::default()
    }

    // optional .CMsgSystemAudioManagerObject base = 1;

    pub fn base(&self) -> &CMsgSystemAudioManagerObject {
        self.base.as_ref().unwrap_or_else(|| <CMsgSystemAudioManagerObject as crate::Message>::default_instance())
    }

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: CMsgSystemAudioManagerObject) {
        self.base = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut CMsgSystemAudioManagerObject {
        self.base.mut_or_insert_default()
    }

    // Take field
    pub fn take_base(&mut self) -> CMsgSystemAudioManagerObject {
        self.base.take().unwrap_or_else(|| CMsgSystemAudioManagerObject::new())
    }

    // optional uint32 device_id = 2;

    pub fn device_id(&self) -> u32 {
        self.device_id.unwrap_or(0)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u32) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nick = 4;

    pub fn nick(&self) -> &str {
        match self.nick.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nick(&mut self) {
        self.nick = ::std::option::Option::None;
    }

    pub fn has_nick(&self) -> bool {
        self.nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nick(&mut self, v: ::std::string::String) {
        self.nick = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nick(&mut self) -> &mut ::std::string::String {
        if self.nick.is_none() {
            self.nick = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_nick(&mut self) -> ::std::string::String {
        self.nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 5;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ESystemAudioDirection edirection = 6;

    pub fn edirection(&self) -> super::enums::ESystemAudioDirection {
        match self.edirection {
            Some(e) => e.enum_value_or(super::enums::ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            None => super::enums::ESystemAudioDirection::k_SystemAudioDirection_Invalid,
        }
    }

    pub fn clear_edirection(&mut self) {
        self.edirection = ::std::option::Option::None;
    }

    pub fn has_edirection(&self) -> bool {
        self.edirection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edirection(&mut self, v: super::enums::ESystemAudioDirection) {
        self.edirection = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .CMsgSystemAudioVolume volume = 7;

    pub fn volume(&self) -> &CMsgSystemAudioVolume {
        self.volume.as_ref().unwrap_or_else(|| <CMsgSystemAudioVolume as crate::Message>::default_instance())
    }

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: CMsgSystemAudioVolume) {
        self.volume = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut CMsgSystemAudioVolume {
        self.volume.mut_or_insert_default()
    }

    // Take field
    pub fn take_volume(&mut self) -> CMsgSystemAudioVolume {
        self.volume.take().unwrap_or_else(|| CMsgSystemAudioVolume::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemAudioManagerObject>(
            "base",
            |m: &CMsgSystemAudioManagerNode| { &m.base },
            |m: &mut CMsgSystemAudioManagerNode| { &mut m.base },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id",
            |m: &CMsgSystemAudioManagerNode| { &m.device_id },
            |m: &mut CMsgSystemAudioManagerNode| { &mut m.device_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSystemAudioManagerNode| { &m.name },
            |m: &mut CMsgSystemAudioManagerNode| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "nick",
            |m: &CMsgSystemAudioManagerNode| { &m.nick },
            |m: &mut CMsgSystemAudioManagerNode| { &mut m.nick },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgSystemAudioManagerNode| { &m.description },
            |m: &mut CMsgSystemAudioManagerNode| { &mut m.description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edirection",
            |m: &CMsgSystemAudioManagerNode| { &m.edirection },
            |m: &mut CMsgSystemAudioManagerNode| { &mut m.edirection },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemAudioVolume>(
            "volume",
            |m: &CMsgSystemAudioManagerNode| { &m.volume },
            |m: &mut CMsgSystemAudioManagerNode| { &mut m.volume },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerNode>(
            "CMsgSystemAudioManagerNode",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerNode {
    const NAME: &'static str = "CMsgSystemAudioManagerNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.device_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.nick = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.edirection = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.volume)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.device_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.nick.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.edirection {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.base.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.device_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nick.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.edirection {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.volume.as_ref() {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerNode {
        CMsgSystemAudioManagerNode::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.device_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.nick = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.edirection = ::std::option::Option::None;
        self.volume.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerNode {
        static instance: CMsgSystemAudioManagerNode = CMsgSystemAudioManagerNode {
            base: crate::MessageField::none(),
            device_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            nick: ::std::option::Option::None,
            description: ::std::option::Option::None,
            edirection: ::std::option::Option::None,
            volume: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerNode {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerNode {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerPort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerPort {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.base)
    pub base: crate::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.alias)
    pub alias: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.etype)
    pub etype: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemAudioPortType>>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.edirection)
    pub edirection: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemAudioPortDirection>>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_physical)
    pub is_physical: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_terminal)
    pub is_terminal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_control)
    pub is_control: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_monitor)
    pub is_monitor: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerPort.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerPort {
    fn default() -> &'a CMsgSystemAudioManagerPort {
        <CMsgSystemAudioManagerPort as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerPort {
    pub fn new() -> CMsgSystemAudioManagerPort {
        ::std::default::Default::default()
    }

    // optional .CMsgSystemAudioManagerObject base = 1;

    pub fn base(&self) -> &CMsgSystemAudioManagerObject {
        self.base.as_ref().unwrap_or_else(|| <CMsgSystemAudioManagerObject as crate::Message>::default_instance())
    }

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: CMsgSystemAudioManagerObject) {
        self.base = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut CMsgSystemAudioManagerObject {
        self.base.mut_or_insert_default()
    }

    // Take field
    pub fn take_base(&mut self) -> CMsgSystemAudioManagerObject {
        self.base.take().unwrap_or_else(|| CMsgSystemAudioManagerObject::new())
    }

    // optional uint32 node_id = 3;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string alias = 5;

    pub fn alias(&self) -> &str {
        match self.alias.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_alias(&mut self) {
        self.alias = ::std::option::Option::None;
    }

    pub fn has_alias(&self) -> bool {
        self.alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        if self.alias.is_none() {
            self.alias = ::std::option::Option::Some(::std::string::String::new());
        }
        self.alias.as_mut().unwrap()
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        self.alias.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ESystemAudioPortType etype = 6;

    pub fn etype(&self) -> super::enums::ESystemAudioPortType {
        match self.etype {
            Some(e) => e.enum_value_or(super::enums::ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            None => super::enums::ESystemAudioPortType::k_SystemAudioPortType_Invalid,
        }
    }

    pub fn clear_etype(&mut self) {
        self.etype = ::std::option::Option::None;
    }

    pub fn has_etype(&self) -> bool {
        self.etype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_etype(&mut self, v: super::enums::ESystemAudioPortType) {
        self.etype = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .ESystemAudioPortDirection edirection = 7;

    pub fn edirection(&self) -> super::enums::ESystemAudioPortDirection {
        match self.edirection {
            Some(e) => e.enum_value_or(super::enums::ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            None => super::enums::ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid,
        }
    }

    pub fn clear_edirection(&mut self) {
        self.edirection = ::std::option::Option::None;
    }

    pub fn has_edirection(&self) -> bool {
        self.edirection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edirection(&mut self, v: super::enums::ESystemAudioPortDirection) {
        self.edirection = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool is_physical = 8;

    pub fn is_physical(&self) -> bool {
        self.is_physical.unwrap_or(false)
    }

    pub fn clear_is_physical(&mut self) {
        self.is_physical = ::std::option::Option::None;
    }

    pub fn has_is_physical(&self) -> bool {
        self.is_physical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_physical(&mut self, v: bool) {
        self.is_physical = ::std::option::Option::Some(v);
    }

    // optional bool is_terminal = 9;

    pub fn is_terminal(&self) -> bool {
        self.is_terminal.unwrap_or(false)
    }

    pub fn clear_is_terminal(&mut self) {
        self.is_terminal = ::std::option::Option::None;
    }

    pub fn has_is_terminal(&self) -> bool {
        self.is_terminal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_terminal(&mut self, v: bool) {
        self.is_terminal = ::std::option::Option::Some(v);
    }

    // optional bool is_control = 10;

    pub fn is_control(&self) -> bool {
        self.is_control.unwrap_or(false)
    }

    pub fn clear_is_control(&mut self) {
        self.is_control = ::std::option::Option::None;
    }

    pub fn has_is_control(&self) -> bool {
        self.is_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_control(&mut self, v: bool) {
        self.is_control = ::std::option::Option::Some(v);
    }

    // optional bool is_monitor = 11;

    pub fn is_monitor(&self) -> bool {
        self.is_monitor.unwrap_or(false)
    }

    pub fn clear_is_monitor(&mut self) {
        self.is_monitor = ::std::option::Option::None;
    }

    pub fn has_is_monitor(&self) -> bool {
        self.is_monitor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_monitor(&mut self, v: bool) {
        self.is_monitor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemAudioManagerObject>(
            "base",
            |m: &CMsgSystemAudioManagerPort| { &m.base },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.base },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "node_id",
            |m: &CMsgSystemAudioManagerPort| { &m.node_id },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.node_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSystemAudioManagerPort| { &m.name },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "alias",
            |m: &CMsgSystemAudioManagerPort| { &m.alias },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.alias },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "etype",
            |m: &CMsgSystemAudioManagerPort| { &m.etype },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.etype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "edirection",
            |m: &CMsgSystemAudioManagerPort| { &m.edirection },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.edirection },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_physical",
            |m: &CMsgSystemAudioManagerPort| { &m.is_physical },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.is_physical },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_terminal",
            |m: &CMsgSystemAudioManagerPort| { &m.is_terminal },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.is_terminal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_control",
            |m: &CMsgSystemAudioManagerPort| { &m.is_control },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.is_control },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_monitor",
            |m: &CMsgSystemAudioManagerPort| { &m.is_monitor },
            |m: &mut CMsgSystemAudioManagerPort| { &mut m.is_monitor },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerPort>(
            "CMsgSystemAudioManagerPort",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerPort {
    const NAME: &'static str = "CMsgSystemAudioManagerPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                24 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.alias = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.etype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.edirection = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.is_physical = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_terminal = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.is_control = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.is_monitor = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.node_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.alias.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.etype {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.edirection {
            my_size += crate::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.is_physical {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_terminal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_control {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_monitor {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.base.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.alias.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.etype {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.edirection {
            os.write_enum(7, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_physical {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_terminal {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_control {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_monitor {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerPort {
        CMsgSystemAudioManagerPort::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.node_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.alias = ::std::option::Option::None;
        self.etype = ::std::option::Option::None;
        self.edirection = ::std::option::Option::None;
        self.is_physical = ::std::option::Option::None;
        self.is_terminal = ::std::option::Option::None;
        self.is_control = ::std::option::Option::None;
        self.is_monitor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerPort {
        static instance: CMsgSystemAudioManagerPort = CMsgSystemAudioManagerPort {
            base: crate::MessageField::none(),
            node_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            alias: ::std::option::Option::None,
            etype: ::std::option::Option::None,
            edirection: ::std::option::Option::None,
            is_physical: ::std::option::Option::None,
            is_terminal: ::std::option::Option::None,
            is_control: ::std::option::Option::None,
            is_monitor: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerPort {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerPort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerPort {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerLink)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerLink {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.base)
    pub base: crate::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.output_node_id)
    pub output_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.output_port_id)
    pub output_port_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.input_node_id)
    pub input_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.input_port_id)
    pub input_port_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerLink.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerLink {
    fn default() -> &'a CMsgSystemAudioManagerLink {
        <CMsgSystemAudioManagerLink as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerLink {
    pub fn new() -> CMsgSystemAudioManagerLink {
        ::std::default::Default::default()
    }

    // optional .CMsgSystemAudioManagerObject base = 1;

    pub fn base(&self) -> &CMsgSystemAudioManagerObject {
        self.base.as_ref().unwrap_or_else(|| <CMsgSystemAudioManagerObject as crate::Message>::default_instance())
    }

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: CMsgSystemAudioManagerObject) {
        self.base = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut CMsgSystemAudioManagerObject {
        self.base.mut_or_insert_default()
    }

    // Take field
    pub fn take_base(&mut self) -> CMsgSystemAudioManagerObject {
        self.base.take().unwrap_or_else(|| CMsgSystemAudioManagerObject::new())
    }

    // optional uint32 output_node_id = 2;

    pub fn output_node_id(&self) -> u32 {
        self.output_node_id.unwrap_or(0)
    }

    pub fn clear_output_node_id(&mut self) {
        self.output_node_id = ::std::option::Option::None;
    }

    pub fn has_output_node_id(&self) -> bool {
        self.output_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_node_id(&mut self, v: u32) {
        self.output_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 output_port_id = 3;

    pub fn output_port_id(&self) -> u32 {
        self.output_port_id.unwrap_or(0)
    }

    pub fn clear_output_port_id(&mut self) {
        self.output_port_id = ::std::option::Option::None;
    }

    pub fn has_output_port_id(&self) -> bool {
        self.output_port_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_port_id(&mut self, v: u32) {
        self.output_port_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_node_id = 4;

    pub fn input_node_id(&self) -> u32 {
        self.input_node_id.unwrap_or(0)
    }

    pub fn clear_input_node_id(&mut self) {
        self.input_node_id = ::std::option::Option::None;
    }

    pub fn has_input_node_id(&self) -> bool {
        self.input_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_node_id(&mut self, v: u32) {
        self.input_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_port_id = 5;

    pub fn input_port_id(&self) -> u32 {
        self.input_port_id.unwrap_or(0)
    }

    pub fn clear_input_port_id(&mut self) {
        self.input_port_id = ::std::option::Option::None;
    }

    pub fn has_input_port_id(&self) -> bool {
        self.input_port_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_port_id(&mut self, v: u32) {
        self.input_port_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemAudioManagerObject>(
            "base",
            |m: &CMsgSystemAudioManagerLink| { &m.base },
            |m: &mut CMsgSystemAudioManagerLink| { &mut m.base },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "output_node_id",
            |m: &CMsgSystemAudioManagerLink| { &m.output_node_id },
            |m: &mut CMsgSystemAudioManagerLink| { &mut m.output_node_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "output_port_id",
            |m: &CMsgSystemAudioManagerLink| { &m.output_port_id },
            |m: &mut CMsgSystemAudioManagerLink| { &mut m.output_port_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_node_id",
            |m: &CMsgSystemAudioManagerLink| { &m.input_node_id },
            |m: &mut CMsgSystemAudioManagerLink| { &mut m.input_node_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_port_id",
            |m: &CMsgSystemAudioManagerLink| { &m.input_port_id },
            |m: &mut CMsgSystemAudioManagerLink| { &mut m.input_port_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerLink>(
            "CMsgSystemAudioManagerLink",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerLink {
    const NAME: &'static str = "CMsgSystemAudioManagerLink";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.output_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.output_port_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.input_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.input_port_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output_node_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.output_port_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.input_node_id {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.input_port_id {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.base.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.output_node_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.output_port_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.input_node_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.input_port_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerLink {
        CMsgSystemAudioManagerLink::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.output_node_id = ::std::option::Option::None;
        self.output_port_id = ::std::option::Option::None;
        self.input_node_id = ::std::option::Option::None;
        self.input_port_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerLink {
        static instance: CMsgSystemAudioManagerLink = CMsgSystemAudioManagerLink {
            base: crate::MessageField::none(),
            output_node_id: ::std::option::Option::None,
            output_port_id: ::std::option::Option::None,
            input_node_id: ::std::option::Option::None,
            input_port_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerLink {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerLink").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerLink {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerStateHW)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerStateHW {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.devices)
    pub devices: ::std::vec::Vec<CMsgSystemAudioManagerDevice>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.nodes)
    pub nodes: ::std::vec::Vec<CMsgSystemAudioManagerNode>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.ports)
    pub ports: ::std::vec::Vec<CMsgSystemAudioManagerPort>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.links)
    pub links: ::std::vec::Vec<CMsgSystemAudioManagerLink>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerStateHW.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerStateHW {
    fn default() -> &'a CMsgSystemAudioManagerStateHW {
        <CMsgSystemAudioManagerStateHW as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerStateHW {
    pub fn new() -> CMsgSystemAudioManagerStateHW {
        ::std::default::Default::default()
    }

    // repeated .CMsgSystemAudioManagerDevice devices = 1;

    pub fn devices(&self) -> &[CMsgSystemAudioManagerDevice] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<CMsgSystemAudioManagerDevice>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<CMsgSystemAudioManagerDevice> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<CMsgSystemAudioManagerDevice> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    // repeated .CMsgSystemAudioManagerNode nodes = 2;

    pub fn nodes(&self) -> &[CMsgSystemAudioManagerNode] {
        &self.nodes
    }

    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::std::vec::Vec<CMsgSystemAudioManagerNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::std::vec::Vec<CMsgSystemAudioManagerNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::std::vec::Vec<CMsgSystemAudioManagerNode> {
        ::std::mem::replace(&mut self.nodes, ::std::vec::Vec::new())
    }

    // repeated .CMsgSystemAudioManagerPort ports = 3;

    pub fn ports(&self) -> &[CMsgSystemAudioManagerPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<CMsgSystemAudioManagerPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<CMsgSystemAudioManagerPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<CMsgSystemAudioManagerPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .CMsgSystemAudioManagerLink links = 4;

    pub fn links(&self) -> &[CMsgSystemAudioManagerLink] {
        &self.links
    }

    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::vec::Vec<CMsgSystemAudioManagerLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::std::vec::Vec<CMsgSystemAudioManagerLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::vec::Vec<CMsgSystemAudioManagerLink> {
        ::std::mem::replace(&mut self.links, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &CMsgSystemAudioManagerStateHW| { &m.devices },
            |m: &mut CMsgSystemAudioManagerStateHW| { &mut m.devices },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &CMsgSystemAudioManagerStateHW| { &m.nodes },
            |m: &mut CMsgSystemAudioManagerStateHW| { &mut m.nodes },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &CMsgSystemAudioManagerStateHW| { &m.ports },
            |m: &mut CMsgSystemAudioManagerStateHW| { &mut m.ports },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links",
            |m: &CMsgSystemAudioManagerStateHW| { &m.links },
            |m: &mut CMsgSystemAudioManagerStateHW| { &mut m.links },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerStateHW>(
            "CMsgSystemAudioManagerStateHW",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerStateHW {
    const NAME: &'static str = "CMsgSystemAudioManagerStateHW";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.devices.push(is.read_message()?);
                },
                18 => {
                    self.nodes.push(is.read_message()?);
                },
                26 => {
                    self.ports.push(is.read_message()?);
                },
                34 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.devices {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.nodes {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.ports {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.links {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerStateHW {
        CMsgSystemAudioManagerStateHW::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.nodes.clear();
        self.ports.clear();
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerStateHW {
        static instance: CMsgSystemAudioManagerStateHW = CMsgSystemAudioManagerStateHW {
            devices: ::std::vec::Vec::new(),
            nodes: ::std::vec::Vec::new(),
            ports: ::std::vec::Vec::new(),
            links: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerStateHW {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerStateHW").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerStateHW {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerStateHW {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerState.rtime_filter)
    pub rtime_filter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerState.counter)
    pub counter: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerState.hw)
    pub hw: crate::MessageField<CMsgSystemAudioManagerStateHW>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerState {
    fn default() -> &'a CMsgSystemAudioManagerState {
        <CMsgSystemAudioManagerState as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerState {
    pub fn new() -> CMsgSystemAudioManagerState {
        ::std::default::Default::default()
    }

    // optional fixed32 rtime_filter = 1;

    pub fn rtime_filter(&self) -> u32 {
        self.rtime_filter.unwrap_or(0)
    }

    pub fn clear_rtime_filter(&mut self) {
        self.rtime_filter = ::std::option::Option::None;
    }

    pub fn has_rtime_filter(&self) -> bool {
        self.rtime_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_filter(&mut self, v: u32) {
        self.rtime_filter = ::std::option::Option::Some(v);
    }

    // optional int32 counter = 2;

    pub fn counter(&self) -> i32 {
        self.counter.unwrap_or(0)
    }

    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i32) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional .CMsgSystemAudioManagerStateHW hw = 3;

    pub fn hw(&self) -> &CMsgSystemAudioManagerStateHW {
        self.hw.as_ref().unwrap_or_else(|| <CMsgSystemAudioManagerStateHW as crate::Message>::default_instance())
    }

    pub fn clear_hw(&mut self) {
        self.hw.clear();
    }

    pub fn has_hw(&self) -> bool {
        self.hw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hw(&mut self, v: CMsgSystemAudioManagerStateHW) {
        self.hw = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hw(&mut self) -> &mut CMsgSystemAudioManagerStateHW {
        self.hw.mut_or_insert_default()
    }

    // Take field
    pub fn take_hw(&mut self) -> CMsgSystemAudioManagerStateHW {
        self.hw.take().unwrap_or_else(|| CMsgSystemAudioManagerStateHW::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_filter",
            |m: &CMsgSystemAudioManagerState| { &m.rtime_filter },
            |m: &mut CMsgSystemAudioManagerState| { &mut m.rtime_filter },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "counter",
            |m: &CMsgSystemAudioManagerState| { &m.counter },
            |m: &mut CMsgSystemAudioManagerState| { &mut m.counter },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemAudioManagerStateHW>(
            "hw",
            |m: &CMsgSystemAudioManagerState| { &m.hw },
            |m: &mut CMsgSystemAudioManagerState| { &mut m.hw },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerState>(
            "CMsgSystemAudioManagerState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerState {
    const NAME: &'static str = "CMsgSystemAudioManagerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.rtime_filter = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.counter = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.hw)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rtime_filter {
            my_size += 1 + 4;
        }
        if let Some(v) = self.counter {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.hw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.rtime_filter {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.counter {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.hw.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerState {
        CMsgSystemAudioManagerState::new()
    }

    fn clear(&mut self) {
        self.rtime_filter = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.hw.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerState {
        static instance: CMsgSystemAudioManagerState = CMsgSystemAudioManagerState {
            rtime_filter: ::std::option::Option::None,
            counter: ::std::option::Option::None,
            hw: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerUpdateSomething)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerUpdateSomething {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerUpdateSomething.counter)
    pub counter: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerUpdateSomething.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerUpdateSomething {
    fn default() -> &'a CMsgSystemAudioManagerUpdateSomething {
        <CMsgSystemAudioManagerUpdateSomething as crate::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerUpdateSomething {
    pub fn new() -> CMsgSystemAudioManagerUpdateSomething {
        ::std::default::Default::default()
    }

    // optional int32 counter = 1;

    pub fn counter(&self) -> i32 {
        self.counter.unwrap_or(0)
    }

    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i32) {
        self.counter = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "counter",
            |m: &CMsgSystemAudioManagerUpdateSomething| { &m.counter },
            |m: &mut CMsgSystemAudioManagerUpdateSomething| { &mut m.counter },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemAudioManagerUpdateSomething>(
            "CMsgSystemAudioManagerUpdateSomething",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemAudioManagerUpdateSomething {
    const NAME: &'static str = "CMsgSystemAudioManagerUpdateSomething";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.counter = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.counter {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.counter {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerUpdateSomething {
        CMsgSystemAudioManagerUpdateSomething::new()
    }

    fn clear(&mut self) {
        self.counter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerUpdateSomething {
        static instance: CMsgSystemAudioManagerUpdateSomething = CMsgSystemAudioManagerUpdateSomething {
            counter: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemAudioManagerUpdateSomething {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemAudioManagerUpdateSomething").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemAudioManagerUpdateSomething {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemAudioManagerUpdateSomething {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemDisplayMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplayMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.refresh_hz)
    pub refresh_hz: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplayMode.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplayMode {
    fn default() -> &'a CMsgSystemDisplayMode {
        <CMsgSystemDisplayMode as crate::Message>::default_instance()
    }
}

impl CMsgSystemDisplayMode {
    pub fn new() -> CMsgSystemDisplayMode {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 refresh_hz = 4;

    pub fn refresh_hz(&self) -> i32 {
        self.refresh_hz.unwrap_or(0)
    }

    pub fn clear_refresh_hz(&mut self) {
        self.refresh_hz = ::std::option::Option::None;
    }

    pub fn has_refresh_hz(&self) -> bool {
        self.refresh_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_hz(&mut self, v: i32) {
        self.refresh_hz = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgSystemDisplayMode| { &m.id },
            |m: &mut CMsgSystemDisplayMode| { &mut m.id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgSystemDisplayMode| { &m.width },
            |m: &mut CMsgSystemDisplayMode| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgSystemDisplayMode| { &m.height },
            |m: &mut CMsgSystemDisplayMode| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "refresh_hz",
            |m: &CMsgSystemDisplayMode| { &m.refresh_hz },
            |m: &mut CMsgSystemDisplayMode| { &mut m.refresh_hz },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemDisplayMode>(
            "CMsgSystemDisplayMode",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemDisplayMode {
    const NAME: &'static str = "CMsgSystemDisplayMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.refresh_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.refresh_hz {
            my_size += crate::rt::int32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.refresh_hz {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplayMode {
        CMsgSystemDisplayMode::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.refresh_hz = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplayMode {
        static instance: CMsgSystemDisplayMode = CMsgSystemDisplayMode {
            id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            refresh_hz: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemDisplayMode {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemDisplayMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemDisplayMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemDisplayMode {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemDisplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplay {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplay.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_primary)
    pub is_primary: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_enabled)
    pub is_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_internal)
    pub is_internal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.has_mode_override)
    pub has_mode_override: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.width_mm)
    pub width_mm: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.height_mm)
    pub height_mm: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.current_mode_id)
    pub current_mode_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.modes)
    pub modes: ::std::vec::Vec<CMsgSystemDisplayMode>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.refresh_rate_min)
    pub refresh_rate_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.refresh_rate_max)
    pub refresh_rate_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_vrr_capable)
    pub is_vrr_capable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_vrr_enabled)
    pub is_vrr_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_hdr_capable)
    pub is_hdr_capable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_hdr_enabled)
    pub is_hdr_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.compatibility_params)
    pub compatibility_params: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.app_wants_hdr)
    pub app_wants_hdr: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplay.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplay {
    fn default() -> &'a CMsgSystemDisplay {
        <CMsgSystemDisplay as crate::Message>::default_instance()
    }
}

impl CMsgSystemDisplay {
    pub fn new() -> CMsgSystemDisplay {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 3;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_primary = 4;

    pub fn is_primary(&self) -> bool {
        self.is_primary.unwrap_or(false)
    }

    pub fn clear_is_primary(&mut self) {
        self.is_primary = ::std::option::Option::None;
    }

    pub fn has_is_primary(&self) -> bool {
        self.is_primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_primary(&mut self, v: bool) {
        self.is_primary = ::std::option::Option::Some(v);
    }

    // optional bool is_enabled = 5;

    pub fn is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }

    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_internal = 6;

    pub fn is_internal(&self) -> bool {
        self.is_internal.unwrap_or(false)
    }

    pub fn clear_is_internal(&mut self) {
        self.is_internal = ::std::option::Option::None;
    }

    pub fn has_is_internal(&self) -> bool {
        self.is_internal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_internal(&mut self, v: bool) {
        self.is_internal = ::std::option::Option::Some(v);
    }

    // optional bool has_mode_override = 7;

    pub fn has_mode_override(&self) -> bool {
        self.has_mode_override.unwrap_or(false)
    }

    pub fn clear_has_mode_override(&mut self) {
        self.has_mode_override = ::std::option::Option::None;
    }

    pub fn has_has_mode_override(&self) -> bool {
        self.has_mode_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_mode_override(&mut self, v: bool) {
        self.has_mode_override = ::std::option::Option::Some(v);
    }

    // optional int32 width_mm = 8;

    pub fn width_mm(&self) -> i32 {
        self.width_mm.unwrap_or(0)
    }

    pub fn clear_width_mm(&mut self) {
        self.width_mm = ::std::option::Option::None;
    }

    pub fn has_width_mm(&self) -> bool {
        self.width_mm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width_mm(&mut self, v: i32) {
        self.width_mm = ::std::option::Option::Some(v);
    }

    // optional int32 height_mm = 9;

    pub fn height_mm(&self) -> i32 {
        self.height_mm.unwrap_or(0)
    }

    pub fn clear_height_mm(&mut self) {
        self.height_mm = ::std::option::Option::None;
    }

    pub fn has_height_mm(&self) -> bool {
        self.height_mm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height_mm(&mut self, v: i32) {
        self.height_mm = ::std::option::Option::Some(v);
    }

    // optional int32 current_mode_id = 10;

    pub fn current_mode_id(&self) -> i32 {
        self.current_mode_id.unwrap_or(0)
    }

    pub fn clear_current_mode_id(&mut self) {
        self.current_mode_id = ::std::option::Option::None;
    }

    pub fn has_current_mode_id(&self) -> bool {
        self.current_mode_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_mode_id(&mut self, v: i32) {
        self.current_mode_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSystemDisplayMode modes = 11;

    pub fn modes(&self) -> &[CMsgSystemDisplayMode] {
        &self.modes
    }

    pub fn clear_modes(&mut self) {
        self.modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_modes(&mut self, v: ::std::vec::Vec<CMsgSystemDisplayMode>) {
        self.modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modes(&mut self) -> &mut ::std::vec::Vec<CMsgSystemDisplayMode> {
        &mut self.modes
    }

    // Take field
    pub fn take_modes(&mut self) -> ::std::vec::Vec<CMsgSystemDisplayMode> {
        ::std::mem::replace(&mut self.modes, ::std::vec::Vec::new())
    }

    // optional int32 refresh_rate_min = 12;

    pub fn refresh_rate_min(&self) -> i32 {
        self.refresh_rate_min.unwrap_or(0)
    }

    pub fn clear_refresh_rate_min(&mut self) {
        self.refresh_rate_min = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_min(&self) -> bool {
        self.refresh_rate_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_min(&mut self, v: i32) {
        self.refresh_rate_min = ::std::option::Option::Some(v);
    }

    // optional int32 refresh_rate_max = 13;

    pub fn refresh_rate_max(&self) -> i32 {
        self.refresh_rate_max.unwrap_or(0)
    }

    pub fn clear_refresh_rate_max(&mut self) {
        self.refresh_rate_max = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_max(&self) -> bool {
        self.refresh_rate_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_max(&mut self, v: i32) {
        self.refresh_rate_max = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_capable = 14;

    pub fn is_vrr_capable(&self) -> bool {
        self.is_vrr_capable.unwrap_or(false)
    }

    pub fn clear_is_vrr_capable(&mut self) {
        self.is_vrr_capable = ::std::option::Option::None;
    }

    pub fn has_is_vrr_capable(&self) -> bool {
        self.is_vrr_capable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_capable(&mut self, v: bool) {
        self.is_vrr_capable = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_enabled = 15;

    pub fn is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.unwrap_or(false)
    }

    pub fn clear_is_vrr_enabled(&mut self) {
        self.is_vrr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_enabled(&mut self, v: bool) {
        self.is_vrr_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_hdr_capable = 16;

    pub fn is_hdr_capable(&self) -> bool {
        self.is_hdr_capable.unwrap_or(false)
    }

    pub fn clear_is_hdr_capable(&mut self) {
        self.is_hdr_capable = ::std::option::Option::None;
    }

    pub fn has_is_hdr_capable(&self) -> bool {
        self.is_hdr_capable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_capable(&mut self, v: bool) {
        self.is_hdr_capable = ::std::option::Option::Some(v);
    }

    // optional bool is_hdr_enabled = 17;

    pub fn is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.unwrap_or(false)
    }

    pub fn clear_is_hdr_enabled(&mut self) {
        self.is_hdr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_enabled(&mut self, v: bool) {
        self.is_hdr_enabled = ::std::option::Option::Some(v);
    }

    // repeated int32 compatibility_params = 18;

    pub fn compatibility_params(&self) -> &[i32] {
        &self.compatibility_params
    }

    pub fn clear_compatibility_params(&mut self) {
        self.compatibility_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_compatibility_params(&mut self, v: ::std::vec::Vec<i32>) {
        self.compatibility_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compatibility_params(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.compatibility_params
    }

    // Take field
    pub fn take_compatibility_params(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.compatibility_params, ::std::vec::Vec::new())
    }

    // optional bool app_wants_hdr = 19;

    pub fn app_wants_hdr(&self) -> bool {
        self.app_wants_hdr.unwrap_or(false)
    }

    pub fn clear_app_wants_hdr(&mut self) {
        self.app_wants_hdr = ::std::option::Option::None;
    }

    pub fn has_app_wants_hdr(&self) -> bool {
        self.app_wants_hdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_wants_hdr(&mut self, v: bool) {
        self.app_wants_hdr = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgSystemDisplay| { &m.id },
            |m: &mut CMsgSystemDisplay| { &mut m.id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSystemDisplay| { &m.name },
            |m: &mut CMsgSystemDisplay| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgSystemDisplay| { &m.description },
            |m: &mut CMsgSystemDisplay| { &mut m.description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_primary",
            |m: &CMsgSystemDisplay| { &m.is_primary },
            |m: &mut CMsgSystemDisplay| { &mut m.is_primary },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_enabled",
            |m: &CMsgSystemDisplay| { &m.is_enabled },
            |m: &mut CMsgSystemDisplay| { &mut m.is_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_internal",
            |m: &CMsgSystemDisplay| { &m.is_internal },
            |m: &mut CMsgSystemDisplay| { &mut m.is_internal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_mode_override",
            |m: &CMsgSystemDisplay| { &m.has_mode_override },
            |m: &mut CMsgSystemDisplay| { &mut m.has_mode_override },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width_mm",
            |m: &CMsgSystemDisplay| { &m.width_mm },
            |m: &mut CMsgSystemDisplay| { &mut m.width_mm },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height_mm",
            |m: &CMsgSystemDisplay| { &m.height_mm },
            |m: &mut CMsgSystemDisplay| { &mut m.height_mm },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_mode_id",
            |m: &CMsgSystemDisplay| { &m.current_mode_id },
            |m: &mut CMsgSystemDisplay| { &mut m.current_mode_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modes",
            |m: &CMsgSystemDisplay| { &m.modes },
            |m: &mut CMsgSystemDisplay| { &mut m.modes },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "refresh_rate_min",
            |m: &CMsgSystemDisplay| { &m.refresh_rate_min },
            |m: &mut CMsgSystemDisplay| { &mut m.refresh_rate_min },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "refresh_rate_max",
            |m: &CMsgSystemDisplay| { &m.refresh_rate_max },
            |m: &mut CMsgSystemDisplay| { &mut m.refresh_rate_max },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_vrr_capable",
            |m: &CMsgSystemDisplay| { &m.is_vrr_capable },
            |m: &mut CMsgSystemDisplay| { &mut m.is_vrr_capable },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_vrr_enabled",
            |m: &CMsgSystemDisplay| { &m.is_vrr_enabled },
            |m: &mut CMsgSystemDisplay| { &mut m.is_vrr_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hdr_capable",
            |m: &CMsgSystemDisplay| { &m.is_hdr_capable },
            |m: &mut CMsgSystemDisplay| { &mut m.is_hdr_capable },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hdr_enabled",
            |m: &CMsgSystemDisplay| { &m.is_hdr_enabled },
            |m: &mut CMsgSystemDisplay| { &mut m.is_hdr_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "compatibility_params",
            |m: &CMsgSystemDisplay| { &m.compatibility_params },
            |m: &mut CMsgSystemDisplay| { &mut m.compatibility_params },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_wants_hdr",
            |m: &CMsgSystemDisplay| { &m.app_wants_hdr },
            |m: &mut CMsgSystemDisplay| { &mut m.app_wants_hdr },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemDisplay>(
            "CMsgSystemDisplay",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemDisplay {
    const NAME: &'static str = "CMsgSystemDisplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.is_primary = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_internal = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.has_mode_override = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.width_mm = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.height_mm = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.current_mode_id = ::std::option::Option::Some(is.read_int32()?);
                },
                90 => {
                    self.modes.push(is.read_message()?);
                },
                96 => {
                    self.refresh_rate_min = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.refresh_rate_max = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.is_vrr_capable = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.is_vrr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.is_hdr_capable = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_hdr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    is.read_repeated_packed_int32_into(&mut self.compatibility_params)?;
                },
                144 => {
                    self.compatibility_params.push(is.read_int32()?);
                },
                152 => {
                    self.app_wants_hdr = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.is_primary {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_internal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_mode_override {
            my_size += 1 + 1;
        }
        if let Some(v) = self.width_mm {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.height_mm {
            my_size += crate::rt::int32_size(9, v);
        }
        if let Some(v) = self.current_mode_id {
            my_size += crate::rt::int32_size(10, v);
        }
        for value in &self.modes {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.refresh_rate_min {
            my_size += crate::rt::int32_size(12, v);
        }
        if let Some(v) = self.refresh_rate_max {
            my_size += crate::rt::int32_size(13, v);
        }
        if let Some(v) = self.is_vrr_capable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_vrr_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hdr_capable {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_hdr_enabled {
            my_size += 2 + 1;
        }
        for value in &self.compatibility_params {
            my_size += crate::rt::int32_size(18, *value);
        };
        if let Some(v) = self.app_wants_hdr {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.is_primary {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_enabled {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_internal {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.has_mode_override {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.width_mm {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.height_mm {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.current_mode_id {
            os.write_int32(10, v)?;
        }
        for v in &self.modes {
            crate::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.refresh_rate_min {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.refresh_rate_max {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.is_vrr_capable {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.is_vrr_enabled {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.is_hdr_capable {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_hdr_enabled {
            os.write_bool(17, v)?;
        }
        for v in &self.compatibility_params {
            os.write_int32(18, *v)?;
        };
        if let Some(v) = self.app_wants_hdr {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplay {
        CMsgSystemDisplay::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.is_primary = ::std::option::Option::None;
        self.is_enabled = ::std::option::Option::None;
        self.is_internal = ::std::option::Option::None;
        self.has_mode_override = ::std::option::Option::None;
        self.width_mm = ::std::option::Option::None;
        self.height_mm = ::std::option::Option::None;
        self.current_mode_id = ::std::option::Option::None;
        self.modes.clear();
        self.refresh_rate_min = ::std::option::Option::None;
        self.refresh_rate_max = ::std::option::Option::None;
        self.is_vrr_capable = ::std::option::Option::None;
        self.is_vrr_enabled = ::std::option::Option::None;
        self.is_hdr_capable = ::std::option::Option::None;
        self.is_hdr_enabled = ::std::option::Option::None;
        self.compatibility_params.clear();
        self.app_wants_hdr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplay {
        static instance: CMsgSystemDisplay = CMsgSystemDisplay {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            description: ::std::option::Option::None,
            is_primary: ::std::option::Option::None,
            is_enabled: ::std::option::Option::None,
            is_internal: ::std::option::Option::None,
            has_mode_override: ::std::option::Option::None,
            width_mm: ::std::option::Option::None,
            height_mm: ::std::option::Option::None,
            current_mode_id: ::std::option::Option::None,
            modes: ::std::vec::Vec::new(),
            refresh_rate_min: ::std::option::Option::None,
            refresh_rate_max: ::std::option::Option::None,
            is_vrr_capable: ::std::option::Option::None,
            is_vrr_enabled: ::std::option::Option::None,
            is_hdr_capable: ::std::option::Option::None,
            is_hdr_enabled: ::std::option::Option::None,
            compatibility_params: ::std::vec::Vec::new(),
            app_wants_hdr: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemDisplay {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemDisplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemDisplay {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemDisplayManagerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplayManagerState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerState.displays)
    pub displays: ::std::vec::Vec<CMsgSystemDisplay>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerState.is_mode_switching_supported)
    pub is_mode_switching_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerState.compatibility_mode)
    pub compatibility_mode: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemDisplayCompatibilityMode>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplayManagerState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplayManagerState {
    fn default() -> &'a CMsgSystemDisplayManagerState {
        <CMsgSystemDisplayManagerState as crate::Message>::default_instance()
    }
}

impl CMsgSystemDisplayManagerState {
    pub fn new() -> CMsgSystemDisplayManagerState {
        ::std::default::Default::default()
    }

    // repeated .CMsgSystemDisplay displays = 1;

    pub fn displays(&self) -> &[CMsgSystemDisplay] {
        &self.displays
    }

    pub fn clear_displays(&mut self) {
        self.displays.clear();
    }

    // Param is passed by value, moved
    pub fn set_displays(&mut self, v: ::std::vec::Vec<CMsgSystemDisplay>) {
        self.displays = v;
    }

    // Mutable pointer to the field.
    pub fn mut_displays(&mut self) -> &mut ::std::vec::Vec<CMsgSystemDisplay> {
        &mut self.displays
    }

    // Take field
    pub fn take_displays(&mut self) -> ::std::vec::Vec<CMsgSystemDisplay> {
        ::std::mem::replace(&mut self.displays, ::std::vec::Vec::new())
    }

    // optional bool is_mode_switching_supported = 2;

    pub fn is_mode_switching_supported(&self) -> bool {
        self.is_mode_switching_supported.unwrap_or(false)
    }

    pub fn clear_is_mode_switching_supported(&mut self) {
        self.is_mode_switching_supported = ::std::option::Option::None;
    }

    pub fn has_is_mode_switching_supported(&self) -> bool {
        self.is_mode_switching_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_mode_switching_supported(&mut self, v: bool) {
        self.is_mode_switching_supported = ::std::option::Option::Some(v);
    }

    // optional .ESystemDisplayCompatibilityMode compatibility_mode = 3;

    pub fn compatibility_mode(&self) -> super::enums::ESystemDisplayCompatibilityMode {
        match self.compatibility_mode {
            Some(e) => e.enum_value_or(super::enums::ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid),
            None => super::enums::ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid,
        }
    }

    pub fn clear_compatibility_mode(&mut self) {
        self.compatibility_mode = ::std::option::Option::None;
    }

    pub fn has_compatibility_mode(&self) -> bool {
        self.compatibility_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compatibility_mode(&mut self, v: super::enums::ESystemDisplayCompatibilityMode) {
        self.compatibility_mode = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "displays",
            |m: &CMsgSystemDisplayManagerState| { &m.displays },
            |m: &mut CMsgSystemDisplayManagerState| { &mut m.displays },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_mode_switching_supported",
            |m: &CMsgSystemDisplayManagerState| { &m.is_mode_switching_supported },
            |m: &mut CMsgSystemDisplayManagerState| { &mut m.is_mode_switching_supported },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "compatibility_mode",
            |m: &CMsgSystemDisplayManagerState| { &m.compatibility_mode },
            |m: &mut CMsgSystemDisplayManagerState| { &mut m.compatibility_mode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemDisplayManagerState>(
            "CMsgSystemDisplayManagerState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemDisplayManagerState {
    const NAME: &'static str = "CMsgSystemDisplayManagerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displays.push(is.read_message()?);
                },
                16 => {
                    self.is_mode_switching_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.compatibility_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.displays {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_mode_switching_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.compatibility_mode {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.displays {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_mode_switching_supported {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.compatibility_mode {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplayManagerState {
        CMsgSystemDisplayManagerState::new()
    }

    fn clear(&mut self) {
        self.displays.clear();
        self.is_mode_switching_supported = ::std::option::Option::None;
        self.compatibility_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplayManagerState {
        static instance: CMsgSystemDisplayManagerState = CMsgSystemDisplayManagerState {
            displays: ::std::vec::Vec::new(),
            is_mode_switching_supported: ::std::option::Option::None,
            compatibility_mode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemDisplayManagerState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemDisplayManagerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemDisplayManagerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemDisplayManagerState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemDisplayManagerSetMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplayManagerSetMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerSetMode.display_id)
    pub display_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerSetMode.mode_id)
    pub mode_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplayManagerSetMode.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplayManagerSetMode {
    fn default() -> &'a CMsgSystemDisplayManagerSetMode {
        <CMsgSystemDisplayManagerSetMode as crate::Message>::default_instance()
    }
}

impl CMsgSystemDisplayManagerSetMode {
    pub fn new() -> CMsgSystemDisplayManagerSetMode {
        ::std::default::Default::default()
    }

    // optional int32 display_id = 1;

    pub fn display_id(&self) -> i32 {
        self.display_id.unwrap_or(0)
    }

    pub fn clear_display_id(&mut self) {
        self.display_id = ::std::option::Option::None;
    }

    pub fn has_display_id(&self) -> bool {
        self.display_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_id(&mut self, v: i32) {
        self.display_id = ::std::option::Option::Some(v);
    }

    // optional int32 mode_id = 2;

    pub fn mode_id(&self) -> i32 {
        self.mode_id.unwrap_or(0)
    }

    pub fn clear_mode_id(&mut self) {
        self.mode_id = ::std::option::Option::None;
    }

    pub fn has_mode_id(&self) -> bool {
        self.mode_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_id(&mut self, v: i32) {
        self.mode_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_id",
            |m: &CMsgSystemDisplayManagerSetMode| { &m.display_id },
            |m: &mut CMsgSystemDisplayManagerSetMode| { &mut m.display_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode_id",
            |m: &CMsgSystemDisplayManagerSetMode| { &m.mode_id },
            |m: &mut CMsgSystemDisplayManagerSetMode| { &mut m.mode_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemDisplayManagerSetMode>(
            "CMsgSystemDisplayManagerSetMode",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemDisplayManagerSetMode {
    const NAME: &'static str = "CMsgSystemDisplayManagerSetMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mode_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.display_id {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.mode_id {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.display_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mode_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplayManagerSetMode {
        CMsgSystemDisplayManagerSetMode::new()
    }

    fn clear(&mut self) {
        self.display_id = ::std::option::Option::None;
        self.mode_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplayManagerSetMode {
        static instance: CMsgSystemDisplayManagerSetMode = CMsgSystemDisplayManagerSetMode {
            display_id: ::std::option::Option::None,
            mode_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemDisplayManagerSetMode {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemDisplayManagerSetMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemDisplayManagerSetMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemDisplayManagerSetMode {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemManagerSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemManagerSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_backlight_dim_battery_seconds)
    pub idle_backlight_dim_battery_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_backlight_dim_ac_seconds)
    pub idle_backlight_dim_ac_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_suspend_battery_seconds)
    pub idle_suspend_battery_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_suspend_ac_seconds)
    pub idle_suspend_ac_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_suspend_supressed)
    pub idle_suspend_supressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_adaptive_brightness_available)
    pub is_adaptive_brightness_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_adaptive_brightness_enabled)
    pub display_adaptive_brightness_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_enabled)
    pub display_nightmode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_tintstrength)
    pub display_nightmode_tintstrength: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_maxhue)
    pub display_nightmode_maxhue: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_maxsat)
    pub display_nightmode_maxsat: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_uiexp)
    pub display_nightmode_uiexp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_blend)
    pub display_nightmode_blend: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_reset)
    pub display_nightmode_reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_schedule_enabled)
    pub display_nightmode_schedule_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_schedule_starttime)
    pub display_nightmode_schedule_starttime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_schedule_endtime)
    pub display_nightmode_schedule_endtime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_diagnostics_enabled)
    pub display_diagnostics_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.als_lux_primary)
    pub als_lux_primary: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.als_lux_median)
    pub als_lux_median: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_backlight_raw)
    pub display_backlight_raw: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_brightness_adaptivemin)
    pub display_brightness_adaptivemin: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_brightness_adaptivemax)
    pub display_brightness_adaptivemax: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_wifi_powersave_enabled)
    pub is_wifi_powersave_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_fan_control_available)
    pub is_fan_control_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.fan_control_mode)
    pub fan_control_mode: ::std::option::Option<crate::EnumOrUnknown<super::enums::ESystemFanControlMode>>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_display_brightness_available)
    pub is_display_brightness_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_display_colormanagement_available)
    pub is_display_colormanagement_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_colorgamut)
    pub display_colorgamut: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.als_lux_alternate)
    pub als_lux_alternate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_display_colortemp_available)
    pub is_display_colortemp_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_colortemp)
    pub display_colortemp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_colortemp_default)
    pub display_colortemp_default: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_colortemp_enabled)
    pub display_colortemp_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_colorgamut_labelset)
    pub display_colorgamut_labelset: ::std::option::Option<crate::EnumOrUnknown<super::enums::EColorGamutLabelSet>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemManagerSettings.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemManagerSettings {
    fn default() -> &'a CMsgSystemManagerSettings {
        <CMsgSystemManagerSettings as crate::Message>::default_instance()
    }
}

impl CMsgSystemManagerSettings {
    pub fn new() -> CMsgSystemManagerSettings {
        ::std::default::Default::default()
    }

    // optional float idle_backlight_dim_battery_seconds = 1;

    pub fn idle_backlight_dim_battery_seconds(&self) -> f32 {
        self.idle_backlight_dim_battery_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_backlight_dim_battery_seconds(&mut self) {
        self.idle_backlight_dim_battery_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_backlight_dim_battery_seconds(&self) -> bool {
        self.idle_backlight_dim_battery_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_backlight_dim_battery_seconds(&mut self, v: f32) {
        self.idle_backlight_dim_battery_seconds = ::std::option::Option::Some(v);
    }

    // optional float idle_backlight_dim_ac_seconds = 2;

    pub fn idle_backlight_dim_ac_seconds(&self) -> f32 {
        self.idle_backlight_dim_ac_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_backlight_dim_ac_seconds(&mut self) {
        self.idle_backlight_dim_ac_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_backlight_dim_ac_seconds(&self) -> bool {
        self.idle_backlight_dim_ac_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_backlight_dim_ac_seconds(&mut self, v: f32) {
        self.idle_backlight_dim_ac_seconds = ::std::option::Option::Some(v);
    }

    // optional float idle_suspend_battery_seconds = 3;

    pub fn idle_suspend_battery_seconds(&self) -> f32 {
        self.idle_suspend_battery_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_suspend_battery_seconds(&mut self) {
        self.idle_suspend_battery_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_suspend_battery_seconds(&self) -> bool {
        self.idle_suspend_battery_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_suspend_battery_seconds(&mut self, v: f32) {
        self.idle_suspend_battery_seconds = ::std::option::Option::Some(v);
    }

    // optional float idle_suspend_ac_seconds = 4;

    pub fn idle_suspend_ac_seconds(&self) -> f32 {
        self.idle_suspend_ac_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_suspend_ac_seconds(&mut self) {
        self.idle_suspend_ac_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_suspend_ac_seconds(&self) -> bool {
        self.idle_suspend_ac_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_suspend_ac_seconds(&mut self, v: f32) {
        self.idle_suspend_ac_seconds = ::std::option::Option::Some(v);
    }

    // optional bool idle_suspend_supressed = 5;

    pub fn idle_suspend_supressed(&self) -> bool {
        self.idle_suspend_supressed.unwrap_or(false)
    }

    pub fn clear_idle_suspend_supressed(&mut self) {
        self.idle_suspend_supressed = ::std::option::Option::None;
    }

    pub fn has_idle_suspend_supressed(&self) -> bool {
        self.idle_suspend_supressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_suspend_supressed(&mut self, v: bool) {
        self.idle_suspend_supressed = ::std::option::Option::Some(v);
    }

    // optional bool is_adaptive_brightness_available = 6;

    pub fn is_adaptive_brightness_available(&self) -> bool {
        self.is_adaptive_brightness_available.unwrap_or(false)
    }

    pub fn clear_is_adaptive_brightness_available(&mut self) {
        self.is_adaptive_brightness_available = ::std::option::Option::None;
    }

    pub fn has_is_adaptive_brightness_available(&self) -> bool {
        self.is_adaptive_brightness_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_adaptive_brightness_available(&mut self, v: bool) {
        self.is_adaptive_brightness_available = ::std::option::Option::Some(v);
    }

    // optional bool display_adaptive_brightness_enabled = 7;

    pub fn display_adaptive_brightness_enabled(&self) -> bool {
        self.display_adaptive_brightness_enabled.unwrap_or(false)
    }

    pub fn clear_display_adaptive_brightness_enabled(&mut self) {
        self.display_adaptive_brightness_enabled = ::std::option::Option::None;
    }

    pub fn has_display_adaptive_brightness_enabled(&self) -> bool {
        self.display_adaptive_brightness_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_adaptive_brightness_enabled(&mut self, v: bool) {
        self.display_adaptive_brightness_enabled = ::std::option::Option::Some(v);
    }

    // optional bool display_nightmode_enabled = 10;

    pub fn display_nightmode_enabled(&self) -> bool {
        self.display_nightmode_enabled.unwrap_or(false)
    }

    pub fn clear_display_nightmode_enabled(&mut self) {
        self.display_nightmode_enabled = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_enabled(&self) -> bool {
        self.display_nightmode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_enabled(&mut self, v: bool) {
        self.display_nightmode_enabled = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_tintstrength = 11;

    pub fn display_nightmode_tintstrength(&self) -> f32 {
        self.display_nightmode_tintstrength.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_tintstrength(&mut self) {
        self.display_nightmode_tintstrength = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_tintstrength(&self) -> bool {
        self.display_nightmode_tintstrength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_tintstrength(&mut self, v: f32) {
        self.display_nightmode_tintstrength = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_maxhue = 12;

    pub fn display_nightmode_maxhue(&self) -> f32 {
        self.display_nightmode_maxhue.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_maxhue(&mut self) {
        self.display_nightmode_maxhue = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_maxhue(&self) -> bool {
        self.display_nightmode_maxhue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_maxhue(&mut self, v: f32) {
        self.display_nightmode_maxhue = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_maxsat = 13;

    pub fn display_nightmode_maxsat(&self) -> f32 {
        self.display_nightmode_maxsat.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_maxsat(&mut self) {
        self.display_nightmode_maxsat = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_maxsat(&self) -> bool {
        self.display_nightmode_maxsat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_maxsat(&mut self, v: f32) {
        self.display_nightmode_maxsat = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_uiexp = 14;

    pub fn display_nightmode_uiexp(&self) -> f32 {
        self.display_nightmode_uiexp.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_uiexp(&mut self) {
        self.display_nightmode_uiexp = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_uiexp(&self) -> bool {
        self.display_nightmode_uiexp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_uiexp(&mut self, v: f32) {
        self.display_nightmode_uiexp = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_blend = 15;

    pub fn display_nightmode_blend(&self) -> f32 {
        self.display_nightmode_blend.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_blend(&mut self) {
        self.display_nightmode_blend = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_blend(&self) -> bool {
        self.display_nightmode_blend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_blend(&mut self, v: f32) {
        self.display_nightmode_blend = ::std::option::Option::Some(v);
    }

    // optional bool display_nightmode_reset = 16;

    pub fn display_nightmode_reset(&self) -> bool {
        self.display_nightmode_reset.unwrap_or(false)
    }

    pub fn clear_display_nightmode_reset(&mut self) {
        self.display_nightmode_reset = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_reset(&self) -> bool {
        self.display_nightmode_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_reset(&mut self, v: bool) {
        self.display_nightmode_reset = ::std::option::Option::Some(v);
    }

    // optional bool display_nightmode_schedule_enabled = 17;

    pub fn display_nightmode_schedule_enabled(&self) -> bool {
        self.display_nightmode_schedule_enabled.unwrap_or(false)
    }

    pub fn clear_display_nightmode_schedule_enabled(&mut self) {
        self.display_nightmode_schedule_enabled = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_schedule_enabled(&self) -> bool {
        self.display_nightmode_schedule_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_schedule_enabled(&mut self, v: bool) {
        self.display_nightmode_schedule_enabled = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_schedule_starttime = 18;

    pub fn display_nightmode_schedule_starttime(&self) -> f32 {
        self.display_nightmode_schedule_starttime.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_schedule_starttime(&mut self) {
        self.display_nightmode_schedule_starttime = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_schedule_starttime(&self) -> bool {
        self.display_nightmode_schedule_starttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_schedule_starttime(&mut self, v: f32) {
        self.display_nightmode_schedule_starttime = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_schedule_endtime = 19;

    pub fn display_nightmode_schedule_endtime(&self) -> f32 {
        self.display_nightmode_schedule_endtime.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_schedule_endtime(&mut self) {
        self.display_nightmode_schedule_endtime = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_schedule_endtime(&self) -> bool {
        self.display_nightmode_schedule_endtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_schedule_endtime(&mut self, v: f32) {
        self.display_nightmode_schedule_endtime = ::std::option::Option::Some(v);
    }

    // optional bool display_diagnostics_enabled = 20;

    pub fn display_diagnostics_enabled(&self) -> bool {
        self.display_diagnostics_enabled.unwrap_or(false)
    }

    pub fn clear_display_diagnostics_enabled(&mut self) {
        self.display_diagnostics_enabled = ::std::option::Option::None;
    }

    pub fn has_display_diagnostics_enabled(&self) -> bool {
        self.display_diagnostics_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_diagnostics_enabled(&mut self, v: bool) {
        self.display_diagnostics_enabled = ::std::option::Option::Some(v);
    }

    // optional float als_lux_primary = 21;

    pub fn als_lux_primary(&self) -> f32 {
        self.als_lux_primary.unwrap_or(0.)
    }

    pub fn clear_als_lux_primary(&mut self) {
        self.als_lux_primary = ::std::option::Option::None;
    }

    pub fn has_als_lux_primary(&self) -> bool {
        self.als_lux_primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_als_lux_primary(&mut self, v: f32) {
        self.als_lux_primary = ::std::option::Option::Some(v);
    }

    // optional float als_lux_median = 22;

    pub fn als_lux_median(&self) -> f32 {
        self.als_lux_median.unwrap_or(0.)
    }

    pub fn clear_als_lux_median(&mut self) {
        self.als_lux_median = ::std::option::Option::None;
    }

    pub fn has_als_lux_median(&self) -> bool {
        self.als_lux_median.is_some()
    }

    // Param is passed by value, moved
    pub fn set_als_lux_median(&mut self, v: f32) {
        self.als_lux_median = ::std::option::Option::Some(v);
    }

    // optional float display_backlight_raw = 23;

    pub fn display_backlight_raw(&self) -> f32 {
        self.display_backlight_raw.unwrap_or(0.)
    }

    pub fn clear_display_backlight_raw(&mut self) {
        self.display_backlight_raw = ::std::option::Option::None;
    }

    pub fn has_display_backlight_raw(&self) -> bool {
        self.display_backlight_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_backlight_raw(&mut self, v: f32) {
        self.display_backlight_raw = ::std::option::Option::Some(v);
    }

    // optional float display_brightness_adaptivemin = 24;

    pub fn display_brightness_adaptivemin(&self) -> f32 {
        self.display_brightness_adaptivemin.unwrap_or(0.)
    }

    pub fn clear_display_brightness_adaptivemin(&mut self) {
        self.display_brightness_adaptivemin = ::std::option::Option::None;
    }

    pub fn has_display_brightness_adaptivemin(&self) -> bool {
        self.display_brightness_adaptivemin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_brightness_adaptivemin(&mut self, v: f32) {
        self.display_brightness_adaptivemin = ::std::option::Option::Some(v);
    }

    // optional float display_brightness_adaptivemax = 25;

    pub fn display_brightness_adaptivemax(&self) -> f32 {
        self.display_brightness_adaptivemax.unwrap_or(0.)
    }

    pub fn clear_display_brightness_adaptivemax(&mut self) {
        self.display_brightness_adaptivemax = ::std::option::Option::None;
    }

    pub fn has_display_brightness_adaptivemax(&self) -> bool {
        self.display_brightness_adaptivemax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_brightness_adaptivemax(&mut self, v: f32) {
        self.display_brightness_adaptivemax = ::std::option::Option::Some(v);
    }

    // optional bool is_wifi_powersave_enabled = 26;

    pub fn is_wifi_powersave_enabled(&self) -> bool {
        self.is_wifi_powersave_enabled.unwrap_or(false)
    }

    pub fn clear_is_wifi_powersave_enabled(&mut self) {
        self.is_wifi_powersave_enabled = ::std::option::Option::None;
    }

    pub fn has_is_wifi_powersave_enabled(&self) -> bool {
        self.is_wifi_powersave_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_wifi_powersave_enabled(&mut self, v: bool) {
        self.is_wifi_powersave_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_fan_control_available = 27;

    pub fn is_fan_control_available(&self) -> bool {
        self.is_fan_control_available.unwrap_or(false)
    }

    pub fn clear_is_fan_control_available(&mut self) {
        self.is_fan_control_available = ::std::option::Option::None;
    }

    pub fn has_is_fan_control_available(&self) -> bool {
        self.is_fan_control_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fan_control_available(&mut self, v: bool) {
        self.is_fan_control_available = ::std::option::Option::Some(v);
    }

    // optional .ESystemFanControlMode fan_control_mode = 28;

    pub fn fan_control_mode(&self) -> super::enums::ESystemFanControlMode {
        match self.fan_control_mode {
            Some(e) => e.enum_value_or(super::enums::ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            None => super::enums::ESystemFanControlMode::k_SystemFanControlMode_Invalid,
        }
    }

    pub fn clear_fan_control_mode(&mut self) {
        self.fan_control_mode = ::std::option::Option::None;
    }

    pub fn has_fan_control_mode(&self) -> bool {
        self.fan_control_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fan_control_mode(&mut self, v: super::enums::ESystemFanControlMode) {
        self.fan_control_mode = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool is_display_brightness_available = 29;

    pub fn is_display_brightness_available(&self) -> bool {
        self.is_display_brightness_available.unwrap_or(false)
    }

    pub fn clear_is_display_brightness_available(&mut self) {
        self.is_display_brightness_available = ::std::option::Option::None;
    }

    pub fn has_is_display_brightness_available(&self) -> bool {
        self.is_display_brightness_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_display_brightness_available(&mut self, v: bool) {
        self.is_display_brightness_available = ::std::option::Option::Some(v);
    }

    // optional bool is_display_colormanagement_available = 31;

    pub fn is_display_colormanagement_available(&self) -> bool {
        self.is_display_colormanagement_available.unwrap_or(false)
    }

    pub fn clear_is_display_colormanagement_available(&mut self) {
        self.is_display_colormanagement_available = ::std::option::Option::None;
    }

    pub fn has_is_display_colormanagement_available(&self) -> bool {
        self.is_display_colormanagement_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_display_colormanagement_available(&mut self, v: bool) {
        self.is_display_colormanagement_available = ::std::option::Option::Some(v);
    }

    // optional float display_colorgamut = 32;

    pub fn display_colorgamut(&self) -> f32 {
        self.display_colorgamut.unwrap_or(0.)
    }

    pub fn clear_display_colorgamut(&mut self) {
        self.display_colorgamut = ::std::option::Option::None;
    }

    pub fn has_display_colorgamut(&self) -> bool {
        self.display_colorgamut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_colorgamut(&mut self, v: f32) {
        self.display_colorgamut = ::std::option::Option::Some(v);
    }

    // optional float als_lux_alternate = 33;

    pub fn als_lux_alternate(&self) -> f32 {
        self.als_lux_alternate.unwrap_or(0.)
    }

    pub fn clear_als_lux_alternate(&mut self) {
        self.als_lux_alternate = ::std::option::Option::None;
    }

    pub fn has_als_lux_alternate(&self) -> bool {
        self.als_lux_alternate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_als_lux_alternate(&mut self, v: f32) {
        self.als_lux_alternate = ::std::option::Option::Some(v);
    }

    // optional bool is_display_colortemp_available = 34;

    pub fn is_display_colortemp_available(&self) -> bool {
        self.is_display_colortemp_available.unwrap_or(false)
    }

    pub fn clear_is_display_colortemp_available(&mut self) {
        self.is_display_colortemp_available = ::std::option::Option::None;
    }

    pub fn has_is_display_colortemp_available(&self) -> bool {
        self.is_display_colortemp_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_display_colortemp_available(&mut self, v: bool) {
        self.is_display_colortemp_available = ::std::option::Option::Some(v);
    }

    // optional float display_colortemp = 35;

    pub fn display_colortemp(&self) -> f32 {
        self.display_colortemp.unwrap_or(0.)
    }

    pub fn clear_display_colortemp(&mut self) {
        self.display_colortemp = ::std::option::Option::None;
    }

    pub fn has_display_colortemp(&self) -> bool {
        self.display_colortemp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_colortemp(&mut self, v: f32) {
        self.display_colortemp = ::std::option::Option::Some(v);
    }

    // optional float display_colortemp_default = 36;

    pub fn display_colortemp_default(&self) -> f32 {
        self.display_colortemp_default.unwrap_or(0.)
    }

    pub fn clear_display_colortemp_default(&mut self) {
        self.display_colortemp_default = ::std::option::Option::None;
    }

    pub fn has_display_colortemp_default(&self) -> bool {
        self.display_colortemp_default.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_colortemp_default(&mut self, v: f32) {
        self.display_colortemp_default = ::std::option::Option::Some(v);
    }

    // optional bool display_colortemp_enabled = 37;

    pub fn display_colortemp_enabled(&self) -> bool {
        self.display_colortemp_enabled.unwrap_or(false)
    }

    pub fn clear_display_colortemp_enabled(&mut self) {
        self.display_colortemp_enabled = ::std::option::Option::None;
    }

    pub fn has_display_colortemp_enabled(&self) -> bool {
        self.display_colortemp_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_colortemp_enabled(&mut self, v: bool) {
        self.display_colortemp_enabled = ::std::option::Option::Some(v);
    }

    // optional .EColorGamutLabelSet display_colorgamut_labelset = 38;

    pub fn display_colorgamut_labelset(&self) -> super::enums::EColorGamutLabelSet {
        match self.display_colorgamut_labelset {
            Some(e) => e.enum_value_or(super::enums::EColorGamutLabelSet::k_ColorGamutLabelSet_Default),
            None => super::enums::EColorGamutLabelSet::k_ColorGamutLabelSet_Default,
        }
    }

    pub fn clear_display_colorgamut_labelset(&mut self) {
        self.display_colorgamut_labelset = ::std::option::Option::None;
    }

    pub fn has_display_colorgamut_labelset(&self) -> bool {
        self.display_colorgamut_labelset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_colorgamut_labelset(&mut self, v: super::enums::EColorGamutLabelSet) {
        self.display_colorgamut_labelset = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(35);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_backlight_dim_battery_seconds",
            |m: &CMsgSystemManagerSettings| { &m.idle_backlight_dim_battery_seconds },
            |m: &mut CMsgSystemManagerSettings| { &mut m.idle_backlight_dim_battery_seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_backlight_dim_ac_seconds",
            |m: &CMsgSystemManagerSettings| { &m.idle_backlight_dim_ac_seconds },
            |m: &mut CMsgSystemManagerSettings| { &mut m.idle_backlight_dim_ac_seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_suspend_battery_seconds",
            |m: &CMsgSystemManagerSettings| { &m.idle_suspend_battery_seconds },
            |m: &mut CMsgSystemManagerSettings| { &mut m.idle_suspend_battery_seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_suspend_ac_seconds",
            |m: &CMsgSystemManagerSettings| { &m.idle_suspend_ac_seconds },
            |m: &mut CMsgSystemManagerSettings| { &mut m.idle_suspend_ac_seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_suspend_supressed",
            |m: &CMsgSystemManagerSettings| { &m.idle_suspend_supressed },
            |m: &mut CMsgSystemManagerSettings| { &mut m.idle_suspend_supressed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_adaptive_brightness_available",
            |m: &CMsgSystemManagerSettings| { &m.is_adaptive_brightness_available },
            |m: &mut CMsgSystemManagerSettings| { &mut m.is_adaptive_brightness_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_adaptive_brightness_enabled",
            |m: &CMsgSystemManagerSettings| { &m.display_adaptive_brightness_enabled },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_adaptive_brightness_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_enabled",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_enabled },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_tintstrength",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_tintstrength },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_tintstrength },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_maxhue",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_maxhue },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_maxhue },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_maxsat",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_maxsat },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_maxsat },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_uiexp",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_uiexp },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_uiexp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_blend",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_blend },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_blend },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_reset",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_reset },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_reset },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_schedule_enabled",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_schedule_enabled },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_schedule_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_schedule_starttime",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_schedule_starttime },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_schedule_starttime },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_nightmode_schedule_endtime",
            |m: &CMsgSystemManagerSettings| { &m.display_nightmode_schedule_endtime },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_nightmode_schedule_endtime },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_diagnostics_enabled",
            |m: &CMsgSystemManagerSettings| { &m.display_diagnostics_enabled },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_diagnostics_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "als_lux_primary",
            |m: &CMsgSystemManagerSettings| { &m.als_lux_primary },
            |m: &mut CMsgSystemManagerSettings| { &mut m.als_lux_primary },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "als_lux_median",
            |m: &CMsgSystemManagerSettings| { &m.als_lux_median },
            |m: &mut CMsgSystemManagerSettings| { &mut m.als_lux_median },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_backlight_raw",
            |m: &CMsgSystemManagerSettings| { &m.display_backlight_raw },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_backlight_raw },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_brightness_adaptivemin",
            |m: &CMsgSystemManagerSettings| { &m.display_brightness_adaptivemin },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_brightness_adaptivemin },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_brightness_adaptivemax",
            |m: &CMsgSystemManagerSettings| { &m.display_brightness_adaptivemax },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_brightness_adaptivemax },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_wifi_powersave_enabled",
            |m: &CMsgSystemManagerSettings| { &m.is_wifi_powersave_enabled },
            |m: &mut CMsgSystemManagerSettings| { &mut m.is_wifi_powersave_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_fan_control_available",
            |m: &CMsgSystemManagerSettings| { &m.is_fan_control_available },
            |m: &mut CMsgSystemManagerSettings| { &mut m.is_fan_control_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fan_control_mode",
            |m: &CMsgSystemManagerSettings| { &m.fan_control_mode },
            |m: &mut CMsgSystemManagerSettings| { &mut m.fan_control_mode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_display_brightness_available",
            |m: &CMsgSystemManagerSettings| { &m.is_display_brightness_available },
            |m: &mut CMsgSystemManagerSettings| { &mut m.is_display_brightness_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_display_colormanagement_available",
            |m: &CMsgSystemManagerSettings| { &m.is_display_colormanagement_available },
            |m: &mut CMsgSystemManagerSettings| { &mut m.is_display_colormanagement_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_colorgamut",
            |m: &CMsgSystemManagerSettings| { &m.display_colorgamut },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_colorgamut },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "als_lux_alternate",
            |m: &CMsgSystemManagerSettings| { &m.als_lux_alternate },
            |m: &mut CMsgSystemManagerSettings| { &mut m.als_lux_alternate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_display_colortemp_available",
            |m: &CMsgSystemManagerSettings| { &m.is_display_colortemp_available },
            |m: &mut CMsgSystemManagerSettings| { &mut m.is_display_colortemp_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_colortemp",
            |m: &CMsgSystemManagerSettings| { &m.display_colortemp },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_colortemp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_colortemp_default",
            |m: &CMsgSystemManagerSettings| { &m.display_colortemp_default },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_colortemp_default },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_colortemp_enabled",
            |m: &CMsgSystemManagerSettings| { &m.display_colortemp_enabled },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_colortemp_enabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_colorgamut_labelset",
            |m: &CMsgSystemManagerSettings| { &m.display_colorgamut_labelset },
            |m: &mut CMsgSystemManagerSettings| { &mut m.display_colorgamut_labelset },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemManagerSettings>(
            "CMsgSystemManagerSettings",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemManagerSettings {
    const NAME: &'static str = "CMsgSystemManagerSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.idle_backlight_dim_battery_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.idle_backlight_dim_ac_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.idle_suspend_battery_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.idle_suspend_ac_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.idle_suspend_supressed = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_adaptive_brightness_available = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.display_adaptive_brightness_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.display_nightmode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                93 => {
                    self.display_nightmode_tintstrength = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.display_nightmode_maxhue = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.display_nightmode_maxsat = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.display_nightmode_uiexp = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.display_nightmode_blend = ::std::option::Option::Some(is.read_float()?);
                },
                128 => {
                    self.display_nightmode_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.display_nightmode_schedule_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                149 => {
                    self.display_nightmode_schedule_starttime = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.display_nightmode_schedule_endtime = ::std::option::Option::Some(is.read_float()?);
                },
                160 => {
                    self.display_diagnostics_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                173 => {
                    self.als_lux_primary = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.als_lux_median = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.display_backlight_raw = ::std::option::Option::Some(is.read_float()?);
                },
                197 => {
                    self.display_brightness_adaptivemin = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.display_brightness_adaptivemax = ::std::option::Option::Some(is.read_float()?);
                },
                208 => {
                    self.is_wifi_powersave_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.is_fan_control_available = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.fan_control_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                232 => {
                    self.is_display_brightness_available = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.is_display_colormanagement_available = ::std::option::Option::Some(is.read_bool()?);
                },
                261 => {
                    self.display_colorgamut = ::std::option::Option::Some(is.read_float()?);
                },
                269 => {
                    self.als_lux_alternate = ::std::option::Option::Some(is.read_float()?);
                },
                272 => {
                    self.is_display_colortemp_available = ::std::option::Option::Some(is.read_bool()?);
                },
                285 => {
                    self.display_colortemp = ::std::option::Option::Some(is.read_float()?);
                },
                293 => {
                    self.display_colortemp_default = ::std::option::Option::Some(is.read_float()?);
                },
                296 => {
                    self.display_colortemp_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                304 => {
                    self.display_colorgamut_labelset = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.idle_backlight_dim_battery_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_backlight_dim_ac_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_suspend_battery_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_suspend_ac_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_suspend_supressed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_adaptive_brightness_available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_adaptive_brightness_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_nightmode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_nightmode_tintstrength {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_maxhue {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_maxsat {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_uiexp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_blend {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_reset {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_nightmode_schedule_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_nightmode_schedule_starttime {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_nightmode_schedule_endtime {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_diagnostics_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.als_lux_primary {
            my_size += 2 + 4;
        }
        if let Some(v) = self.als_lux_median {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_backlight_raw {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_brightness_adaptivemin {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_brightness_adaptivemax {
            my_size += 2 + 4;
        }
        if let Some(v) = self.is_wifi_powersave_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_fan_control_available {
            my_size += 2 + 1;
        }
        if let Some(v) = self.fan_control_mode {
            my_size += crate::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.is_display_brightness_available {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_display_colormanagement_available {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_colorgamut {
            my_size += 2 + 4;
        }
        if let Some(v) = self.als_lux_alternate {
            my_size += 2 + 4;
        }
        if let Some(v) = self.is_display_colortemp_available {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_colortemp {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_colortemp_default {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_colortemp_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_colorgamut_labelset {
            my_size += crate::rt::int32_size(38, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.idle_backlight_dim_battery_seconds {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.idle_backlight_dim_ac_seconds {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.idle_suspend_battery_seconds {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.idle_suspend_ac_seconds {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.idle_suspend_supressed {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_adaptive_brightness_available {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.display_adaptive_brightness_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.display_nightmode_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.display_nightmode_tintstrength {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.display_nightmode_maxhue {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.display_nightmode_maxsat {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.display_nightmode_uiexp {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.display_nightmode_blend {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.display_nightmode_reset {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.display_nightmode_schedule_enabled {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.display_nightmode_schedule_starttime {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.display_nightmode_schedule_endtime {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.display_diagnostics_enabled {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.als_lux_primary {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.als_lux_median {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.display_backlight_raw {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.display_brightness_adaptivemin {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.display_brightness_adaptivemax {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.is_wifi_powersave_enabled {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.is_fan_control_available {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.fan_control_mode {
            os.write_enum(28, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_display_brightness_available {
            os.write_bool(29, v)?;
        }
        if let Some(v) = self.is_display_colormanagement_available {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.display_colorgamut {
            os.write_float(32, v)?;
        }
        if let Some(v) = self.als_lux_alternate {
            os.write_float(33, v)?;
        }
        if let Some(v) = self.is_display_colortemp_available {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.display_colortemp {
            os.write_float(35, v)?;
        }
        if let Some(v) = self.display_colortemp_default {
            os.write_float(36, v)?;
        }
        if let Some(v) = self.display_colortemp_enabled {
            os.write_bool(37, v)?;
        }
        if let Some(v) = self.display_colorgamut_labelset {
            os.write_enum(38, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemManagerSettings {
        CMsgSystemManagerSettings::new()
    }

    fn clear(&mut self) {
        self.idle_backlight_dim_battery_seconds = ::std::option::Option::None;
        self.idle_backlight_dim_ac_seconds = ::std::option::Option::None;
        self.idle_suspend_battery_seconds = ::std::option::Option::None;
        self.idle_suspend_ac_seconds = ::std::option::Option::None;
        self.idle_suspend_supressed = ::std::option::Option::None;
        self.is_adaptive_brightness_available = ::std::option::Option::None;
        self.display_adaptive_brightness_enabled = ::std::option::Option::None;
        self.display_nightmode_enabled = ::std::option::Option::None;
        self.display_nightmode_tintstrength = ::std::option::Option::None;
        self.display_nightmode_maxhue = ::std::option::Option::None;
        self.display_nightmode_maxsat = ::std::option::Option::None;
        self.display_nightmode_uiexp = ::std::option::Option::None;
        self.display_nightmode_blend = ::std::option::Option::None;
        self.display_nightmode_reset = ::std::option::Option::None;
        self.display_nightmode_schedule_enabled = ::std::option::Option::None;
        self.display_nightmode_schedule_starttime = ::std::option::Option::None;
        self.display_nightmode_schedule_endtime = ::std::option::Option::None;
        self.display_diagnostics_enabled = ::std::option::Option::None;
        self.als_lux_primary = ::std::option::Option::None;
        self.als_lux_median = ::std::option::Option::None;
        self.display_backlight_raw = ::std::option::Option::None;
        self.display_brightness_adaptivemin = ::std::option::Option::None;
        self.display_brightness_adaptivemax = ::std::option::Option::None;
        self.is_wifi_powersave_enabled = ::std::option::Option::None;
        self.is_fan_control_available = ::std::option::Option::None;
        self.fan_control_mode = ::std::option::Option::None;
        self.is_display_brightness_available = ::std::option::Option::None;
        self.is_display_colormanagement_available = ::std::option::Option::None;
        self.display_colorgamut = ::std::option::Option::None;
        self.als_lux_alternate = ::std::option::Option::None;
        self.is_display_colortemp_available = ::std::option::Option::None;
        self.display_colortemp = ::std::option::Option::None;
        self.display_colortemp_default = ::std::option::Option::None;
        self.display_colortemp_enabled = ::std::option::Option::None;
        self.display_colorgamut_labelset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemManagerSettings {
        static instance: CMsgSystemManagerSettings = CMsgSystemManagerSettings {
            idle_backlight_dim_battery_seconds: ::std::option::Option::None,
            idle_backlight_dim_ac_seconds: ::std::option::Option::None,
            idle_suspend_battery_seconds: ::std::option::Option::None,
            idle_suspend_ac_seconds: ::std::option::Option::None,
            idle_suspend_supressed: ::std::option::Option::None,
            is_adaptive_brightness_available: ::std::option::Option::None,
            display_adaptive_brightness_enabled: ::std::option::Option::None,
            display_nightmode_enabled: ::std::option::Option::None,
            display_nightmode_tintstrength: ::std::option::Option::None,
            display_nightmode_maxhue: ::std::option::Option::None,
            display_nightmode_maxsat: ::std::option::Option::None,
            display_nightmode_uiexp: ::std::option::Option::None,
            display_nightmode_blend: ::std::option::Option::None,
            display_nightmode_reset: ::std::option::Option::None,
            display_nightmode_schedule_enabled: ::std::option::Option::None,
            display_nightmode_schedule_starttime: ::std::option::Option::None,
            display_nightmode_schedule_endtime: ::std::option::Option::None,
            display_diagnostics_enabled: ::std::option::Option::None,
            als_lux_primary: ::std::option::Option::None,
            als_lux_median: ::std::option::Option::None,
            display_backlight_raw: ::std::option::Option::None,
            display_brightness_adaptivemin: ::std::option::Option::None,
            display_brightness_adaptivemax: ::std::option::Option::None,
            is_wifi_powersave_enabled: ::std::option::Option::None,
            is_fan_control_available: ::std::option::Option::None,
            fan_control_mode: ::std::option::Option::None,
            is_display_brightness_available: ::std::option::Option::None,
            is_display_colormanagement_available: ::std::option::Option::None,
            display_colorgamut: ::std::option::Option::None,
            als_lux_alternate: ::std::option::Option::None,
            is_display_colortemp_available: ::std::option::Option::None,
            display_colortemp: ::std::option::Option::None,
            display_colortemp_default: ::std::option::Option::None,
            display_colortemp_enabled: ::std::option::Option::None,
            display_colorgamut_labelset: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemManagerSettings {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemManagerSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemManagerSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemManagerSettings {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSelectOSBranchParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSelectOSBranchParams {
    // message fields
    // @@protoc_insertion_point(field:CMsgSelectOSBranchParams.branch)
    pub branch: ::std::option::Option<crate::EnumOrUnknown<super::enums::EOSBranch>>,
    // @@protoc_insertion_point(field:CMsgSelectOSBranchParams.custom_branch)
    pub custom_branch: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSelectOSBranchParams.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSelectOSBranchParams {
    fn default() -> &'a CMsgSelectOSBranchParams {
        <CMsgSelectOSBranchParams as crate::Message>::default_instance()
    }
}

impl CMsgSelectOSBranchParams {
    pub fn new() -> CMsgSelectOSBranchParams {
        ::std::default::Default::default()
    }

    // optional .EOSBranch branch = 1;

    pub fn branch(&self) -> super::enums::EOSBranch {
        match self.branch {
            Some(e) => e.enum_value_or(super::enums::EOSBranch::k_EOSBranch_Unknown),
            None => super::enums::EOSBranch::k_EOSBranch_Unknown,
        }
    }

    pub fn clear_branch(&mut self) {
        self.branch = ::std::option::Option::None;
    }

    pub fn has_branch(&self) -> bool {
        self.branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch(&mut self, v: super::enums::EOSBranch) {
        self.branch = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string custom_branch = 2;

    pub fn custom_branch(&self) -> &str {
        match self.custom_branch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_branch(&mut self) {
        self.custom_branch = ::std::option::Option::None;
    }

    pub fn has_custom_branch(&self) -> bool {
        self.custom_branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_branch(&mut self, v: ::std::string::String) {
        self.custom_branch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_branch(&mut self) -> &mut ::std::string::String {
        if self.custom_branch.is_none() {
            self.custom_branch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_branch(&mut self) -> ::std::string::String {
        self.custom_branch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "branch",
            |m: &CMsgSelectOSBranchParams| { &m.branch },
            |m: &mut CMsgSelectOSBranchParams| { &mut m.branch },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_branch",
            |m: &CMsgSelectOSBranchParams| { &m.custom_branch },
            |m: &mut CMsgSelectOSBranchParams| { &mut m.custom_branch },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSelectOSBranchParams>(
            "CMsgSelectOSBranchParams",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSelectOSBranchParams {
    const NAME: &'static str = "CMsgSelectOSBranchParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.branch = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.custom_branch = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.branch {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.custom_branch.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.branch {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_branch.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSelectOSBranchParams {
        CMsgSelectOSBranchParams::new()
    }

    fn clear(&mut self) {
        self.branch = ::std::option::Option::None;
        self.custom_branch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSelectOSBranchParams {
        static instance: CMsgSelectOSBranchParams = CMsgSelectOSBranchParams {
            branch: ::std::option::Option::None,
            custom_branch: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSelectOSBranchParams {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSelectOSBranchParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSelectOSBranchParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSelectOSBranchParams {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemUpdateProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateProgress.stage_progress)
    pub stage_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateProgress.stage_size_bytes)
    pub stage_size_bytes: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateProgress.rtime_estimated_completion)
    pub rtime_estimated_completion: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateProgress.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateProgress {
    fn default() -> &'a CMsgSystemUpdateProgress {
        <CMsgSystemUpdateProgress as crate::Message>::default_instance()
    }
}

impl CMsgSystemUpdateProgress {
    pub fn new() -> CMsgSystemUpdateProgress {
        ::std::default::Default::default()
    }

    // optional float stage_progress = 1;

    pub fn stage_progress(&self) -> f32 {
        self.stage_progress.unwrap_or(0.)
    }

    pub fn clear_stage_progress(&mut self) {
        self.stage_progress = ::std::option::Option::None;
    }

    pub fn has_stage_progress(&self) -> bool {
        self.stage_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage_progress(&mut self, v: f32) {
        self.stage_progress = ::std::option::Option::Some(v);
    }

    // optional int64 stage_size_bytes = 2;

    pub fn stage_size_bytes(&self) -> i64 {
        self.stage_size_bytes.unwrap_or(0)
    }

    pub fn clear_stage_size_bytes(&mut self) {
        self.stage_size_bytes = ::std::option::Option::None;
    }

    pub fn has_stage_size_bytes(&self) -> bool {
        self.stage_size_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage_size_bytes(&mut self, v: i64) {
        self.stage_size_bytes = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_estimated_completion = 3;

    pub fn rtime_estimated_completion(&self) -> u32 {
        self.rtime_estimated_completion.unwrap_or(0)
    }

    pub fn clear_rtime_estimated_completion(&mut self) {
        self.rtime_estimated_completion = ::std::option::Option::None;
    }

    pub fn has_rtime_estimated_completion(&self) -> bool {
        self.rtime_estimated_completion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_estimated_completion(&mut self, v: u32) {
        self.rtime_estimated_completion = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stage_progress",
            |m: &CMsgSystemUpdateProgress| { &m.stage_progress },
            |m: &mut CMsgSystemUpdateProgress| { &mut m.stage_progress },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stage_size_bytes",
            |m: &CMsgSystemUpdateProgress| { &m.stage_size_bytes },
            |m: &mut CMsgSystemUpdateProgress| { &mut m.stage_size_bytes },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_estimated_completion",
            |m: &CMsgSystemUpdateProgress| { &m.rtime_estimated_completion },
            |m: &mut CMsgSystemUpdateProgress| { &mut m.rtime_estimated_completion },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemUpdateProgress>(
            "CMsgSystemUpdateProgress",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemUpdateProgress {
    const NAME: &'static str = "CMsgSystemUpdateProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.stage_progress = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.stage_size_bytes = ::std::option::Option::Some(is.read_int64()?);
                },
                29 => {
                    self.rtime_estimated_completion = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stage_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stage_size_bytes {
            my_size += crate::rt::int64_size(2, v);
        }
        if let Some(v) = self.rtime_estimated_completion {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.stage_progress {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.stage_size_bytes {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.rtime_estimated_completion {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateProgress {
        CMsgSystemUpdateProgress::new()
    }

    fn clear(&mut self) {
        self.stage_progress = ::std::option::Option::None;
        self.stage_size_bytes = ::std::option::Option::None;
        self.rtime_estimated_completion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateProgress {
        static instance: CMsgSystemUpdateProgress = CMsgSystemUpdateProgress {
            stage_progress: ::std::option::Option::None,
            stage_size_bytes: ::std::option::Option::None,
            rtime_estimated_completion: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemUpdateProgress {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemUpdateProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemUpdateProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemUpdateProgress {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemUpdateCheckResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateCheckResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<super::enums::EUpdaterType>>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.rtime_checked)
    pub rtime_checked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.available)
    pub available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.auto_message)
    pub auto_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateCheckResult.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateCheckResult {
    fn default() -> &'a CMsgSystemUpdateCheckResult {
        <CMsgSystemUpdateCheckResult as crate::Message>::default_instance()
    }
}

impl CMsgSystemUpdateCheckResult {
    pub fn new() -> CMsgSystemUpdateCheckResult {
        ::std::default::Default::default()
    }

    // optional .EUpdaterType type = 1;

    pub fn type_(&self) -> super::enums::EUpdaterType {
        match self.type_ {
            Some(e) => e.enum_value_or(super::enums::EUpdaterType::k_EUpdaterType_Invalid),
            None => super::enums::EUpdaterType::k_EUpdaterType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: super::enums::EUpdaterType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_checked = 3;

    pub fn rtime_checked(&self) -> u32 {
        self.rtime_checked.unwrap_or(0)
    }

    pub fn clear_rtime_checked(&mut self) {
        self.rtime_checked = ::std::option::Option::None;
    }

    pub fn has_rtime_checked(&self) -> bool {
        self.rtime_checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_checked(&mut self, v: u32) {
        self.rtime_checked = ::std::option::Option::Some(v);
    }

    // optional bool available = 4;

    pub fn available(&self) -> bool {
        self.available.unwrap_or(false)
    }

    pub fn clear_available(&mut self) {
        self.available = ::std::option::Option::None;
    }

    pub fn has_available(&self) -> bool {
        self.available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: bool) {
        self.available = ::std::option::Option::Some(v);
    }

    // optional string version = 5;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string auto_message = 6;

    pub fn auto_message(&self) -> &str {
        match self.auto_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_auto_message(&mut self) {
        self.auto_message = ::std::option::Option::None;
    }

    pub fn has_auto_message(&self) -> bool {
        self.auto_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_message(&mut self, v: ::std::string::String) {
        self.auto_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auto_message(&mut self) -> &mut ::std::string::String {
        if self.auto_message.is_none() {
            self.auto_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.auto_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_auto_message(&mut self) -> ::std::string::String {
        self.auto_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgSystemUpdateCheckResult| { &m.type_ },
            |m: &mut CMsgSystemUpdateCheckResult| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgSystemUpdateCheckResult| { &m.eresult },
            |m: &mut CMsgSystemUpdateCheckResult| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_checked",
            |m: &CMsgSystemUpdateCheckResult| { &m.rtime_checked },
            |m: &mut CMsgSystemUpdateCheckResult| { &mut m.rtime_checked },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "available",
            |m: &CMsgSystemUpdateCheckResult| { &m.available },
            |m: &mut CMsgSystemUpdateCheckResult| { &mut m.available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSystemUpdateCheckResult| { &m.version },
            |m: &mut CMsgSystemUpdateCheckResult| { &mut m.version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "auto_message",
            |m: &CMsgSystemUpdateCheckResult| { &m.auto_message },
            |m: &mut CMsgSystemUpdateCheckResult| { &mut m.auto_message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemUpdateCheckResult>(
            "CMsgSystemUpdateCheckResult",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemUpdateCheckResult {
    const NAME: &'static str = "CMsgSystemUpdateCheckResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.rtime_checked = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.available = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.auto_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rtime_checked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.version.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.auto_message.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rtime_checked {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.available {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.auto_message.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateCheckResult {
        CMsgSystemUpdateCheckResult::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.rtime_checked = ::std::option::Option::None;
        self.available = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.auto_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateCheckResult {
        static instance: CMsgSystemUpdateCheckResult = CMsgSystemUpdateCheckResult {
            type_: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            rtime_checked: ::std::option::Option::None,
            available: ::std::option::Option::None,
            version: ::std::option::Option::None,
            auto_message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemUpdateCheckResult {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemUpdateCheckResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemUpdateCheckResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemUpdateCheckResult {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemUpdateApplyParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateApplyParams {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyParams.apply_types)
    pub apply_types: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EUpdaterType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateApplyParams.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateApplyParams {
    fn default() -> &'a CMsgSystemUpdateApplyParams {
        <CMsgSystemUpdateApplyParams as crate::Message>::default_instance()
    }
}

impl CMsgSystemUpdateApplyParams {
    pub fn new() -> CMsgSystemUpdateApplyParams {
        ::std::default::Default::default()
    }

    // repeated .EUpdaterType apply_types = 1;

    pub fn apply_types(&self) -> &[crate::EnumOrUnknown<super::enums::EUpdaterType>] {
        &self.apply_types
    }

    pub fn clear_apply_types(&mut self) {
        self.apply_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_apply_types(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EUpdaterType>>) {
        self.apply_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apply_types(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EUpdaterType>> {
        &mut self.apply_types
    }

    // Take field
    pub fn take_apply_types(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<super::enums::EUpdaterType>> {
        ::std::mem::replace(&mut self.apply_types, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apply_types",
            |m: &CMsgSystemUpdateApplyParams| { &m.apply_types },
            |m: &mut CMsgSystemUpdateApplyParams| { &mut m.apply_types },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemUpdateApplyParams>(
            "CMsgSystemUpdateApplyParams",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemUpdateApplyParams {
    const NAME: &'static str = "CMsgSystemUpdateApplyParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.apply_types.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.apply_types)?
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apply_types {
            my_size += crate::rt::int32_size(1, value.value());
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.apply_types {
            os.write_enum(1, crate::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateApplyParams {
        CMsgSystemUpdateApplyParams::new()
    }

    fn clear(&mut self) {
        self.apply_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateApplyParams {
        static instance: CMsgSystemUpdateApplyParams = CMsgSystemUpdateApplyParams {
            apply_types: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemUpdateApplyParams {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemUpdateApplyParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemUpdateApplyParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemUpdateApplyParams {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemUpdateApplyResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateApplyResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<super::enums::EUpdaterType>>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.requires_client_restart)
    pub requires_client_restart: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.requires_system_restart)
    pub requires_system_restart: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateApplyResult.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateApplyResult {
    fn default() -> &'a CMsgSystemUpdateApplyResult {
        <CMsgSystemUpdateApplyResult as crate::Message>::default_instance()
    }
}

impl CMsgSystemUpdateApplyResult {
    pub fn new() -> CMsgSystemUpdateApplyResult {
        ::std::default::Default::default()
    }

    // optional .EUpdaterType type = 1;

    pub fn type_(&self) -> super::enums::EUpdaterType {
        match self.type_ {
            Some(e) => e.enum_value_or(super::enums::EUpdaterType::k_EUpdaterType_Invalid),
            None => super::enums::EUpdaterType::k_EUpdaterType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: super::enums::EUpdaterType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool requires_client_restart = 3;

    pub fn requires_client_restart(&self) -> bool {
        self.requires_client_restart.unwrap_or(false)
    }

    pub fn clear_requires_client_restart(&mut self) {
        self.requires_client_restart = ::std::option::Option::None;
    }

    pub fn has_requires_client_restart(&self) -> bool {
        self.requires_client_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_client_restart(&mut self, v: bool) {
        self.requires_client_restart = ::std::option::Option::Some(v);
    }

    // optional bool requires_system_restart = 4;

    pub fn requires_system_restart(&self) -> bool {
        self.requires_system_restart.unwrap_or(false)
    }

    pub fn clear_requires_system_restart(&mut self) {
        self.requires_system_restart = ::std::option::Option::None;
    }

    pub fn has_requires_system_restart(&self) -> bool {
        self.requires_system_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_system_restart(&mut self, v: bool) {
        self.requires_system_restart = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgSystemUpdateApplyResult| { &m.type_ },
            |m: &mut CMsgSystemUpdateApplyResult| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgSystemUpdateApplyResult| { &m.eresult },
            |m: &mut CMsgSystemUpdateApplyResult| { &mut m.eresult },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_client_restart",
            |m: &CMsgSystemUpdateApplyResult| { &m.requires_client_restart },
            |m: &mut CMsgSystemUpdateApplyResult| { &mut m.requires_client_restart },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_system_restart",
            |m: &CMsgSystemUpdateApplyResult| { &m.requires_system_restart },
            |m: &mut CMsgSystemUpdateApplyResult| { &mut m.requires_system_restart },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemUpdateApplyResult>(
            "CMsgSystemUpdateApplyResult",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemUpdateApplyResult {
    const NAME: &'static str = "CMsgSystemUpdateApplyResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.requires_client_restart = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.requires_system_restart = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.eresult {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.requires_client_restart {
            my_size += 1 + 1;
        }
        if let Some(v) = self.requires_system_restart {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.requires_client_restart {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.requires_system_restart {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateApplyResult {
        CMsgSystemUpdateApplyResult::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.requires_client_restart = ::std::option::Option::None;
        self.requires_system_restart = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateApplyResult {
        static instance: CMsgSystemUpdateApplyResult = CMsgSystemUpdateApplyResult {
            type_: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            requires_client_restart: ::std::option::Option::None,
            requires_system_restart: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemUpdateApplyResult {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemUpdateApplyResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemUpdateApplyResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemUpdateApplyResult {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSystemUpdateState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.state)
    pub state: ::std::option::Option<crate::EnumOrUnknown<super::enums::EUpdaterState>>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.progress)
    pub progress: crate::MessageField<CMsgSystemUpdateProgress>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.update_check_results)
    pub update_check_results: ::std::vec::Vec<CMsgSystemUpdateCheckResult>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.update_apply_results)
    pub update_apply_results: ::std::vec::Vec<CMsgSystemUpdateApplyResult>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.supports_os_updates)
    pub supports_os_updates: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateState {
    fn default() -> &'a CMsgSystemUpdateState {
        <CMsgSystemUpdateState as crate::Message>::default_instance()
    }
}

impl CMsgSystemUpdateState {
    pub fn new() -> CMsgSystemUpdateState {
        ::std::default::Default::default()
    }

    // optional .EUpdaterState state = 1;

    pub fn state(&self) -> super::enums::EUpdaterState {
        match self.state {
            Some(e) => e.enum_value_or(super::enums::EUpdaterState::k_EUpdaterState_Invalid),
            None => super::enums::EUpdaterState::k_EUpdaterState_Invalid,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::enums::EUpdaterState) {
        self.state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .CMsgSystemUpdateProgress progress = 2;

    pub fn progress(&self) -> &CMsgSystemUpdateProgress {
        self.progress.as_ref().unwrap_or_else(|| <CMsgSystemUpdateProgress as crate::Message>::default_instance())
    }

    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: CMsgSystemUpdateProgress) {
        self.progress = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut CMsgSystemUpdateProgress {
        self.progress.mut_or_insert_default()
    }

    // Take field
    pub fn take_progress(&mut self) -> CMsgSystemUpdateProgress {
        self.progress.take().unwrap_or_else(|| CMsgSystemUpdateProgress::new())
    }

    // repeated .CMsgSystemUpdateCheckResult update_check_results = 3;

    pub fn update_check_results(&self) -> &[CMsgSystemUpdateCheckResult] {
        &self.update_check_results
    }

    pub fn clear_update_check_results(&mut self) {
        self.update_check_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_update_check_results(&mut self, v: ::std::vec::Vec<CMsgSystemUpdateCheckResult>) {
        self.update_check_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_update_check_results(&mut self) -> &mut ::std::vec::Vec<CMsgSystemUpdateCheckResult> {
        &mut self.update_check_results
    }

    // Take field
    pub fn take_update_check_results(&mut self) -> ::std::vec::Vec<CMsgSystemUpdateCheckResult> {
        ::std::mem::replace(&mut self.update_check_results, ::std::vec::Vec::new())
    }

    // repeated .CMsgSystemUpdateApplyResult update_apply_results = 4;

    pub fn update_apply_results(&self) -> &[CMsgSystemUpdateApplyResult] {
        &self.update_apply_results
    }

    pub fn clear_update_apply_results(&mut self) {
        self.update_apply_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_update_apply_results(&mut self, v: ::std::vec::Vec<CMsgSystemUpdateApplyResult>) {
        self.update_apply_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_update_apply_results(&mut self) -> &mut ::std::vec::Vec<CMsgSystemUpdateApplyResult> {
        &mut self.update_apply_results
    }

    // Take field
    pub fn take_update_apply_results(&mut self) -> ::std::vec::Vec<CMsgSystemUpdateApplyResult> {
        ::std::mem::replace(&mut self.update_apply_results, ::std::vec::Vec::new())
    }

    // optional bool supports_os_updates = 5;

    pub fn supports_os_updates(&self) -> bool {
        self.supports_os_updates.unwrap_or(false)
    }

    pub fn clear_supports_os_updates(&mut self) {
        self.supports_os_updates = ::std::option::Option::None;
    }

    pub fn has_supports_os_updates(&self) -> bool {
        self.supports_os_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_os_updates(&mut self, v: bool) {
        self.supports_os_updates = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CMsgSystemUpdateState| { &m.state },
            |m: &mut CMsgSystemUpdateState| { &mut m.state },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMsgSystemUpdateProgress>(
            "progress",
            |m: &CMsgSystemUpdateState| { &m.progress },
            |m: &mut CMsgSystemUpdateState| { &mut m.progress },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "update_check_results",
            |m: &CMsgSystemUpdateState| { &m.update_check_results },
            |m: &mut CMsgSystemUpdateState| { &mut m.update_check_results },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "update_apply_results",
            |m: &CMsgSystemUpdateState| { &m.update_apply_results },
            |m: &mut CMsgSystemUpdateState| { &mut m.update_apply_results },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supports_os_updates",
            |m: &CMsgSystemUpdateState| { &m.supports_os_updates },
            |m: &mut CMsgSystemUpdateState| { &mut m.supports_os_updates },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemUpdateState>(
            "CMsgSystemUpdateState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgSystemUpdateState {
    const NAME: &'static str = "CMsgSystemUpdateState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.progress)?;
                },
                26 => {
                    self.update_check_results.push(is.read_message()?);
                },
                34 => {
                    self.update_apply_results.push(is.read_message()?);
                },
                40 => {
                    self.supports_os_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.update_check_results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.update_apply_results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.supports_os_updates {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.progress.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.update_check_results {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.update_apply_results {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.supports_os_updates {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateState {
        CMsgSystemUpdateState::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.progress.clear();
        self.update_check_results.clear();
        self.update_apply_results.clear();
        self.supports_os_updates = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateState {
        static instance: CMsgSystemUpdateState = CMsgSystemUpdateState {
            state: ::std::option::Option::None,
            progress: crate::MessageField::none(),
            update_check_results: ::std::vec::Vec::new(),
            update_apply_results: ::std::vec::Vec::new(),
            supports_os_updates: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgSystemUpdateState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemUpdateState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemUpdateState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgSystemUpdateState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAchievementChange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAchievementChange {
    // message fields
    // @@protoc_insertion_point(field:CMsgAchievementChange.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAchievementChange.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAchievementChange {
    fn default() -> &'a CMsgAchievementChange {
        <CMsgAchievementChange as crate::Message>::default_instance()
    }
}

impl CMsgAchievementChange {
    pub fn new() -> CMsgAchievementChange {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgAchievementChange| { &m.appid },
            |m: &mut CMsgAchievementChange| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAchievementChange>(
            "CMsgAchievementChange",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgAchievementChange {
    const NAME: &'static str = "CMsgAchievementChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAchievementChange {
        CMsgAchievementChange::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAchievementChange {
        static instance: CMsgAchievementChange = CMsgAchievementChange {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgAchievementChange {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAchievementChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAchievementChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgAchievementChange {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCellList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCellList {
    // message fields
    // @@protoc_insertion_point(field:CMsgCellList.cells)
    pub cells: ::std::vec::Vec<cmsg_cell_list::Cell>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCellList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCellList {
    fn default() -> &'a CMsgCellList {
        <CMsgCellList as crate::Message>::default_instance()
    }
}

impl CMsgCellList {
    pub fn new() -> CMsgCellList {
        ::std::default::Default::default()
    }

    // repeated .CMsgCellList.Cell cells = 1;

    pub fn cells(&self) -> &[cmsg_cell_list::Cell] {
        &self.cells
    }

    pub fn clear_cells(&mut self) {
        self.cells.clear();
    }

    // Param is passed by value, moved
    pub fn set_cells(&mut self, v: ::std::vec::Vec<cmsg_cell_list::Cell>) {
        self.cells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cells(&mut self) -> &mut ::std::vec::Vec<cmsg_cell_list::Cell> {
        &mut self.cells
    }

    // Take field
    pub fn take_cells(&mut self) -> ::std::vec::Vec<cmsg_cell_list::Cell> {
        ::std::mem::replace(&mut self.cells, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cells",
            |m: &CMsgCellList| { &m.cells },
            |m: &mut CMsgCellList| { &mut m.cells },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCellList>(
            "CMsgCellList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgCellList {
    const NAME: &'static str = "CMsgCellList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cells.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cells {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.cells {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCellList {
        CMsgCellList::new()
    }

    fn clear(&mut self) {
        self.cells.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCellList {
        static instance: CMsgCellList = CMsgCellList {
            cells: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgCellList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCellList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCellList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgCellList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCellList`
pub mod cmsg_cell_list {
    // @@protoc_insertion_point(message:CMsgCellList.Cell)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cell {
        // message fields
        // @@protoc_insertion_point(field:CMsgCellList.Cell.cell_id)
        pub cell_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgCellList.Cell.loc_name)
        pub loc_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCellList.Cell.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cell {
        fn default() -> &'a Cell {
            <Cell as crate::Message>::default_instance()
        }
    }

    impl Cell {
        pub fn new() -> Cell {
            ::std::default::Default::default()
        }

        // optional uint32 cell_id = 1;

        pub fn cell_id(&self) -> u32 {
            self.cell_id.unwrap_or(0)
        }

        pub fn clear_cell_id(&mut self) {
            self.cell_id = ::std::option::Option::None;
        }

        pub fn has_cell_id(&self) -> bool {
            self.cell_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cell_id(&mut self, v: u32) {
            self.cell_id = ::std::option::Option::Some(v);
        }

        // optional string loc_name = 2;

        pub fn loc_name(&self) -> &str {
            match self.loc_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_loc_name(&mut self) {
            self.loc_name = ::std::option::Option::None;
        }

        pub fn has_loc_name(&self) -> bool {
            self.loc_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_loc_name(&mut self, v: ::std::string::String) {
            self.loc_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_loc_name(&mut self) -> &mut ::std::string::String {
            if self.loc_name.is_none() {
                self.loc_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.loc_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_loc_name(&mut self) -> ::std::string::String {
            self.loc_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "cell_id",
                |m: &Cell| { &m.cell_id },
                |m: &mut Cell| { &mut m.cell_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "loc_name",
                |m: &Cell| { &m.loc_name },
                |m: &mut Cell| { &mut m.loc_name },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Cell>(
                "CMsgCellList.Cell",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Cell {
        const NAME: &'static str = "Cell";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.loc_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.cell_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.loc_name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.cell_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.loc_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cell {
            Cell::new()
        }

        fn clear(&mut self) {
            self.cell_id = ::std::option::Option::None;
            self.loc_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cell {
            static instance: Cell = Cell {
                cell_id: ::std::option::Option::None,
                loc_name: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Cell {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCellList.Cell").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Cell {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Cell {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgShortcutInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShortcutInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgShortcutInfo.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.exe)
    pub exe: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.start_dir)
    pub start_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.args)
    pub args: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.app_name)
    pub app_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.override_appid)
    pub override_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.flatpak_appid)
    pub flatpak_appid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_remote)
    pub is_remote: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_hidden)
    pub is_hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_temporary)
    pub is_temporary: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_openvr)
    pub is_openvr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.allow_desktop_config)
    pub allow_desktop_config: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.allow_overlay)
    pub allow_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.rt_last_played_time)
    pub rt_last_played_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_devkit_shortcut)
    pub is_devkit_shortcut: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.devkit_gameid)
    pub devkit_gameid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShortcutInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShortcutInfo {
    fn default() -> &'a CMsgShortcutInfo {
        <CMsgShortcutInfo as crate::Message>::default_instance()
    }
}

impl CMsgShortcutInfo {
    pub fn new() -> CMsgShortcutInfo {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string exe = 2;

    pub fn exe(&self) -> &str {
        match self.exe.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_exe(&mut self) {
        self.exe = ::std::option::Option::None;
    }

    pub fn has_exe(&self) -> bool {
        self.exe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exe(&mut self, v: ::std::string::String) {
        self.exe = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exe(&mut self) -> &mut ::std::string::String {
        if self.exe.is_none() {
            self.exe = ::std::option::Option::Some(::std::string::String::new());
        }
        self.exe.as_mut().unwrap()
    }

    // Take field
    pub fn take_exe(&mut self) -> ::std::string::String {
        self.exe.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string start_dir = 3;

    pub fn start_dir(&self) -> &str {
        match self.start_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_dir(&mut self) {
        self.start_dir = ::std::option::Option::None;
    }

    pub fn has_start_dir(&self) -> bool {
        self.start_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_dir(&mut self, v: ::std::string::String) {
        self.start_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_dir(&mut self) -> &mut ::std::string::String {
        if self.start_dir.is_none() {
            self.start_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_dir(&mut self) -> ::std::string::String {
        self.start_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 4;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 5;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string args = 6;

    pub fn args(&self) -> &str {
        match self.args.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_args(&mut self) {
        self.args = ::std::option::Option::None;
    }

    pub fn has_args(&self) -> bool {
        self.args.is_some()
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::string::String) {
        self.args = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_args(&mut self) -> &mut ::std::string::String {
        if self.args.is_none() {
            self.args = ::std::option::Option::Some(::std::string::String::new());
        }
        self.args.as_mut().unwrap()
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::string::String {
        self.args.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string app_name = 7;

    pub fn app_name(&self) -> &str {
        match self.app_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_app_name(&mut self) {
        self.app_name = ::std::option::Option::None;
    }

    pub fn has_app_name(&self) -> bool {
        self.app_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_name(&mut self, v: ::std::string::String) {
        self.app_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_name(&mut self) -> &mut ::std::string::String {
        if self.app_name.is_none() {
            self.app_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.app_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_name(&mut self) -> ::std::string::String {
        self.app_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 override_appid = 8;

    pub fn override_appid(&self) -> u32 {
        self.override_appid.unwrap_or(0)
    }

    pub fn clear_override_appid(&mut self) {
        self.override_appid = ::std::option::Option::None;
    }

    pub fn has_override_appid(&self) -> bool {
        self.override_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_appid(&mut self, v: u32) {
        self.override_appid = ::std::option::Option::Some(v);
    }

    // optional string flatpak_appid = 9;

    pub fn flatpak_appid(&self) -> &str {
        match self.flatpak_appid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_flatpak_appid(&mut self) {
        self.flatpak_appid = ::std::option::Option::None;
    }

    pub fn has_flatpak_appid(&self) -> bool {
        self.flatpak_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flatpak_appid(&mut self, v: ::std::string::String) {
        self.flatpak_appid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flatpak_appid(&mut self) -> &mut ::std::string::String {
        if self.flatpak_appid.is_none() {
            self.flatpak_appid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.flatpak_appid.as_mut().unwrap()
    }

    // Take field
    pub fn take_flatpak_appid(&mut self) -> ::std::string::String {
        self.flatpak_appid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tags = 10;

    pub fn tags(&self) -> &[::std::string::String] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    // optional bool is_remote = 11;

    pub fn is_remote(&self) -> bool {
        self.is_remote.unwrap_or(false)
    }

    pub fn clear_is_remote(&mut self) {
        self.is_remote = ::std::option::Option::None;
    }

    pub fn has_is_remote(&self) -> bool {
        self.is_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_remote(&mut self, v: bool) {
        self.is_remote = ::std::option::Option::Some(v);
    }

    // optional bool is_hidden = 12;

    pub fn is_hidden(&self) -> bool {
        self.is_hidden.unwrap_or(false)
    }

    pub fn clear_is_hidden(&mut self) {
        self.is_hidden = ::std::option::Option::None;
    }

    pub fn has_is_hidden(&self) -> bool {
        self.is_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hidden(&mut self, v: bool) {
        self.is_hidden = ::std::option::Option::Some(v);
    }

    // optional bool is_temporary = 13;

    pub fn is_temporary(&self) -> bool {
        self.is_temporary.unwrap_or(false)
    }

    pub fn clear_is_temporary(&mut self) {
        self.is_temporary = ::std::option::Option::None;
    }

    pub fn has_is_temporary(&self) -> bool {
        self.is_temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_temporary(&mut self, v: bool) {
        self.is_temporary = ::std::option::Option::Some(v);
    }

    // optional bool is_openvr = 14;

    pub fn is_openvr(&self) -> bool {
        self.is_openvr.unwrap_or(false)
    }

    pub fn clear_is_openvr(&mut self) {
        self.is_openvr = ::std::option::Option::None;
    }

    pub fn has_is_openvr(&self) -> bool {
        self.is_openvr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_openvr(&mut self, v: bool) {
        self.is_openvr = ::std::option::Option::Some(v);
    }

    // optional bool allow_desktop_config = 15;

    pub fn allow_desktop_config(&self) -> bool {
        self.allow_desktop_config.unwrap_or(false)
    }

    pub fn clear_allow_desktop_config(&mut self) {
        self.allow_desktop_config = ::std::option::Option::None;
    }

    pub fn has_allow_desktop_config(&self) -> bool {
        self.allow_desktop_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_desktop_config(&mut self, v: bool) {
        self.allow_desktop_config = ::std::option::Option::Some(v);
    }

    // optional bool allow_overlay = 16;

    pub fn allow_overlay(&self) -> bool {
        self.allow_overlay.unwrap_or(false)
    }

    pub fn clear_allow_overlay(&mut self) {
        self.allow_overlay = ::std::option::Option::None;
    }

    pub fn has_allow_overlay(&self) -> bool {
        self.allow_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_overlay(&mut self, v: bool) {
        self.allow_overlay = ::std::option::Option::Some(v);
    }

    // optional uint32 rt_last_played_time = 17;

    pub fn rt_last_played_time(&self) -> u32 {
        self.rt_last_played_time.unwrap_or(0)
    }

    pub fn clear_rt_last_played_time(&mut self) {
        self.rt_last_played_time = ::std::option::Option::None;
    }

    pub fn has_rt_last_played_time(&self) -> bool {
        self.rt_last_played_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_last_played_time(&mut self, v: u32) {
        self.rt_last_played_time = ::std::option::Option::Some(v);
    }

    // optional bool is_devkit_shortcut = 18;

    pub fn is_devkit_shortcut(&self) -> bool {
        self.is_devkit_shortcut.unwrap_or(false)
    }

    pub fn clear_is_devkit_shortcut(&mut self) {
        self.is_devkit_shortcut = ::std::option::Option::None;
    }

    pub fn has_is_devkit_shortcut(&self) -> bool {
        self.is_devkit_shortcut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_devkit_shortcut(&mut self, v: bool) {
        self.is_devkit_shortcut = ::std::option::Option::Some(v);
    }

    // optional string devkit_gameid = 19;

    pub fn devkit_gameid(&self) -> &str {
        match self.devkit_gameid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_devkit_gameid(&mut self) {
        self.devkit_gameid = ::std::option::Option::None;
    }

    pub fn has_devkit_gameid(&self) -> bool {
        self.devkit_gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devkit_gameid(&mut self, v: ::std::string::String) {
        self.devkit_gameid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devkit_gameid(&mut self) -> &mut ::std::string::String {
        if self.devkit_gameid.is_none() {
            self.devkit_gameid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.devkit_gameid.as_mut().unwrap()
    }

    // Take field
    pub fn take_devkit_gameid(&mut self) -> ::std::string::String {
        self.devkit_gameid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgShortcutInfo| { &m.appid },
            |m: &mut CMsgShortcutInfo| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "exe",
            |m: &CMsgShortcutInfo| { &m.exe },
            |m: &mut CMsgShortcutInfo| { &mut m.exe },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_dir",
            |m: &CMsgShortcutInfo| { &m.start_dir },
            |m: &mut CMsgShortcutInfo| { &mut m.start_dir },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CMsgShortcutInfo| { &m.icon },
            |m: &mut CMsgShortcutInfo| { &mut m.icon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CMsgShortcutInfo| { &m.path },
            |m: &mut CMsgShortcutInfo| { &mut m.path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "args",
            |m: &CMsgShortcutInfo| { &m.args },
            |m: &mut CMsgShortcutInfo| { &mut m.args },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_name",
            |m: &CMsgShortcutInfo| { &m.app_name },
            |m: &mut CMsgShortcutInfo| { &mut m.app_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_appid",
            |m: &CMsgShortcutInfo| { &m.override_appid },
            |m: &mut CMsgShortcutInfo| { &mut m.override_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "flatpak_appid",
            |m: &CMsgShortcutInfo| { &m.flatpak_appid },
            |m: &mut CMsgShortcutInfo| { &mut m.flatpak_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CMsgShortcutInfo| { &m.tags },
            |m: &mut CMsgShortcutInfo| { &mut m.tags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_remote",
            |m: &CMsgShortcutInfo| { &m.is_remote },
            |m: &mut CMsgShortcutInfo| { &mut m.is_remote },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hidden",
            |m: &CMsgShortcutInfo| { &m.is_hidden },
            |m: &mut CMsgShortcutInfo| { &mut m.is_hidden },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_temporary",
            |m: &CMsgShortcutInfo| { &m.is_temporary },
            |m: &mut CMsgShortcutInfo| { &mut m.is_temporary },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_openvr",
            |m: &CMsgShortcutInfo| { &m.is_openvr },
            |m: &mut CMsgShortcutInfo| { &mut m.is_openvr },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_desktop_config",
            |m: &CMsgShortcutInfo| { &m.allow_desktop_config },
            |m: &mut CMsgShortcutInfo| { &mut m.allow_desktop_config },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_overlay",
            |m: &CMsgShortcutInfo| { &m.allow_overlay },
            |m: &mut CMsgShortcutInfo| { &mut m.allow_overlay },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rt_last_played_time",
            |m: &CMsgShortcutInfo| { &m.rt_last_played_time },
            |m: &mut CMsgShortcutInfo| { &mut m.rt_last_played_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_devkit_shortcut",
            |m: &CMsgShortcutInfo| { &m.is_devkit_shortcut },
            |m: &mut CMsgShortcutInfo| { &mut m.is_devkit_shortcut },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "devkit_gameid",
            |m: &CMsgShortcutInfo| { &m.devkit_gameid },
            |m: &mut CMsgShortcutInfo| { &mut m.devkit_gameid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShortcutInfo>(
            "CMsgShortcutInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgShortcutInfo {
    const NAME: &'static str = "CMsgShortcutInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.exe = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.start_dir = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.args = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.app_name = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.override_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.flatpak_appid = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.tags.push(is.read_string()?);
                },
                88 => {
                    self.is_remote = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_temporary = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_openvr = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.allow_desktop_config = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.allow_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.rt_last_played_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.is_devkit_shortcut = ::std::option::Option::Some(is.read_bool()?);
                },
                154 => {
                    self.devkit_gameid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.exe.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.start_dir.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.args.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.app_name.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.override_appid {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.flatpak_appid.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        for value in &self.tags {
            my_size += crate::rt::string_size(10, &value);
        };
        if let Some(v) = self.is_remote {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_temporary {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_openvr {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_desktop_config {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_overlay {
            my_size += 2 + 1;
        }
        if let Some(v) = self.rt_last_played_time {
            my_size += crate::rt::uint32_size(17, v);
        }
        if let Some(v) = self.is_devkit_shortcut {
            my_size += 2 + 1;
        }
        if let Some(v) = self.devkit_gameid.as_ref() {
            my_size += crate::rt::string_size(19, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.exe.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.start_dir.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.args.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.app_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.override_appid {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.flatpak_appid.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.tags {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.is_remote {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_hidden {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_temporary {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_openvr {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.allow_desktop_config {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.allow_overlay {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.rt_last_played_time {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.is_devkit_shortcut {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.devkit_gameid.as_ref() {
            os.write_string(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShortcutInfo {
        CMsgShortcutInfo::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.exe = ::std::option::Option::None;
        self.start_dir = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.args = ::std::option::Option::None;
        self.app_name = ::std::option::Option::None;
        self.override_appid = ::std::option::Option::None;
        self.flatpak_appid = ::std::option::Option::None;
        self.tags.clear();
        self.is_remote = ::std::option::Option::None;
        self.is_hidden = ::std::option::Option::None;
        self.is_temporary = ::std::option::Option::None;
        self.is_openvr = ::std::option::Option::None;
        self.allow_desktop_config = ::std::option::Option::None;
        self.allow_overlay = ::std::option::Option::None;
        self.rt_last_played_time = ::std::option::Option::None;
        self.is_devkit_shortcut = ::std::option::Option::None;
        self.devkit_gameid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShortcutInfo {
        static instance: CMsgShortcutInfo = CMsgShortcutInfo {
            appid: ::std::option::Option::None,
            exe: ::std::option::Option::None,
            start_dir: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            path: ::std::option::Option::None,
            args: ::std::option::Option::None,
            app_name: ::std::option::Option::None,
            override_appid: ::std::option::Option::None,
            flatpak_appid: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            is_remote: ::std::option::Option::None,
            is_hidden: ::std::option::Option::None,
            is_temporary: ::std::option::Option::None,
            is_openvr: ::std::option::Option::None,
            allow_desktop_config: ::std::option::Option::None,
            allow_overlay: ::std::option::Option::None,
            rt_last_played_time: ::std::option::Option::None,
            is_devkit_shortcut: ::std::option::Option::None,
            devkit_gameid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgShortcutInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShortcutInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShortcutInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgShortcutInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShortcutAppIds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShortcutAppIds {
    // message fields
    // @@protoc_insertion_point(field:CMsgShortcutAppIds.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShortcutAppIds.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShortcutAppIds {
    fn default() -> &'a CMsgShortcutAppIds {
        <CMsgShortcutAppIds as crate::Message>::default_instance()
    }
}

impl CMsgShortcutAppIds {
    pub fn new() -> CMsgShortcutAppIds {
        ::std::default::Default::default()
    }

    // repeated uint32 appids = 1;

    pub fn appids(&self) -> &[u32] {
        &self.appids
    }

    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CMsgShortcutAppIds| { &m.appids },
            |m: &mut CMsgShortcutAppIds| { &mut m.appids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShortcutAppIds>(
            "CMsgShortcutAppIds",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgShortcutAppIds {
    const NAME: &'static str = "CMsgShortcutAppIds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                8 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += crate::rt::uint32_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.appids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShortcutAppIds {
        CMsgShortcutAppIds::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShortcutAppIds {
        static instance: CMsgShortcutAppIds = CMsgShortcutAppIds {
            appids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgShortcutAppIds {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShortcutAppIds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShortcutAppIds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgShortcutAppIds {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMonitorInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMonitorInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgMonitorInfo.selected_display_name)
    pub selected_display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMonitorInfo.monitors)
    pub monitors: ::std::vec::Vec<cmsg_monitor_info::MonitorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMonitorInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMonitorInfo {
    fn default() -> &'a CMsgMonitorInfo {
        <CMsgMonitorInfo as crate::Message>::default_instance()
    }
}

impl CMsgMonitorInfo {
    pub fn new() -> CMsgMonitorInfo {
        ::std::default::Default::default()
    }

    // required string selected_display_name = 1;

    pub fn selected_display_name(&self) -> &str {
        match self.selected_display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selected_display_name(&mut self) {
        self.selected_display_name = ::std::option::Option::None;
    }

    pub fn has_selected_display_name(&self) -> bool {
        self.selected_display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_display_name(&mut self, v: ::std::string::String) {
        self.selected_display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected_display_name(&mut self) -> &mut ::std::string::String {
        if self.selected_display_name.is_none() {
            self.selected_display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selected_display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected_display_name(&mut self) -> ::std::string::String {
        self.selected_display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgMonitorInfo.MonitorInfo monitors = 2;

    pub fn monitors(&self) -> &[cmsg_monitor_info::MonitorInfo] {
        &self.monitors
    }

    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::std::vec::Vec<cmsg_monitor_info::MonitorInfo>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::std::vec::Vec<cmsg_monitor_info::MonitorInfo> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::std::vec::Vec<cmsg_monitor_info::MonitorInfo> {
        ::std::mem::replace(&mut self.monitors, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_display_name",
            |m: &CMsgMonitorInfo| { &m.selected_display_name },
            |m: &mut CMsgMonitorInfo| { &mut m.selected_display_name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitors",
            |m: &CMsgMonitorInfo| { &m.monitors },
            |m: &mut CMsgMonitorInfo| { &mut m.monitors },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMonitorInfo>(
            "CMsgMonitorInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgMonitorInfo {
    const NAME: &'static str = "CMsgMonitorInfo";

    fn is_initialized(&self) -> bool {
        if self.selected_display_name.is_none() {
            return false;
        }
        for v in &self.monitors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selected_display_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.monitors.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selected_display_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.monitors {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.selected_display_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.monitors {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMonitorInfo {
        CMsgMonitorInfo::new()
    }

    fn clear(&mut self) {
        self.selected_display_name = ::std::option::Option::None;
        self.monitors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMonitorInfo {
        static instance: CMsgMonitorInfo = CMsgMonitorInfo {
            selected_display_name: ::std::option::Option::None,
            monitors: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgMonitorInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMonitorInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMonitorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgMonitorInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMonitorInfo`
pub mod cmsg_monitor_info {
    // @@protoc_insertion_point(message:CMsgMonitorInfo.MonitorInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MonitorInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgMonitorInfo.MonitorInfo.monitor_device_name)
        pub monitor_device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgMonitorInfo.MonitorInfo.monitor_display_name)
        pub monitor_display_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMonitorInfo.MonitorInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MonitorInfo {
        fn default() -> &'a MonitorInfo {
            <MonitorInfo as crate::Message>::default_instance()
        }
    }

    impl MonitorInfo {
        pub fn new() -> MonitorInfo {
            ::std::default::Default::default()
        }

        // required string monitor_device_name = 1;

        pub fn monitor_device_name(&self) -> &str {
            match self.monitor_device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_monitor_device_name(&mut self) {
            self.monitor_device_name = ::std::option::Option::None;
        }

        pub fn has_monitor_device_name(&self) -> bool {
            self.monitor_device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_monitor_device_name(&mut self, v: ::std::string::String) {
            self.monitor_device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_monitor_device_name(&mut self) -> &mut ::std::string::String {
            if self.monitor_device_name.is_none() {
                self.monitor_device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.monitor_device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_monitor_device_name(&mut self) -> ::std::string::String {
            self.monitor_device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string monitor_display_name = 2;

        pub fn monitor_display_name(&self) -> &str {
            match self.monitor_display_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_monitor_display_name(&mut self) {
            self.monitor_display_name = ::std::option::Option::None;
        }

        pub fn has_monitor_display_name(&self) -> bool {
            self.monitor_display_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_monitor_display_name(&mut self, v: ::std::string::String) {
            self.monitor_display_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_monitor_display_name(&mut self) -> &mut ::std::string::String {
            if self.monitor_display_name.is_none() {
                self.monitor_display_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.monitor_display_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_monitor_display_name(&mut self) -> ::std::string::String {
            self.monitor_display_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "monitor_device_name",
                |m: &MonitorInfo| { &m.monitor_device_name },
                |m: &mut MonitorInfo| { &mut m.monitor_device_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "monitor_display_name",
                |m: &MonitorInfo| { &m.monitor_display_name },
                |m: &mut MonitorInfo| { &mut m.monitor_display_name },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<MonitorInfo>(
                "CMsgMonitorInfo.MonitorInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for MonitorInfo {
        const NAME: &'static str = "MonitorInfo";

        fn is_initialized(&self) -> bool {
            if self.monitor_device_name.is_none() {
                return false;
            }
            if self.monitor_display_name.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.monitor_device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.monitor_display_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.monitor_device_name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.monitor_display_name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.monitor_device_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.monitor_display_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MonitorInfo {
            MonitorInfo::new()
        }

        fn clear(&mut self) {
            self.monitor_device_name = ::std::option::Option::None;
            self.monitor_display_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MonitorInfo {
            static instance: MonitorInfo = MonitorInfo {
                monitor_device_name: ::std::option::Option::None,
                monitor_display_name: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for MonitorInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMonitorInfo.MonitorInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MonitorInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for MonitorInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGenerateSystemReportReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGenerateSystemReportReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgGenerateSystemReportReply.report_id)
    pub report_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGenerateSystemReportReply.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGenerateSystemReportReply {
    fn default() -> &'a CMsgGenerateSystemReportReply {
        <CMsgGenerateSystemReportReply as crate::Message>::default_instance()
    }
}

impl CMsgGenerateSystemReportReply {
    pub fn new() -> CMsgGenerateSystemReportReply {
        ::std::default::Default::default()
    }

    // optional string report_id = 1;

    pub fn report_id(&self) -> &str {
        match self.report_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_report_id(&mut self) {
        self.report_id = ::std::option::Option::None;
    }

    pub fn has_report_id(&self) -> bool {
        self.report_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_id(&mut self, v: ::std::string::String) {
        self.report_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report_id(&mut self) -> &mut ::std::string::String {
        if self.report_id.is_none() {
            self.report_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.report_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_report_id(&mut self) -> ::std::string::String {
        self.report_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "report_id",
            |m: &CMsgGenerateSystemReportReply| { &m.report_id },
            |m: &mut CMsgGenerateSystemReportReply| { &mut m.report_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGenerateSystemReportReply>(
            "CMsgGenerateSystemReportReply",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgGenerateSystemReportReply {
    const NAME: &'static str = "CMsgGenerateSystemReportReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.report_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.report_id.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.report_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGenerateSystemReportReply {
        CMsgGenerateSystemReportReply::new()
    }

    fn clear(&mut self) {
        self.report_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGenerateSystemReportReply {
        static instance: CMsgGenerateSystemReportReply = CMsgGenerateSystemReportReply {
            report_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgGenerateSystemReportReply {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGenerateSystemReportReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGenerateSystemReportReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgGenerateSystemReportReply {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgWebUITransportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgWebUITransportInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgWebUITransportInfo.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgWebUITransportInfo.auth_key)
    pub auth_key: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgWebUITransportInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgWebUITransportInfo {
    fn default() -> &'a CMsgWebUITransportInfo {
        <CMsgWebUITransportInfo as crate::Message>::default_instance()
    }
}

impl CMsgWebUITransportInfo {
    pub fn new() -> CMsgWebUITransportInfo {
        ::std::default::Default::default()
    }

    // optional uint32 port = 1;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string auth_key = 2;

    pub fn auth_key(&self) -> &str {
        match self.auth_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_auth_key(&mut self) {
        self.auth_key = ::std::option::Option::None;
    }

    pub fn has_auth_key(&self) -> bool {
        self.auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_key(&mut self, v: ::std::string::String) {
        self.auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_key(&mut self) -> &mut ::std::string::String {
        if self.auth_key.is_none() {
            self.auth_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_key(&mut self) -> ::std::string::String {
        self.auth_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &CMsgWebUITransportInfo| { &m.port },
            |m: &mut CMsgWebUITransportInfo| { &mut m.port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "auth_key",
            |m: &CMsgWebUITransportInfo| { &m.auth_key },
            |m: &mut CMsgWebUITransportInfo| { &mut m.auth_key },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgWebUITransportInfo>(
            "CMsgWebUITransportInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgWebUITransportInfo {
    const NAME: &'static str = "CMsgWebUITransportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.auth_key = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.auth_key.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.auth_key.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgWebUITransportInfo {
        CMsgWebUITransportInfo::new()
    }

    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.auth_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgWebUITransportInfo {
        static instance: CMsgWebUITransportInfo = CMsgWebUITransportInfo {
            port: ::std::option::Option::None,
            auth_key: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgWebUITransportInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgWebUITransportInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgWebUITransportInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgWebUITransportInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientShaderHitCacheEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientShaderHitCacheEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientShaderHitCacheEntry.key_sha)
    pub key_sha: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientShaderHitCacheEntry.code_sha)
    pub code_sha: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgClientShaderHitCacheEntry.time_last_reported)
    pub time_last_reported: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientShaderHitCacheEntry.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientShaderHitCacheEntry {
    fn default() -> &'a CMsgClientShaderHitCacheEntry {
        <CMsgClientShaderHitCacheEntry as crate::Message>::default_instance()
    }
}

impl CMsgClientShaderHitCacheEntry {
    pub fn new() -> CMsgClientShaderHitCacheEntry {
        ::std::default::Default::default()
    }

    // optional bytes key_sha = 1;

    pub fn key_sha(&self) -> &[u8] {
        match self.key_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_sha(&mut self) {
        self.key_sha = ::std::option::Option::None;
    }

    pub fn has_key_sha(&self) -> bool {
        self.key_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_sha(&mut self, v: ::bytes::Bytes) {
        self.key_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_sha(&mut self) -> &mut ::bytes::Bytes {
        if self.key_sha.is_none() {
            self.key_sha = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.key_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_sha(&mut self) -> ::bytes::Bytes {
        self.key_sha.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes code_sha = 2;

    pub fn code_sha(&self) -> &[u8] {
        match self.code_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_code_sha(&mut self) {
        self.code_sha = ::std::option::Option::None;
    }

    pub fn has_code_sha(&self) -> bool {
        self.code_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_sha(&mut self, v: ::bytes::Bytes) {
        self.code_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_sha(&mut self) -> &mut ::bytes::Bytes {
        if self.code_sha.is_none() {
            self.code_sha = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.code_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_code_sha(&mut self) -> ::bytes::Bytes {
        self.code_sha.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint64 time_last_reported = 3;

    pub fn time_last_reported(&self) -> u64 {
        self.time_last_reported.unwrap_or(0)
    }

    pub fn clear_time_last_reported(&mut self) {
        self.time_last_reported = ::std::option::Option::None;
    }

    pub fn has_time_last_reported(&self) -> bool {
        self.time_last_reported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_reported(&mut self, v: u64) {
        self.time_last_reported = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_sha",
            |m: &CMsgClientShaderHitCacheEntry| { &m.key_sha },
            |m: &mut CMsgClientShaderHitCacheEntry| { &mut m.key_sha },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_sha",
            |m: &CMsgClientShaderHitCacheEntry| { &m.code_sha },
            |m: &mut CMsgClientShaderHitCacheEntry| { &mut m.code_sha },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_reported",
            |m: &CMsgClientShaderHitCacheEntry| { &m.time_last_reported },
            |m: &mut CMsgClientShaderHitCacheEntry| { &mut m.time_last_reported },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientShaderHitCacheEntry>(
            "CMsgClientShaderHitCacheEntry",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientShaderHitCacheEntry {
    const NAME: &'static str = "CMsgClientShaderHitCacheEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_sha = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                18 => {
                    self.code_sha = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.time_last_reported = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_sha.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.code_sha.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.time_last_reported {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.key_sha.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.code_sha.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.time_last_reported {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientShaderHitCacheEntry {
        CMsgClientShaderHitCacheEntry::new()
    }

    fn clear(&mut self) {
        self.key_sha = ::std::option::Option::None;
        self.code_sha = ::std::option::Option::None;
        self.time_last_reported = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientShaderHitCacheEntry {
        static instance: CMsgClientShaderHitCacheEntry = CMsgClientShaderHitCacheEntry {
            key_sha: ::std::option::Option::None,
            code_sha: ::std::option::Option::None,
            time_last_reported: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientShaderHitCacheEntry {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientShaderHitCacheEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientShaderHitCacheEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientShaderHitCacheEntry {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientShaderHitCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientShaderHitCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientShaderHitCache.entries)
    pub entries: ::std::vec::Vec<CMsgClientShaderHitCacheEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientShaderHitCache.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientShaderHitCache {
    fn default() -> &'a CMsgClientShaderHitCache {
        <CMsgClientShaderHitCache as crate::Message>::default_instance()
    }
}

impl CMsgClientShaderHitCache {
    pub fn new() -> CMsgClientShaderHitCache {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientShaderHitCacheEntry entries = 1;

    pub fn entries(&self) -> &[CMsgClientShaderHitCacheEntry] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<CMsgClientShaderHitCacheEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<CMsgClientShaderHitCacheEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<CMsgClientShaderHitCacheEntry> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgClientShaderHitCache| { &m.entries },
            |m: &mut CMsgClientShaderHitCache| { &mut m.entries },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientShaderHitCache>(
            "CMsgClientShaderHitCache",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgClientShaderHitCache {
    const NAME: &'static str = "CMsgClientShaderHitCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientShaderHitCache {
        CMsgClientShaderHitCache::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientShaderHitCache {
        static instance: CMsgClientShaderHitCache = CMsgClientShaderHitCache {
            entries: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgClientShaderHitCache {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientShaderHitCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientShaderHitCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgClientShaderHitCache {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECloudPendingRemoteOperation)
pub enum ECloudPendingRemoteOperation {
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationNone)
    k_ECloudPendingRemoteOperationNone = 0,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationAppSessionActive)
    k_ECloudPendingRemoteOperationAppSessionActive = 1,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationUploadInProgress)
    k_ECloudPendingRemoteOperationUploadInProgress = 2,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationUploadPending)
    k_ECloudPendingRemoteOperationUploadPending = 3,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationAppSessionSuspended)
    k_ECloudPendingRemoteOperationAppSessionSuspended = 4,
}

impl crate::Enum for ECloudPendingRemoteOperation {
    const NAME: &'static str = "ECloudPendingRemoteOperation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECloudPendingRemoteOperation> {
        match value {
            0 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone),
            1 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionActive),
            2 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadInProgress),
            3 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadPending),
            4 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionSuspended),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECloudPendingRemoteOperation> {
        match str {
            "k_ECloudPendingRemoteOperationNone" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone),
            "k_ECloudPendingRemoteOperationAppSessionActive" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionActive),
            "k_ECloudPendingRemoteOperationUploadInProgress" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadInProgress),
            "k_ECloudPendingRemoteOperationUploadPending" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadPending),
            "k_ECloudPendingRemoteOperationAppSessionSuspended" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionSuspended),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECloudPendingRemoteOperation] = &[
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionActive,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadInProgress,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadPending,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionSuspended,
    ];
}

impl crate::EnumFull for ECloudPendingRemoteOperation {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECloudPendingRemoteOperation").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECloudPendingRemoteOperation {
    fn default() -> Self {
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone
    }
}

impl ECloudPendingRemoteOperation {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ECloudPendingRemoteOperation>("ECloudPendingRemoteOperation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckKeyboardLayout)
pub enum ESteamDeckKeyboardLayout {
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_QWERTY)
    k_ESteamDeckKeyboardLayout_QWERTY = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Bulgarian)
    k_ESteamDeckKeyboardLayout_Bulgarian = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Simplified)
    k_ESteamDeckKeyboardLayout_Chinese_Simplified = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional = 3,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Czech)
    k_ESteamDeckKeyboardLayout_Czech = 4,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Danish)
    k_ESteamDeckKeyboardLayout_Danish = 5,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Finnish)
    k_ESteamDeckKeyboardLayout_Finnish = 6,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_French)
    k_ESteamDeckKeyboardLayout_French = 7,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_German)
    k_ESteamDeckKeyboardLayout_German = 8,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Greek)
    k_ESteamDeckKeyboardLayout_Greek = 9,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Hungarian)
    k_ESteamDeckKeyboardLayout_Hungarian = 10,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Italian)
    k_ESteamDeckKeyboardLayout_Italian = 11,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Japanese)
    k_ESteamDeckKeyboardLayout_Japanese = 12,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Korean)
    k_ESteamDeckKeyboardLayout_Korean = 13,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Norwegian)
    k_ESteamDeckKeyboardLayout_Norwegian = 14,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Polish)
    k_ESteamDeckKeyboardLayout_Polish = 15,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Portuguese)
    k_ESteamDeckKeyboardLayout_Portuguese = 16,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Romanian)
    k_ESteamDeckKeyboardLayout_Romanian = 17,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Russian)
    k_ESteamDeckKeyboardLayout_Russian = 18,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Spanish)
    k_ESteamDeckKeyboardLayout_Spanish = 19,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Swedish)
    k_ESteamDeckKeyboardLayout_Swedish = 20,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Thai)
    k_ESteamDeckKeyboardLayout_Thai = 21,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Turkish_F)
    k_ESteamDeckKeyboardLayout_Turkish_F = 22,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Turkish_Q)
    k_ESteamDeckKeyboardLayout_Turkish_Q = 23,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Ukrainian)
    k_ESteamDeckKeyboardLayout_Ukrainian = 24,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Vietnamese)
    k_ESteamDeckKeyboardLayout_Vietnamese = 25,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_QWERTY_International)
    k_ESteamDeckKeyboardLayout_QWERTY_International = 26,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Dvorak)
    k_ESteamDeckKeyboardLayout_Dvorak = 27,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Colemak)
    k_ESteamDeckKeyboardLayout_Colemak = 28,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional)
    k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional = 29,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic)
    k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic = 30,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo = 31,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie = 32,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Japanese_Kana)
    k_ESteamDeckKeyboardLayout_Japanese_Kana = 33,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick = 34,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Indonesian)
    k_ESteamDeckKeyboardLayout_Indonesian = 35,
}

impl crate::Enum for ESteamDeckKeyboardLayout {
    const NAME: &'static str = "ESteamDeckKeyboardLayout";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckKeyboardLayout> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY),
            1 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian),
            2 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Simplified),
            3 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional),
            4 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Czech),
            5 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Danish),
            6 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Finnish),
            7 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_French),
            8 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_German),
            9 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Greek),
            10 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Hungarian),
            11 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Italian),
            12 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese),
            13 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Korean),
            14 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Norwegian),
            15 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Polish),
            16 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Portuguese),
            17 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Romanian),
            18 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Russian),
            19 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Spanish),
            20 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Swedish),
            21 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Thai),
            22 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_F),
            23 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_Q),
            24 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Ukrainian),
            25 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Vietnamese),
            26 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY_International),
            27 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Dvorak),
            28 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Colemak),
            29 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional),
            30 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic),
            31 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo),
            32 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie),
            33 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese_Kana),
            34 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick),
            35 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Indonesian),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckKeyboardLayout> {
        match str {
            "k_ESteamDeckKeyboardLayout_QWERTY" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY),
            "k_ESteamDeckKeyboardLayout_Bulgarian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian),
            "k_ESteamDeckKeyboardLayout_Chinese_Simplified" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Simplified),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional),
            "k_ESteamDeckKeyboardLayout_Czech" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Czech),
            "k_ESteamDeckKeyboardLayout_Danish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Danish),
            "k_ESteamDeckKeyboardLayout_Finnish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Finnish),
            "k_ESteamDeckKeyboardLayout_French" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_French),
            "k_ESteamDeckKeyboardLayout_German" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_German),
            "k_ESteamDeckKeyboardLayout_Greek" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Greek),
            "k_ESteamDeckKeyboardLayout_Hungarian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Hungarian),
            "k_ESteamDeckKeyboardLayout_Italian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Italian),
            "k_ESteamDeckKeyboardLayout_Japanese" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese),
            "k_ESteamDeckKeyboardLayout_Korean" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Korean),
            "k_ESteamDeckKeyboardLayout_Norwegian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Norwegian),
            "k_ESteamDeckKeyboardLayout_Polish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Polish),
            "k_ESteamDeckKeyboardLayout_Portuguese" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Portuguese),
            "k_ESteamDeckKeyboardLayout_Romanian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Romanian),
            "k_ESteamDeckKeyboardLayout_Russian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Russian),
            "k_ESteamDeckKeyboardLayout_Spanish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Spanish),
            "k_ESteamDeckKeyboardLayout_Swedish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Swedish),
            "k_ESteamDeckKeyboardLayout_Thai" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Thai),
            "k_ESteamDeckKeyboardLayout_Turkish_F" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_F),
            "k_ESteamDeckKeyboardLayout_Turkish_Q" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_Q),
            "k_ESteamDeckKeyboardLayout_Ukrainian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Ukrainian),
            "k_ESteamDeckKeyboardLayout_Vietnamese" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Vietnamese),
            "k_ESteamDeckKeyboardLayout_QWERTY_International" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY_International),
            "k_ESteamDeckKeyboardLayout_Dvorak" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Dvorak),
            "k_ESteamDeckKeyboardLayout_Colemak" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Colemak),
            "k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional),
            "k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie),
            "k_ESteamDeckKeyboardLayout_Japanese_Kana" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese_Kana),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick),
            "k_ESteamDeckKeyboardLayout_Indonesian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Indonesian),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckKeyboardLayout] = &[
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Simplified,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Czech,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Danish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Finnish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_French,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_German,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Greek,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Hungarian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Italian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Korean,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Norwegian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Polish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Portuguese,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Romanian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Russian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Spanish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Swedish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Thai,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_F,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_Q,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Ukrainian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Vietnamese,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY_International,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Dvorak,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Colemak,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese_Kana,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Indonesian,
    ];
}

impl crate::EnumFull for ESteamDeckKeyboardLayout {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDeckKeyboardLayout").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDeckKeyboardLayout {
    fn default() -> Self {
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY
    }
}

impl ESteamDeckKeyboardLayout {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESteamDeckKeyboardLayout>("ESteamDeckKeyboardLayout")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"steammessages_client_objects.proto\x1a\x0benums.proto\"\xd7\x02\n0St\
    eamMessagesClientIClientForcedEnumDependencies\x12B\n\x01a\x18\x01\x20\
    \x01(\x0e2\x15.EBluetoothDeviceType:\x1dk_BluetoothDeviceType_InvalidR\
    \x01a\x12K\n\x01b\x18\x02\x20\x01(\x0e2\x19.EStorageBlockContentType:\"k\
    _EStorageBlockContentType_InvalidR\x01b\x12Q\n\x01c\x18\x03\x20\x01(\x0e\
    2\x1c.EStorageBlockFileSystemType:%k_EStorageBlockFileSystemType_Invalid\
    R\x01c\x12?\n\x01d\x18\x04\x20\x01(\x0e2\x13.ESDCardFormatStage:\x1ck_ES\
    DCardFormatStage_InvalidR\x01d\"J\n\x1bCMsgNetworkDeviceIP4Address\x12\
    \x11\n\x02ip\x18\x01\x20\x01(\x05:\x010R\x02ip\x12\x18\n\x07netmask\x18\
    \x02\x20\x01(\x05R\x07netmask\"\x86\x02\n\x1aCMsgNetworkDeviceIP4Config\
    \x12:\n\taddresses\x18\x01\x20\x03(\x0b2\x1c.CMsgNetworkDeviceIP4Address\
    R\taddresses\x12\x15\n\x06dns_ip\x18\x02\x20\x03(\x05R\x05dnsIp\x12\x1d\
    \n\ngateway_ip\x18\x03\x20\x01(\x05R\tgatewayIp\x12&\n\x0fis_dhcp_enable\
    d\x18\x04\x20\x01(\x08R\risDhcpEnabled\x12(\n\x10is_default_route\x18\
    \x05\x20\x01(\x08R\x0eisDefaultRoute\x12$\n\nis_enabled\x18\x06\x20\x01(\
    \x08:\x05falseR\tisEnabled\"-\n\x1bCMsgNetworkDeviceIP6Address\x12\x0e\n\
    \x02ip\x18\x01\x20\x01(\tR\x02ip\"\x86\x02\n\x1aCMsgNetworkDeviceIP6Conf\
    ig\x12:\n\taddresses\x18\x01\x20\x03(\x0b2\x1c.CMsgNetworkDeviceIP6Addre\
    ssR\taddresses\x12\x15\n\x06dns_ip\x18\x02\x20\x03(\tR\x05dnsIp\x12\x1d\
    \n\ngateway_ip\x18\x03\x20\x01(\tR\tgatewayIp\x12&\n\x0fis_dhcp_enabled\
    \x18\x04\x20\x01(\x08R\risDhcpEnabled\x12(\n\x10is_default_route\x18\x05\
    \x20\x01(\x08R\x0eisDefaultRoute\x12$\n\nis_enabled\x18\x06\x20\x01(\x08\
    :\x05falseR\tisEnabled\"\xa6\x08\n\x16CMsgNetworkDevicesData\x128\n\x07d\
    evices\x18\x01\x20\x03(\x0b2\x1e.CMsgNetworkDevicesData.DeviceR\x07devic\
    es\x12&\n\x0fis_wifi_enabled\x18\x02\x20\x01(\x08R\risWifiEnabled\x127\n\
    \x18is_wifi_scanning_enabled\x18\x03\x20\x01(\x08R\x15isWifiScanningEnab\
    led\x1a\xf0\x06\n\x06Device\x12\x11\n\x02id\x18\x01\x20\x01(\r:\x010R\
    \x02id\x12\x14\n\x05etype\x18\x02\x20\x01(\x05R\x05etype\x12\x16\n\x06es\
    tate\x18\x03\x20\x01(\x05R\x06estate\x12\x10\n\x03mac\x18\x04\x20\x01(\t\
    R\x03mac\x12\x16\n\x06vendor\x18\x05\x20\x01(\tR\x06vendor\x12\x18\n\x07\
    product\x18\x06\x20\x01(\tR\x07product\x12-\n\x03ip4\x18\x07\x20\x01(\
    \x0b2\x1b.CMsgNetworkDeviceIP4ConfigR\x03ip4\x12-\n\x03ip6\x18\x08\x20\
    \x01(\x0b2\x1b.CMsgNetworkDeviceIP6ConfigR\x03ip6\x12:\n\x05wired\x18\t\
    \x20\x01(\x0b2$.CMsgNetworkDevicesData.Device.WiredR\x05wired\x12C\n\x08\
    wireless\x18\n\x20\x01(\x0b2'.CMsgNetworkDevicesData.Device.WirelessR\
    \x08wireless\x1a|\n\x05Wired\x12/\n\x10is_cable_present\x18\x01\x20\x01(\
    \x08:\x05falseR\x0eisCablePresent\x12\x1d\n\nspeed_mbit\x18\x02\x20\x01(\
    \rR\tspeedMbit\x12#\n\rfriendly_name\x18\x03\x20\x01(\tR\x0cfriendlyName\
    \x1a\x83\x03\n\x08Wireless\x12<\n\x03aps\x18\x01\x20\x03(\x0b2*.CMsgNetw\
    orkDevicesData.Device.Wireless.APR\x03aps\x12/\n\x13esecurity_supported\
    \x18\x02\x20\x01(\x05R\x12esecuritySupported\x1a\x87\x02\n\x02AP\x12\x11\
    \n\x02id\x18\x01\x20\x01(\r:\x010R\x02id\x12\x1c\n\testrength\x18\x02\
    \x20\x01(\x05R\testrength\x12\x12\n\x04ssid\x18\x03\x20\x01(\tR\x04ssid\
    \x12\x1b\n\tis_active\x18\x04\x20\x01(\x08R\x08isActive\x12%\n\x0eis_aut\
    oconnect\x18\x05\x20\x01(\x08R\risAutoconnect\x12\x1c\n\tesecurity\x18\
    \x06\x20\x01(\x05R\tesecurity\x12\x1b\n\tuser_name\x18\x07\x20\x01(\tR\
    \x08userName\x12\x1a\n\x08password\x18\x08\x20\x01(\tR\x08password\x12!\
    \n\x0cstrength_raw\x18\t\x20\x01(\x05R\x0bstrengthRaw\"\x94\x04\n\x18CMs\
    gNetworkDeviceConnect\x12\x1e\n\tdevice_id\x18\x01\x20\x01(\r:\x010R\x08\
    deviceId\x12G\n\x0bcredentials\x18\x04\x20\x01(\x0b2%.CMsgNetworkDeviceC\
    onnect.CredentialsR\x0bcredentials\x12-\n\x03ip4\x18\x05\x20\x01(\x0b2\
    \x1b.CMsgNetworkDeviceIP4ConfigR\x03ip4\x12-\n\x03ip6\x18\x06\x20\x01(\
    \x0b2\x1b.CMsgNetworkDeviceIP6ConfigR\x03ip6\x12>\n\x08ap_known\x18\x02\
    \x20\x01(\x0b2!.CMsgNetworkDeviceConnect.KnownAPH\0R\x07apKnown\x12A\n\t\
    ap_custom\x18\x03\x20\x01(\x0b2\".CMsgNetworkDeviceConnect.CustomAPH\0R\
    \x08apCustom\x1a\x1e\n\x07KnownAP\x12\x13\n\x05ap_id\x18\x01\x20\x01(\rR\
    \x04apId\x1a<\n\x08CustomAP\x12\x12\n\x04ssid\x18\x01\x20\x01(\tR\x04ssi\
    d\x12\x1c\n\tesecurity\x18\x02\x20\x01(\x05R\tesecurity\x1aE\n\x0bCreden\
    tials\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\x1a\n\
    \x08password\x18\x02\x20\x01(\tR\x08passwordB\t\n\x07ap_info\"\xab\x08\n\
    \x16CMsgStorageDevicesData\x125\n\x06drives\x18\x01\x20\x03(\x0b2\x1d.CM\
    sgStorageDevicesData.DriveR\x06drives\x12H\n\rblock_devices\x18\x02\x20\
    \x03(\x0b2#.CMsgStorageDevicesData.BlockDeviceR\x0cblockDevices\x120\n\
    \x14is_unmount_supported\x18\x03\x20\x01(\x08R\x12isUnmountSupported\x12\
    *\n\x11is_trim_supported\x18\x04\x20\x01(\x08R\x0fisTrimSupported\x12&\n\
    \x0fis_trim_running\x18\x05\x20\x01(\x08R\risTrimRunning\x1a\xfc\x01\n\
    \x05Drive\x12\x11\n\x02id\x18\x01\x20\x01(\r:\x010R\x02id\x12\x14\n\x05m\
    odel\x18\x02\x20\x01(\tR\x05model\x12\x16\n\x06vendor\x18\x03\x20\x01(\t\
    R\x06vendor\x12\x16\n\x06serial\x18\x04\x20\x01(\tR\x06serial\x12!\n\x0c\
    is_ejectable\x18\x05\x20\x01(\x08R\x0bisEjectable\x12\x1d\n\nsize_bytes\
    \x18\x06\x20\x01(\x04R\tsizeBytes\x12X\n\nmedia_type\x18\x07\x20\x01(\
    \x0e2\x17.EStorageDriveMediaType:\x20k_EStorageDriveMediaType_InvalidR\t\
    mediaType\x1a\x8a\x04\n\x0bBlockDevice\x12\x11\n\x02id\x18\x01\x20\x01(\
    \r:\x010R\x02id\x12\x1c\n\x08drive_id\x18\x02\x20\x01(\r:\x010R\x07drive\
    Id\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04path\x12#\n\rfriendly_path\
    \x18\x04\x20\x01(\tR\x0cfriendlyPath\x12\x14\n\x05label\x18\x05\x20\x01(\
    \tR\x05label\x12\x1d\n\nsize_bytes\x18\x06\x20\x01(\x04R\tsizeBytes\x12%\
    \n\x0eis_formattable\x18\x07\x20\x01(\x08R\risFormattable\x12\x20\n\x0ci\
    s_read_only\x18\x08\x20\x01(\x08R\nisReadOnly\x12$\n\x0eis_root_device\
    \x18\t\x20\x01(\x08R\x0cisRootDevice\x12`\n\x0ccontent_type\x18\n\x20\
    \x01(\x0e2\x19.EStorageBlockContentType:\"k_EStorageBlockContentType_Inv\
    alidR\x0bcontentType\x12l\n\x0ffilesystem_type\x18\x0b\x20\x01(\x0e2\x1c\
    .EStorageBlockFileSystemType:%k_EStorageBlockFileSystemType_InvalidR\x0e\
    filesystemType\x12\x1d\n\nmount_path\x18\x0c\x20\x01(\tR\tmountPath\"\
    \xec\x01\n\x1dCCloud_PendingRemoteOperation\x12_\n\toperation\x18\x01\
    \x20\x01(\x0e2\x1d.ECloudPendingRemoteOperation:\"k_ECloudPendingRemoteO\
    perationNoneR\toperation\x12!\n\x0cmachine_name\x18\x02\x20\x01(\tR\x0bm\
    achineName\x12\x1b\n\tclient_id\x18\x03\x20\x01(\x04R\x08clientId\x12*\n\
    \x11time_last_updated\x18\x04\x20\x01(\rR\x0ftimeLastUpdated\"b\n\x20CMs\
    gCloudPendingRemoteOperations\x12>\n\noperations\x18\x01\x20\x03(\x0b2\
    \x1e.CCloud_PendingRemoteOperationR\noperations\"\xaf\x05\n\x18CMsgBluet\
    oothDevicesData\x12=\n\x08adapters\x18\x01\x20\x03(\x0b2!.CMsgBluetoothD\
    evicesData.AdapterR\x08adapters\x12:\n\x07devices\x18\x02\x20\x03(\x0b2\
    \x20.CMsgBluetoothDevicesData.DeviceR\x07devices\x12;\n\x07manager\x18\
    \x03\x20\x01(\x0b2!.CMsgBluetoothDevicesData.ManagerR\x07manager\x1a\x88\
    \x01\n\x07Adapter\x12\x11\n\x02id\x18\x01\x20\x01(\r:\x010R\x02id\x12\
    \x10\n\x03mac\x18\x02\x20\x01(\tR\x03mac\x12\x12\n\x04name\x18\x03\x20\
    \x01(\tR\x04name\x12\x1d\n\nis_enabled\x18\x04\x20\x01(\x08R\tisEnabled\
    \x12%\n\x0eis_discovering\x18\x05\x20\x01(\x08R\risDiscovering\x1a\x92\
    \x02\n\x06Device\x12\x11\n\x02id\x18\x01\x20\x01(\r:\x010R\x02id\x12\x20\
    \n\nadapter_id\x18\x02\x20\x01(\r:\x010R\tadapterId\x12J\n\x05etype\x18\
    \x03\x20\x01(\x0e2\x15.EBluetoothDeviceType:\x1dk_BluetoothDeviceType_In\
    validR\x05etype\x12\x10\n\x03mac\x18\x04\x20\x01(\tR\x03mac\x12\x12\n\
    \x04name\x18\x05\x20\x01(\tR\x04name\x12!\n\x0cis_connected\x18\x06\x20\
    \x01(\x08R\x0bisConnected\x12\x1b\n\tis_paired\x18\x07\x20\x01(\x08R\x08\
    isPaired\x12!\n\x0cstrength_raw\x18\x08\x20\x01(\x05R\x0bstrengthRaw\x1a\
    ;\n\x07Manager\x120\n\x14is_bluetooth_enabled\x18\x01\x20\x01(\x08R\x12i\
    sBluetoothEnabled\"I\n\x1dCMsgSystemPerfDiagnosticEntry\x12\x12\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value\"\xf0\x01\n\x1eCMsgSystemPerfNetworkInterface\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x01R\
    \ttimestamp\x12$\n\x0etx_bytes_total\x18\x03\x20\x01(\x03R\x0ctxBytesTot\
    al\x12$\n\x0erx_bytes_total\x18\x04\x20\x01(\x03R\x0crxBytesTotal\x12'\n\
    \x10tx_bytes_per_sec\x18\x05\x20\x01(\x05R\rtxBytesPerSec\x12'\n\x10rx_b\
    ytes_per_sec\x18\x06\x20\x01(\x05R\rrxBytesPerSec\"\xbf\x01\n\x1cCMsgSys\
    temPerfDiagnosticInfo\x128\n\x07entries\x18\x01\x20\x03(\x0b2\x1e.CMsgSy\
    stemPerfDiagnosticEntryR\x07entries\x12?\n\ninterfaces\x18\x02\x20\x03(\
    \x0b2\x1f.CMsgSystemPerfNetworkInterfaceR\ninterfaces\x12$\n\x0ebattery_\
    temp_c\x18\x03\x20\x01(\x02R\x0cbatteryTempC\"\xfb\x0e\n\x14CMsgSystemPe\
    rfLimits\x12<\n\x1bcpu_governor_manual_min_mhz\x18\x01\x20\x01(\x05R\x17\
    cpuGovernorManualMinMhz\x12<\n\x1bcpu_governor_manual_max_mhz\x18\x02\
    \x20\x01(\x05R\x17cpuGovernorManualMaxMhz\x12*\n\x11fsr_sharpness_min\
    \x18\x03\x20\x01(\x05R\x0ffsrSharpnessMin\x12*\n\x11fsr_sharpness_max\
    \x18\x04\x20\x01(\x05R\x0ffsrSharpnessMax\x12B\n\x1egpu_performance_manu\
    al_min_mhz\x18\x05\x20\x01(\x05R\x1agpuPerformanceManualMinMhz\x12B\n\
    \x1egpu_performance_manual_max_mhz\x18\x06\x20\x01(\x05R\x1agpuPerforman\
    ceManualMaxMhz\x12;\n\x1aperf_overlay_is_standalone\x18\x07\x20\x01(\x08\
    R\x17perfOverlayIsStandalone\x127\n\x18is_dynamic_vrs_available\x18\x08\
    \x20\x01(\x08R\x15isDynamicVrsAvailable\x12U\n(is_manual_display_refresh\
    _rate_available\x18\t\x20\x01(\x08R#isManualDisplayRefreshRateAvailable\
    \x12^\n\x20gpu_performance_levels_available\x18\n\x20\x03(\x0e2\x15.EGPU\
    PerformanceLevelR\x1dgpuPerformanceLevelsAvailable\x12@\n\x1ddisplay_ref\
    resh_manual_hz_min\x18\x0b\x20\x01(\x05R\x19displayRefreshManualHzMin\
    \x12@\n\x1ddisplay_refresh_manual_hz_max\x18\x0c\x20\x01(\x05R\x19displa\
    yRefreshManualHzMax\x12*\n\x11fps_limit_options\x18\r\x20\x03(\x05R\x0ff\
    psLimitOptions\x12\"\n\rtdp_limit_min\x18\x0e\x20\x01(\x05R\x0btdpLimitM\
    in\x12\"\n\rtdp_limit_max\x18\x0f\x20\x01(\x05R\x0btdpLimitMax\x12(\n\
    \x10is_nis_supported\x18\x10\x20\x01(\x08R\x0eisNisSupported\x12*\n\x11n\
    is_sharpness_min\x18\x11\x20\x01(\x05R\x0fnisSharpnessMin\x12*\n\x11nis_\
    sharpness_max\x18\x12\x20\x01(\x05R\x0fnisSharpnessMax\x12Q\n&display_ex\
    ternal_refresh_manual_hz_min\x18\x13\x20\x01(\x05R!displayExternalRefres\
    hManualHzMin\x12Q\n&display_external_refresh_manual_hz_max\x18\x14\x20\
    \x01(\x05R!displayExternalRefreshManualHzMax\x12;\n\x1afps_limit_options\
    _external\x18\x15\x20\x03(\x05R\x17fpsLimitOptionsExternal\x120\n\x14is_\
    tearing_supported\x18\x16\x20\x01(\x08R\x12isTearingSupported\x12(\n\x10\
    is_vrr_supported\x18\x17\x20\x01(\x08R\x0eisVrrSupported\x12X\n*is_dynam\
    ic_refresh_rate_in_steam_supported\x18\x18\x20\x01(\x08R$isDynamicRefres\
    hRateInSteamSupported\x12U\n(is_split_scaling_and_filtering_supported\
    \x18\x19\x20\x01(\x08R#isSplitScalingAndFilteringSupported\x12[\n\x1fspl\
    it_scaling_filters_available\x18\x1a\x20\x03(\x0e2\x14.ESplitScalingFilt\
    erR\x1csplitScalingFiltersAvailable\x12[\n\x1fsplit_scaling_scalers_avai\
    lable\x18\x1b\x20\x03(\x0e2\x14.ESplitScalingScalerR\x1csplitScalingScal\
    ersAvailable\x12(\n\x10is_hdr_supported\x18\x1c\x20\x01(\x08R\x0eisHdrSu\
    pported\x12E\n\x20display_refresh_manual_hz_oc_max\x18\x1d\x20\x01(\x05R\
    \x1bdisplayRefreshManualHzOcMax\x12E\n\x1fdisable_refresh_rate_managemen\
    t\x18\x1e\x20\x01(\x08R\x1cdisableRefreshRateManagement\"\x8a\x0b\n\x1cC\
    MsgSystemPerfSettingsGlobal\x124\n\x16diagnostic_update_rate\x18\x01\x20\
    \x01(\x02R\x14diagnosticUpdateRate\x12t\n\x1asystem_trace_service_state\
    \x18\x02\x20\x01(\x0e2\x14.ESystemServiceState:!k_ESystemServiceState_Un\
    availableR\x17systemTraceServiceState\x12\x80\x01\n\x20graphics_profilin\
    g_service_state\x18\x03\x20\x01(\x0e2\x14.ESystemServiceState:!k_ESystem\
    ServiceState_UnavailableR\x1dgraphicsProfilingServiceState\x12t\n\x1aper\
    f_overlay_service_state\x18\x04\x20\x01(\x0e2\x14.ESystemServiceState:!k\
    _ESystemServiceState_UnavailableR\x17perfOverlayServiceState\x12l\n\x12p\
    erf_overlay_level\x18\x05\x20\x01(\x0e2\x1a.EGraphicsPerfOverlayLevel:\"\
    k_EGraphicsPerfOverlayLevel_HiddenR\x10perfOverlayLevel\x12R\n'is_show_p\
    erf_overlay_over_steam_enabled\x18\x06\x20\x01(\x08R!isShowPerfOverlayOv\
    erSteamEnabled\x12?\n\x1cis_advanced_settings_enabled\x18\x07\x20\x01(\
    \x08R\x19isAdvancedSettingsEnabled\x12R\n&allow_external_display_refresh\
    _control\x18\x08\x20\x01(\x08R\"allowExternalDisplayRefreshControl\x12$\
    \n\x0eis_hdr_enabled\x18\t\x20\x01(\x08R\x0cisHdrEnabled\x12q\n\x1bhdr_o\
    n_sdr_tonemap_operator\x18\x0c\x20\x01(\x0e2\x14.EHDRToneMapOperator:\
    \x1dk_EHDRToneMapOperator_InvalidR\x17hdrOnSdrTonemapOperator\x12>\n\x1c\
    is_hdr_debug_heatmap_enabled\x18\r\x20\x01(\x08R\x18isHdrDebugHeatmapEna\
    bled\x12E\n\x1dforce_hdr_wide_gammut_for_sdr\x18\x0f\x20\x01(\x08:\x04tr\
    ueR\x18forceHdrWideGammutForSdr\x124\n\x16allow_experimental_hdr\x18\x10\
    \x20\x01(\x08R\x14allowExperimentalHdr\x121\n\x15sdr_to_hdr_brightness\
    \x18\x16\x20\x01(\x02R\x12sdrToHdrBrightness\x125\n\x17debug_force_hdr_s\
    upport\x18\x12\x20\x01(\x08R\x14debugForceHdrSupport\x12<\n\x1bforce_hdr\
    _10pq_output_debug\x18\x13\x20\x01(\x08R\x17forceHdr10pqOutputDebug\x121\
    \n\x15is_display_oc_enabled\x18\x14\x20\x01(\x08R\x12isDisplayOcEnabled\
    \x12=\n\x1bis_color_management_enabled\x18\x15\x20\x01(\x08R\x18isColorM\
    anagementEnabled\"\xe3\x0b\n\x1cCMsgSystemPerfSettingsPerApp\x12;\n\x1ag\
    pu_performance_manual_mhz\x18\x01\x20\x01(\x05R\x17gpuPerformanceManualM\
    hz\x12\x1b\n\tfps_limit\x18\x02\x20\x01(\x05R\x08fpsLimit\x12C\n\x1eis_v\
    ariable_resolution_enabled\x18\x03\x20\x01(\x08R\x1bisVariableResolution\
    Enabled\x12D\n\x1fis_dynamic_refresh_rate_enabled\x18\x04\x20\x01(\x08R\
    \x1bisDynamicRefreshRateEnabled\x12\x1b\n\ttdp_limit\x18\x05\x20\x01(\
    \x05R\x08tdpLimit\x12H\n\x0ccpu_governor\x18\x06\x20\x01(\x0e2\r.ECPUGov\
    ernor:\x16k_ECPUGovernor_InvalidR\x0bcpuGovernor\x125\n\x17cpu_governor_\
    manual_mhz\x18\x07\x20\x01(\x05R\x14cpuGovernorManualMhz\x12%\n\x0escali\
    ng_filter\x18\x08\x20\x01(\x05R\rscalingFilter\x12#\n\rfsr_sharpness\x18\
    \t\x20\x01(\x05R\x0cfsrSharpness\x12/\n\x14is_fps_limit_enabled\x18\n\
    \x20\x01(\x08R\x11isFpsLimitEnabled\x12/\n\x14is_tdp_limit_enabled\x18\
    \x0b\x20\x01(\x08R\x11isTdpLimitEnabled\x12<\n\x1bis_low_latency_mode_en\
    abled\x18\x0c\x20\x01(\x08R\x17isLowLatencyModeEnabled\x129\n\x19display\
    _refresh_manual_hz\x18\r\x20\x01(\x05R\x16displayRefreshManualHz\x12>\n\
    \x1cis_game_perf_profile_enabled\x18\x0e\x20\x01(\x08R\x18isGamePerfProf\
    ileEnabled\x12i\n\x15gpu_performance_level\x18\x0f\x20\x01(\x0e2\x15.EGP\
    UPerformanceLevel:\x1ek_EGPUPerformanceLevel_InvalidR\x13gpuPerformanceL\
    evel\x12#\n\rnis_sharpness\x18\x10\x20\x01(\x05R\x0cnisSharpness\x12J\n\
    \"display_external_refresh_manual_hz\x18\x11\x20\x01(\x05R\x1edisplayExt\
    ernalRefreshManualHz\x12,\n\x12fps_limit_external\x18\x12\x20\x01(\x05R\
    \x10fpsLimitExternal\x12,\n\x12is_tearing_enabled\x18\x13\x20\x01(\x08R\
    \x10isTearingEnabled\x12$\n\x0eis_vrr_enabled\x18\x14\x20\x01(\x08R\x0ci\
    sVrrEnabled\x12;\n\x1ais_composite_debug_enabled\x18\x15\x20\x01(\x08R\
    \x17isCompositeDebugEnabled\x12'\n\x0fforce_composite\x18\x16\x20\x01(\
    \x08R\x0eforceComposite\x12G\n!use_dynamic_refresh_rate_in_steam\x18\x17\
    \x20\x01(\x08R\x1cuseDynamicRefreshRateInSteam\x12e\n\x14split_scaling_f\
    ilter\x18\x18\x20\x01(\x0e2\x14.ESplitScalingFilter:\x1dk_ESplitScalingF\
    ilter_InvalidR\x12splitScalingFilter\x12e\n\x14split_scaling_scaler\x18\
    \x19\x20\x01(\x0e2\x14.ESplitScalingScaler:\x1dk_ESplitScalingScaler_Inv\
    alidR\x12splitScalingScaler\"\x87\x01\n\x16CMsgSystemPerfSettings\x125\n\
    \x06global\x18\x01\x20\x01(\x0b2\x1d.CMsgSystemPerfSettingsGlobalR\x06gl\
    obal\x126\n\x07per_app\x18\x02\x20\x01(\x0b2\x1d.CMsgSystemPerfSettingsP\
    erAppR\x06perApp\"\xd6\x0b\n\x18CMsgSystemPerfSettingsV1\x124\n\x16diagn\
    ostic_update_rate\x18\x01\x20\x01(\x02R\x14diagnosticUpdateRate\x12t\n\
    \x1asystem_trace_service_state\x18\x02\x20\x01(\x0e2\x14.ESystemServiceS\
    tate:!k_ESystemServiceState_UnavailableR\x17systemTraceServiceState\x12\
    \x80\x01\n\x20graphics_profiling_service_state\x18\x03\x20\x01(\x0e2\x14\
    .ESystemServiceState:!k_ESystemServiceState_UnavailableR\x1dgraphicsProf\
    ilingServiceState\x12t\n\x1aperf_overlay_service_state\x18\x04\x20\x01(\
    \x0e2\x14.ESystemServiceState:!k_ESystemServiceState_UnavailableR\x17per\
    fOverlayServiceState\x12l\n\x12perf_overlay_level\x18\x05\x20\x01(\x0e2\
    \x1a.EGraphicsPerfOverlayLevel:\"k_EGraphicsPerfOverlayLevel_HiddenR\x10\
    perfOverlayLevel\x12i\n\x15gpu_performance_level\x18\x06\x20\x01(\x0e2\
    \x15.EGPUPerformanceLevel:\x1ek_EGPUPerformanceLevel_InvalidR\x13gpuPerf\
    ormanceLevel\x12;\n\x1agpu_performance_manual_mhz\x18\x07\x20\x01(\x05R\
    \x17gpuPerformanceManualMhz\x12\x1b\n\tfps_limit\x18\x08\x20\x01(\x05R\
    \x08fpsLimit\x12C\n\x1eis_variable_resolution_enabled\x18\t\x20\x01(\x08\
    R\x1bisVariableResolutionEnabled\x12D\n\x1fis_dynamic_refresh_rate_enabl\
    ed\x18\n\x20\x01(\x08R\x1bisDynamicRefreshRateEnabled\x12\x1b\n\ttdp_lim\
    it\x18\x0b\x20\x01(\x05R\x08tdpLimit\x12H\n\x0ccpu_governor\x18\x0c\x20\
    \x01(\x0e2\r.ECPUGovernor:\x16k_ECPUGovernor_InvalidR\x0bcpuGovernor\x12\
    5\n\x17cpu_governor_manual_mhz\x18\r\x20\x01(\x05R\x14cpuGovernorManualM\
    hz\x12%\n\x0escaling_filter\x18\x0e\x20\x01(\x05R\rscalingFilter\x12#\n\
    \rfsr_sharpness\x18\x0f\x20\x01(\x05R\x0cfsrSharpness\x12/\n\x14is_fps_l\
    imit_enabled\x18\x10\x20\x01(\x08R\x11isFpsLimitEnabled\x12/\n\x14is_tdp\
    _limit_enabled\x18\x11\x20\x01(\x08R\x11isTdpLimitEnabled\x12R\n'is_show\
    _perf_overlay_over_steam_enabled\x18\x12\x20\x01(\x08R!isShowPerfOverlay\
    OverSteamEnabled\x12<\n\x1bis_low_latency_mode_enabled\x18\x13\x20\x01(\
    \x08R\x17isLowLatencyModeEnabled\x129\n\x19display_refresh_manual_hz\x18\
    \x14\x20\x01(\x05R\x16displayRefreshManualHz\x12>\n\x1cis_game_perf_prof\
    ile_enabled\x18\x15\x20\x01(\x08R\x18isGamePerfProfileEnabled\"\xd6\x01\
    \n\x13CMsgSystemPerfState\x12-\n\x06limits\x18\x01\x20\x01(\x0b2\x15.CMs\
    gSystemPerfLimitsR\x06limits\x123\n\x08settings\x18\x02\x20\x01(\x0b2\
    \x17.CMsgSystemPerfSettingsR\x08settings\x12&\n\x0fcurrent_game_id\x18\
    \x03\x20\x01(\x04R\rcurrentGameId\x123\n\x16active_profile_game_id\x18\
    \x04\x20\x01(\x04R\x13activeProfileGameId\"\xde\x01\n\x1cCMsgSystemPerfU\
    pdateSettings\x12\x16\n\x06gameid\x18\x01\x20\x01(\x04R\x06gameid\x12.\n\
    \x13skip_storage_update\x18\x04\x20\x01(\x08R\x11skipStorageUpdate\x12*\
    \n\x10reset_to_default\x18\x02\x20\x01(\x08H\0R\x0eresetToDefault\x12@\n\
    \x0esettings_delta\x18\x03\x20\x01(\x0b2\x17.CMsgSystemPerfSettingsH\0R\
    \rsettingsDeltaB\x08\n\x06update\"\xef\x02\n\x19CMsgSystemDockUpdateStat\
    e\x12=\n\x05state\x18\x01\x20\x01(\x0e2\x0e.EUpdaterState:\x17k_EUpdater\
    State_InvalidR\x05state\x12,\n\x12rtime_last_checked\x18\x02\x20\x01(\
    \x07R\x10rtimeLastChecked\x12'\n\x0fversion_current\x18\x03\x20\x01(\tR\
    \x0eversionCurrent\x12+\n\x11version_available\x18\x04\x20\x01(\tR\x10ve\
    rsionAvailable\x12%\n\x0estage_progress\x18\x05\x20\x01(\x02R\rstageProg\
    ress\x12<\n\x1artime_estimated_completion\x18\x06\x20\x01(\x07R\x18rtime\
    EstimatedCompletion\x12*\n\x11old_fw_workaround\x18\x07\x20\x01(\x05R\
    \x0foldFwWorkaround\"T\n\x13CMsgSystemDockState\x12=\n\x0cupdate_state\
    \x18\x01\x20\x01(\x0b2\x1a.CMsgSystemDockUpdateStateR\x0bupdateState\"=\
    \n\x1cCMsgSystemDockUpdateFirmware\x12\x1d\n\ncheck_only\x18\x01\x20\x01\
    (\x08R\tcheckOnly\"\xe9\x01\n\x15CMsgSystemAudioVolume\x12=\n\x07entries\
    \x18\x01\x20\x03(\x0b2#.CMsgSystemAudioVolume.ChannelEntryR\x07entries\
    \x12\x19\n\x08is_muted\x18\x02\x20\x01(\x08R\x07isMuted\x1av\n\x0cChanne\
    lEntry\x12N\n\x08echannel\x18\x01\x20\x01(\x0e2\x14.ESystemAudioChannel:\
    \x1ck_SystemAudioChannel_InvalidR\x08echannel\x12\x16\n\x06volume\x18\
    \x02\x20\x01(\x02R\x06volume\"Z\n\x1cCMsgSystemAudioManagerObject\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12*\n\x11rtime_last_update\x18\
    \x02\x20\x01(\x07R\x0frtimeLastUpdate\"\xad\x01\n\x1cCMsgSystemAudioMana\
    gerDevice\x121\n\x04base\x18\x01\x20\x01(\x0b2\x1d.CMsgSystemAudioManage\
    rObjectR\x04base\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\
    \x04nick\x18\x03\x20\x01(\tR\x04nick\x12\x20\n\x0bdescription\x18\x04\
    \x20\x01(\tR\x0bdescription\x12\x10\n\x03api\x18\x05\x20\x01(\tR\x03api\
    \"\xbe\x02\n\x1aCMsgSystemAudioManagerNode\x121\n\x04base\x18\x01\x20\
    \x01(\x0b2\x1d.CMsgSystemAudioManagerObjectR\x04base\x12\x1b\n\tdevice_i\
    d\x18\x02\x20\x01(\rR\x08deviceId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\x12\x12\n\x04nick\x18\x04\x20\x01(\tR\x04nick\x12\x20\n\x0bdesc\
    ription\x18\x05\x20\x01(\tR\x0bdescription\x12V\n\nedirection\x18\x06\
    \x20\x01(\x0e2\x16.ESystemAudioDirection:\x1ek_SystemAudioDirection_Inva\
    lidR\nedirection\x12.\n\x06volume\x18\x07\x20\x01(\x0b2\x16.CMsgSystemAu\
    dioVolumeR\x06volume\"\xbe\x03\n\x1aCMsgSystemAudioManagerPort\x121\n\
    \x04base\x18\x01\x20\x01(\x0b2\x1d.CMsgSystemAudioManagerObjectR\x04base\
    \x12\x17\n\x07node_id\x18\x03\x20\x01(\rR\x06nodeId\x12\x12\n\x04name\
    \x18\x04\x20\x01(\tR\x04name\x12\x14\n\x05alias\x18\x05\x20\x01(\tR\x05a\
    lias\x12J\n\x05etype\x18\x06\x20\x01(\x0e2\x15.ESystemAudioPortType:\x1d\
    k_SystemAudioPortType_InvalidR\x05etype\x12^\n\nedirection\x18\x07\x20\
    \x01(\x0e2\x1a.ESystemAudioPortDirection:\"k_SystemAudioPortDirection_In\
    validR\nedirection\x12\x1f\n\x0bis_physical\x18\x08\x20\x01(\x08R\nisPhy\
    sical\x12\x1f\n\x0bis_terminal\x18\t\x20\x01(\x08R\nisTerminal\x12\x1d\n\
    \nis_control\x18\n\x20\x01(\x08R\tisControl\x12\x1d\n\nis_monitor\x18\
    \x0b\x20\x01(\x08R\tisMonitor\"\xe3\x01\n\x1aCMsgSystemAudioManagerLink\
    \x121\n\x04base\x18\x01\x20\x01(\x0b2\x1d.CMsgSystemAudioManagerObjectR\
    \x04base\x12$\n\x0eoutput_node_id\x18\x02\x20\x01(\rR\x0coutputNodeId\
    \x12$\n\x0eoutput_port_id\x18\x03\x20\x01(\rR\x0coutputPortId\x12\"\n\ri\
    nput_node_id\x18\x04\x20\x01(\rR\x0binputNodeId\x12\"\n\rinput_port_id\
    \x18\x05\x20\x01(\rR\x0binputPortId\"\xf1\x01\n\x1dCMsgSystemAudioManage\
    rStateHW\x127\n\x07devices\x18\x01\x20\x03(\x0b2\x1d.CMsgSystemAudioMana\
    gerDeviceR\x07devices\x121\n\x05nodes\x18\x02\x20\x03(\x0b2\x1b.CMsgSyst\
    emAudioManagerNodeR\x05nodes\x121\n\x05ports\x18\x03\x20\x03(\x0b2\x1b.C\
    MsgSystemAudioManagerPortR\x05ports\x121\n\x05links\x18\x04\x20\x03(\x0b\
    2\x1b.CMsgSystemAudioManagerLinkR\x05links\"\x8a\x01\n\x1bCMsgSystemAudi\
    oManagerState\x12!\n\x0crtime_filter\x18\x01\x20\x01(\x07R\x0brtimeFilte\
    r\x12\x18\n\x07counter\x18\x02\x20\x01(\x05R\x07counter\x12.\n\x02hw\x18\
    \x03\x20\x01(\x0b2\x1e.CMsgSystemAudioManagerStateHWR\x02hw\"A\n%CMsgSys\
    temAudioManagerUpdateSomething\x12\x18\n\x07counter\x18\x01\x20\x01(\x05\
    R\x07counter\"t\n\x15CMsgSystemDisplayMode\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\x05R\x02id\x12\x14\n\x05width\x18\x02\x20\x01(\x05R\x05width\x12\
    \x16\n\x06height\x18\x03\x20\x01(\x05R\x06height\x12\x1d\n\nrefresh_hz\
    \x18\x04\x20\x01(\x05R\trefreshHz\"\xb5\x05\n\x11CMsgSystemDisplay\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescrip\
    tion\x12\x1d\n\nis_primary\x18\x04\x20\x01(\x08R\tisPrimary\x12\x1d\n\ni\
    s_enabled\x18\x05\x20\x01(\x08R\tisEnabled\x12\x1f\n\x0bis_internal\x18\
    \x06\x20\x01(\x08R\nisInternal\x12*\n\x11has_mode_override\x18\x07\x20\
    \x01(\x08R\x0fhasModeOverride\x12\x19\n\x08width_mm\x18\x08\x20\x01(\x05\
    R\x07widthMm\x12\x1b\n\theight_mm\x18\t\x20\x01(\x05R\x08heightMm\x12&\n\
    \x0fcurrent_mode_id\x18\n\x20\x01(\x05R\rcurrentModeId\x12,\n\x05modes\
    \x18\x0b\x20\x03(\x0b2\x16.CMsgSystemDisplayModeR\x05modes\x12(\n\x10ref\
    resh_rate_min\x18\x0c\x20\x01(\x05R\x0erefreshRateMin\x12(\n\x10refresh_\
    rate_max\x18\r\x20\x01(\x05R\x0erefreshRateMax\x12$\n\x0eis_vrr_capable\
    \x18\x0e\x20\x01(\x08R\x0cisVrrCapable\x12$\n\x0eis_vrr_enabled\x18\x0f\
    \x20\x01(\x08R\x0cisVrrEnabled\x12$\n\x0eis_hdr_capable\x18\x10\x20\x01(\
    \x08R\x0cisHdrCapable\x12$\n\x0eis_hdr_enabled\x18\x11\x20\x01(\x08R\x0c\
    isHdrEnabled\x121\n\x14compatibility_params\x18\x12\x20\x03(\x05R\x13com\
    patibilityParams\x12\"\n\rapp_wants_hdr\x18\x13\x20\x01(\x08R\x0bappWant\
    sHdr\"\x8a\x02\n\x1dCMsgSystemDisplayManagerState\x12.\n\x08displays\x18\
    \x01\x20\x03(\x0b2\x12.CMsgSystemDisplayR\x08displays\x12=\n\x1bis_mode_\
    switching_supported\x18\x02\x20\x01(\x08R\x18isModeSwitchingSupported\
    \x12z\n\x12compatibility_mode\x18\x03\x20\x01(\x0e2\x20.ESystemDisplayCo\
    mpatibilityMode:)k_ESystemDisplayCompatibilityMode_InvalidR\x11compatibi\
    lityMode\"Y\n\x1fCMsgSystemDisplayManagerSetMode\x12\x1d\n\ndisplay_id\
    \x18\x01\x20\x01(\x05R\tdisplayId\x12\x17\n\x07mode_id\x18\x02\x20\x01(\
    \x05R\x06modeId\"\xed\x11\n\x19CMsgSystemManagerSettings\x12J\n\"idle_ba\
    cklight_dim_battery_seconds\x18\x01\x20\x01(\x02R\x1eidleBacklightDimBat\
    terySeconds\x12@\n\x1didle_backlight_dim_ac_seconds\x18\x02\x20\x01(\x02\
    R\x19idleBacklightDimAcSeconds\x12?\n\x1cidle_suspend_battery_seconds\
    \x18\x03\x20\x01(\x02R\x19idleSuspendBatterySeconds\x125\n\x17idle_suspe\
    nd_ac_seconds\x18\x04\x20\x01(\x02R\x14idleSuspendAcSeconds\x124\n\x16id\
    le_suspend_supressed\x18\x05\x20\x01(\x08R\x14idleSuspendSupressed\x12G\
    \n\x20is_adaptive_brightness_available\x18\x06\x20\x01(\x08R\x1disAdapti\
    veBrightnessAvailable\x12M\n#display_adaptive_brightness_enabled\x18\x07\
    \x20\x01(\x08R\x20displayAdaptiveBrightnessEnabled\x12:\n\x19display_nig\
    htmode_enabled\x18\n\x20\x01(\x08R\x17displayNightmodeEnabled\x12D\n\x1e\
    display_nightmode_tintstrength\x18\x0b\x20\x01(\x02R\x1cdisplayNightmode\
    Tintstrength\x128\n\x18display_nightmode_maxhue\x18\x0c\x20\x01(\x02R\
    \x16displayNightmodeMaxhue\x128\n\x18display_nightmode_maxsat\x18\r\x20\
    \x01(\x02R\x16displayNightmodeMaxsat\x126\n\x17display_nightmode_uiexp\
    \x18\x0e\x20\x01(\x02R\x15displayNightmodeUiexp\x126\n\x17display_nightm\
    ode_blend\x18\x0f\x20\x01(\x02R\x15displayNightmodeBlend\x126\n\x17displ\
    ay_nightmode_reset\x18\x10\x20\x01(\x08R\x15displayNightmodeReset\x12K\n\
    \"display_nightmode_schedule_enabled\x18\x11\x20\x01(\x08R\x1fdisplayNig\
    htmodeScheduleEnabled\x12O\n$display_nightmode_schedule_starttime\x18\
    \x12\x20\x01(\x02R!displayNightmodeScheduleStarttime\x12K\n\"display_nig\
    htmode_schedule_endtime\x18\x13\x20\x01(\x02R\x1fdisplayNightmodeSchedul\
    eEndtime\x12>\n\x1bdisplay_diagnostics_enabled\x18\x14\x20\x01(\x08R\x19\
    displayDiagnosticsEnabled\x12&\n\x0fals_lux_primary\x18\x15\x20\x01(\x02\
    R\ralsLuxPrimary\x12$\n\x0eals_lux_median\x18\x16\x20\x01(\x02R\x0calsLu\
    xMedian\x122\n\x15display_backlight_raw\x18\x17\x20\x01(\x02R\x13display\
    BacklightRaw\x12D\n\x1edisplay_brightness_adaptivemin\x18\x18\x20\x01(\
    \x02R\x1cdisplayBrightnessAdaptivemin\x12D\n\x1edisplay_brightness_adapt\
    ivemax\x18\x19\x20\x01(\x02R\x1cdisplayBrightnessAdaptivemax\x129\n\x19i\
    s_wifi_powersave_enabled\x18\x1a\x20\x01(\x08R\x16isWifiPowersaveEnabled\
    \x127\n\x18is_fan_control_available\x18\x1b\x20\x01(\x08R\x15isFanContro\
    lAvailable\x12`\n\x10fan_control_mode\x18\x1c\x20\x01(\x0e2\x16.ESystemF\
    anControlMode:\x1ek_SystemFanControlMode_InvalidR\x0efanControlMode\x12E\
    \n\x1fis_display_brightness_available\x18\x1d\x20\x01(\x08R\x1cisDisplay\
    BrightnessAvailable\x12O\n$is_display_colormanagement_available\x18\x1f\
    \x20\x01(\x08R!isDisplayColormanagementAvailable\x12-\n\x12display_color\
    gamut\x18\x20\x20\x01(\x02R\x11displayColorgamut\x12*\n\x11als_lux_alter\
    nate\x18!\x20\x01(\x02R\x0falsLuxAlternate\x12C\n\x1eis_display_colortem\
    p_available\x18\"\x20\x01(\x08R\x1bisDisplayColortempAvailable\x12+\n\
    \x11display_colortemp\x18#\x20\x01(\x02R\x10displayColortemp\x12:\n\x19d\
    isplay_colortemp_default\x18$\x20\x01(\x02R\x17displayColortempDefault\
    \x12:\n\x19display_colortemp_enabled\x18%\x20\x01(\x08R\x17displayColort\
    empEnabled\x12r\n\x1bdisplay_colorgamut_labelset\x18&\x20\x01(\x0e2\x14.\
    EColorGamutLabelSet:\x1ck_ColorGamutLabelSet_DefaultR\x19displayColorgam\
    utLabelset\"x\n\x18CMsgSelectOSBranchParams\x127\n\x06branch\x18\x01\x20\
    \x01(\x0e2\n.EOSBranch:\x13k_EOSBranch_UnknownR\x06branch\x12#\n\rcustom\
    _branch\x18\x02\x20\x01(\tR\x0ccustomBranch\"\xa9\x01\n\x18CMsgSystemUpd\
    ateProgress\x12%\n\x0estage_progress\x18\x01\x20\x01(\x02R\rstageProgres\
    s\x12(\n\x10stage_size_bytes\x18\x02\x20\x01(\x03R\x0estageSizeBytes\x12\
    <\n\x1artime_estimated_completion\x18\x03\x20\x01(\x07R\x18rtimeEstimate\
    dCompletion\"\xf5\x01\n\x1bCMsgSystemUpdateCheckResult\x129\n\x04type\
    \x18\x01\x20\x01(\x0e2\r.EUpdaterType:\x16k_EUpdaterType_InvalidR\x04typ\
    e\x12\x1b\n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07eresult\x12#\n\rrtim\
    e_checked\x18\x03\x20\x01(\x07R\x0crtimeChecked\x12\x1c\n\tavailable\x18\
    \x04\x20\x01(\x08R\tavailable\x12\x18\n\x07version\x18\x05\x20\x01(\tR\
    \x07version\x12!\n\x0cauto_message\x18\x06\x20\x01(\tR\x0bautoMessage\"M\
    \n\x1bCMsgSystemUpdateApplyParams\x12.\n\x0bapply_types\x18\x01\x20\x03(\
    \x0e2\r.EUpdaterTypeR\napplyTypes\"\xf3\x01\n\x1bCMsgSystemUpdateApplyRe\
    sult\x129\n\x04type\x18\x01\x20\x01(\x0e2\r.EUpdaterType:\x16k_EUpdaterT\
    ype_InvalidR\x04type\x12\x1b\n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07e\
    result\x12=\n\x17requires_client_restart\x18\x03\x20\x01(\x08:\x05falseR\
    \x15requiresClientRestart\x12=\n\x17requires_system_restart\x18\x04\x20\
    \x01(\x08:\x05falseR\x15requiresSystemRestart\"\xdd\x02\n\x15CMsgSystemU\
    pdateState\x12=\n\x05state\x18\x01\x20\x01(\x0e2\x0e.EUpdaterState:\x17k\
    _EUpdaterState_InvalidR\x05state\x125\n\x08progress\x18\x02\x20\x01(\x0b\
    2\x19.CMsgSystemUpdateProgressR\x08progress\x12N\n\x14update_check_resul\
    ts\x18\x03\x20\x03(\x0b2\x1c.CMsgSystemUpdateCheckResultR\x12updateCheck\
    Results\x12N\n\x14update_apply_results\x18\x04\x20\x03(\x0b2\x1c.CMsgSys\
    temUpdateApplyResultR\x12updateApplyResults\x12.\n\x13supports_os_update\
    s\x18\x05\x20\x01(\x08R\x11supportsOsUpdates\"-\n\x15CMsgAchievementChan\
    ge\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"t\n\x0cCMsgCellList\
    \x12(\n\x05cells\x18\x01\x20\x03(\x0b2\x12.CMsgCellList.CellR\x05cells\
    \x1a:\n\x04Cell\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellId\x12\
    \x19\n\x08loc_name\x18\x02\x20\x01(\tR\x07locName\"\xe1\x04\n\x10CMsgSho\
    rtcutInfo\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x10\n\x03e\
    xe\x18\x02\x20\x01(\tR\x03exe\x12\x1b\n\tstart_dir\x18\x03\x20\x01(\tR\
    \x08startDir\x12\x12\n\x04icon\x18\x04\x20\x01(\tR\x04icon\x12\x12\n\x04\
    path\x18\x05\x20\x01(\tR\x04path\x12\x12\n\x04args\x18\x06\x20\x01(\tR\
    \x04args\x12\x19\n\x08app_name\x18\x07\x20\x01(\tR\x07appName\x12%\n\x0e\
    override_appid\x18\x08\x20\x01(\rR\roverrideAppid\x12#\n\rflatpak_appid\
    \x18\t\x20\x01(\tR\x0cflatpakAppid\x12\x12\n\x04tags\x18\n\x20\x03(\tR\
    \x04tags\x12\x1b\n\tis_remote\x18\x0b\x20\x01(\x08R\x08isRemote\x12\x1b\
    \n\tis_hidden\x18\x0c\x20\x01(\x08R\x08isHidden\x12!\n\x0cis_temporary\
    \x18\r\x20\x01(\x08R\x0bisTemporary\x12\x1b\n\tis_openvr\x18\x0e\x20\x01\
    (\x08R\x08isOpenvr\x120\n\x14allow_desktop_config\x18\x0f\x20\x01(\x08R\
    \x12allowDesktopConfig\x12#\n\rallow_overlay\x18\x10\x20\x01(\x08R\x0cal\
    lowOverlay\x12-\n\x13rt_last_played_time\x18\x11\x20\x01(\rR\x10rtLastPl\
    ayedTime\x12,\n\x12is_devkit_shortcut\x18\x12\x20\x01(\x08R\x10isDevkitS\
    hortcut\x12#\n\rdevkit_gameid\x18\x13\x20\x01(\tR\x0cdevkitGameid\",\n\
    \x12CMsgShortcutAppIds\x12\x16\n\x06appids\x18\x01\x20\x03(\rR\x06appids\
    \"\xf0\x01\n\x0fCMsgMonitorInfo\x122\n\x15selected_display_name\x18\x01\
    \x20\x02(\tR\x13selectedDisplayName\x128\n\x08monitors\x18\x02\x20\x03(\
    \x0b2\x1c.CMsgMonitorInfo.MonitorInfoR\x08monitors\x1ao\n\x0bMonitorInfo\
    \x12.\n\x13monitor_device_name\x18\x01\x20\x02(\tR\x11monitorDeviceName\
    \x120\n\x14monitor_display_name\x18\x02\x20\x02(\tR\x12monitorDisplayNam\
    e\"<\n\x1dCMsgGenerateSystemReportReply\x12\x1b\n\treport_id\x18\x01\x20\
    \x01(\tR\x08reportId\"G\n\x16CMsgWebUITransportInfo\x12\x12\n\x04port\
    \x18\x01\x20\x01(\rR\x04port\x12\x19\n\x08auth_key\x18\x02\x20\x01(\tR\
    \x07authKey\"\x81\x01\n\x1dCMsgClientShaderHitCacheEntry\x12\x17\n\x07ke\
    y_sha\x18\x01\x20\x01(\x0cR\x06keySha\x12\x19\n\x08code_sha\x18\x02\x20\
    \x01(\x0cR\x07codeSha\x12,\n\x12time_last_reported\x18\x03\x20\x01(\x04R\
    \x10timeLastReported\"T\n\x18CMsgClientShaderHitCache\x128\n\x07entries\
    \x18\x01\x20\x03(\x0b2\x1e.CMsgClientShaderHitCacheEntryR\x07entries*\
    \x96\x02\n\x1cECloudPendingRemoteOperation\x12&\n\"k_ECloudPendingRemote\
    OperationNone\x10\0\x122\n.k_ECloudPendingRemoteOperationAppSessionActiv\
    e\x10\x01\x122\n.k_ECloudPendingRemoteOperationUploadInProgress\x10\x02\
    \x12/\n+k_ECloudPendingRemoteOperationUploadPending\x10\x03\x125\n1k_ECl\
    oudPendingRemoteOperationAppSessionSuspended\x10\x04*\xca\x0c\n\x18EStea\
    mDeckKeyboardLayout\x12%\n!k_ESteamDeckKeyboardLayout_QWERTY\x10\0\x12(\
    \n$k_ESteamDeckKeyboardLayout_Bulgarian\x10\x01\x121\n-k_ESteamDeckKeybo\
    ardLayout_Chinese_Simplified\x10\x02\x122\n.k_ESteamDeckKeyboardLayout_C\
    hinese_Traditional\x10\x03\x12$\n\x20k_ESteamDeckKeyboardLayout_Czech\
    \x10\x04\x12%\n!k_ESteamDeckKeyboardLayout_Danish\x10\x05\x12&\n\"k_ESte\
    amDeckKeyboardLayout_Finnish\x10\x06\x12%\n!k_ESteamDeckKeyboardLayout_F\
    rench\x10\x07\x12%\n!k_ESteamDeckKeyboardLayout_German\x10\x08\x12$\n\
    \x20k_ESteamDeckKeyboardLayout_Greek\x10\t\x12(\n$k_ESteamDeckKeyboardLa\
    yout_Hungarian\x10\n\x12&\n\"k_ESteamDeckKeyboardLayout_Italian\x10\x0b\
    \x12'\n#k_ESteamDeckKeyboardLayout_Japanese\x10\x0c\x12%\n!k_ESteamDeckK\
    eyboardLayout_Korean\x10\r\x12(\n$k_ESteamDeckKeyboardLayout_Norwegian\
    \x10\x0e\x12%\n!k_ESteamDeckKeyboardLayout_Polish\x10\x0f\x12)\n%k_EStea\
    mDeckKeyboardLayout_Portuguese\x10\x10\x12'\n#k_ESteamDeckKeyboardLayout\
    _Romanian\x10\x11\x12&\n\"k_ESteamDeckKeyboardLayout_Russian\x10\x12\x12\
    &\n\"k_ESteamDeckKeyboardLayout_Spanish\x10\x13\x12&\n\"k_ESteamDeckKeyb\
    oardLayout_Swedish\x10\x14\x12#\n\x1fk_ESteamDeckKeyboardLayout_Thai\x10\
    \x15\x12(\n$k_ESteamDeckKeyboardLayout_Turkish_F\x10\x16\x12(\n$k_ESteam\
    DeckKeyboardLayout_Turkish_Q\x10\x17\x12(\n$k_ESteamDeckKeyboardLayout_U\
    krainian\x10\x18\x12)\n%k_ESteamDeckKeyboardLayout_Vietnamese\x10\x19\
    \x123\n/k_ESteamDeckKeyboardLayout_QWERTY_International\x10\x1a\x12%\n!k\
    _ESteamDeckKeyboardLayout_Dvorak\x10\x1b\x12&\n\"k_ESteamDeckKeyboardLay\
    out_Colemak\x10\x1c\x12=\n9k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic\
    _Traditional\x10\x1d\x121\n-k_ESteamDeckKeyboardLayout_Bulgarian_Phoneti\
    c\x10\x1e\x12;\n7k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo\
    \x10\x1f\x12:\n6k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie\
    \x10\x20\x12,\n(k_ESteamDeckKeyboardLayout_Japanese_Kana\x10!\x128\n4k_E\
    SteamDeckKeyboardLayout_Chinese_Traditional_Quick\x10\"\x12)\n%k_ESteamD\
    eckKeyboardLayout_Indonesian\x10#B\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(68);
            messages.push(SteamMessagesClientIClientForcedEnumDependencies::generated_message_descriptor_data());
            messages.push(CMsgNetworkDeviceIP4Address::generated_message_descriptor_data());
            messages.push(CMsgNetworkDeviceIP4Config::generated_message_descriptor_data());
            messages.push(CMsgNetworkDeviceIP6Address::generated_message_descriptor_data());
            messages.push(CMsgNetworkDeviceIP6Config::generated_message_descriptor_data());
            messages.push(CMsgNetworkDevicesData::generated_message_descriptor_data());
            messages.push(CMsgNetworkDeviceConnect::generated_message_descriptor_data());
            messages.push(CMsgStorageDevicesData::generated_message_descriptor_data());
            messages.push(CCloud_PendingRemoteOperation::generated_message_descriptor_data());
            messages.push(CMsgCloudPendingRemoteOperations::generated_message_descriptor_data());
            messages.push(CMsgBluetoothDevicesData::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfDiagnosticEntry::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfNetworkInterface::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfDiagnosticInfo::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfLimits::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfSettingsGlobal::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfSettingsPerApp::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfSettings::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfSettingsV1::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfState::generated_message_descriptor_data());
            messages.push(CMsgSystemPerfUpdateSettings::generated_message_descriptor_data());
            messages.push(CMsgSystemDockUpdateState::generated_message_descriptor_data());
            messages.push(CMsgSystemDockState::generated_message_descriptor_data());
            messages.push(CMsgSystemDockUpdateFirmware::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioVolume::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerObject::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerDevice::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerNode::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerPort::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerLink::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerStateHW::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerState::generated_message_descriptor_data());
            messages.push(CMsgSystemAudioManagerUpdateSomething::generated_message_descriptor_data());
            messages.push(CMsgSystemDisplayMode::generated_message_descriptor_data());
            messages.push(CMsgSystemDisplay::generated_message_descriptor_data());
            messages.push(CMsgSystemDisplayManagerState::generated_message_descriptor_data());
            messages.push(CMsgSystemDisplayManagerSetMode::generated_message_descriptor_data());
            messages.push(CMsgSystemManagerSettings::generated_message_descriptor_data());
            messages.push(CMsgSelectOSBranchParams::generated_message_descriptor_data());
            messages.push(CMsgSystemUpdateProgress::generated_message_descriptor_data());
            messages.push(CMsgSystemUpdateCheckResult::generated_message_descriptor_data());
            messages.push(CMsgSystemUpdateApplyParams::generated_message_descriptor_data());
            messages.push(CMsgSystemUpdateApplyResult::generated_message_descriptor_data());
            messages.push(CMsgSystemUpdateState::generated_message_descriptor_data());
            messages.push(CMsgAchievementChange::generated_message_descriptor_data());
            messages.push(CMsgCellList::generated_message_descriptor_data());
            messages.push(CMsgShortcutInfo::generated_message_descriptor_data());
            messages.push(CMsgShortcutAppIds::generated_message_descriptor_data());
            messages.push(CMsgMonitorInfo::generated_message_descriptor_data());
            messages.push(CMsgGenerateSystemReportReply::generated_message_descriptor_data());
            messages.push(CMsgWebUITransportInfo::generated_message_descriptor_data());
            messages.push(CMsgClientShaderHitCacheEntry::generated_message_descriptor_data());
            messages.push(CMsgClientShaderHitCache::generated_message_descriptor_data());
            messages.push(cmsg_network_devices_data::Device::generated_message_descriptor_data());
            messages.push(cmsg_network_devices_data::device::Wired::generated_message_descriptor_data());
            messages.push(cmsg_network_devices_data::device::Wireless::generated_message_descriptor_data());
            messages.push(cmsg_network_devices_data::device::wireless::AP::generated_message_descriptor_data());
            messages.push(cmsg_network_device_connect::KnownAP::generated_message_descriptor_data());
            messages.push(cmsg_network_device_connect::CustomAP::generated_message_descriptor_data());
            messages.push(cmsg_network_device_connect::Credentials::generated_message_descriptor_data());
            messages.push(cmsg_storage_devices_data::Drive::generated_message_descriptor_data());
            messages.push(cmsg_storage_devices_data::BlockDevice::generated_message_descriptor_data());
            messages.push(cmsg_bluetooth_devices_data::Adapter::generated_message_descriptor_data());
            messages.push(cmsg_bluetooth_devices_data::Device::generated_message_descriptor_data());
            messages.push(cmsg_bluetooth_devices_data::Manager::generated_message_descriptor_data());
            messages.push(cmsg_system_audio_volume::ChannelEntry::generated_message_descriptor_data());
            messages.push(cmsg_cell_list::Cell::generated_message_descriptor_data());
            messages.push(cmsg_monitor_info::MonitorInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ECloudPendingRemoteOperation::generated_enum_descriptor_data());
            enums.push(ESteamDeckKeyboardLayout::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
